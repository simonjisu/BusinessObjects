{"sample_id": "train.6779", "db_id": "activity_1", "question": "Show the first and last name of all the faculty members who participated in some activity, together with the number of activities they participated in.", "rationale": ["Identify the relevant tables, which are 'Faculty' and 'Faculty_Participates_In'.", "Select the columns to display: 'fname' and 'lname' from the 'Faculty' table, and count the number of activities from the 'Faculty_Participates_In' table.", "Join the 'Faculty' table with the 'Faculty_Participates_In' table on the faculty identifier to link faculty members with their activities.", "Group the results by the faculty identifier to count the number of activities for each faculty member."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "description": "The virtual table presents the first and last names of faculty members from the 'Faculty' table who have participated in various activities, along with a count of the total number of activities each faculty member has engaged in. The join operation links the 'Faculty' table with the 'Faculty_Participates_In' table based on the faculty identifier, and the grouping is done by the faculty identifier to aggregate the count of activities.", "virtual_table": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID"}
{"sample_id": "train.6723", "db_id": "activity_1", "question": "Show the first name, last name, and phone number for all female faculty members.", "rationale": ["Identify the relevant table, which is 'Faculty'.", "Select the columns to display: 'Fname', 'Lname', and 'phone'.", "Add a condition to filter the 'Sex' column for female faculty members using a placeholder for string values."], "gold_sql": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'", "source_tables": ["faculty"], "description": "The virtual table presents the first name, last name, and phone number of faculty members from the 'Faculty' table who are identified as female. The placeholder in the WHERE clause is used to specify the gender of the faculty members.", "virtual_table": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6761", "db_id": "activity_1", "question": "Show the ids for all the faculty members who have at least 2 students.", "rationale": ["Identify the relevant tables, which are 'Faculty' and 'Student'.", "Join the 'Faculty' table with the 'Student' table on the advisor relationship.", "Select the 'FacID' from the 'Faculty' table.", "Group the results by 'FacID' to aggregate the number of students each faculty member advises.", "Add a condition in the HAVING clause to filter faculty members who advise at least a specified number of students using a placeholder for numeric values."], "gold_sql": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  2", "source_tables": ["faculty", "student"], "description": "The virtual table lists the unique identifiers of faculty members from the 'Faculty' table who are advising at least a specified number of students. The placeholder in the HAVING clause indicates the minimum number of students that a faculty member must advise to be included in the results.", "virtual_table": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6799", "db_id": "activity_1", "question": "Find the first names of the faculty members who participate in Canoeing and Kayaking.", "rationale": ["Identify the relevant tables: 'Faculty', 'Faculty_participates_in', and 'Activity'.", "Select the column to display, which is 'lname' from the 'Faculty' table.", "Join the 'Faculty' table with 'Faculty_participates_in' on 'FacID' to link faculty members to their activities.", "Join the 'Faculty_participates_in' table with 'Activity' on 'actid' to filter by activity names.", "Use an INTERSECT to ensure that only faculty members participating in both specified activities are included in the results.", "Add conditions to filter the 'activity_name' column for the specified activities using placeholders for string values."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "The virtual table describes the last names of faculty members from the 'Faculty' table who participate in specific activities. It combines results from two queries using an INTERSECT operation, ensuring that only faculty members who participate in both activities are included. The placeholders in the WHERE clause represent the names of the activities being queried.", "virtual_table": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6802", "db_id": "activity_1", "question": "Which students participate in both Canoeing and Kayaking as their activities? Tell me their student ids.", "rationale": ["Identify the relevant tables, which are 'Participates_in' and 'Activity'.", "Select the column to display, 'stuid', which represents the student IDs.", "Use JOIN to connect 'Participates_in' with 'Activity' based on the activity identifier 'actid'.", "Filter the results using INTERSECT to find students participating in both specified activities, with placeholders for the activity names."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "description": "The virtual table identifies students who are involved in both specified activities by filtering the 'Participates_in' table based on the activity names. The placeholder in the query represents the names of the activities, allowing for the selection of student IDs who participate in both activities.", "virtual_table": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6797", "db_id": "activity_1", "question": "Find the first names of professors who are not playing Canoeing or Kayaking.", "rationale": ["Identify the relevant table, which is 'Faculty'.", "Select the column to display, 'lname'.", "Add a condition to filter the 'rank' column for the specified rank using a placeholder for string values.", "Use an EXCEPT clause to exclude faculty members who are participating in activities with specific names.", "Join the 'Faculty' table with 'Faculty_participates_in' and 'Activity' tables to filter out those participating in the specified activities."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "The virtual table lists the last names of faculty members from the 'Faculty' table who hold a specific academic rank and are not participating in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities that are being excluded from the results.", "virtual_table": "SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6800", "db_id": "activity_1", "question": "What are the first names of the faculty members playing both Canoeing and Kayaking?", "rationale": ["Identify the relevant tables: 'Faculty', 'Faculty_participates_in', and 'Activity'.", "Select the column to display, which is 'lname' from the 'Faculty' table.", "Join the 'Faculty' table with 'Faculty_participates_in' to link faculty members to their activities.", "Join the 'Faculty_participates_in' table with the 'Activity' table to filter by activity names.", "Use the INTERSECT operator to find faculty members who participate in both activities, with placeholders for the activity names."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "The virtual table describes the last names of faculty members from the 'Faculty' table who participate in both specified activities. The placeholders in the WHERE clauses represent the names of the activities, allowing for the selection of faculty members involved in both Canoeing and Kayaking.", "virtual_table": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the relevant table, which is 'Faculty'.", "Select the column to display, 'lname'.", "Add a condition to filter the 'rank' column for the specified rank using a placeholder for string values.", "Use the EXCEPT clause to exclude faculty members who participate in specific activities by joining the 'Faculty' table with 'Faculty_participates_in' and 'Activity' tables.", "Add conditions to filter out the activities 'Canoeing' and 'Kayaking' using placeholders for string values."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "The virtual table describes the last names of faculty members from the 'Faculty' table who hold a specific academic rank and do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities that are being excluded from the results.", "virtual_table": "SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6796", "db_id": "activity_1", "question": "Which faculty members are playing either Canoeing or Kayaking? Tell me their first names.", "rationale": ["Identify the relevant tables: 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "Select the column to display, which is the last name of faculty members.", "Join the 'Faculty' table with 'Faculty_Participates_in' on the faculty ID, and then join with the 'Activity' table on the activity ID.", "Add a condition to filter the 'activity_name' column for the specified activities using placeholders for string values."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "The virtual table describes the distinct last names of faculty members from the 'Faculty' table who are participating in specific activities. The table joins the 'Faculty', 'Faculty_Participates_in', and 'Activity' tables to filter faculty based on their participation in activities, with placeholders representing the names of the activities.", "virtual_table": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables, which are 'Participates_in' and 'Student'.", "Select the column to display, 'StuID', from the 'Participates_in' table.", "Use an INTERSECT operation to ensure that only students who participate in activities are included.", "Add a condition to filter the 'Student' table for students under a specified age using a placeholder for numeric values."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "description": "The virtual table provides the unique identifiers of students from the 'Participates_in' table who are involved in activities and are under a specified age. The placeholder in the WHERE clause represents the age limit for filtering the students.", "virtual_table": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6738", "db_id": "activity_1", "question": "Find the building that has the largest number of faculty members.", "rationale": ["Identify the relevant table, which is 'Faculty'.", "Select the 'building' column to display.", "Group the results by 'building' to count the number of faculty members in each building.", "Order the results by the count of faculty members in descending order to find the building with the most faculty.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "description": "The virtual table summarizes the buildings where faculty members are located, grouped by each building. It orders the results by the count of faculty members in descending order, allowing the identification of the building with the largest number of faculty members. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the relevant tables, which are 'Faculty' and 'Student'.", "Select the columns to display, 'fname' and 'lname' from the 'Student' table.", "Join the 'Faculty' table with the 'Student' table on the advisor relationship.", "Add conditions to filter the faculty member's first and last names using placeholders for string values."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "description": "The virtual table describes the first and last names of students from the 'Student' table who are advised by a specific faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.", "virtual_table": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6781", "db_id": "activity_1", "question": "Show all the activity names and the number of faculty involved in each activity.", "rationale": ["Identify the relevant tables, which are 'Activity' and 'Faculty_Participates_in'.", "Select the 'activity_name' from the 'Activity' table and count the number of faculty members from the 'Faculty_Participates_in' table.", "Join the two tables on the activity identifier to link activities with their respective faculty participants.", "Group the results by the activity identifier to ensure the count reflects the number of faculty per activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "description": "The virtual table presents the names of activities along with the count of faculty members participating in each activity. The join between the 'Activity' and 'Faculty_Participates_in' tables allows for the aggregation of faculty involvement per activity, with the grouping based on the unique activity identifier.", "virtual_table": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the relevant tables, which are 'Faculty' and 'Student'.", "Select the columns to display, 'fname' and 'lname' from the 'Faculty' table.", "Join the 'Faculty' table with the 'Student' table on the advisor's ID.", "Add conditions to filter the 'Student' table for the specified first and last names using placeholders."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "description": "The virtual table provides the first and last names of faculty members who serve as advisors to a specific student. The query joins the 'Faculty' and 'Student' tables based on the advisor's ID, filtering for the student's first and last name using placeholders.", "virtual_table": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  [PLACEHOLDER-TYPE:STRING] AND T2.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6733", "db_id": "activity_1", "question": "Show the first name and last name for all the instructors.", "rationale": ["Identify the relevant table, which is 'Faculty'.", "Select the columns to display, 'fname' and 'lname'.", "Add a condition to filter the 'Rank' column for the specified rank using a placeholder for string values."], "gold_sql": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  'Instructor'", "source_tables": ["faculty"], "description": "The virtual table presents the first and last names of faculty members from the 'Faculty' table, filtered by their academic rank. The placeholder in the WHERE clause allows for specifying the desired rank of the instructors.", "virtual_table": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6755", "db_id": "activity_1", "question": "Show the faculty id of each faculty member, along with the number of students he or she advises.", "rationale": ["Identify the relevant tables, which are 'Faculty' and 'Student'.", "Select the 'FacID' from the 'Faculty' table and count the number of students from the 'Student' table.", "Join the two tables on the condition that the faculty ID matches the advisor field in the 'Student' table.", "Group the results by faculty ID to aggregate the count of students advised by each faculty member."], "gold_sql": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID", "source_tables": ["faculty", "student"], "description": "The virtual table displays the faculty IDs of faculty members along with the count of students they advise. It combines data from the 'Faculty' table and the 'Student' table, using a join on the faculty ID and the advisor field. The result is grouped by faculty ID to provide a count of students for each faculty member.", "virtual_table": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID"}
{"sample_id": "train.6752", "db_id": "activity_1", "question": "Which students have professors as their advisors? Find their student ids.", "rationale": ["Identify the relevant tables, which are 'Faculty' and 'Student'.", "Select the column to display, which is 'StuID' from the 'Student' table.", "Join the 'Faculty' table with the 'Student' table on the condition that the faculty member's ID matches the advisor ID of the student.", "Add a condition to filter the results based on the faculty member's rank using a placeholder for string values."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "description": "The virtual table lists the unique identifiers of students from the 'Student' table who have faculty members as their advisors. The join operation connects the 'Faculty' and 'Student' tables based on the faculty member's ID and the advisor ID of the student. A placeholder is used to filter the results based on the academic rank of the faculty advisor.", "virtual_table": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6766", "db_id": "activity_1", "question": "List all the activities we have.", "rationale": ["Identify the relevant table, which is 'Activity'.", "Select the column to display, 'activity_name'.", "No conditions are needed since the query requests all activities."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "description": "The virtual table lists the names of all activities from the 'Activity' table. There are no filters or conditions applied, so it retrieves all available activity names.", "virtual_table": "SELECT activity_name FROM Activity"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the relevant table, which is 'Faculty'.", "Select the column to display, 'FacID'.", "Add a condition to filter the 'Sex' column for male faculty using a placeholder for string values."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "description": "The virtual table contains the unique identifiers of faculty members from the 'Faculty' table who are male. The placeholder in the WHERE clause represents the gender of the faculty members.", "virtual_table": "SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6726", "db_id": "activity_1", "question": "What are the faculty ids of all the male faculty members?", "rationale": ["Identify the relevant table, which is 'Faculty'.", "Select the column to display, 'FacID'.", "Add a condition to filter the 'Sex' column for male faculty members using a placeholder for string values."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "description": "The virtual table contains the unique identifiers of faculty members from the 'Faculty' table who are male. The placeholder in the WHERE clause represents the gender of the faculty members being queried.", "virtual_table": "SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.535", "db_id": "allergy_1", "question": "Find the first name and major of the students who are not allegry to soy.", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'major'.", "Add a condition to filter out students based on their allergies by using a subquery that checks the 'Has_Allergy' table for the specified allergy, using a placeholder for string values."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "description": "The virtual table presents the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being excluded from the results.", "virtual_table": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.526", "db_id": "allergy_1", "question": "How old are the students with allergies to food and animal types on average?", "rationale": ["Identify the relevant table, which is 'Student' for age information.", "Use the AVG function to calculate the average age of students.", "Filter the students based on their allergies by using a subquery that joins 'Has_Allergy' and 'Allergy_Type' tables.", "The subquery checks for students with allergies of two specific types using placeholders for the allergy types."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "The virtual table calculates the average age of students from the 'Student' table who have allergies categorized as food and animal types. The placeholders in the INTERSECT clause represent the specific allergy types being queried.", "virtual_table": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the columns to display, 'lname' and 'age'.", "Use a subquery to filter 'StuID' from the 'Has_allergy' table for the specified allergies, ensuring that only students with both allergies are included."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "description": "The virtual table provides the last names and ages of students from the 'Student' table who have allergies to specific substances. The query uses a subquery to filter students based on their allergies, allowing for the identification of students who are allergic to both specified allergens.", "virtual_table": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["Identify the relevant table, which is 'Student'.", "Count the number of students by using the count(*) function.", "Add a condition to filter the 'sex' column for male students using a placeholder for string values.", "Use a subquery to filter students who have allergies by joining 'Has_Allergy' and 'Allergy_Type' tables on the allergy name, and filter for the specific allergy type using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "The virtual table provides a count of male students from the 'Student' table who have allergies to a specific type of food. The placeholders in the query represent the gender of the students and the type of allergy being queried.", "virtual_table": "SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the relevant tables, which are 'Student' and 'Has_Allergy'.", "Select the columns to display, 'fname' and 'city_code', ensuring that only distinct values are returned.", "Join the 'Student' table with the 'Has_Allergy' table on the student identifier to correlate students with their allergies.", "Add a condition to filter the 'Allergy' column for the specified allergies using placeholders for string values."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "description": "The virtual table describes the distinct first names and city codes of students from the 'Student' table who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies that the students may have, allowing for the selection of students with either of the specified allergies.", "virtual_table": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the columns to display, 'lname' and 'age'.", "Use a subquery to filter students based on their allergies by checking for the presence of both specified allergies using the INTERSECT operator."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "description": "The virtual table provides the last names and ages of students from the 'Student' table who have allergies to both specified allergens. The placeholders in the query represent the names of the allergies being checked.", "virtual_table": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["Identify the relevant tables, which are 'Student' and 'Has_Allergy'.", "Select the columns to display, 'fname' and 'city_code', ensuring distinct results.", "Join the 'Student' table with the 'Has_Allergy' table on the student identifier to correlate students with their allergies.", "Add a condition to filter the 'Allergy' column for the specified allergies using placeholders for string values."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "description": "The virtual table presents the distinct first names and city codes of students from the 'Student' table who have allergies to specific substances. The placeholders in the WHERE clause allow for the specification of the allergy names, enabling the query to filter students based on their allergies.", "virtual_table": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.536", "db_id": "allergy_1", "question": "What are the first name and major of the students who are able to consume soy?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'major'.", "Add a condition to filter out students who have a specific allergy by using a subquery that checks the 'StuID' in the 'Has_Allergy' table, with a placeholder for the allergy name."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "description": "The virtual table presents the first names and majors of students from the 'Student' table who do not have a specific allergy, in this case, soy. The placeholder in the WHERE clause is used to specify the allergy name that is being filtered out.", "virtual_table": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'lname'.", "Add a condition to filter out students whose IDs are in the subquery results, which identifies students with allergies of a specific type using a placeholder for string values."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "The virtual table provides the first and last names of students from the 'Student' table who do not have any allergies to a specific type of food. The placeholder in the WHERE clause represents the category of allergy that is being excluded from the results.", "virtual_table": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the column to display, 'major'.", "Group the results by 'major' to count the number of students in each major.", "Order the results in descending order based on the count of students.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "The virtual table summarizes the academic majors of students from the 'Student' table, grouping them to count the number of students in each major. The placeholder in the LIMIT clause indicates the number of top majors to retrieve based on their student count.", "virtual_table": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.513", "db_id": "allergy_1", "question": "Which allergy has most number of students affected?", "rationale": ["Identify the relevant table, which is 'Has_Allergy'.", "Select the 'Allergy' column to display.", "Group the results by 'Allergy' to count the number of students affected by each allergy.", "Order the results in descending order based on the count of students.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "description": "The virtual table summarizes the allergies from the 'Has_Allergy' table, grouping them to count the number of students affected by each allergy. The results are ordered in descending order based on the count, allowing the identification of the allergy with the highest number of affected students. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["Identify the relevant table, which is 'Allergy_Type'.", "Select the distinct values from the 'allergy' column to ensure no duplicates are included.", "Add a condition to filter the results based on the 'allergytype' column using a placeholder for string values."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "description": "The virtual table provides a list of unique food allergies from the 'Allergy_Type' table, filtered by a specific category of allergy. The placeholder in the WHERE clause represents the type of allergy being queried.", "virtual_table": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["Identify the relevant table, which is 'Allergy_Type'.", "Group the results by the 'AllergyType' column to categorize the allergies.", "Order the results by the count of allergies in descending order to find the most common allergy type.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "description": "The virtual table summarizes the types of allergies categorized in the 'Allergy_Type' table, grouped by their respective allergy types. The query retrieves the allergy type that has the highest count of associated allergies, with a placeholder to limit the number of results returned.", "virtual_table": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.518", "db_id": "allergy_1", "question": "How many students are affected by each allergy type?", "rationale": ["Identify the relevant tables, which are 'Has_Allergy' and 'Allergy_Type'.", "Join the two tables on the allergy name to associate students with their respective allergy types.", "Select the 'allergytype' from the 'Allergy_Type' table and count the number of occurrences from the 'Has_Allergy' table.", "Group the results by 'allergytype' to get the count of students for each allergy type."], "gold_sql": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype", "source_tables": ["has_allergy", "allergy_type"], "description": "The virtual table summarizes the count of students affected by each type of allergy. It combines data from the 'Has_Allergy' table, which links students to their allergies, and the 'Allergy_Type' table, which categorizes those allergies. The result groups the data by allergy type, providing a count of students for each category.", "virtual_table": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the relevant tables, which are 'Has_Allergy' and 'Student'.", "Count the total number of records that meet the specified criteria.", "Join the two tables on the unique student identifier 'StuID'.", "Filter the results based on the gender of the students and the specific allergies using placeholders for string values."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "description": "The virtual table provides a count of female students who have allergies to specific substances, namely milk or eggs. It combines data from the 'Has_Allergy' and 'Student' tables, filtering based on the gender of the students and the names of the allergies. The placeholders in the WHERE clause represent the gender and the names of the allergies being queried.", "virtual_table": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.450", "db_id": "allergy_1", "question": "What is allergy type of a cat allergy?", "rationale": ["Identify the relevant table, which is 'Allergy_Type'.", "Select the column to display, 'allergytype'.", "Add a condition to filter the 'allergy' column for the specified allergy name using a placeholder for string values."], "gold_sql": "SELECT allergytype FROM Allergy_type WHERE allergy  =  'Cat'", "source_tables": ["allergy_type"], "description": "The virtual table provides information about the type of allergy associated with a specific allergy name from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the name of the allergy being queried.", "virtual_table": "SELECT allergytype FROM Allergy_type WHERE allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["Identify the relevant table, which is 'Has_Allergy'.", "Use the count function to determine the number of students with a specific allergy.", "Add a condition to filter the 'Allergy' column for the specified allergy using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "description": "The virtual table provides a count of students from the 'Has_Allergy' table who have a specific type of allergy. The placeholder in the WHERE clause represents the name of the allergy being queried.", "virtual_table": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.512", "db_id": "allergy_1", "question": "How many students are affected by food related allergies?", "rationale": ["Identify the relevant tables, which are 'Has_Allergy' and 'Allergy_Type'.", "Use a JOIN operation to connect these tables based on the allergy name.", "Select the count of students affected by the specified allergy type using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  'food'", "source_tables": ["has_allergy", "allergy_type"], "description": "The virtual table provides a count of students who have food-related allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the WHERE clause specifies the type of allergy, allowing for filtering based on the allergy type.", "virtual_table": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.511", "db_id": "allergy_1", "question": "How many students have a food allergy?", "rationale": ["Identify the relevant tables, which are 'Has_Allergy' and 'Allergy_Type'.", "Count the number of records to determine how many students have allergies.", "Join the two tables on the allergy name to filter the results based on the allergy type using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  'food'", "source_tables": ["has_allergy", "allergy_type"], "description": "The virtual table provides a count of students who have a specific type of food allergy by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the WHERE clause represents the category of the allergy being queried.", "virtual_table": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the column to display, 'StuID'.", "Add a condition to filter the 'Sex' column for male students using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "description": "The virtual table contains the unique identifiers of students from the 'Student' table who are male. The placeholder in the WHERE clause represents the gender of the students being queried.", "virtual_table": "SELECT StuID FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the columns to display, 'Fname' and 'Lname', which represent the first and last names of the students."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "description": "The virtual table contains the first and last names of students from the 'Student' table. This allows for the retrieval of full names of all students enrolled.", "virtual_table": "SELECT Fname ,  Lname FROM Student"}
{"sample_id": "train.1262", "db_id": "apartment_rentals", "question": "Show the most common apartment type code among apartments with more than 1 bathroom.", "rationale": ["Identify the relevant table, which is 'Apartments'.", "Select the column to display, 'apt_type_code'.", "Add a condition to filter the 'bathroom_count' column for apartments with more than a specified number of bathrooms using a placeholder for numeric values.", "Group the results by 'apt_type_code' to aggregate the data.", "Order the results by the count of each apartment type in descending order to find the most common type.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "description": "The virtual table summarizes the apartment type codes from the 'Apartments' table, specifically focusing on those apartments that have more than a specified number of bathrooms. The results are grouped by apartment type code and ordered by their frequency, allowing for the identification of the most common type. The placeholders in the query represent the minimum number of bathrooms and the limit on the number of results to return.", "virtual_table": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1258", "db_id": "apartment_rentals", "question": "Show the apartment type code that has the largest number of total rooms, together with the number of bathrooms and number of bedrooms.", "rationale": ["Identify the relevant table, which is 'Apartments'.", "Select the columns to display: 'apt_type_code', 'bathroom_count', and 'bedroom_count'.", "Group the results by 'apt_type_code' to aggregate the data.", "Order the results by the sum of 'room_count' in descending order to find the apartment type with the largest total rooms.", "Add a limit to the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "source_tables": ["apartments"], "description": "The virtual table summarizes the apartment type codes along with the corresponding number of bathrooms and bedrooms from the 'Apartments' table. It groups the results by apartment type code and orders them by the total number of rooms in descending order, allowing the user to specify a limit on the number of results returned.", "virtual_table": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1257", "db_id": "apartment_rentals", "question": "What are the top three apartment types in terms of the average room count? Give me the", "rationale": ["Identify the relevant table, which is 'Apartments'.", "Select the column to display, 'apt_type_code'.", "Group the results by 'apt_type_code' to aggregate data for each type.", "Calculate the average of 'room_count' for each apartment type and order the results in descending order.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "source_tables": ["apartments"], "description": "The virtual table summarizes the apartment types from the 'Apartments' table, grouping them by their type code. It calculates the average room count for each apartment type and orders the results in descending order to identify the top types. The placeholder in the LIMIT clause allows for specifying the number of top results to return.", "virtual_table": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1260", "db_id": "apartment_rentals", "question": "Show the most common apartment type code.", "rationale": ["Identify the relevant table, which is 'Apartments'.", "Select the column 'apt_type_code' to display the apartment type codes.", "Group the results by 'apt_type_code' to aggregate the counts of each type.", "Order the results in descending order based on the count of each apartment type code to find the most common ones.", "Use a placeholder in the LIMIT clause to specify how many of the most common apartment type codes to return."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "description": "The virtual table summarizes the apartment type codes from the 'Apartments' table, grouping them to identify the most common types. The placeholder in the LIMIT clause allows for specifying the number of results to return, indicating how many of the most common apartment type codes should be displayed.", "virtual_table": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1225", "db_id": "apartment_rentals", "question": "Find the booking start date and end date for the apartments that have more than two bedrooms.", "rationale": ["Identify the relevant tables, which are 'Apartment_Bookings' and 'Apartments'.", "Select the columns to display, 'booking_start_date' and 'booking_end_date' from the 'Apartment_Bookings' table.", "Join the 'Apartment_Bookings' table with the 'Apartments' table on the apartment ID to access bedroom information.", "Add a condition to filter the 'bedroom_count' column for apartments with more than a specified number of bedrooms using a placeholder for numeric values."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "description": "The virtual table provides the booking start and end dates for apartments from the 'Apartment_Bookings' table that have a specified number of bedrooms. The placeholder in the WHERE clause allows for filtering apartments based on the number of bedrooms they contain.", "virtual_table": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1232", "db_id": "apartment_rentals", "question": "Show the guest first names, start dates, and end dates of all the apartment bookings.", "rationale": ["Identify the relevant tables, which are 'Apartment_Bookings' and 'Guests'.", "Select the columns to display: 'guest_first_name' from the 'Guests' table and 'booking_start_date' and 'booking_end_date' from the 'Apartment_Bookings' table.", "Use a JOIN operation to connect the two tables based on the 'guest_id' to ensure that the guest information corresponds to the correct booking."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "description": "The virtual table provides the first names of guests along with the start and end dates of their apartment bookings. It combines data from the 'Apartment_Bookings' table, which contains booking details, and the 'Guests' table, which holds guest information. The join condition links the bookings to the respective guests using their unique identifiers.", "virtual_table": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id"}
{"sample_id": "train.1235", "db_id": "apartment_rentals", "question": "What are the start date and end date of the apartment bookings made by female guests (gender code \"Female\")?", "rationale": ["Identify the relevant tables, which are 'Apartment_Bookings' and 'Guests'.", "Select the columns to display, 'booking_start_date' and 'booking_end_date'.", "Join the two tables on the 'guest_id' to link bookings to guests.", "Add a condition to filter the 'gender_code' column for female guests using a placeholder for string values."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  'Female'", "source_tables": ["apartment_bookings", "guests"], "description": "The virtual table provides the start and end dates of apartment bookings from the 'Apartment_Bookings' table, specifically for bookings made by female guests. The join with the 'Guests' table allows filtering based on the gender code, represented by a placeholder for string values.", "virtual_table": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1233", "db_id": "apartment_rentals", "question": "What are the guest first name, start date, and end date of each apartment booking?", "rationale": ["Identify the relevant tables, which are 'Apartment_Bookings' and 'Guests'.", "Select the columns to display: 'guest_first_name' from the 'Guests' table and 'booking_start_date' and 'booking_end_date' from the 'Apartment_Bookings' table.", "Use a JOIN operation to connect the two tables based on the 'guest_id' to ensure that the booking information corresponds to the correct guest."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "description": "The virtual table provides the first names of guests along with the start and end dates of their respective apartment bookings. It combines data from the 'Apartment_Bookings' table, which contains booking details, and the 'Guests' table, which holds guest information. The join condition links the bookings to the guests based on their unique identifiers.", "virtual_table": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id"}
{"sample_id": "train.1220", "db_id": "apartment_rentals", "question": "Show the apartment numbers, start dates, and end dates of all the apartment bookings.", "rationale": ["Identify the relevant tables, which are 'Apartment_Bookings' and 'Apartments'.", "Select the columns to display: 'apt_number' from the 'Apartments' table and 'booking_start_date' and 'booking_end_date' from the 'Apartment_Bookings' table.", "Use a JOIN operation to connect the two tables based on the apartment identifier, ensuring that the booking details correspond to the correct apartment."], "gold_sql": "SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id", "source_tables": ["apartment_bookings", "apartments"], "description": "The virtual table displays the apartment numbers along with the start and end dates of all apartment bookings. It combines data from the 'Apartment_Bookings' table, which contains booking details, and the 'Apartments' table, which provides information about the apartments, specifically their numbers. The join condition links the bookings to their respective apartments using the apartment identifier.", "virtual_table": "SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id"}
{"sample_id": "train.1239", "db_id": "apartment_rentals", "question": "What are the facility codes of the apartments with more than four bedrooms?", "rationale": ["Identify the relevant tables, which are 'Apartment_Facilities' and 'Apartments'.", "Select the column to display, 'facility_code' from 'Apartment_Facilities'.", "Join 'Apartment_Facilities' with 'Apartments' on the apartment identifier to link facilities to their respective apartments.", "Add a condition to filter the 'bedroom_count' column for apartments with more than a specified number of bedrooms using a placeholder for numeric values."], "gold_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "source_tables": ["apartments", "apartment_facilities"], "description": "The virtual table describes the facility codes associated with apartments from the 'Apartment_Facilities' table that have a specific number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.", "virtual_table": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3698", "db_id": "baseball_1", "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?", "rationale": ["Identify the relevant tables: 'salary' for salary records, 'player' for player names, and 'team' for team identification.", "Select the columns to display: 'name_first' and 'name_last' from the 'player' table.", "Join the 'salary' table with the 'player' table on 'player_id' to link salary information with player names.", "Join the 'salary' table with the 'team' table to filter by team name using the 'team_id_br' identifier.", "Use the INTERSECT operator to find players who appear in both salary records for the specified years, ensuring they were paid in both years."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "description": "The virtual table provides the first and last names of players who received a salary from the Washington Nationals during the years specified. It combines data from the 'salary' table, which records salary information, with the 'player' table to retrieve player names. The query uses an INTERSECT operation to ensure that only players who were paid in both years (2005 and 2007) are included in the results. Placeholders are used for the year values and the team name to allow for flexible querying.", "virtual_table": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3683", "db_id": "baseball_1", "question": "What were all the salary values of players in 2010 and 2001?", "rationale": ["Identify the relevant table, which is 'salary'.", "Select the 'salary' column to display the salary values.", "Use a UNION to combine results from two different years, each specified by a placeholder for numeric values in the WHERE clause."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "description": "The virtual table provides the salary values of players from the 'salary' table for two specific years. The placeholders in the WHERE clause represent the years for which the salary data is being queried, allowing for the retrieval of salary information for players in those years.", "virtual_table": "SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3641", "db_id": "baseball_1", "question": "In 2014, what are the id and rank of the team that has the largest average number of attendance?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'team' for team rankings.", "Select the columns to display: 'team_id' and 'rank' from the 'team' table.", "Join the 'home_game' table with the 'team' table on 'team_id' to correlate attendance with team rankings.", "Filter the results for a specific year using a placeholder for numeric values.", "Group the results by 'team_id' to calculate the average attendance for each team.", "Order the results by the average attendance in descending order to find the team with the largest average attendance.", "Limit the results to return only the top entry."], "gold_sql": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  2014 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;", "source_tables": ["team", "home_game"], "description": "The virtual table provides the team ID and rank of the team that has the highest average attendance for home games in a specified year. It combines data from the 'home_game' table, which records attendance figures, and the 'team' table, which contains team rankings. The query groups the results by team ID and orders them by the average attendance in descending order, allowing for the identification of the top team based on attendance.", "virtual_table": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3671", "db_id": "baseball_1", "question": "What is the number of wins the team Boston Red Stockings got in the postseasons each year in history?", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team information.", "Select the count of wins and the year from the 'postseason' table.", "Join the 'postseason' table with the 'team' table on the winning team identifier to filter for the specific team.", "Group the results by year to get the number of wins per year for the specified team."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "description": "The virtual table summarizes the count of wins achieved by the Boston Red Stockings in postseason games, organized by year. It combines data from the 'postseason' table, which records postseason results, and the 'team' table, which contains team identifiers and names. The placeholder in the WHERE clause is used to specify the team name, allowing for dynamic querying based on different team inputs.", "virtual_table": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["Identify the relevant tables, which are 'player' and 'player_award'.", "Select the columns to display, 'name_first' and 'name_last' from the 'player' table.", "Join the 'player' table with the 'player_award' table to access award information.", "Filter the results for the specified years using placeholders for numeric values.", "Use INTERSECT to ensure that only players who won awards in both years are included."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "description": "The virtual table provides the first and last names of players who have won awards in both specified years. It combines data from the 'player' table and the 'player_award' table, filtering for the years of interest using placeholders for numeric values. The use of INTERSECT ensures that only players who won awards in both years are included in the results.", "virtual_table": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3684", "db_id": "baseball_1", "question": "List all the salary values players received in 2010 and 2001.", "rationale": ["Identify the relevant table, which is 'salary'.", "Select the 'salary' column to display the salary values.", "Use a UNION to combine results from two different years, utilizing placeholders for the year values to allow for flexible querying."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "description": "The virtual table contains the salary values of players from the 'salary' table for the specified years. The placeholders represent the years for which the salary data is being queried, allowing for the retrieval of salary information for multiple years in a single query.", "virtual_table": "SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3662", "db_id": "baseball_1", "question": "Which players won awards in both 1960 and 1961? Return their first names and last names.", "rationale": ["Identify the relevant tables, which are 'player' and 'player_award'.", "Select the columns to display, 'name_first' and 'name_last' from the 'player' table.", "Join the 'player' table with the 'player_award' table to access award information.", "Filter the results for the specified years using placeholders for numeric values.", "Use INTERSECT to find players who won awards in both years."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "description": "The virtual table provides the first and last names of players who have received awards in both specified years. It combines data from the 'player' table and the 'player_award' table, filtering for the years of interest using placeholders for numeric values. The use of INTERSECT ensures that only players who won awards in both years are included in the results.", "virtual_table": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3669", "db_id": "baseball_1", "question": "What are the name and id of the team with the most victories in 2008 postseason?", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team details.", "Select the columns to display: team name from 'team' and team ID from 'postseason'.", "Join the 'postseason' table with the 'team' table on the winning team ID.", "Filter the results for the specified postseason year using a placeholder for numeric values.", "Group the results by the winning team ID to count victories.", "Order the results in descending order to find the team with the most victories.", "Limit the results to return only the top team."], "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"], "description": "The virtual table provides the names and identifiers of teams that achieved the most victories during the postseason of a specific year. It combines data from the 'postseason' table, which records the winning teams, with the 'team' table, which contains team details. The query filters for a particular year and groups the results by team identifier, ordering them by the count of victories to identify the top-performing team. Placeholders are used for the year and the limit on the number of results returned.", "virtual_table": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["Identify the relevant table, which is 'hall_of_fame'.", "Select the 'yearid' column to display the years of induction.", "Group the results by 'yearid' to count the number of inductees per year.", "Order the results by the count of inductees in ascending order to find the year with the least inductees.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "description": "The virtual table provides a list of years from the 'hall_of_fame' table, grouped by the year of induction. It orders the years based on the count of inductees in ascending order, allowing the user to identify the year with the least number of inductees. The placeholder in the LIMIT clause indicates the maximum number of results to return, which can be adjusted as needed.", "virtual_table": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3693", "db_id": "baseball_1", "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'team' for team identification.", "Select the sum of the 'attendance' column from the 'home_game' table.", "Join the 'home_game' table with the 'team' table on the team identifier to filter by team name.", "Add a condition to filter the results based on the specified team name using a placeholder for string values.", "Include a condition to filter the years using placeholders for numeric values to define the range."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "description": "The virtual table summarizes the total home game attendance for a specific team over a defined range of years. It combines data from the 'home_game' table, which contains attendance records, and the 'team' table, which identifies the team by name. The placeholders in the query allow users to specify the team name and the year range for which they want to calculate the total attendance.", "virtual_table": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3710", "db_id": "baseball_1", "question": "Which park did the most people attend in 2008?", "rationale": ["Identify the relevant tables, which are 'home_game' and 'park'.", "Select the 'park_name' column from the 'park' table.", "Join the 'home_game' table with the 'park' table on the 'park_id' to access attendance data.", "Add a condition to filter the results for the specified year using a placeholder for numeric values.", "Order the results by attendance in descending order to find the park with the most attendees.", "Limit the results to return only the top entry."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "description": "The virtual table provides the names of parks from the 'park' table that hosted home games in a specific year, filtered by the year of interest. It joins the 'home_game' table to retrieve attendance data, allowing users to identify which park had the highest attendance. The placeholders in the WHERE clause represent the year and the limit for the number of results to return.", "virtual_table": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["Identify the relevant table, which is 'player'.", "Select the 'birth_country' column to display the countries of origin.", "Group the results by 'birth_country' to aggregate the player counts.", "Order the results by the count of players in ascending order to find the least represented countries.", "Limit the results to three countries using a placeholder for numeric values."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "description": "The virtual table provides a list of countries represented by players in the 'player' table, grouped by country. It orders the countries by the number of players from each, in ascending order, and limits the results to the three countries with the fewest players. The placeholder in the LIMIT clause indicates the number of countries to return.", "virtual_table": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3700", "db_id": "baseball_1", "question": "Count the total number of games the team Boston Red Stockings attended from 1990 to 2000.", "rationale": ["Identify the relevant tables: 'home_game' for home game statistics and 'team' for team details.", "Select the sum of games from the 'home_game' table.", "Join the 'home_game' table with the 'team' table on the team identifier to filter by team name.", "Add a condition to filter the results based on the specified team name and the year range using placeholders."], "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"], "description": "The virtual table summarizes the total number of home games attended by a specific team over a defined range of years. It combines data from the 'home_game' table, which contains information about home games, and the 'team' table, which provides details about the team, including its name. The placeholders in the query allow for the specification of the team's name and the year range for the analysis.", "virtual_table": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["Identify the relevant table, which is 'hall_of_fame'.", "Select the 'yearid' column to display the years of induction.", "Group the results by 'yearid' to count the number of inductees per year.", "Order the results by the count of inductees in ascending order to find the year with the least inductees.", "Limit the results to a single entry using a placeholder for numeric values."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "description": "The virtual table provides a list of years from the 'hall_of_fame' table, grouped by the year of induction. It orders the years based on the count of inductees in ascending order, allowing the user to identify the year with the least number of inductees. The placeholder in the LIMIT clause indicates that the user can specify how many years they want to retrieve, focusing on the year with the least entries.", "virtual_table": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3694", "db_id": "baseball_1", "question": "How many games in total did team Boston Red Stockings attend from 2000 to 2010?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'team' for team identification.", "Select the sum of the 'attendance' column from the 'home_game' table.", "Join the 'home_game' table with the 'team' table on the team identifier to filter by the specific team.", "Add a condition to filter the team name using a placeholder for string values.", "Include a condition to filter the years using placeholders for numeric values."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "description": "The virtual table summarizes the total attendance of home games played by the team identified as 'Boston Red Stockings' over a specified range of years. It combines data from the 'home_game' table, which contains attendance records, and the 'team' table, which provides the team's identification. The placeholders in the query allow for dynamic input of the team name and the year range for the analysis.", "virtual_table": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3638", "db_id": "baseball_1", "question": "Count the number of players who enter hall of fame for each year.", "rationale": ["Identify the relevant table, which is 'hall_of_fame'.", "Select the 'yearid' column to represent the year of induction.", "Count the number of players for each year using the COUNT function.", "Group the results by 'yearid' to get the count for each specific year."], "gold_sql": "SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;", "source_tables": ["hall_of_fame"], "description": "The virtual table summarizes the number of players inducted into the Hall of Fame for each year. It groups the data by the year of induction and counts the total number of players for each year.", "virtual_table": "SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["Identify the relevant tables, which are 'team' and 'salary'.", "Select the columns to display, 'name' and 'team_id' from the 'team' table.", "Join the 'team' table with the 'salary' table on the 'team_id' column to associate teams with their salary records.", "Group the results by 'team_id' to calculate the average salary for each team.", "Order the results by the average salary in ascending order to find the team with the lowest average salary.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "description": "The virtual table provides the names and identifiers of teams from the 'team' table that are associated with salary records. It calculates the average salary for each team by joining the 'team' and 'salary' tables, grouping the results by team identifier, and ordering them in ascending order to identify the team with the lowest average salary. The placeholder in the LIMIT clause allows for specifying the number of results to return.", "virtual_table": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant tables, which are 'home_game' for home game statistics and 'team' for team names.", "Join the 'home_game' table with the 'team' table on the team identifier to access team names.", "Filter the results for a specific year using a placeholder for numeric values.", "Order the results by attendance in ascending order to find the team with the least number of home games.", "Limit the results to one to get only the team with the least attendance."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "description": "The virtual table provides the names of teams that hosted home games in a specific year, filtered to show only the team with the least attendance. The placeholders allow for the year and the limit on the number of results to be specified.", "virtual_table": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: 'home_game' for home game statistics and 'park' for park details.", "Join the 'home_game' table with the 'park' table on the park identifier to link games to their respective parks.", "Count the total number of games played by filtering the results based on the specified year and park name using placeholders."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "description": "The virtual table provides a count of the total number of games played in a specific park during a particular year. It combines data from the 'home_game' table, which records home game statistics, and the 'park' table, which contains information about different parks. The placeholders in the query allow users to specify the year and the name of the park they are interested in.", "virtual_table": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T2.park_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3667", "db_id": "baseball_1", "question": "How many times did Boston Red Stockings lose in 2009 postseason?", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team details.", "Join the 'postseason' table with the 'team' table on the condition that the losing team's ID matches the team's identifier in the Baseball Reference database.", "Count the number of records that meet the criteria for the specified team name and year, using placeholders for these values."], "gold_sql": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year = 2009;", "source_tables": ["postseason", "team"], "description": "The virtual table provides a count of the losses experienced by a specific team during the postseason in a given year. It combines data from the 'postseason' table, which records the outcomes of postseason games, and the 'team' table, which contains information about the teams. The placeholders allow for the specification of the team's name and the year of interest.", "virtual_table": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3668", "db_id": "baseball_1", "question": "Count the number of times the team \"Boston Red Stockings\" lost in 2009 postseason.", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team information.", "Select the count of losses by using count(*) from the 'postseason' table.", "Join the 'postseason' table with the 'team' table on the condition that the losing team's ID matches the team's identifier in the 'team' table.", "Add a condition to filter the team name and the year of the postseason using placeholders for string and numeric values."], "gold_sql": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year = 2009;", "source_tables": ["postseason", "team"], "description": "The virtual table provides a count of the total losses experienced by a specific team during the postseason in a given year. It combines data from the 'postseason' table, which records the outcomes of postseason games, and the 'team' table, which contains information about the teams, including their names. The placeholders allow for the specification of the team's name and the year of interest.", "virtual_table": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3673", "db_id": "baseball_1", "question": "What is the total number of postseason games that team Boston Red Stockings participated in?", "rationale": ["Identify the relevant tables: 'postseason' for game outcomes and 'team' for team details.", "Use a UNION to combine results from two queries: one for games where the team won and another for games where the team lost.", "Join the 'postseason' table with the 'team' table on the winning and losing team identifiers respectively.", "Filter the results based on the specified team name using placeholders for string values."], "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"], "description": "The virtual table provides a count of all postseason games that the specified team participated in, either as a winner or a loser. It combines data from the 'postseason' table, which records the outcomes of postseason games, and the 'team' table, which contains information about the teams, including their names. The placeholders in the query represent the name of the team being queried, allowing for flexibility in specifying different teams.", "virtual_table": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: 'home_game' for home game statistics and 'park' for park information.", "Join the 'home_game' table with the 'park' table on the park_id to link games to their respective locations.", "Count the total number of games by using the count(*) function.", "Add conditions to filter the results based on the specified year and city using placeholders for numeric and string values."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "description": "The virtual table provides a count of the total number of home games that took place in a specific city during a given year. It combines data from the 'home_game' table, which records home game statistics, and the 'park' table, which contains information about the parks where these games were held. The placeholders in the query allow users to specify the year and the city of interest.", "virtual_table": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.city  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["Identify the relevant tables, which are 'salary' and 'team'.", "Select the average salary from the 'salary' table.", "Join the 'salary' table with the 'team' table on the team identifier.", "Add a condition to filter the 'team' table for the specified team name using a placeholder for string values."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "description": "The virtual table calculates the average salary of players from the 'salary' table who are associated with a specific team. It joins the 'salary' table with the 'team' table using the team identifier, and filters the results based on the team's name provided as a placeholder.", "virtual_table": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3680", "db_id": "baseball_1", "question": "How many players did Boston Red Stockings have in 2000?", "rationale": ["Identify the relevant tables, which are 'salary' and 'team'.", "Use a JOIN operation to connect the 'salary' table with the 'team' table based on the team identifier.", "Count the total number of players by using the COUNT function.", "Add conditions to filter the results based on the team name and the year using placeholders for string and numeric values."], "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"], "description": "The virtual table provides a count of players from the 'salary' table who were associated with the Boston Red Stockings in the year specified. It joins the 'salary' table with the 'team' table based on the team identifier, filtering the results to include only those players from the specified team name and year.", "virtual_table": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3677", "db_id": "baseball_1", "question": "What is the total salary paid by team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant tables: 'salary' for salary records and 'team' for team information.", "Select the sum of the salary from the 'salary' table.", "Join the 'salary' table with the 'team' table on the team identifier to link salary data with team names.", "Add conditions to filter the results based on the specified team name and year using placeholders."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "description": "The virtual table summarizes the total salary paid by a specific team in a given year. It combines data from the 'salary' table, which contains salary records, and the 'team' table, which provides team identifiers and names. The placeholders in the query allow users to specify the team name and the year for which they want to calculate the total salary.", "virtual_table": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.205", "db_id": "bike_1", "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.", "rationale": ["Identify the relevant tables, which are 'weather' and 'trip'.", "Select the 'zip_code' column from both tables.", "Group the results by 'zip_code' to aggregate data for each zip code.", "Use the HAVING clause to filter for zip codes with an average mean humidity below a specified value from the 'weather' table.", "Use the INTERSECT operator to combine results with another query that filters for zip codes from the 'trip' table that have a count of trips greater than or equal to a specified number."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "description": "The virtual table summarizes the zip codes from the 'weather' and 'trip' tables. It filters the results to include only those zip codes where the average mean humidity is below a specified threshold and where there have been at least a certain number of trips recorded. The placeholders represent the specific humidity value and the minimum number of trips required for inclusion in the results.", "virtual_table": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.142", "db_id": "bike_1", "question": "What are the ids of the stations in San Francisco that normally have more than 10 bikes available?", "rationale": ["Identify the relevant tables, which are 'station' and 'status'.", "Select the 'id' column from the 'station' table to get the station identifiers.", "Filter the 'station' table by the 'city' column using a placeholder for the city name.", "Use an INTERSECT to combine results with a subquery that selects 'station_id' from the 'status' table.", "Group the results by 'station_id' and apply a HAVING clause to filter for stations with an average of bikes available greater than a specified number, using a placeholder for the numeric value."], "gold_sql": "SELECT id FROM station WHERE city  =  'San Francisco' INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available)  >  10", "source_tables": ["status", "station"], "description": "The virtual table provides the unique identifiers of bike stations located in a specific city, filtered to include only those stations that typically have a higher average number of bikes available. The placeholders in the query allow for customization of the city name and the minimum average bike availability threshold.", "virtual_table": "SELECT id FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.123", "db_id": "bike_1", "question": "For each zip code, return the average mean temperature of August there.", "rationale": ["Identify the relevant table, which is 'weather'.", "Select the 'zip_code' and calculate the average of 'mean_temperature_f'.", "Add a condition to filter the records for the month of August using a placeholder for string values in the WHERE clause.", "Group the results by 'zip_code' to get the average temperature for each zip code."], "gold_sql": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE '8/%' GROUP BY zip_code", "source_tables": ["weather"], "description": "The virtual table summarizes the average mean temperature recorded in August for each zip code from the 'weather' table. The placeholder in the WHERE clause is used to filter the records specifically for the month of August, while the results are grouped by zip code to provide the average temperature for each area.", "virtual_table": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY zip_code"}
{"sample_id": "train.133", "db_id": "bike_1", "question": "Which start station had the most trips starting from August? Give me the name and id of the station.", "rationale": ["Identify the relevant table, which is 'trip'.", "Select the columns to display, 'start_station_name' and 'start_station_id'.", "Add a condition to filter the 'start_date' column for trips starting in a specific month using a placeholder for string values.", "Group the results by 'start_station_name' to count the number of trips per station.", "Order the results in descending order based on the count of trips to find the station with the most trips.", "Limit the results to return only the top station."], "gold_sql": "SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE '8/%' GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "description": "The virtual table summarizes the names and identifiers of bike stations from the 'trip' table that had the highest number of trips starting from a specific month. The placeholder in the WHERE clause is used to filter trips based on the start date, while the LIMIT placeholder restricts the number of results returned to the top station.", "virtual_table": "SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.144", "db_id": "bike_1", "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "rationale": ["Identify the relevant tables, which are 'station' and 'status'.", "Select the columns to display, 'name' and 'id' from the 'station' table.", "Join the 'station' table with the 'status' table on the station identifier to access bike availability data.", "Group the results by station identifier to calculate the average number of bikes available.", "Add a condition to filter for stations with an average bike availability greater than a specified number using a placeholder for numeric values.", "Use a UNION to combine results with a second query that selects station names and ids based on installation date, using a placeholder for string values."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "description": "The virtual table provides the names and unique identifiers of bike stations from the 'station' table that either have an average of more than a specified number of bikes available or were installed in a specific month. The first part of the query joins the 'station' and 'status' tables to calculate the average number of bikes available at each station, while the second part filters stations based on their installation date using a placeholder for string values.", "virtual_table": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT name ,  id FROM station WHERE installation_date LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.135", "db_id": "bike_1", "question": "Which bike traveled the most often in zip code 94002?", "rationale": ["Identify the relevant table, which is 'trip'.", "Select the column to display, 'bike_id'.", "Add a condition to filter the 'zip_code' column for the specified zip code using a placeholder for numeric values.", "Group the results by 'bike_id' to count the number of trips for each bike.", "Order the results by the count of trips in descending order to find the most frequently used bike.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "description": "The virtual table summarizes the bike trips recorded in the 'trip' table, specifically focusing on the bike identifiers that have been used most frequently within a specified zip code. The query groups the results by bike ID and orders them by the count of trips in descending order, allowing for the identification of the most frequently used bike. Placeholders are used to represent the zip code and the limit for the number of results returned.", "virtual_table": "SELECT bike_id FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.155", "db_id": "bike_1", "question": "Give me ids for all the trip that took place in a zip code area with average mean temperature above 60.", "rationale": ["Identify the relevant tables, which are 'trip' and 'weather'.", "Select the 'id' column from the 'trip' table to display the trip identifiers.", "Join the 'trip' table with the 'weather' table on the 'zip_code' column to correlate trips with weather data.", "Group the results by 'zip_code' to calculate the average mean temperature for each area.", "Add a condition to filter the groups based on the average mean temperature using a placeholder for numeric values."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  60", "source_tables": ["weather", "trip"], "description": "The virtual table provides the unique identifiers for trips from the 'trip' table that occurred in specific zip code areas. It joins the 'trip' table with the 'weather' table based on matching zip codes and groups the results by zip code. The condition applied filters the groups to include only those with an average mean temperature exceeding a specified threshold, represented by a placeholder for numeric values.", "virtual_table": "SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.145", "db_id": "bike_1", "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?", "rationale": ["Identify the relevant table, which is 'weather'.", "Select the 'cloud_cover' column to display the cloud cover rates.", "Add a condition to filter the 'zip_code' column for the specified region using a placeholder for numeric values.", "Group the results by 'cloud_cover' to aggregate the data.", "Order the results by the count of occurrences in descending order to find the most common rates.", "Limit the results to the top three common cloud cover rates."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "description": "The virtual table presents the cloud cover rates recorded in the 'weather' table for a specific zip code. It groups the data by cloud cover rates and orders them by their frequency, allowing the user to identify the most common rates. The placeholders in the query represent the zip code and the limit for the number of results to return.", "virtual_table": "SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.143", "db_id": "bike_1", "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?", "rationale": ["Identify the relevant tables, which are 'station' and 'status'.", "Select the columns to display, 'name' and 'id' from the 'station' table.", "Join the 'station' table with the 'status' table on the station identifier to access bike availability data.", "Group the results by station identifier to calculate the average number of bikes available.", "Add a condition to filter for stations with an average bike availability greater than a specified number using a placeholder for numeric values.", "Use a UNION to combine results with a second query that selects stations based on their installation date, using a placeholder for string values."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "description": "The virtual table provides the names and unique identifiers of bike stations from the 'station' table that either have an average availability of more than a specified number of bikes or were installed in a specific month. The first part of the query joins the 'station' and 'status' tables to calculate the average number of bikes available at each station, while the second part filters stations based on their installation date using a placeholder for string values.", "virtual_table": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT name ,  id FROM station WHERE installation_date LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.137", "db_id": "bike_1", "question": "How many days had both mean humidity above 50 and mean visibility above 8?", "rationale": ["Identify the relevant table, which is 'weather'.", "Count the total number of records that meet the specified conditions.", "Add conditions to filter the 'mean_humidity' and 'mean_visibility_miles' columns using placeholders for numeric values."], "gold_sql": "SELECT COUNT(*) FROM weather WHERE mean_humidity  >  50 AND mean_visibility_miles  >  8", "source_tables": ["weather"], "description": "The virtual table summarizes the count of days from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that need to be defined by the user.", "virtual_table": "SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.191", "db_id": "bike_1", "question": "For each station, find its latitude and the minimum duration of trips that ended at the station.", "rationale": ["Identify the relevant tables, which are 'station' and 'trip'.", "Select the columns to display: 'name' and 'lat' from the 'station' table, and the minimum 'duration' from the 'trip' table.", "Join the 'station' table with the 'trip' table on the condition that the station's ID matches the end station ID in the trip records.", "Group the results by the end station ID to ensure that the minimum duration is calculated for each station."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "description": "The virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum duration of trips that concluded at each station. The data is aggregated by the station's identifier, allowing for a summary of trip durations associated with each station.", "virtual_table": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id"}
{"sample_id": "train.204", "db_id": "bike_1", "question": "What are the different ids and names of the stations that have had more than 12 bikes available?", "rationale": ["Identify the relevant tables, which are 'station' and 'status'.", "Select the distinct columns to display, 'id' and 'name' from the 'station' table.", "Join the 'station' table with the 'status' table on the station identifier to correlate station information with bike availability.", "Add a condition to filter the results where the number of bikes available exceeds a specified numeric value using a placeholder."], "gold_sql": "SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  12", "source_tables": ["status", "station"], "description": "The virtual table provides a distinct list of station identifiers and names from the 'station' table that are associated with a status indicating more than a specified number of bikes available. The placeholder in the WHERE clause allows for the input of a numeric value to filter the results based on bike availability.", "virtual_table": "SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.190", "db_id": "bike_1", "question": "For each start station id, what is its name, longitude and average duration of trips started there?", "rationale": ["Identify the relevant tables, which are 'station' and 'trip'.", "Select the columns to display: 'name' and 'long' from the 'station' table, and the average of 'duration' from the 'trip' table.", "Join the 'station' table with the 'trip' table on the condition that the station ID matches the start station ID in the trip records.", "Group the results by the start station ID to compute the average duration of trips for each station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "description": "The virtual table provides the names and longitudes of bike stations along with the average duration of trips that started at each station. It combines data from the 'station' table, which includes station identifiers and geographical information, with the 'trip' table, which records trip details including start station identifiers and trip durations. The results are grouped by the start station identifier to calculate the average trip duration for each station.", "virtual_table": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id"}
{"sample_id": "train.184", "db_id": "bike_1", "question": "For each city, list their names in decreasing order by their highest station latitude.", "rationale": ["Identify the relevant table, which is 'station'.", "Select the 'city' column to display the names of the cities.", "Group the results by the 'city' column to ensure each city is listed once.", "Order the results by the maximum latitude of the stations in each city in descending order."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "description": "The virtual table provides a list of cities derived from the 'station' table, grouped by city name. The results are ordered in descending order based on the maximum latitude of the stations located in each city. This allows for an overview of cities ranked by their highest station latitude.", "virtual_table": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC"}
{"sample_id": "train.153", "db_id": "bike_1", "question": "When and in what zip code did max temperature reach 80?", "rationale": ["Identify the relevant table, which is 'weather'.", "Select the columns to display, 'date' and 'zip_code'.", "Add a condition to filter the 'max_temperature_f' column for the specified temperature using a placeholder for numeric values."], "gold_sql": "SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  80", "source_tables": ["weather"], "description": "The virtual table provides the date and zip code from the 'weather' table where the maximum temperature reached or exceeded a specified threshold. The placeholder in the WHERE clause represents the temperature value to filter the results accordingly.", "virtual_table": "SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.167", "db_id": "bike_1", "question": "In zip code 94107, on which day neither Fog nor Rain was not observed?", "rationale": ["Identify the relevant table, which is 'weather'.", "Select the 'date' column to display the days that meet the criteria.", "Add conditions to filter the 'zip_code' for the specified area and exclude specific weather events using placeholders for numeric and string values."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "description": "The virtual table provides the dates from the 'weather' table for a specific zip code where neither fog nor rain events were recorded. The placeholders in the WHERE clause represent the zip code and the weather events to be excluded.", "virtual_table": "SELECT date FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] AND EVENTS != [PLACEHOLDER-TYPE:STRING] AND EVENTS != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.163", "db_id": "bike_1", "question": "Which trip started from the station with the largest dock count? Give me the trip id.", "rationale": ["Identify the relevant tables, which are 'trip' and 'station'.", "Select the 'id' column from the 'trip' table to display the trip identifiers.", "Join the 'trip' table with the 'station' table using the station identifier to correlate trips with their starting stations.", "Order the results by the 'dock_count' column from the 'station' table in descending order to find the station with the largest dock count.", "Limit the output to a specified number of results using a placeholder for numeric values."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "description": "The virtual table provides the unique identifiers of trips that started from the station with the highest number of docks available. It joins the 'trip' table with the 'station' table based on the station's identifier, and orders the results by the dock count in descending order, limiting the output to a specified number of results.", "virtual_table": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.161", "db_id": "bike_1", "question": "For each trip, return its ending station's installation date.", "rationale": ["Identify the relevant tables, which are 'trip' and 'station'.", "Select the trip identifier from the 'trip' table and the installation date from the 'station' table.", "Join the 'trip' table with the 'station' table using the ending station's identifier to link the two datasets."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "description": "The virtual table provides a list of trips along with the installation dates of their respective ending stations. It combines data from the 'trip' table, which contains details about each trip, and the 'station' table, which holds information about the bike stations, including their installation dates. The relationship between the two tables is established through the ending station's identifier.", "virtual_table": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id"}
{"sample_id": "train.211", "db_id": "bike_1", "question": "What is the average latitude and longitude of the starting points of all trips?", "rationale": ["Identify the relevant tables, which are 'station' and 'trip'.", "Join the 'station' table with the 'trip' table using the station identifier to link trips to their starting stations.", "Select the average latitude and longitude from the 'station' table for the starting points of the trips."], "gold_sql": "SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id", "source_tables": ["trip", "station"], "description": "The virtual table provides the average latitude and longitude of the starting points of all trips by joining the 'station' and 'trip' tables. The join is based on the station identifier, allowing for the calculation of average coordinates for all trips that started at various bike stations.", "virtual_table": "SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id"}
{"sample_id": "train.162", "db_id": "bike_1", "question": "What is the installation date for each ending station on all the trips?", "rationale": ["Identify the relevant tables, which are 'trip' and 'station'.", "Select the columns to display, which are the unique identifier from the 'trip' table and the installation date from the 'station' table.", "Join the 'trip' table with the 'station' table on the condition that the end station ID from the 'trip' table matches the ID from the 'station' table."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "description": "The virtual table provides the unique identifiers and installation dates of the ending stations for all trips recorded in the 'trip' table. It combines data from the 'trip' table and the 'station' table based on the matching station identifiers, allowing users to see when each ending station was installed.", "virtual_table": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id"}
{"sample_id": "train.2403", "db_id": "candidate_poll", "question": "What are the support, consider, and oppose rates of each candidate, ordered ascending by their unsure rate?", "rationale": ["Identify the relevant table, which is 'candidate'.", "Select the columns to display: 'Support_rate', 'Consider_rate', and 'Oppose_rate'.", "Add an ORDER BY clause to sort the results based on the 'unsure_rate' column in ascending order."], "gold_sql": "SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate", "source_tables": ["candidate"], "description": "The virtual table presents the support, consideration, and opposition rates of candidates from the 'candidate' table. The results are sorted in ascending order based on the unsure rate, which indicates the percentage of respondents who are uncertain about each candidate.", "virtual_table": "SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate"}
{"sample_id": "train.2417", "db_id": "candidate_poll", "question": "For each sex, what is the name and sex of the candidate with the oppose rate for their sex?", "rationale": ["Identify the relevant tables, which are 'people' and 'candidate'.", "Select the columns to display: 'name' and 'sex' from the 'people' table, and the minimum 'oppose_rate' from the 'candidate' table.", "Join the 'people' table with the 'candidate' table on the 'People_ID' to link candidates with their personal details.", "Group the results by 'sex' to ensure that the minimum oppose rate is calculated for each gender."], "gold_sql": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex", "source_tables": ["candidate", "people"], "description": "The virtual table provides the names and genders of candidates from the 'people' table, along with the minimum oppose rate for each gender. The data is aggregated by gender, allowing for a comparison of the lowest oppose rates among candidates of the same sex.", "virtual_table": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex"}
{"sample_id": "train.2397", "db_id": "candidate_poll", "question": "Return the poll resource associated with the most candidates.", "rationale": ["Identify the relevant table, which is 'candidate'.", "Select the 'poll_source' column to display.", "Group the results by 'poll_source' to count the number of candidates associated with each source.", "Order the results in descending order based on the count of candidates.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "description": "The virtual table summarizes the poll sources from the 'candidate' table, grouping them by the source and counting the number of candidates associated with each source. The placeholder in the LIMIT clause indicates the maximum number of poll sources to return, allowing for flexibility in the query results.", "virtual_table": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2396", "db_id": "candidate_poll", "question": "Which poll resource provided the most number of candidate information?", "rationale": ["Identify the relevant table, which is 'candidate'.", "Select the 'poll_source' column to display the sources of poll data.", "Group the results by 'poll_source' to aggregate the candidate information.", "Count the number of candidates for each poll source and order the results in descending order to find the most frequent source.", "Add a limit to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "description": "The virtual table summarizes the sources of poll data from the 'candidate' table, grouping the information by each unique poll source. It counts the number of candidates associated with each source and orders the results in descending order to identify the source with the highest number of candidates. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2398", "db_id": "candidate_poll", "question": "what are the top 3 highest support rates?", "rationale": ["Identify the relevant table, which is 'candidate'.", "Select the column to display, 'support_rate'.", "Order the results by 'support_rate' in descending order to get the highest values first.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT 3", "source_tables": ["candidate"], "description": "The virtual table contains the support rates of candidates from the 'candidate' table, ordered from highest to lowest. The placeholder in the LIMIT clause indicates the number of top support rates to retrieve.", "virtual_table": "SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.171", "db_id": "car_1", "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?", "rationale": ["Identify the relevant tables: 'MODEL_LIST', 'CAR_NAMES', 'CARS_DATA', and 'CAR_MAKERS'.", "Select the distinct 'model' column from the 'MODEL_LIST'.", "Join the tables on their respective identifiers to link models to their makes and data.", "Add conditions to filter models based on weight and exclude those made by a specific manufacturer using placeholders for numeric and string values."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';", "source_tables": ["car_makers", "model_list", "car_names", "cars_data"], "description": "The virtual table describes distinct car models from the 'MODEL_LIST' that are lighter than a specified weight and are not manufactured by a specific car maker. The placeholders in the WHERE clause represent the weight limit and the name of the car maker to exclude.", "virtual_table": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  [PLACEHOLDER-TYPE:NUMBER] AND T4.FullName != [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the relevant tables, which are 'CAR_NAMES' and 'CARS_DATA'.", "Select the columns to display, 'horsepower' from 'CARS_DATA' and 'Make' from 'CAR_NAMES'.", "Join the two tables on the condition that 'MakeId' from 'CAR_NAMES' matches 'Id' from 'CARS_DATA'.", "Add a condition to filter the 'cylinders' column for the specified number of cylinders using a placeholder for numeric values.", "Order the results by 'horsepower' in descending order and limit the number of results using placeholders."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "The virtual table summarizes the maximum horsepower and the make of car models from the 'CAR_NAMES' and 'CARS_DATA' tables, specifically for models that have 3 cylinders. The placeholders in the WHERE clause represent the number of cylinders to filter by, and the LIMIT clause allows for specifying how many results to return.", "virtual_table": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the relevant tables: 'countries', 'continents', and 'car_makers'.", "Select the column to display, which is 'CountryName' from the 'countries' table.", "Join the 'countries' table with the 'continents' table to filter for countries in Europe.", "Join the 'countries' table with the 'car_makers' table to count the number of manufacturers per country.", "Add a condition to filter for the continent being 'Europe' using a placeholder for string values.", "Group the results by 'CountryName' and use a HAVING clause to ensure that only countries with at least three manufacturers are included, using a placeholder for the numeric value."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "description": "The virtual table lists the names of countries from the 'countries' table that are located in Europe and have a minimum of three car manufacturers. The query joins the 'countries' table with the 'continents' table to filter for European countries and then joins with the 'car_makers' table to count the number of manufacturers per country. The placeholders represent the continent name and the minimum count of manufacturers required.", "virtual_table": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.CountryName HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.161", "db_id": "car_1", "question": "How many countries has more than 2 car makers ?", "rationale": ["Identify the relevant tables, which are 'countries' and 'car_makers'.", "Count the number of car makers for each country by joining the two tables on the country identifier.", "Group the results by country to aggregate the count of car makers.", "Use a HAVING clause to filter the results to only include countries with a count greater than a specified number, represented by a placeholder."], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "source_tables": ["car_makers", "countries"], "description": "The virtual table provides a count of countries from the 'countries' table that have more than a specified number of car makers associated with them. The join operation links the 'countries' table with the 'car_makers' table based on the country identifier, and the result is grouped by country to count the number of car makers per country. The placeholder in the HAVING clause allows for filtering countries based on a specified minimum count of car makers.", "virtual_table": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.175", "db_id": "car_1", "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .", "rationale": ["Identify the relevant tables, which are 'car_makers', 'model_list', and 'car_names'.", "Select the columns to display, 'id' and 'maker' from the 'car_makers' table.", "Join the 'car_makers' table with the 'model_list' table to count the number of models produced by each maker.", "Group the results by 'id' to aggregate the counts of models for each maker.", "Use the HAVING clause to filter makers that produce at least a specified number of models.", "Perform an intersection with another query that counts the number of car makers associated with each model, ensuring that the results meet the criteria for both counts."], "gold_sql": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "description": "The virtual table provides a list of car makers from the 'car_makers' table who produce at least a specified number of models and are associated with more than a specified number of car makers. The placeholders in the HAVING clauses represent the minimum counts for models and car makers, respectively.", "virtual_table": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["Identify the relevant tables, which are 'CAR_MAKERS', 'MODEL_LIST', and 'CAR_NAMES'.", "Select the columns to display, 'Id' and 'Maker' from the 'CAR_MAKERS' table.", "Join the 'CAR_MAKERS' table with the 'MODEL_LIST' table to filter car makers based on the number of models they produce.", "Group the results by 'Id' and 'Maker' to count the number of models for each maker.", "Use the HAVING clause to filter makers that produce at least a specified number of models.", "Perform an intersection with another query that counts the number of cars for each maker by joining 'CAR_MAKERS', 'MODEL_LIST', and 'CAR_NAMES'.", "Use the HAVING clause again to filter makers that manufacture more than a specified number of cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "description": "The virtual table provides the unique identifiers and names of car makers from the 'CAR_MAKERS' table who produce a minimum number of car models and manufacture a greater number of cars. The placeholders in the HAVING clause represent the minimum counts required for models and cars, respectively.", "virtual_table": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.104", "db_id": "car_1", "question": "What are the different models for the cards produced after 1980?", "rationale": ["Identify the relevant tables: 'model_list', 'car_names', and 'cars_data'.", "Select the distinct 'model' column from the 'model_list' table.", "Join the 'model_list' with 'car_names' on the model name to link car models with their respective makes.", "Join the resulting table with 'cars_data' to access the manufacturing year of each model.", "Add a condition to filter the results for models manufactured after a specified year using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "description": "The virtual table describes the distinct car models produced after a specified year, sourced from the 'model_list', 'car_names', and 'cars_data' tables. The placeholder in the WHERE clause represents the year threshold for filtering the car models.", "virtual_table": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.103", "db_id": "car_1", "question": "Which distinct car models are the produced after 1980?", "rationale": ["Identify the relevant tables: 'model_list', 'car_names', and 'cars_data'.", "Select the distinct 'model' column from the 'model_list' table.", "Join the 'model_list' with 'car_names' on the model name to link car models with their makes.", "Join the resulting table with 'cars_data' to access the manufacturing year of each model.", "Add a condition to filter the results based on the year using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "description": "The virtual table describes distinct car models produced after a specific year, sourced from the 'model_list', 'car_names', and 'cars_data' tables. The placeholder in the WHERE clause represents the year threshold for filtering the car models.", "virtual_table": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.157", "db_id": "car_1", "question": "For model volvo, how many cylinders does the car with the least accelerate have?", "rationale": ["Identify the relevant tables, which are 'CARS_DATA' and 'CAR_NAMES'.", "Select the 'cylinders' column from 'CARS_DATA'.", "Join 'CARS_DATA' with 'CAR_NAMES' on the matching 'Id' and 'MakeId' columns.", "Add a condition to filter the 'Model' column in 'CAR_NAMES' for the specified model using a placeholder for string values.", "Order the results by the 'accelerate' column in ascending order to find the car with the least acceleration time.", "Limit the results to one entry using a placeholder for numeric values."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "description": "The virtual table describes the number of cylinders for a specific car model from the 'CARS_DATA' table, filtered by the model name provided. It retrieves the car with the least acceleration time, ordering the results in ascending order and limiting the output to one entry. The placeholders represent the car model's name and the limit for the number of results.", "virtual_table": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables, which are 'CAR_NAMES' and 'CARS_DATA'.", "Select the 'Model' column from 'CAR_NAMES'.", "Join 'CAR_NAMES' with 'CARS_DATA' on the 'MakeId' and 'Id' columns respectively.", "Add a condition to filter the 'Cylinders' column for the specified number using a placeholder for numeric values.", "Order the results by 'horsepower' in descending order to find the model with the largest horsepower.", "Limit the results to a single entry using a placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "The virtual table describes car models from the 'CAR_NAMES' table that are associated with specific car entries in the 'CARS_DATA' table. It filters the results to include only those models that have a specified number of cylinders, represented by a placeholder. The results are ordered by horsepower in descending order, allowing the identification of the model with the largest horsepower for the given cylinder count. The second placeholder limits the number of results returned.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.97", "db_id": "car_1", "question": "Find the model of the car whose weight is below the average weight.", "rationale": ["Identify the relevant tables, which are 'CAR_NAMES' and 'CARS_DATA'.", "Select the 'model' column from 'CAR_NAMES'.", "Join 'CAR_NAMES' with 'CARS_DATA' on the 'MakeId' and 'Id' columns to associate car models with their data.", "Add a condition to filter the results where the weight of the cars is less than the average weight calculated from the 'CARS_DATA' table."], "gold_sql": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "source_tables": ["car_names", "cars_data"], "description": "The virtual table provides the models of cars from the 'CAR_NAMES' table that have a weight less than the average weight of all cars in the 'CARS_DATA' table. The query uses a join to connect car models with their corresponding data entries, and it includes a subquery to calculate the average weight.", "virtual_table": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)"}
{"sample_id": "dev.115", "db_id": "car_1", "question": "How many car models are produced in the usa?", "rationale": ["Identify the relevant tables: 'model_list', 'car_makers', and 'countries'.", "Count the total number of car models by using the count(*) function.", "Join the 'model_list' table with the 'car_makers' table on the Maker identifier.", "Join the 'car_makers' table with the 'countries' table on the Country identifier.", "Add a condition to filter the results based on the specified country name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "description": "The virtual table provides a count of car models produced by car makers based in a specific country. It combines data from the 'model_list', 'car_makers', and 'countries' tables, linking them through their respective identifiers. The placeholder in the WHERE clause represents the name of the country for which the count of car models is requested.", "virtual_table": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.114", "db_id": "car_1", "question": "What is the number of makers of care in France?", "rationale": ["Identify the relevant tables, which are 'car_makers' and 'countries'.", "Use a JOIN to connect 'car_makers' with 'countries' based on the country identifier.", "Select the count of car makers as the output.", "Add a condition to filter the 'CountryName' column for the specified country using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "description": "The virtual table provides a count of car makers based in a specific country, which is France in this case. It combines data from the 'car_makers' and 'countries' tables, linking them through the country identifier. The placeholder in the WHERE clause allows for the specification of the country name to filter the results accordingly.", "virtual_table": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.134", "db_id": "car_1", "question": "What is the car model with the highest mpg ?", "rationale": ["Identify the relevant tables, which are 'car_names' and 'cars_data'.", "Join the two tables on the condition that the 'makeid' from 'car_names' matches the 'id' from 'cars_data'.", "Select the 'model' column from 'car_names'.", "Order the results by the 'mpg' column from 'cars_data' in descending order to get the highest mpg first.", "Use a placeholder to limit the number of results returned, allowing the user to specify the desired number."], "gold_sql": "select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit 1;", "source_tables": ["car_names", "cars_data"], "description": "The virtual table describes the car models from the 'car_names' table, joined with the 'cars_data' table to retrieve their corresponding miles per gallon (mpg) values. The results are ordered in descending order based on mpg, and a placeholder is used to limit the number of results returned, allowing the user to specify how many top models they want to see.", "virtual_table": "select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.122", "db_id": "car_1", "question": "What are the makers and models?", "rationale": ["Identify the relevant table, which is 'model_list'.", "Select the columns to display, 'Maker' and 'Model'.", "This query retrieves the names of car makers and their associated models from the 'model_list' table."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "description": "The virtual table provides a list of car makers along with their corresponding car models. The data is sourced from the 'model_list' table, which links car makers to their models, allowing users to see the relationship between different car manufacturers and the models they produce.", "virtual_table": "SELECT Maker ,  Model FROM MODEL_LIST;"}
{"sample_id": "dev.121", "db_id": "car_1", "question": "What are all the makers and models?", "rationale": ["Identify the relevant table, which is 'model_list'.", "Select the columns to display, 'Maker' and 'Model'.", "No filtering conditions are needed as the query requests all makers and models."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "description": "The virtual table lists the makers and models of cars from the 'model_list' table. The columns include the short name of the car maker and the name of the car model.", "virtual_table": "SELECT Maker ,  Model FROM MODEL_LIST;"}
{"sample_id": "dev.96", "db_id": "car_1", "question": "What is the model of the car with the smallest amount of horsepower?", "rationale": ["Identify the relevant tables, which are 'CAR_NAMES' and 'CARS_DATA'.", "Select the 'Model' column from 'CAR_NAMES'.", "Join 'CAR_NAMES' with 'CARS_DATA' on the 'MakeId' to access horsepower information.", "Order the results by the 'horsepower' column in ascending order to find the smallest value.", "Limit the output to a single result using a placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "The virtual table describes the model of the car from the 'CAR_NAMES' table that has the smallest amount of horsepower. It joins the 'CARS_DATA' table to access the horsepower data and orders the results in ascending order, limiting the output to the top entry. The placeholder in the LIMIT clause represents the number of results to return.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6298", "db_id": "city_record", "question": "Please give me a list of cities whose regional population is over 8000000 or under 5000000.", "rationale": ["Identify the relevant table, which is 'city'.", "Select the column to display, which is 'city'.", "Add conditions to filter the 'regional_population' column for both specified thresholds using placeholders for numeric values."], "gold_sql": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000", "source_tables": ["city"], "description": "The virtual table lists the names of cities from the 'city' table that have a regional population either exceeding a specified upper limit or falling below a specified lower limit. The placeholders in the WHERE clauses represent the numeric thresholds for population.", "virtual_table": "SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the relevant tables: 'city', 'temperature', and 'hosting_city'.", "Join the 'city' table with the 'temperature' table to access temperature data for each city.", "Apply a condition to filter cities where the average temperature in March is less than in December.", "Use the EXCEPT clause to exclude cities that have hosted matches by checking against the 'hosting_city' table."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "The virtual table lists cities that have a lower average temperature in March compared to December and have never hosted a match. It combines data from the 'city' and 'temperature' tables to filter cities based on their temperature records, while excluding those that appear in the 'hosting_city' table.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6290", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in July and which have also served as host cities?", "rationale": ["Identify the relevant tables: 'city', 'temperature', and 'hosting_city'.", "Join the 'city' table with the 'temperature' table to access temperature data for each city.", "Filter the results to include only those cities where the average temperature in March is lower than in July.", "Use an INTERSECT operation to ensure that the cities listed have also served as host cities, by joining the 'city' table with the 'hosting_city' table."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "The virtual table provides a list of cities that have hosted matches and have a March temperature lower than their July temperature. It combines data from the 'city', 'temperature', and 'hosting_city' tables, ensuring that only cities meeting the temperature criteria and hosting criteria are included.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6292", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in Dec and which have never been host cities.", "rationale": ["Identify the relevant tables: 'city', 'temperature', and 'hosting_city'.", "Select the 'city' column from the 'city' table.", "Join the 'city' table with the 'temperature' table to access temperature data for comparison.", "Add a condition to filter cities where the March temperature is less than the December temperature.", "Use the EXCEPT clause to exclude cities that appear in the 'hosting_city' table, indicating they have hosted matches."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "The virtual table lists cities from the 'city' table that have a March temperature lower than their December temperature, while also excluding those cities that have hosted any matches. The comparison of temperatures is done using the 'temperature' table, and the exclusion of host cities is managed through the 'hosting_city' table.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6289", "db_id": "city_record", "question": "Which cities' temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables, which are 'city' and 'temperature'.", "Select the 'city' column from the 'city' table.", "Join the 'city' table with the 'temperature' table on the 'city_id' to access temperature data.", "Add conditions to filter cities based on the average temperature in March compared to July and October using placeholders for numeric values."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "description": "The virtual table provides a list of cities along with their temperature data, specifically focusing on the comparison of average temperatures in March with those in July and October. The query filters cities where the temperature in March is either lower than in July or higher than in October, allowing users to analyze temperature variations across different months.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct"}
{"sample_id": "train.6276", "db_id": "city_record", "question": "What is the venue of the competition \"1994 FIFA World Cup qualification\" hosted by \"Nanjing ( Jiangsu )\"?", "rationale": ["Identify the relevant tables: 'city', 'hosting_city', and 'match'.", "Select the 'venue' column from the 'match' table.", "Join the 'city' table with 'hosting_city' on the city identifier to filter by the host city.", "Join the 'hosting_city' table with 'match' on the match identifier to access competition details.", "Add conditions to filter the results based on the specified city name and competition name using placeholders for string values."], "gold_sql": "SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = 'Nanjing ( Jiangsu )' AND T3.competition = '1994 FIFA World Cup qualification'", "source_tables": ["hosting_city", "city", "match"], "description": "The virtual table provides information about the venue of matches from the 'match' table that were hosted in a specific city, as indicated in the 'hosting_city' table. It joins the 'city' table to filter by the city's name and the 'match' table to filter by the competition name, both represented by placeholders for string values.", "virtual_table": "SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables, which are 'city' and 'temperature'.", "Join the 'city' table with the 'temperature' table on the 'City_ID' to associate cities with their temperature data.", "Select the 'City' column from the 'city' table to display the names of the cities.", "Order the results by the 'Feb' column from the 'temperature' table in descending order to find the highest temperature.", "Use a placeholder in the LIMIT clause to allow the user to specify how many cities they want to retrieve."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "description": "The virtual table provides a list of cities along with their corresponding February temperatures, sorted in descending order. The placeholder in the LIMIT clause indicates that the user can specify the number of cities to retrieve, allowing for flexibility in the query results.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6283", "db_id": "city_record", "question": "What are the three largest cities in terms of regional population?", "rationale": ["Identify the relevant table, which is 'city'.", "Select the column to display, 'city'.", "Order the results by 'regional_population' in descending order to get the largest cities first.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "description": "The virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder indicates that the user can specify the number of cities to retrieve, allowing for flexibility in the query results.", "virtual_table": "SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4270", "db_id": "club_1", "question": "Find all the female members of club \"Bootup Baltimore\". Show the first name and last name.", "rationale": ["Identify the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "Select the columns to display: 'fname' and 'lname' from the 'Student' table.", "Join the 'Club' table with the 'Member_of_club' table on 'ClubID' to link clubs with their members.", "Join the 'Member_of_club' table with the 'Student' table on 'StuID' to link members with their details.", "Add conditions to filter for the specified club name and for female students using placeholders for string values."], "gold_sql": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  'Bootup Baltimore' AND t3.sex  =  'F'", "source_tables": ["club", "member_of_club", "student"], "description": "The virtual table provides the first and last names of female students who are members of a specific club. It combines data from the 'Student', 'Club', and 'Member_of_club' tables, filtering for a particular club name and gender. The placeholders in the WHERE clause represent the club's name and the gender of the students.", "virtual_table": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  [PLACEHOLDER-TYPE:STRING] AND t3.sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4278", "db_id": "club_1", "question": "Find the name of the club that has the most female students.", "rationale": ["Identify the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "Select the column to display, which is 'clubname' from the 'Club' table.", "Join the 'Club' table with 'Member_of_club' on 'clubid' and then with 'Student' on 'stuid' to access student information.", "Add a condition to filter the results based on the 'sex' column for female students using a placeholder for string values.", "Group the results by 'clubname' to count the number of female members in each club.", "Order the results in descending order based on the count of female members and limit the output to the top result using placeholders for the limit."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "description": "The virtual table provides the names of clubs from the 'Club' table that have the highest number of female students as members. It joins the 'Club', 'Member_of_club', and 'Student' tables to filter the results based on the gender of the students, using a placeholder for the gender value and another placeholder to limit the number of results returned.", "virtual_table": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4279", "db_id": "club_1", "question": "Which club has the most female students as their members? Give me the name of the club.", "rationale": ["Identify the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "Select the 'clubname' from the 'Club' table.", "Join the 'Member_of_club' table to associate students with their respective clubs.", "Join the 'Student' table to filter members based on their gender.", "Add a condition to filter the 'sex' column for female students using a placeholder for string values.", "Group the results by club name and order them by the count of female members in descending order.", "Limit the results to return only the top club using a placeholder for numeric values."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "description": "The virtual table provides the names of clubs from the 'Club' table that have the highest number of female student members. It joins the 'Club', 'Member_of_club', and 'Student' tables to filter members based on gender, using a placeholder for the gender value and another placeholder to limit the number of results returned.", "virtual_table": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4312", "db_id": "club_1", "question": "List the clubs that have at least a member with advisor \"1121\".", "rationale": ["Identify the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "Select the distinct 'ClubName' from the 'Club' table.", "Join the 'Member_of_club' table on 'ClubID' to associate members with their respective clubs.", "Join the 'Student' table on 'StuID' to access the advisor information of the members.", "Add a condition to filter the results based on the advisor's ID using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  1121", "source_tables": ["club", "member_of_club", "student"], "description": "The virtual table lists the unique names of clubs from the 'Club' table that have at least one member whose academic advisor matches a specified identifier. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the advisor's ID provided as a placeholder.", "virtual_table": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4256", "db_id": "club_1", "question": "What are the first names of all the students?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the column to display, 'Fname', ensuring to retrieve distinct values to avoid duplicates."], "gold_sql": "SELECT DISTINCT fname FROM student", "source_tables": ["student"], "description": "The virtual table contains the distinct first names of students from the 'Student' table. This table provides a unique list of first names without any duplicates.", "virtual_table": "SELECT DISTINCT fname FROM student"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["Identify the relevant tables: 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT'.", "Select the distinct first names from the 'EMPLOYEE' table and the highest degree from the 'PROFESSOR' table.", "Join the tables based on their relationships: 'CLASS' to 'EMPLOYEE' via 'PROF_NUM', 'EMPLOYEE' to 'PROFESSOR' via 'EMP_NUM', and 'PROFESSOR' to 'DEPARTMENT' via 'DEPT_CODE'.", "Add a condition to filter the results based on the department name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "description": "The virtual table provides a list of distinct first names of professors along with their highest degree attained, specifically for those teaching in a designated department. The query joins multiple tables: 'CLASS' to identify the professors, 'EMPLOYEE' to retrieve their first names, 'PROFESSOR' to access their highest degree, and 'DEPARTMENT' to filter by the department name. The placeholder in the WHERE clause allows for specifying the department of interest.", "virtual_table": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3272", "db_id": "college_1", "question": "Which department has the most professors with a Ph.D.?", "rationale": ["Identify the relevant tables, which are 'professor' and 'department'.", "Select the columns to display, 'dept_name' from the 'department' table and 'dept_code' from the 'professor' table.", "Join the 'professor' table with the 'department' table on the department code to associate professors with their respective departments.", "Add a condition to filter the professors based on their highest degree using a placeholder for string values.", "Group the results by department code to aggregate the count of professors per department.", "Order the results by the count of professors in descending order to find the department with the most professors.", "Limit the results to return only the top department based on the count of professors."], "gold_sql": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  'Ph.D.' GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["department", "professor"], "description": "The virtual table provides a list of department names along with their corresponding department codes, specifically focusing on departments that have professors holding a Ph.D. The results are grouped by department code and ordered by the count of professors in descending order, allowing for the identification of the department with the highest number of Ph.D. professors. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the number of results to return.", "virtual_table": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3323", "db_id": "college_1", "question": "Find the first names and degree of all professors who are teaching some class in Computer Info. Systems department.", "rationale": ["Identify the relevant tables: 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT'.", "Select the columns to display: 'emp_fname' from 'EMPLOYEE' and 'prof_high_degree' from 'PROFESSOR'.", "Join the tables based on their relationships: 'CLASS' to 'EMPLOYEE' via 'prof_num', 'EMPLOYEE' to 'PROFESSOR' via 'emp_num', and 'PROFESSOR' to 'DEPARTMENT' via 'dept_code'.", "Add a condition to filter the 'DEPARTMENT' table for the specified department's name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "description": "The virtual table provides the first names and highest degrees of professors from the 'professor' table who are teaching classes associated with a specific department. The query joins multiple tables to filter professors based on the department's name, represented by a placeholder for string values.", "virtual_table": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["Identify the relevant tables, which are 'employee' and 'class'.", "Select the column to display, 'emp_fname' from the 'employee' table.", "Join the 'employee' table with the 'class' table on the professor's identifier 'emp_num' and 'prof_num'.", "Add conditions to filter the 'crs_code' column for the specified courses using placeholders for string values."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "description": "The virtual table provides the first names of professors who are teaching specific courses. It combines data from the 'employee' and 'class' tables, linking them through the professor's identifier. The placeholders in the WHERE clause represent the course codes for which the professors are being queried.", "virtual_table": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the relevant tables: 'student', 'enroll', 'class', 'course', and 'department'.", "Select the column to display, which is 'stu_fname' from the 'student' table.", "Join the tables based on their relationships: 'student' to 'enroll' on 'stu_num', 'enroll' to 'class' on 'class_code', 'class' to 'course' on 'crs_code', and 'course' to 'department' on 'dept_code'.", "Add conditions to filter the results for the specified departments using placeholders for string values.", "Use INTERSECT to ensure that only students enrolled in both departments are included."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "description": "The virtual table provides the first names of students who are enrolled in classes from both the accounting and Computer Info. Systems departments. It combines data from multiple tables, including 'student', 'enroll', 'class', 'course', and 'department', using joins to connect the relevant identifiers. The placeholders in the WHERE clause represent the names of the departments being queried.", "virtual_table": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["Identify the relevant tables, which are 'employee' and 'CLASS'.", "Select the columns to display, 'EMP_FNAME' and 'EMP_DOB' from the 'employee' table.", "Join the 'employee' table with the 'CLASS' table on the professor's identifier to link professors with their classes.", "Add a condition to filter the 'CRS_CODE' column for the specified course using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "description": "The virtual table provides the first names and dates of birth of professors from the 'employee' table who are teaching a specific course. The placeholder in the WHERE clause represents the course code associated with the class.", "virtual_table": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3216", "db_id": "college_1", "question": "How many professors have a Ph.D. in each department?", "rationale": ["Identify the relevant table, which is 'professor'.", "Select the count of professors and the department code to display.", "Add a condition to filter the 'prof_high_degree' column for the specified degree using a placeholder for string values.", "Group the results by 'dept_code' to aggregate the count of professors per department."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "description": "The virtual table provides a count of professors holding a specific highest degree, grouped by their respective departments. The placeholder in the WHERE clause allows for filtering by the degree type, such as a Ph.D., while the GROUP BY clause organizes the results by department code.", "virtual_table": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the relevant table, which is 'employee'.", "Select the column to display, 'emp_fname'.", "Add a condition to filter the 'emp_jobcode' column using a placeholder for string values.", "Use the EXCEPT clause to exclude professors who are teaching classes by joining the 'employee' table with the 'CLASS' table on the professor's identifier."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "description": "The virtual table provides the first names of professors from the 'employee' table who are not currently assigned to teach any classes. The query uses a placeholder to specify the job code of the professors, and it excludes those who are linked to any class in the 'CLASS' table by comparing the professor's identifier with the professor number in the class records.", "virtual_table": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num"}
{"sample_id": "train.3210", "db_id": "college_1", "question": "How many different professors are there for the different schools?", "rationale": ["Identify the relevant tables, which are 'department' and 'professor'.", "Count the number of professors by grouping them according to the 'school_code' from the 'department' table.", "Use a JOIN operation to connect the 'department' and 'professor' tables based on the 'dept_code' to ensure accurate counting of professors per school."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "description": "The virtual table provides a count of distinct professors associated with various schools, as represented by the 'school_code' from the 'department' table. The query joins the 'department' and 'professor' tables based on the department code, allowing for aggregation of professors by their respective schools.", "virtual_table": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["Identify the relevant table, which is 'Course'.", "Select the sum of 'crs_credit' to calculate the total credit hours offered.", "Group the results by 'dept_code' to aggregate the total credit hours for each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "description": "The virtual table summarizes the total credit hours offered by each department based on the courses available in the 'Course' table. The placeholder in the SELECT statement represents the total credit hours, while the GROUP BY clause organizes the results by department code.", "virtual_table": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code"}
{"sample_id": "train.3315", "db_id": "college_1", "question": "Find the first names and offices of all instructors who have taught some course and the course description and the department name.", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, COURSE, PROFESSOR, and DEPARTMENT.", "Select the columns to display: first names from EMPLOYEE, office locations from PROFESSOR, course descriptions from COURSE, and department names from DEPARTMENT.", "Establish the necessary joins between the tables based on their relationships, such as linking CLASS to EMPLOYEE through professor identifiers, and linking COURSE to CLASS through course codes."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code", "source_tables": ["course", "department", "professor", "class", "employee"], "description": "The virtual table provides the first names and office locations of instructors who have taught courses, along with the descriptions of those courses and the names of the departments offering them. It combines data from multiple tables, including CLASS, EMPLOYEE, COURSE, PROFESSOR, and DEPARTMENT, to present a comprehensive view of the instructors and their associated courses and departments.", "virtual_table": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant table, which is 'CLASS'.", "Select the count of distinct 'PROF_NUM' to determine the number of unique professors.", "Add a condition to filter the 'CRS_CODE' column for the specified class code using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "description": "The virtual table provides a count of distinct professors from the 'CLASS' table who are assigned to teach a specific class identified by its course code. The placeholder in the WHERE clause represents the course code for which the count of professors is being queried.", "virtual_table": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["Identify the relevant tables: CLASS, ENROLL, COURSE, and DEPARTMENT.", "Join the tables based on their relationships to connect classes with enrollments and courses with departments.", "Select the 'dept_name' from the DEPARTMENT table.", "Group the results by department code to count the number of students enrolled in each department.", "Order the results in descending order based on the count of enrollments to find the department with the most students.", "Limit the results to return only the top department based on the specified number."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "description": "The virtual table provides the names of departments from the 'department' table that have the highest number of students enrolled in their courses. It aggregates the data by counting the number of enrollments per department and orders the results to show the department with the most students at the top. The placeholder in the LIMIT clause allows for specifying how many top departments to return.", "virtual_table": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["Identify the relevant tables, which are 'department' and 'professor'.", "Join the 'department' table with the 'professor' table on the department code to associate professors with their respective schools.", "Select the 'school_code' from the 'department' table.", "Group the results by 'school_code' to aggregate the count of professors for each school.", "Order the results by the count of professors in ascending order to find the school with the smallest number.", "Use a placeholder to limit the results to the top entry."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "description": "The virtual table identifies the school codes from the 'department' table, joining it with the 'professor' table to count the number of professors associated with each school. The results are grouped by school code and ordered by the count of professors, allowing for the identification of the school with the smallest number of professors, as indicated by the placeholder for limiting the results.", "virtual_table": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3253", "db_id": "college_1", "question": "What is the name of the department that has the largest number of students enrolled?", "rationale": ["Identify the relevant tables: 'CLASS', 'ENROLL', 'COURSE', and 'DEPARTMENT'.", "Join these tables based on their foreign key relationships to access the necessary data.", "Count the number of students enrolled in each department by grouping the results by department code.", "Order the results in descending order to find the department with the largest number of students.", "Use a placeholder in the LIMIT clause to allow for flexibility in specifying how many top results to return."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "description": "The virtual table provides the name of the department with the highest enrollment of students by aggregating data from multiple tables. It joins the 'CLASS', 'ENROLL', 'COURSE', and 'DEPARTMENT' tables to count the number of students in each department, grouping the results by department code and ordering them in descending order of student count. The placeholder in the LIMIT clause allows for specifying the number of top results to return.", "virtual_table": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3237", "db_id": "college_1", "question": "Find the total credits of all classes offered by each department.", "rationale": ["Identify the relevant tables, which are 'course' and 'class'.", "Select the sum of 'crs_credit' from the 'course' table and group the results by 'dept_code'.", "Join the 'course' table with the 'class' table on the 'crs_code' to link classes with their respective courses."], "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"], "description": "The virtual table summarizes the total credits of all classes offered by each department by aggregating the credit hours from the 'course' table and joining it with the 'class' table based on the course code. The result is grouped by the department code, allowing for a clear view of the total credits associated with each department.", "virtual_table": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["Identify the relevant tables: 'course', 'class', and 'department'.", "Join the 'course' table with the 'class' table on the course code to associate classes with their respective courses.", "Join the resulting table with the 'department' table to retrieve department names based on the department code.", "Group the results by department to aggregate the total credit hours offered by each department.", "Order the results by the sum of credit hours in descending order to find the department offering the most credits.", "Use a placeholder for the limit to specify how many departments to return."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "description": "The virtual table summarizes the names of departments that offer courses, along with the total credit hours associated with those courses. It aggregates the credit hours from the 'course' table, joins it with the 'class' table to associate classes with their respective courses, and then links to the 'department' table to retrieve the department names. The results are grouped by department and ordered by the total credit hours in descending order, with a limit specified by a placeholder for numeric values.", "virtual_table": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["Identify the relevant table, which is 'student'.", "Select the column to aggregate, 'stu_hrs', and group the results by 'dept_code'.", "Use the SUM function to calculate the total hours for each department."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "The virtual table summarizes the total credit hours completed by students grouped by their respective departments. It aggregates the 'stu_hrs' from the 'student' table and categorizes the results based on the 'dept_code' associated with each student.", "virtual_table": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3205", "db_id": "college_1", "question": "Find the number of classes in each department.", "rationale": ["Identify the relevant tables, which are 'CLASS' and 'COURSE'.", "Count the total number of classes using the count(*) function.", "Join the 'CLASS' table with the 'COURSE' table on the course code to associate classes with their respective departments.", "Group the results by the department code to get the count of classes per department."], "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"], "description": "The virtual table provides a count of classes grouped by their respective departments. It combines data from the 'CLASS' and 'COURSE' tables, linking them through the course code. The result will show the total number of classes available in each department, with a placeholder for the department code used in the grouping.", "virtual_table": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["Identify the relevant table, which is 'Student'.", "Use the COUNT function to calculate the number of students.", "Group the results by the 'dept_code' to get the count for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "The virtual table summarizes the count of students grouped by their respective departments from the 'Student' table. Each entry in the table represents a department code along with the total number of students enrolled in that department.", "virtual_table": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3241", "db_id": "college_1", "question": "How many students enrolled in class ACCT-211?", "rationale": ["Identify the relevant tables, which are 'CLASS' and 'ENROLL'.", "Use a JOIN to connect the 'CLASS' table with the 'ENROLL' table based on the class code.", "Select the count of students by using the count(*) function.", "Add a condition to filter the results based on the course code using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["class", "enroll"], "description": "The virtual table provides a count of students enrolled in a specific class from the 'CLASS' and 'ENROLL' tables. The placeholder in the WHERE clause represents the course code associated with the class, allowing users to specify which class they are inquiring about.", "virtual_table": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3300", "db_id": "college_1", "question": "What is the name of the department with the student that has the lowest GPA?", "rationale": ["Identify the relevant tables, which are 'student' and 'department'.", "Join the 'student' table with the 'department' table using the 'dept_code' to link students to their respective departments.", "Select the 'dept_name' from the 'department' table.", "Order the results by 'stu_gpa' in ascending order to find the student with the lowest GPA.", "Limit the results to one entry to get only the department name of the student with the lowest GPA."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "description": "The virtual table provides the name of the department associated with the student who has the lowest GPA. It combines data from the 'student' and 'department' tables, linking them through the department code. The result is ordered by the student's GPA in ascending order, ensuring that the student with the lowest GPA is selected.", "virtual_table": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["Identify the relevant tables: 'CLASS', 'ENROLL', and 'STUDENT'.", "Select the column to display, which is 'stu_fname' from the 'STUDENT' table.", "Join the 'CLASS' table with the 'ENROLL' table on 'class_code' to link classes with enrollments.", "Join the 'ENROLL' table with the 'STUDENT' table on 'stu_num' to link enrollments with student details.", "Add conditions to filter the results based on the specified course code and grade using placeholders for string values."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "description": "The virtual table provides the first names of students who are enrolled in a specific class and have received a particular grade. It combines data from the 'CLASS', 'ENROLL', and 'STUDENT' tables, using placeholders to filter by the course code and the grade received.", "virtual_table": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables, which are 'course' and 'department'.", "Select the column to display, 'dept_name' from the 'department' table.", "Join the 'course' table with the 'department' table using the 'dept_code' to link them.", "Add a condition to filter the 'crs_description' column for descriptions that contain a specific keyword using a placeholder for string values."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "description": "The virtual table provides the names of departments that offer courses with descriptions containing a specific keyword. The query joins the 'course' and 'department' tables based on the department code, filtering the results to include only those courses whose descriptions match the given criteria.", "virtual_table": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3299", "db_id": "college_1", "question": "What is the department name of the students with lowest gpa belongs to?", "rationale": ["Identify the relevant tables, which are 'Student' and 'Department'.", "Select the 'dept_name' column from the 'Department' table.", "Join the 'Student' table with the 'Department' table using the 'dept_code' foreign key.", "Order the results by the 'stu_gpa' column in ascending order to find students with the lowest GPA.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "description": "The virtual table provides the names of departments associated with students from the 'Student' table, specifically focusing on those with the lowest GPA. The query joins the 'Student' and 'Department' tables based on the department code, and it orders the results by GPA in ascending order, limiting the output to a specified number of entries.", "virtual_table": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the relevant tables: 'CLASS', 'ENROLL', and 'STUDENT'.", "Select the column to display, which is 'stu_fname' from the 'STUDENT' table.", "Join the 'CLASS' table with the 'ENROLL' table on 'class_code' to link classes with enrollments.", "Join the 'ENROLL' table with the 'STUDENT' table on 'stu_num' to link enrollments with student information.", "Add a condition to filter the 'CLASS' table for the specified course code using a placeholder for string values."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "description": "The virtual table provides the first names of students who are enrolled in a specific class identified by its course code. The query joins the 'CLASS', 'ENROLL', and 'STUDENT' tables to filter the results based on the course code placeholder.", "virtual_table": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.370", "db_id": "cre_Doc_Template_Mgt", "question": "What are the ids and names of each document, as well as the number of paragraphs in each?", "rationale": ["Identify the relevant tables, which are 'Documents' and 'Paragraphs'.", "Select the columns to display: 'document_id' and 'document_name' from the 'Documents' table, and count the number of paragraphs from the 'Paragraphs' table.", "Join the 'Paragraphs' table with the 'Documents' table using the document ID as the linking key.", "Group the results by the document ID to ensure that the count of paragraphs corresponds to each document."], "gold_sql": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id", "source_tables": ["paragraphs", "documents"], "description": "The virtual table provides a summary of documents along with their identifiers and names, as well as the count of associated paragraphs. It combines data from the 'Documents' and 'Paragraphs' tables, linking them through the document identifier. The result is grouped by each document's ID to aggregate the number of paragraphs for each document.", "virtual_table": "SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id"}
{"sample_id": "dev.368", "db_id": "cre_Doc_Template_Mgt", "question": "Return the different document ids along with the number of paragraphs corresponding to each, ordered by id.", "rationale": ["Identify the relevant table, which is 'Paragraphs'.", "Select the 'document_id' and use the COUNT function to count the number of paragraphs for each document.", "Group the results by 'document_id' to aggregate the paragraph counts for each document.", "Order the final results by 'document_id' in ascending order."], "gold_sql": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id", "source_tables": ["paragraphs"], "description": "The virtual table provides a summary of document identifiers along with the count of paragraphs associated with each document. The results are organized in ascending order based on the document identifier.", "virtual_table": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id"}
{"sample_id": "dev.311", "db_id": "cre_Doc_Template_Mgt", "question": "What is the id and type code for the template used by the most documents?", "rationale": ["Identify the relevant tables, which are 'Documents' and 'Templates'.", "Select the columns to display, 'template_id' from 'Documents' and 'Template_Type_Code' from 'Templates'.", "Join the two tables on the 'template_id' to associate documents with their templates.", "Group the results by 'template_id' to count the number of documents for each template.", "Order the results in descending order based on the count of documents to find the most used templates.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "description": "The virtual table provides the template IDs and their corresponding type codes from the 'Templates' table, specifically for the templates that are associated with the highest number of documents. The placeholder in the LIMIT clause indicates the number of top results to return based on the document count.", "virtual_table": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.309", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template ids and number of documents using each template.", "rationale": ["Identify the relevant table, which is 'Documents'.", "Select the 'template_id' column to display the IDs of the templates.", "Use the COUNT function to count the number of documents for each template ID.", "Group the results by 'template_id' to aggregate the document counts accordingly."], "gold_sql": "SELECT template_id ,  count(*) FROM Documents GROUP BY template_id", "source_tables": ["documents"], "description": "The virtual table displays the template IDs along with the count of documents associated with each template from the 'Documents' table. The grouping by template ID allows for aggregation of the document counts for each unique template.", "virtual_table": "SELECT template_id ,  count(*) FROM Documents GROUP BY template_id"}
{"sample_id": "dev.342", "db_id": "cre_Doc_Template_Mgt", "question": "What are the different template type codes, and how many documents use each type?", "rationale": ["Identify the relevant tables, which are 'Templates' and 'Documents'.", "Join the two tables on the 'Template_ID' to associate documents with their respective templates.", "Select the 'Template_Type_Code' from the 'Templates' table and count the number of documents for each type.", "Group the results by 'Template_Type_Code' to aggregate the document counts for each template type."], "gold_sql": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code", "source_tables": ["templates", "documents"], "description": "The virtual table provides a summary of the different template type codes along with the count of documents associated with each template type. It combines data from the 'Templates' and 'Documents' tables, linking them through the template identifier. The result is grouped by the template type code, allowing users to see how many documents correspond to each type.", "virtual_table": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code"}
{"sample_id": "dev.362", "db_id": "cre_Doc_Template_Mgt", "question": "What are the details for the paragraph that includes the text 'Korea ' ?", "rationale": ["Identify the relevant table, which is 'Paragraphs'.", "Select the column to display, 'Other_Details'.", "Add a condition to filter the 'Paragraph_Text' column using a placeholder for string values to match the specified text."], "gold_sql": "select other_details from paragraphs where paragraph_text like 'korea'", "source_tables": ["paragraphs"], "description": "The virtual table provides details of paragraphs from the 'Paragraphs' table that contain specific text. The placeholder in the WHERE clause is used to filter the paragraphs based on the text content provided by the user.", "virtual_table": "select other_details from paragraphs where paragraph_text like [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.308", "db_id": "cre_Doc_Template_Mgt", "question": "Count the number of documents that use the PPT template type.", "rationale": ["Identify the relevant tables, which are 'Documents' and 'Templates'.", "Use a JOIN to connect 'Documents' with 'Templates' based on the 'Template_ID'.", "Count the total number of documents by using the count(*) function.", "Add a condition to filter the 'Template_Type_Code' in the WHERE clause using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'", "source_tables": ["templates", "documents"], "description": "The virtual table counts the total number of documents associated with a specific template type from the 'Documents' and 'Templates' tables. The placeholder in the WHERE clause represents the code for the template type being queried.", "virtual_table": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.336", "db_id": "cre_Doc_Template_Mgt", "question": "Return the lowest version number, along with its corresponding template type code.", "rationale": ["Identify the relevant table, which is 'Templates'.", "Select the minimum value of 'Version_Number' and the corresponding 'Template_Type_Code'.", "The use of the aggregate function 'min' allows for retrieving the lowest version number, while the template type code is included to provide context for that version."], "gold_sql": "SELECT min(Version_Number) ,  template_type_code FROM Templates", "source_tables": ["templates"], "description": "The virtual table provides the minimum version number of templates along with their associated template type codes from the 'Templates' table. The placeholder in the SELECT clause indicates that the version number will be dynamically determined based on the data in the table.", "virtual_table": "SELECT min(Version_Number) ,  template_type_code FROM Templates"}
{"sample_id": "dev.335", "db_id": "cre_Doc_Template_Mgt", "question": "What the smallest version number and its template type code?", "rationale": ["Identify the relevant table, which is 'Templates'.", "Select the minimum value of 'Version_Number' and the 'Template_Type_Code' to display.", "The query retrieves the smallest version number and its associated template type code, which is useful for understanding the earliest template versions available."], "gold_sql": "SELECT min(Version_Number) ,  template_type_code FROM Templates", "source_tables": ["templates"], "description": "The virtual table provides the minimum version number of templates along with their corresponding template type codes from the 'Templates' table. This allows users to identify the earliest version of templates and the type associated with it.", "virtual_table": "SELECT min(Version_Number) ,  template_type_code FROM Templates"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["Identify the relevant tables, which are 'Drama_Workshop_Groups' and 'Services'.", "Select the columns to display, 'Store_Phone' and 'Store_Email_Address' from 'Drama_Workshop_Groups'.", "Join the 'Drama_Workshop_Groups' table with the 'Services' table on the 'Workshop_Group_ID' to link workshop groups with their services.", "Add a condition to filter the 'Product_Name' column in the 'Services' table using a placeholder for string values."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "description": "The virtual table provides the store phone numbers and email addresses of workshop groups from the 'Drama_Workshop_Groups' table that offer services associated with a specific product name. The placeholder in the WHERE clause represents the product name being queried.", "virtual_table": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5135", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the names of the workshop groups where services with product name \"film\" are performed.", "rationale": ["Identify the relevant tables, which are 'Drama_Workshop_Groups' and 'Services'.", "Select the columns to display, 'Store_Phone' and 'Store_Email_Address' from 'Drama_Workshop_Groups'.", "Join the 'Drama_Workshop_Groups' table with the 'Services' table on the 'Workshop_Group_ID' to link workshop groups with their services.", "Add a condition to filter the 'Product_Name' column in the 'Services' table using a placeholder for string values."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "description": "The virtual table provides the store phone numbers and email addresses of workshop groups from the 'Drama_Workshop_Groups' table that offer services associated with a specific product name. The placeholder in the WHERE clause represents the product name being queried.", "virtual_table": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5168", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the product ID of the most frequently ordered item on invoices?", "rationale": ["Identify the relevant table, which is 'INVOICES'.", "Select the 'Product_ID' column to display.", "Group the results by 'Product_ID' to aggregate the data.", "Order the results by the count of occurrences in descending order to find the most frequently ordered items.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["invoices"], "description": "The virtual table provides the product IDs of items listed in the 'INVOICES' table, grouped by product ID. It orders the results by the frequency of each product's occurrence in the invoices, allowing the user to identify the most frequently ordered item. The placeholder in the LIMIT clause indicates the number of top results to return, which can be specified by the user.", "virtual_table": "SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["Identify the relevant table, which is 'Bookings'.", "Select the 'Status_Code' column to analyze the booking statuses.", "Group the results by 'Status_Code' to count occurrences of each status.", "Order the results in descending order based on the count of each status code to find the most common one.", "Use a placeholder in the LIMIT clause to specify how many top results to return."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "description": "The virtual table summarizes the status codes of bookings from the 'Bookings' table, grouping them to identify the most frequently occurring status code. The placeholder in the LIMIT clause indicates the number of top results to return, allowing for flexibility in specifying how many of the most common status codes to retrieve.", "virtual_table": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5103", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the minimum, average, and maximum quantities ordered? Check all the invoices.", "rationale": ["Identify the relevant table, which is 'Invoices'.", "Select the 'Order_Quantity' column to perform aggregate functions: minimum, average, and maximum.", "Use aggregate functions to calculate the minimum, average, and maximum values of the 'Order_Quantity' column."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "description": "The virtual table provides the minimum, average, and maximum quantities ordered from the invoices. The data is aggregated from the 'Invoices' table, focusing on the 'Order_Quantity' column to summarize the order quantities across all invoices.", "virtual_table": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["Identify the relevant tables, which are 'ORDER_ITEMS' and 'Products'.", "Select the column 'Other_Item_Details' from the 'ORDER_ITEMS' table.", "Join the 'ORDER_ITEMS' table with the 'Products' table on the 'Product_ID' to access product details.", "Add a condition to filter the products based on their price using a placeholder for numeric values."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "description": "The virtual table provides details about order items from the 'ORDER_ITEMS' table, specifically focusing on the additional details of items whose associated products have a price exceeding a specified amount. The placeholder in the WHERE clause allows for dynamic input of the price threshold.", "virtual_table": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5132", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the phones and emails of workshop groups in which services are performed?", "rationale": ["Identify the relevant tables, which are 'Drama_Workshop_Groups' and 'Services'.", "Select the columns to display, which are 'Store_Phone' and 'Store_Email_Address' from the 'Drama_Workshop_Groups' table.", "Establish a join between the two tables on the 'Workshop_Group_ID' to filter the results to only those workshop groups that have services performed."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID", "source_tables": ["services", "drama_workshop_groups"], "description": "The virtual table provides the phone numbers and email addresses of workshop groups from the 'Drama_Workshop_Groups' table that are associated with services offered in the 'Services' table. The join condition links the workshop groups to the services based on their unique identifiers.", "virtual_table": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID"}
{"sample_id": "train.5166", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the average quantities ordered with payment method code \"MasterCard\" on invoices?", "rationale": ["Identify the relevant table, which is 'Invoices'.", "Select the column to calculate the average, 'Order_Quantity'.", "Add a condition to filter the 'payment_method_code' column for the specified payment method using a placeholder for string values."], "gold_sql": "SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  'MasterCard'", "source_tables": ["invoices"], "description": "The virtual table calculates the average quantity of products ordered from the 'Invoices' table, filtered by a specific payment method code. The placeholder in the WHERE clause represents the payment method being queried.", "virtual_table": "SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5133", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me all the phone numbers and email addresses of the workshop groups where services are performed.", "rationale": ["Identify the relevant tables, which are 'Drama_Workshop_Groups' and 'Services'.", "Select the columns to display, which are 'Store_Phone' and 'Store_Email_Address' from the 'Drama_Workshop_Groups' table.", "Establish a join between 'Drama_Workshop_Groups' and 'Services' using the 'Workshop_Group_ID' to filter the results to only those workshop groups that have services performed."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID", "source_tables": ["services", "drama_workshop_groups"], "description": "The virtual table provides the phone numbers and email addresses of workshop groups from the 'Drama_Workshop_Groups' table that are associated with services offered. The join condition links the workshop groups to the services based on their unique identifiers, ensuring that only relevant workshop groups are included in the results.", "virtual_table": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["Identify the relevant tables, which are 'Bookings' and 'Drama_Workshop_Groups'.", "Select the column to display, 'Store_Name' from the 'Drama_Workshop_Groups' table.", "Join the two tables on the 'Workshop_Group_ID' to link bookings to their respective workshop groups.", "Add a condition to filter the 'Status_Code' column in the 'Bookings' table using a placeholder for string values."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "description": "The virtual table provides the names of workshop groups from the 'Drama_Workshop_Groups' table that have associated bookings in the 'Bookings' table with a specific status code. The placeholder in the WHERE clause represents the status code to filter the results accordingly.", "virtual_table": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5956", "db_id": "cre_Theme_park", "question": "What are the names and ids of the tourist attractions that are visited at most once?", "rationale": ["Identify the relevant tables, which are 'Tourist_Attractions' and 'Visits'.", "Select the columns to display, 'Name' and 'Tourist_Attraction_ID' from 'Tourist_Attractions'.", "Join the 'Tourist_Attractions' table with the 'Visits' table on the 'Tourist_Attraction_ID' to correlate attractions with their visit records.", "Group the results by 'Tourist_Attraction_ID' to aggregate visit counts for each attraction.", "Add a condition in the HAVING clause to filter attractions based on the count of visits, using a placeholder for the maximum visit count."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "description": "The virtual table provides the names and unique identifiers of tourist attractions from the 'Tourist_Attractions' table that have been visited at most a specified number of times. The placeholder in the HAVING clause allows for the definition of the maximum visit count.", "virtual_table": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5951", "db_id": "cre_Theme_park", "question": "Show different tourist attractions' names, ids, and the corresponding number of visits.", "rationale": ["Identify the relevant tables, which are 'Tourist_Attractions' and 'Visits'.", "Select the columns to display: the name of the attraction from 'Tourist_Attractions', the attraction ID from 'Visits', and the count of visits.", "Join the two tables on the common column 'Tourist_Attraction_ID'.", "Group the results by 'Tourist_Attraction_ID' to aggregate the visit counts."], "gold_sql": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID", "source_tables": ["visits", "tourist_attractions"], "description": "The virtual table provides a summary of tourist attractions along with their unique identifiers and the total number of visits recorded for each attraction. It combines data from the 'Tourist_Attractions' table, which includes the names and IDs of the attractions, and the 'Visits' table, which tracks the visit records. The result is grouped by the attraction ID to count the number of visits for each attraction.", "virtual_table": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID"}
{"sample_id": "train.5965", "db_id": "cre_Theme_park", "question": "What are the names of tourist attraction that Alison visited but Rosalind did not visit?", "rationale": ["Identify the relevant tables: 'Tourist_Attractions', 'Visitors', and 'Visits'.", "Select the 'Name' column from the 'Tourist_Attractions' table.", "Join the 'Visitors' and 'Visits' tables to link tourist IDs with their respective visits to attractions.", "Use a WHERE clause to filter visits for the first tourist using a placeholder for their name.", "Use the EXCEPT clause to exclude attractions visited by the second tourist, again using a placeholder for their name."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Alison' EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Rosalind'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "The virtual table lists the names of tourist attractions that a specific tourist visited, while excluding those visited by another specified tourist. It utilizes joins between the 'Tourist_Attractions', 'Visitors', and 'Visits' tables to correlate the attractions with the respective tourists' visit records. The placeholders represent the names of the tourists involved in the query.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5955", "db_id": "cre_Theme_park", "question": "Show the names and ids of tourist attractions that are visited at most once.", "rationale": ["Identify the relevant tables, which are 'Tourist_Attractions' and 'Visits'.", "Select the columns to display, 'Name' and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table.", "Join the 'Tourist_Attractions' table with the 'Visits' table on the 'Tourist_Attraction_ID'.", "Group the results by 'Tourist_Attraction_ID' to count the number of visits for each attraction.", "Add a condition to filter the grouped results to include only those attractions that have been visited at most a specified number of times using a placeholder for numeric values."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "description": "The virtual table provides the names and unique identifiers of tourist attractions from the 'Tourist_Attractions' table that have been visited at most a specified number of times. The query joins the 'Tourist_Attractions' table with the 'Visits' table to count the number of visits for each attraction, filtering the results based on the visit count using a placeholder for numeric values.", "virtual_table": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["Identify the relevant table, which is 'Tourist_Attractions'.", "Select the column 'How_to_Get_There' to display the transportation methods.", "Group the results by 'How_to_Get_There' to aggregate the data based on transportation methods.", "Order the results by the count of occurrences in descending order to find the most popular transportation method.", "Add a limit to specify how many of the top results to return using a placeholder for numeric values."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "description": "The virtual table summarizes the various transportation methods used by visitors to reach tourist attractions. It groups the data by the method of transportation and orders the results based on the frequency of each method, allowing users to identify the most popular choice. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant table, which is 'Tourist_Attractions'.", "Select the column 'How_to_Get_There' to display the transportation methods.", "Group the results by 'How_to_Get_There' to aggregate the data based on different methods.", "Order the results by the count of occurrences in descending order to find the most common method.", "Use a placeholder in the LIMIT clause to specify how many top results to return."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "description": "The virtual table summarizes the various transportation methods used to reach tourist attractions, derived from the 'Tourist_Attractions' table. It groups the data by the 'How_to_Get_There' column and orders the results based on the frequency of each method, allowing users to identify the most commonly used transportation method. The placeholder in the LIMIT clause indicates the number of top methods to retrieve.", "virtual_table": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5898", "db_id": "cre_Theme_park", "question": "What is the average price range of five star hotels that allow pets?", "rationale": ["Identify the relevant table, which is 'Hotels'.", "Select the average of the 'price_range' column to calculate the average price.", "Add conditions to filter the 'star_rating_code' for five-star hotels and 'pets_allowed_yn' to indicate if pets are allowed, using placeholders for these values."], "gold_sql": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  '5' AND pets_allowed_yn  =  1", "source_tables": ["hotels"], "description": "The virtual table provides the average price range of hotels from the 'Hotels' table that have a specific star rating and allow pets. The placeholders in the WHERE clause represent the star rating code and the indication of whether pets are allowed.", "virtual_table": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5927", "db_id": "cre_Theme_park", "question": "What are the details of the markets that can be accessed by walk or bus?", "rationale": ["Identify the relevant tables, which are 'Street_Markets' and 'Tourist_Attractions'.", "Select the column 'Market_Details' from the 'Street_Markets' table.", "Join the 'Street_Markets' table with the 'Tourist_Attractions' table on the condition that the 'Market_ID' matches the 'Tourist_Attraction_ID'.", "Add a condition to filter the results based on the 'How_to_Get_There' column for the specified modes of transportation using placeholders for string values."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "description": "The virtual table provides details of street markets that can be accessed by specific modes of transportation. It combines information from the 'Street_Markets' table and the 'Tourist_Attractions' table, filtering the results based on the accessibility instructions for the attractions. The placeholders in the WHERE clause represent the modes of transportation used to reach the attractions.", "virtual_table": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5941", "db_id": "cre_Theme_park", "question": "Show the details of the top 3 most expensive hotels.", "rationale": ["Identify the relevant table, which is 'Hotels'.", "Select the column 'other_hotel_details' to display the details of the hotels.", "Order the results by 'price_range' in descending order to prioritize the most expensive hotels.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "description": "The virtual table provides details of hotels from the 'Hotels' table, specifically focusing on the additional information about each hotel. The results are ordered by the price range in descending order, allowing users to identify the most expensive hotels. The placeholder in the LIMIT clause indicates that only a specified number of records will be returned, representing the top hotels based on their price range.", "virtual_table": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5902", "db_id": "cre_Theme_park", "question": "Return the detail of the location named \"UK Gallery\".", "rationale": ["Identify the relevant table, which is 'Locations'.", "Select the column to display, 'Other_Details'.", "Add a condition to filter the 'Location_Name' column for the specified location using a placeholder for string values."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "description": "The virtual table provides details about a specific location from the 'Locations' table, identified by its name. The placeholder in the WHERE clause is used to specify the name of the location being queried.", "virtual_table": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5888", "db_id": "cre_Theme_park", "question": "Tell me the price ranges for all the hotels.", "rationale": ["Identify the relevant table, which is 'Hotels'.", "Select the column to display, 'price_range'.", "No additional conditions are needed since the query requests all price ranges."], "gold_sql": "SELECT price_range FROM HOTELS", "source_tables": ["hotels"], "description": "The virtual table provides a list of price ranges for hotels from the 'Hotels' table. Each entry represents a different price category that hotels fall into, allowing users to understand the various pricing options available.", "virtual_table": "SELECT price_range FROM HOTELS"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables, which are 'Royal_Family' and 'Tourist_Attractions'.", "Select the columns to display: 'Royal_Family_Details' from the 'Royal_Family' table and 'How_to_Get_There' from the 'Tourist_Attractions' table.", "Establish a join condition that connects the 'Royal_Family_ID' from the 'Royal_Family' table to the 'Tourist_Attraction_ID' in the 'Tourist_Attractions' table, ensuring that only related records are retrieved."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "description": "The virtual table provides details about tourist attractions associated with royal family entries, including specific information about the royal family and instructions on how to reach the respective attractions. The join operation links the royal family details to the corresponding tourist attractions using a unique identifier.", "virtual_table": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.5893", "db_id": "cre_Theme_park", "question": "Show details of all visitors.", "rationale": ["Identify the relevant table, which is 'Visitors'.", "Select the column to display, 'Tourist_Details'.", "Since the query requests details of all visitors, no additional filtering conditions are needed."], "gold_sql": "SELECT Tourist_Details FROM VISITORS", "source_tables": ["visitors"], "description": "The virtual table contains details of all visitors from the 'Visitors' table. The placeholder represents the specific details related to each tourist.", "virtual_table": "SELECT Tourist_Details FROM VISITORS"}
{"sample_id": "train.5904", "db_id": "cre_Theme_park", "question": "Find all the locations whose names contain the word \"film\".", "rationale": ["Identify the relevant table, which is 'Locations'.", "Select the column to display, 'Location_Name'.", "Add a condition to filter the 'Location_Name' column using a LIKE clause with a placeholder for string values."], "gold_sql": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE '%film%'", "source_tables": ["locations"], "description": "The virtual table contains the names of locations from the 'Locations' table that include a specific keyword in their names. The placeholder in the WHERE clause is used to filter the location names based on the provided search term.", "virtual_table": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5931", "db_id": "cre_Theme_park", "question": "Which tourist attractions does the visitor with detail 'Vincent' visit?", "rationale": ["Identify the relevant tables: 'Tourist_Attractions', 'Visits', and 'Visitors'.", "Select the column to display, which is 'Name' from the 'Tourist_Attractions' table.", "Join the 'Tourist_Attractions' table with the 'Visits' table on the 'Tourist_Attraction_ID' to connect attractions with visits.", "Join the 'Visits' table with the 'Visitors' table on the 'Tourist_ID' to connect visits with specific visitors.", "Add a condition to filter the 'Tourist_Details' column in the 'Visitors' table using a placeholder for string values."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "The virtual table lists the names of tourist attractions that have been visited by a specific visitor. It combines data from the 'Tourist_Attractions', 'Visits', and 'Visitors' tables, linking them through their respective identifiers. The placeholder in the WHERE clause is used to filter the results based on the visitor's details.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the relevant table, which is 'Hotels'.", "Select the column 'other_hotel_details' to display the details of the hotels.", "Order the results by 'price_range' in descending order to prioritize the most expensive hotels.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "description": "The virtual table provides details of hotels from the 'Hotels' table, specifically focusing on the additional information about each hotel. The results are ordered by the price range in descending order, allowing users to identify the most expensive hotels. The placeholder in the LIMIT clause indicates the number of hotels to retrieve, which can be adjusted as needed.", "virtual_table": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5921", "db_id": "cre_Theme_park", "question": "What are the details and ways to get to tourist attractions related to royal family?", "rationale": ["Identify the relevant tables, which are 'Royal_Family' and 'Tourist_Attractions'.", "Select the columns to display: 'Royal_Family_Details' from the 'Royal_Family' table and 'How_to_Get_There' from the 'Tourist_Attractions' table.", "Establish a join between the two tables based on the unique identifier 'Royal_Family_ID' from 'Royal_Family' and 'Tourist_Attraction_ID' from 'Tourist_Attractions' to filter the results accordingly."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "description": "The virtual table provides details about tourist attractions associated with royal family entries, including specific information about the royal family and instructions on how to reach these attractions. The join condition links the royal family details to the corresponding tourist attractions using a unique identifier.", "virtual_table": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.2363", "db_id": "csu_1", "question": "What campus started in year 1956, has more than 200 full time students, and more than 400 students enrolled?", "rationale": ["Identify the relevant tables, which are 'Campuses' and 'Enrollments'.", "Select the 'campus' column from the 'Campuses' table.", "Join the 'Campuses' table with the 'Enrollments' table on the campus identifier.", "Add conditions to filter by the specified year, total enrollment, and full-time equivalent enrollment using placeholders for numeric values."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "description": "The virtual table provides a list of campuses that were established in a specific year, along with their enrollment statistics. It filters campuses based on the year of establishment and checks for conditions on the total number of enrollments and full-time equivalent enrollments, using placeholders for the year and enrollment numbers.", "virtual_table": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] AND totalenrollment_ay  >  [PLACEHOLDER-TYPE:NUMBER] AND FTE_AY  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant tables, which are 'Campuses' and 'Enrollments'.", "Select the 'Campus' column from the 'Campuses' table.", "Join the 'Campuses' table with the 'Enrollments' table on the campus identifier.", "Add conditions to filter the results based on the specified year and the enrollment thresholds using placeholders for numeric values."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "description": "The virtual table identifies campuses that had a total enrollment exceeding a specified number and a full-time equivalent enrollment also exceeding another specified number for a particular year. The placeholders in the WHERE clause represent the year, total enrollment threshold, and full-time equivalent enrollment threshold.", "virtual_table": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] AND totalenrollment_ay  >  [PLACEHOLDER-TYPE:NUMBER] AND FTE_AY  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2335", "db_id": "csu_1", "question": "What campuses are located in Northridge, Los Angeles or in San Francisco, San Francisco?", "rationale": ["Identify the relevant table, which is 'Campuses'.", "Select the 'Campus' column to display the names of the campuses.", "Add conditions to filter the 'Location' and 'County' columns for the specified areas using placeholders for string values.", "Use a UNION to combine results from two different conditions for the two specified locations."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "description": "The virtual table lists the names of campuses located in specific geographical areas, specifically Northridge, Los Angeles, and San Francisco, San Francisco. The placeholders in the WHERE clauses represent the locations and counties of the campuses being queried.", "virtual_table": "SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2357", "db_id": "csu_1", "question": "how many degrees were conferred between 1998 and 2002?", "rationale": ["Identify the relevant tables, which are 'Campuses' and 'degrees'.", "Select the campus identifier and the sum of degrees awarded as the output.", "Join the 'Campuses' table with the 'degrees' table on the campus identifier.", "Add a condition to filter the years of degree conferral using placeholders for numeric values.", "Group the results by campus to get the total degrees conferred for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "description": "The virtual table summarizes the total number of degrees conferred by each campus within a specified range of years. It combines data from the 'Campuses' table and the 'degrees' table, using the campus identifier to link the two. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.", "virtual_table": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus"}
{"sample_id": "train.2334", "db_id": "csu_1", "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.", "rationale": ["Identify the relevant table, which is 'Campuses'.", "Select the column to display, 'Campus'.", "Add conditions to filter the 'Location' and 'County' columns for the specified areas using placeholders for string values.", "Use a UNION to combine results from two different conditions for the specified locations."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "description": "The virtual table provides the names of campuses located in specific geographical areas, specifically those situated in Northridge, Los Angeles, or in San Francisco, San Francisco. The placeholders in the WHERE clauses represent the location and county of the campuses being queried.", "virtual_table": "SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2350", "db_id": "csu_1", "question": "Which campus has the most faculties in year 2003?", "rationale": ["Identify the relevant tables, which are 'Campuses' and 'faculty'.", "Select the 'campus' column from the 'Campuses' table.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Add a condition to filter the results based on the specified year using a placeholder for numeric values.", "Order the results by the number of faculty members in descending order.", "Limit the results to return only the campus with the most faculty members."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "description": "The virtual table provides information about campuses and their associated faculty counts for a specific year. It joins the 'Campuses' table with the 'faculty' table to filter campuses based on the year and sorts them by the number of faculty members in descending order. The placeholders represent the year of interest and the limit for the number of campuses to return.", "virtual_table": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2351", "db_id": "csu_1", "question": "What campus has the most faculties in 2003?", "rationale": ["Identify the relevant tables, which are 'Campuses' and 'faculty'.", "Select the 'campus' column from the 'Campuses' table.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Add a condition to filter the results for a specific year using a placeholder for numeric values.", "Order the results by the number of faculty members in descending order to find the campus with the most faculty.", "Limit the results to return only the top campus based on the faculty count."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "description": "The virtual table provides information about campuses and their associated faculty counts for a specific year. It joins the 'Campuses' table with the 'faculty' table to identify which campus has the highest number of faculty members in a given year. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.", "virtual_table": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2349", "db_id": "csu_1", "question": "What campus has the most degrees  conferrred over its entire existence?", "rationale": ["Identify the relevant table, which is 'degrees'.", "Select the 'campus' column to display the campuses.", "Group the results by 'campus' to aggregate the degree counts.", "Order the results by the sum of degrees in descending order to find the campus with the most degrees conferred.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "description": "The virtual table summarizes the campuses and the total number of degrees conferred at each campus over the years. It groups the data by campus and orders the results in descending order based on the sum of degrees awarded, allowing for the identification of the campus with the highest total. The placeholder in the LIMIT clause indicates the number of top campuses to return.", "virtual_table": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2382", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the least number of degrees in year 2001?", "rationale": ["Identify the relevant tables: 'Campuses', 'faculty', and 'degrees'.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier and the 'degrees' table on both the campus identifier and the year.", "Select the 'faculty' column from the 'faculty' table.", "Add a condition to filter the results by the specified year using a placeholder for numeric values.", "Order the results by the number of degrees awarded to find the campus with the least degrees.", "Limit the results to return only the faculty count for that campus."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "description": "The virtual table provides information about the number of faculty members at universities that awarded the least number of degrees in a specific year. It combines data from the 'Campuses', 'faculty', and 'degrees' tables, using placeholders to filter by the year and limit the results to the campus with the fewest degrees awarded.", "virtual_table": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant tables, which are 'discipline_enrollments' and 'Campuses'.", "Select the sum of the 'undergraduate' column to get the total number of undergraduate enrollments.", "Join the 'discipline_enrollments' table with the 'Campuses' table on the campus identifier.", "Add conditions to filter the results based on the specified year and campus name using placeholders."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "description": "The virtual table summarizes the total number of undergraduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the query represent the year of enrollment data and the name of the campus.", "virtual_table": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND t2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2347", "db_id": "csu_1", "question": "In what year was the most degrees conferred?", "rationale": ["Identify the relevant table, which is 'degrees'.", "Select the 'Year' column to display.", "Group the results by 'Year' to aggregate the data.", "Order the results by the sum of degrees awarded in descending order to find the year with the most degrees conferred.", "Limit the results to a single entry using a placeholder for numeric values."], "gold_sql": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "description": "The virtual table summarizes the years in which degrees were awarded, grouped by year, and ordered by the total number of degrees conferred in descending order. The placeholder indicates the limit on the number of years to return, allowing for the retrieval of the year with the highest number of degrees awarded.", "virtual_table": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2365", "db_id": "csu_1", "question": "How many campuses exist are in the county of LA?", "rationale": ["Identify the relevant table, which is 'Campuses'.", "Use the count function to determine the number of campuses.", "Add a condition to filter the 'county' column for the specified county using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "description": "The virtual table provides a count of campuses from the 'Campuses' table that are located in a specific county. The placeholder in the WHERE clause represents the name of the county being queried.", "virtual_table": "SELECT count(*) FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2387", "db_id": "csu_1", "question": "How many people graduated from San Francisco State University in 2004?", "rationale": ["Identify the relevant tables, which are 'discipline_enrollments' for graduate data and 'Campuses' for campus information.", "Select the sum of graduate enrollments from 'discipline_enrollments'.", "Join 'discipline_enrollments' with 'Campuses' on the campus identifier to filter by campus name.", "Add conditions to filter the year of graduation and the specific campus using placeholders for numeric and string values."], "gold_sql": "SELECT sum(t1.graduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Francisco State University'", "source_tables": ["discipline_enrollments", "campuses"], "description": "The virtual table summarizes the total number of graduate students who graduated from a specific campus in a given year. It combines data from the 'discipline_enrollments' table, which tracks graduate enrollments, and the 'Campuses' table, which provides information about the campus. The placeholders in the query represent the year of graduation and the name of the campus.", "virtual_table": "SELECT sum(t1.graduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND t2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2376", "db_id": "csu_1", "question": "How many faculty lines are there in \"San Francisco State University\" in year 2004?", "rationale": ["Identify the relevant tables, which are 'faculty' and 'Campuses'.", "Select the column to display, 'faculty', which represents the number of faculty members.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to access campus names.", "Add conditions to filter the results based on the specified year and campus name using placeholders for numeric and string values."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "description": "The virtual table summarizes the number of faculty members at a specific campus for a given year. It combines data from the 'faculty' table and the 'Campuses' table, using a join to match the campus identifier with the campus name. The placeholders in the WHERE clause allow for filtering by the year and the campus name.", "virtual_table": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2369", "db_id": "csu_1", "question": "How many degrees were conferred at San Jose State University in 2000?", "rationale": ["Identify the relevant tables, which are 'Campuses' and 'degrees'.", "Join the two tables on the campus identifier to relate degrees to their respective campuses.", "Select the 'degrees' column to display the types of degrees conferred.", "Add conditions to filter the results based on the specified campus name and year using placeholders."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "description": "The virtual table summarizes the types of degrees conferred at a specific campus during a particular year. It combines data from the 'Campuses' and 'degrees' tables, linking them through the campus identifier. The placeholders in the WHERE clause allow for specifying the campus name and the year of interest.", "virtual_table": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2327", "db_id": "csu_1", "question": "What campuses are located in Chico?", "rationale": ["Identify the relevant table, which is 'Campuses'.", "Select the column to display, 'Campus'.", "Add a condition to filter the 'Location' column for the specified location using a placeholder for string values."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Chico'", "source_tables": ["campuses"], "description": "The virtual table lists the names of campuses from the 'Campuses' table that are situated in a specific geographical location. The placeholder in the WHERE clause represents the location of the campus.", "virtual_table": "SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6980", "db_id": "culture_company", "question": "Show all publishers which do not have a book in 1989.", "rationale": ["Identify the relevant table, which is 'book_club'.", "Select the 'publisher' column to display.", "Use the EXCEPT clause to filter out publishers that have books published in the specified year, using a placeholder for numeric values."], "gold_sql": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  1989", "source_tables": ["book_club"], "description": "The virtual table lists all publishers from the 'book_club' table that do not have any associated books published in a specific year. The placeholder in the query represents the year for which the absence of books is being checked.", "virtual_table": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6996", "db_id": "culture_company", "question": "Show the movie titles and book titles for all companies in China.", "rationale": ["Identify the relevant tables: 'movie', 'culture_company', and 'book_club'.", "Select the columns to display: 'title' from the 'movie' table and 'book_title' from the 'book_club' table.", "Join the 'movie' table with the 'culture_company' table using the 'movie_id' foreign key.", "Join the 'culture_company' table with the 'book_club' table using the 'book_club_id' foreign key.", "Add a condition to filter the 'incorporated_in' column for the specified year using a placeholder for string values."], "gold_sql": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  'China'", "source_tables": ["culture_company", "movie", "book_club"], "description": "The virtual table displays the titles of movies and books associated with cultural companies that were incorporated in a specific year. The placeholders in the WHERE clause allow for filtering based on the year of incorporation of the companies.", "virtual_table": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6991", "db_id": "culture_company", "question": "Which directors had a movie in either 1999 or 2000?", "rationale": ["Identify the relevant table, which is 'movie'.", "Select the column to display, 'director'.", "Add a condition to filter the 'Year' column for the specified years using placeholders for numeric values."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "description": "The virtual table lists the directors of movies from the 'movie' table that were released in specific years. The placeholders in the WHERE clause represent the years of interest, allowing for the selection of directors based on the specified release years.", "virtual_table": "SELECT director FROM movie WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] OR YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6995", "db_id": "culture_company", "question": "What are all the company names that have a book published by Alyson?", "rationale": ["Identify the relevant tables, which are 'culture_company' and 'book_club'.", "Select the column to display, 'company_name' from 'culture_company'.", "Join the 'culture_company' table with the 'book_club' table on the 'book_club_id' to link companies with their respective book clubs.", "Add a condition to filter the 'publisher' column in the 'book_club' table for the specified publisher using a placeholder for string values."], "gold_sql": "SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  'Alyson'", "source_tables": ["culture_company", "book_club"], "description": "The virtual table describes the names of cultural companies that are associated with book clubs where a specific publisher has published a book. The placeholder in the WHERE clause represents the name of the publisher.", "virtual_table": "SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5772", "db_id": "customer_complaints", "question": "Which city has the least number of customers whose type code is \"Good Credit Rating\"?", "rationale": ["Identify the relevant table, which is 'Customers'.", "Select the 'town_city' column to display the cities.", "Add a condition to filter the 'customer_type_code' for the specified type using a placeholder for string values.", "Group the results by 'town_city' to count the number of customers in each city.", "Order the results by the count of customers in ascending order to find the city with the least number.", "Limit the results to one to get only the city with the least number of customers."], "gold_sql": "SELECT town_city FROM customers WHERE customer_type_code  =  'Good Credit Rating' GROUP BY town_city ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "description": "The virtual table summarizes the towns or cities from the 'Customers' table where customers with a specific type code reside. It groups the results by city and orders them by the count of customers in ascending order, allowing for the identification of the city with the least number of customers of that type. The placeholders represent the customer type code and the limit for the number of results returned.", "virtual_table": "SELECT town_city FROM customers WHERE customer_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY town_city ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5779", "db_id": "customer_complaints", "question": "Return the names of products that have had complaints filed by the customer who has filed the fewest complaints.", "rationale": ["Identify the relevant tables: 'Products', 'Complaints', and 'Customers'.", "Select the distinct column 'product_name' from the 'Products' table.", "Join the 'Products' table with the 'Complaints' table on the product identifier to filter products with complaints.", "Join the result with the 'Customers' table to access customer information.", "Group the results by 'customer_id' to count the number of complaints per customer.", "Order the results by the count of complaints to identify the customer with the fewest complaints.", "Use a placeholder in the LIMIT clause to specify how many product names to return."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "description": "The virtual table provides a list of distinct product names from the 'Products' table that have received complaints. It joins the 'Products' table with the 'Complaints' table based on the product identifier, and further joins with the 'Customers' table to identify the customer who has filed the fewest complaints. The placeholder in the LIMIT clause indicates the number of products to return based on the specified criteria.", "virtual_table": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Complaints'.", "Select the 'email_address' column from the 'Customers' table.", "Join the 'Customers' table with the 'Complaints' table using the customer_id as the linking key.", "Group the results by customer_id to count the number of complaints for each customer.", "Order the results by the count of complaints to find the product with the greatest number of complaints.", "Use a placeholder in the LIMIT clause to specify the maximum number of results to return."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "description": "The virtual table provides the email addresses of customers from the 'Customers' table who have filed complaints related to a specific product. It joins the 'Customers' and 'Complaints' tables based on the customer identifier, groups the results by customer to count the number of complaints, and orders the results to identify the customers associated with the product that has received the highest number of complaints. The placeholder in the LIMIT clause indicates the maximum number of email addresses to return.", "virtual_table": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5776", "db_id": "customer_complaints", "question": "Find the emails of customers who has filed a complaints of the product with the most complaints.", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Complaints'.", "Select the 'email_address' column from the 'Customers' table.", "Join the 'Customers' table with the 'Complaints' table on the 'customer_id' to link customers with their complaints.", "Group the results by 'customer_id' to aggregate the complaints for each customer.", "Order the results by the count of complaints to find the product with the most complaints.", "Use a placeholder in the LIMIT clause to specify how many top customers to return."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "description": "The virtual table describes the email addresses of customers from the 'Customers' table who have filed complaints related to a specific product. The query joins the 'Customers' and 'Complaints' tables based on the customer ID, groups the results by customer ID, and orders them by the count of complaints to identify the product with the most complaints. The placeholder in the LIMIT clause represents the number of top customers to retrieve.", "virtual_table": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables, which are 'Staff' and 'Complaints'.", "Select the 'first_name' column from the 'Staff' table.", "Join the 'Staff' table with the 'Complaints' table using the 'staff_id' as the key.", "Group the results by 'staff_id' to aggregate the number of complaints handled by each staff member.", "Order the results by the count of complaints in descending order to find the top staff members.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "description": "The virtual table provides the first names of staff members from the 'Staff' table who have managed the highest number of complaints. It joins the 'Staff' and 'Complaints' tables based on the staff identifier, groups the results by staff, and orders them by the count of complaints handled, limiting the results to a specified number.", "virtual_table": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["Identify the relevant table, which is 'Customers'.", "Use the COUNT function to count the number of customers.", "Group the results by 'customer_type_code' to categorize the counts by customer type.", "Order the results in descending order based on the count to find the most common customer type.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "The virtual table provides a count of customers grouped by their customer type, allowing for the identification of the most common customer type. The placeholder in the LIMIT clause indicates the number of top results to return, which can be adjusted as needed.", "virtual_table": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5802", "db_id": "customer_complaints", "question": "What is the last name of the staff who has handled the first ever complaint?", "rationale": ["Identify the relevant tables, which are 'Staff' and 'Complaints'.", "Join the 'Staff' table with the 'Complaints' table on the 'staff_id' to link staff members to the complaints they handled.", "Select the 'last_name' column from the 'Staff' table.", "Order the results by the 'date_complaint_raised' column from the 'Complaints' table to ensure the first complaint is at the top.", "Limit the results to one record to get the last name of the staff member who handled the first complaint."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT 1", "source_tables": ["complaints", "staff"], "description": "The virtual table describes the last names of staff members from the 'Staff' table who have handled complaints, specifically focusing on the first complaint raised. The placeholder in the LIMIT clause indicates the number of records to return, which in this case is set to one to retrieve the last name of the staff member associated with the earliest complaint.", "virtual_table": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the relevant tables: 'Staff', 'Complaints', and 'Products'.", "Select the 'last_name' column from the 'Staff' table.", "Join the 'Complaints' table to link complaints to staff members using 'staff_id'.", "Join the 'Products' table to link complaints to products using 'product_id'.", "Order the results by 'product_price' to find the product with the lowest price.", "Use a placeholder to limit the number of results returned."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "description": "The virtual table describes the last names of staff members from the 'Staff' table who are responsible for handling complaints related to products. It joins the 'Complaints' table to associate each complaint with the corresponding staff member and the 'Products' table to access product details. The results are ordered by product price, allowing the identification of the staff member associated with the complaint on the product that has the lowest price, with a placeholder indicating the limit of results to return.", "virtual_table": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2857", "db_id": "customer_deliveries", "question": "List the state names and the number of customers living in each state.", "rationale": ["Identify the relevant tables, which are 'Customer_Addresses' and 'Addresses'.", "Join the two tables on the 'address_id' to connect customer addresses with their corresponding state information.", "Select the 'state_province_county' from the 'Addresses' table and count the number of customers from the 'Customer_Addresses' table.", "Group the results by 'state_province_county' to get the number of customers in each state."], "gold_sql": "SELECT t2.state_province_county ,  count(*) FROM customer_addresses AS t1 JOIN addresses AS t2 ON t1.address_id  =  t2.address_id GROUP BY t2.state_province_county", "source_tables": ["addresses", "customer_addresses"], "description": "The virtual table provides a summary of the state names along with the count of customers residing in each state. It combines data from the 'Customer_Addresses' and 'Addresses' tables, linking them through the address identifier. The result is grouped by the state, allowing for an aggregated count of customers per state.", "virtual_table": "SELECT t2.state_province_county ,  count(*) FROM customer_addresses AS t1 JOIN addresses AS t2 ON t1.address_id  =  t2.address_id GROUP BY t2.state_province_county"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["Identify the relevant table, which is 'Customers'.", "Select the column to display, 'customer_name'.", "Use an EXCEPT clause to exclude names of customers who live in a specific state.", "Join 'Customers' with 'Customer_Addresses' and 'Addresses' to access the state information for filtering."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "description": "The virtual table presents the names of customers from the 'Customers' table who do not reside in a specified state. It utilizes an EXCEPT clause to exclude customers living in the state indicated by the placeholder. The query involves joining the 'Customers', 'Customer_Addresses', and 'Addresses' tables to filter out those in the specified state.", "virtual_table": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["Identify the relevant tables, which are 'Delivery_Routes' and 'Delivery_Route_Locations'.", "Select the 'route_name' column from 'Delivery_Routes'.", "Join 'Delivery_Routes' with 'Delivery_Route_Locations' on the route identifier to associate routes with their delivery locations.", "Group the results by the route identifier to count the number of deliveries for each route.", "Order the results by the count of deliveries in descending order to find the route with the highest number of deliveries.", "Add a limit to specify how many routes to return using a placeholder for numeric values."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "description": "The virtual table provides the name of delivery routes from the 'Delivery_Routes' table that are associated with delivery locations. It groups the results by route identifier and orders them by the count of deliveries in descending order, allowing the user to specify a limit on the number of routes returned.", "virtual_table": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["Identify the relevant table, which is 'Trucks'.", "Select the column to display, 'truck_details'.", "Add an order clause to sort the results by 'truck_licence_number' in ascending order."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "description": "The virtual table contains detailed information about trucks from the 'Trucks' table, specifically focusing on the truck details. The results are organized in ascending order based on the truck's license number, allowing for easy identification and comparison of the trucks.", "virtual_table": "SELECT truck_details FROM trucks ORDER BY truck_licence_number"}
{"sample_id": "train.6105", "db_id": "customers_and_addresses", "question": "Find the name and active date of the customer that use email as the contact channel.", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "Select the columns to display, 'customer_name' from 'Customers' and 'active_from_date' from 'Customer_Contact_Channels'.", "Join the two tables on the 'customer_id' to link customers with their contact channels.", "Add a condition to filter the 'channel_code' column for the specified contact channel using a placeholder for string values."], "gold_sql": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'", "source_tables": ["customer_contact_channels", "customers"], "description": "The virtual table describes the names of customers along with the dates when their email contact channels became active. The placeholder in the WHERE clause represents the specific contact channel code being queried.", "virtual_table": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["Identify the relevant tables, which are 'Order_Items' and 'Products'.", "Select the columns to display, 'product_details' and 'product_id'.", "Join the 'Order_Items' table with the 'Products' table on the product ID.", "Group the results by 'product_id' to aggregate the order quantities.", "Order the results by the sum of 'order_quantity' to find the product with the largest total order quantity.", "Use a placeholder in the LIMIT clause to specify the number of results to return."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "description": "The virtual table provides the product details and product ID from the 'Products' table, which are associated with the total order quantities from the 'Order_Items' table. The query groups the results by product ID and orders them by the sum of the order quantities, allowing for the identification of the product with the largest total order quantity. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6134", "db_id": "customers_and_addresses", "question": "What are all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table, which is 'Addresses'.", "Select the column to display, 'address_content'.", "Add conditions to filter the 'city' and 'state_province_county' columns for the specified locations using placeholders for string values.", "Use a UNION to combine results from two different city and state combinations."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "description": "The virtual table contains the detailed descriptions of addresses from the 'Addresses' table that are located in specific cities and states. The placeholders in the WHERE clause represent the names of the cities and the corresponding states for which the addresses are being queried.", "virtual_table": "SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table, which is 'Addresses'.", "Select the column to display, 'address_content'.", "Add conditions to filter the 'city' and 'state_province_county' columns for the specified locations using placeholders for string values.", "Use a UNION to combine results from two different city and state combinations."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "description": "The virtual table provides a list of address details from the 'Addresses' table for specific cities and states. The placeholders in the WHERE clause represent the names of the cities and the corresponding state or province, allowing for the retrieval of addresses from two different locations.", "virtual_table": "SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: 'Customers', 'Customer_Addresses', and 'Addresses'.", "Join the tables to connect customers with their respective addresses.", "Group the results by the 'city' column to aggregate customer counts per city.", "Order the results in descending order based on the count of customers in each city.", "Use a placeholder in the LIMIT clause to specify how many top cities to return."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "description": "The virtual table describes the cities associated with customers from the 'Customers' table, joined with their addresses from the 'Addresses' table through the 'Customer_Addresses' table. It groups the results by city and orders them by the number of customers residing in each city, allowing for the identification of the city with the highest customer count. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6086", "db_id": "customers_and_addresses", "question": "Find the city where the most customers live.", "rationale": ["Identify the relevant tables: 'Customers', 'Customer_Addresses', and 'Addresses'.", "Join these tables on their respective foreign keys to link customers to their addresses.", "Select the 'city' column from the 'Addresses' table.", "Group the results by 'city' to aggregate customer counts per city.", "Order the results in descending order based on the count of customers in each city.", "Use a placeholder in the LIMIT clause to specify how many top cities to return."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "description": "The virtual table summarizes the cities associated with customers by joining the 'Customers', 'Customer_Addresses', and 'Addresses' tables. It groups the results by city and orders them based on the number of customers residing in each city, allowing for the identification of the city with the highest customer population. The placeholder in the LIMIT clause indicates the maximum number of cities to return.", "virtual_table": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6075", "db_id": "customers_and_addresses", "question": "Find the detail of products whose detail contains the word \"Latte\" or the word \"Americano\"", "rationale": ["Identify the relevant table, which is 'Products'.", "Select the column to display, 'product_details'.", "Add conditions to filter the 'product_details' column for the specified keywords using placeholders for string values."], "gold_sql": "SELECT product_details FROM products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'", "source_tables": ["products"], "description": "The virtual table provides details of products from the 'Products' table that contain specific keywords in their descriptions. The placeholders in the WHERE clause represent the keywords to be searched for within the product details.", "virtual_table": "SELECT product_details FROM products WHERE product_details LIKE [PLACEHOLDER-TYPE:STRING] OR product_details LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6130", "db_id": "customers_and_addresses", "question": "What is the most frequently ordered product? Tell me the detail of the product", "rationale": ["Identify the relevant tables, which are 'Order_Items' and 'Products'.", "Join the 'Order_Items' table with the 'Products' table on the product_id to access product details.", "Group the results by product_id to count the number of orders for each product.", "Order the results by the count of orders in descending order to find the most frequently ordered product.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "order_items"], "description": "The virtual table provides details of products from the 'Products' table that have been ordered, specifically focusing on the most frequently ordered product. The query aggregates the order items to count the occurrences of each product and sorts them in descending order, allowing the user to retrieve the details of the top product based on the specified limit.", "virtual_table": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6102", "db_id": "customers_and_addresses", "question": "Compute the average active time span of contact channels.", "rationale": ["Identify the relevant table, which is 'Customer_Contact_Channels'.", "Select the average of the difference between 'active_to_date' and 'active_from_date' to compute the average active time span."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "description": "The virtual table computes the average duration of active contact channels from the 'Customer_Contact_Channels' table. The calculation is based on the difference between the activation and deactivation dates of each contact channel.", "virtual_table": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels"}
{"sample_id": "train.6071", "db_id": "customers_and_addresses", "question": "What are the details of all products?", "rationale": ["Identify the relevant table, which is 'Products'.", "Select the column to display, 'product_details'.", "Use DISTINCT to ensure that only unique product details are retrieved."], "gold_sql": "SELECT DISTINCT product_details FROM products", "source_tables": ["products"], "description": "The virtual table contains distinct product details from the 'Products' table, providing a summary of all available products without duplicates.", "virtual_table": "SELECT DISTINCT product_details FROM products"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "Join the two tables on the 'customer_id' to link customers with their contact channels.", "Select the maximum 'active_to_date' from the 'Customer_Contact_Channels' table to find the latest date.", "Add a condition to filter the 'customer_name' column for the specified customer using a placeholder for string values."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "description": "The virtual table provides the latest 'active to date' of contact channels associated with a specific customer from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the customer's name.", "virtual_table": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6127", "db_id": "customers_and_addresses", "question": "Who made the latest order?", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Customer_Orders'.", "Select the 'customer_name' from the 'Customers' table.", "Join the 'Customers' table with the 'Customer_Orders' table using the 'customer_id' as the linking key.", "Order the results by 'order_date' in descending order to get the latest orders.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT 1", "source_tables": ["customer_orders", "customers"], "description": "The virtual table provides the names of customers who have placed orders, specifically focusing on the most recent order. It joins the 'Customers' table with the 'Customer_Orders' table based on the customer identifier, and orders the results by the order date in descending order, limiting the output to a specified number of entries.", "virtual_table": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6060", "db_id": "customers_and_addresses", "question": "Find the average order quantity per order.", "rationale": ["Identify the relevant table, which is 'Order_Items'.", "Select the column 'order_quantity' to calculate the average.", "Use the aggregate function 'avg' to compute the average order quantity."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "description": "The virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result will provide insights into the typical order size across all orders.", "virtual_table": "SELECT avg(order_quantity) FROM order_items"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables, which are 'Accounts' and 'Customers'.", "Select the columns to display: 'account_id', 'date_account_opened', 'account_name', and 'other_account_details' from the 'Accounts' table.", "Join the 'Accounts' table with the 'Customers' table on the 'customer_id' to link accounts to customers.", "Add a condition to filter the 'customer_first_name' column in the 'Customers' table using a placeholder for string values."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "description": "The virtual table provides the account ID, the date the account was opened, the account name, and additional details for all accounts associated with a specific customer. The placeholder in the WHERE clause is used to filter the results based on the customer's first name.", "virtual_table": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1610", "db_id": "customers_and_invoices", "question": "Return the order ids and details for orderes with two or more invoices.", "rationale": ["Identify the relevant tables, which are 'Invoices' and 'Orders'.", "Select the columns to display, 'order_id' and 'order_details' from the 'Orders' table.", "Join the 'Invoices' table with the 'Orders' table on the 'order_id' to link orders with their corresponding invoices.", "Group the results by 'order_id' to aggregate the invoices associated with each order.", "Add a condition in the HAVING clause to filter for orders that have more than a specified number of invoices using a placeholder for numeric values."], "gold_sql": "SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  2", "source_tables": ["orders", "invoices"], "description": "The virtual table provides the order IDs and details from the 'Orders' table for those orders that are associated with two or more invoices. The placeholder in the HAVING clause indicates the minimum number of invoices required for the orders to be included in the results.", "virtual_table": "SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1589", "db_id": "customers_and_invoices", "question": "Show the account name, id and the number of transactions for each account.", "rationale": ["Identify the relevant tables, which are 'Accounts' and 'Financial_Transactions'.", "Select the columns to display: 'account_name' from 'Accounts' and 'account_id' from 'Accounts', along with a count of transactions from 'Financial_Transactions'.", "Join the two tables on the 'account_id' to relate transactions to their respective accounts.", "Group the results by 'account_id' to aggregate the transaction counts for each account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "description": "The virtual table provides a summary of account names, account IDs, and the count of transactions associated with each account. It combines data from the 'Accounts' and 'Financial_Transactions' tables, linking them through the account ID. The count of transactions is aggregated for each account, allowing users to see how many transactions each account has processed.", "virtual_table": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id"}
{"sample_id": "train.1570", "db_id": "customers_and_invoices", "question": "What are the the full names and ids for all customers, and how many accounts does each have?", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Accounts'.", "Select the columns to display: 'customer_id', 'customer_first_name', and 'customer_last_name' from the 'Customers' table, and count the number of accounts from the 'Accounts' table.", "Join the 'Accounts' table with the 'Customers' table on the 'customer_id' to associate each account with the corresponding customer.", "Group the results by 'customer_id' to aggregate the account counts for each customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "description": "The virtual table provides a summary of customers along with their unique identifiers and the count of accounts associated with each customer. It combines data from the 'Customers' and 'Accounts' tables, linking them through the customer ID. The result includes the customer ID, first name, last name, and the total number of accounts for each customer.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id"}
{"sample_id": "train.1602", "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?", "rationale": ["Identify the relevant tables, which are 'Financial_Transactions' and 'Invoices'.", "Join the two tables on the invoice number to correlate transactions with their respective invoices.", "Group the results by invoice number to count the number of transactions for each invoice.", "Order the results in descending order based on the count of transactions to find the invoice with the greatest number of transactions.", "Limit the results to a single entry using a placeholder for numeric values."], "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"], "description": "The virtual table provides the invoice number and invoice date from the 'Invoices' table, corresponding to the invoice that has the highest number of associated financial transactions. The placeholder in the LIMIT clause indicates the maximum number of transactions to consider for the result.", "virtual_table": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1621", "db_id": "customers_and_invoices", "question": "Show all product names and the number of customers having an order on each product.", "rationale": ["Identify the relevant tables: 'Order_Items', 'Products', and 'Orders'.", "Select the 'product_name' from the 'Products' table and count the number of customers from the 'Order_Items' table.", "Join 'Order_Items' with 'Products' on 'product_id' to get product details, and join with 'Orders' on 'order_id' to ensure the orders are counted correctly.", "Group the results by 'product_name' to aggregate the count of customers for each product."], "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"], "description": "The virtual table displays the names of products along with the count of customers who have placed orders for each product. It combines data from the 'Order_Items', 'Products', and 'Orders' tables, using joins to connect the relevant identifiers. The result is grouped by product name to provide a summary of customer orders for each product.", "virtual_table": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name"}
{"sample_id": "train.1599", "db_id": "customers_and_invoices", "question": "Show the invoice number and the number of transactions for each invoice.", "rationale": ["Identify the relevant table, which is 'Financial_Transactions'.", "Select the 'invoice_number' column and use the COUNT function to count the number of transactions.", "Group the results by 'invoice_number' to aggregate the transaction counts for each invoice."], "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"], "description": "The virtual table provides a summary of invoice numbers along with the count of transactions associated with each invoice from the 'Financial_Transactions' table. The grouping by invoice number allows for the aggregation of transaction counts for each unique invoice.", "virtual_table": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["Identify the relevant table, which is 'Order_Items'.", "Select the 'order_id' column and use the COUNT function to count the number of items for each order.", "Group the results by 'order_id' to aggregate the counts for each unique order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "description": "The virtual table displays the order IDs along with the count of items associated with each order from the 'Order_Items' table. The grouping by 'order_id' allows for aggregation of the number of items per order, providing a summary of item quantities for each unique order.", "virtual_table": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id"}
{"sample_id": "train.1580", "db_id": "customers_and_invoices", "question": "Count the number of financial transactions that correspond to each account id.", "rationale": ["Identify the relevant table, which is 'Financial_Transactions'.", "Select the count of transactions and group them by 'account_id'.", "Use a placeholder to represent the account identifier in the output."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "description": "The virtual table summarizes the count of financial transactions associated with each account from the 'Financial_Transactions' table. The placeholder in the SELECT statement represents the account identifier, allowing for the aggregation of transaction counts per account.", "virtual_table": "SELECT count(*) ,  account_id FROM Financial_transactions"}
{"sample_id": "train.1549", "db_id": "customers_and_invoices", "question": "How many customers have opened an account?", "rationale": ["Identify the relevant table, which is 'Accounts'.", "Use the COUNT function to count the number of distinct 'customer_id' entries.", "The query focuses on counting unique customers who have opened accounts, hence the use of DISTINCT."], "gold_sql": "SELECT count(DISTINCT customer_id) FROM Accounts", "source_tables": ["accounts"], "description": "The virtual table provides a count of unique customers who have opened accounts from the 'Accounts' table. The query uses a placeholder to represent the distinct customer identifier, ensuring that only unique customers are counted.", "virtual_table": "SELECT count(DISTINCT customer_id) FROM Accounts"}
{"sample_id": "train.727", "db_id": "customers_card_transactions", "question": "Show the customer ids and firstname without a credit card.", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Customers_Cards'.", "Select the columns to display, 'customer_id' and 'customer_first_name'.", "Use the EXCEPT clause to exclude customers who have a credit card by joining the two tables on 'customer_id' and filtering by 'card_type_code' using a placeholder for string values."], "gold_sql": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  'Credit'", "source_tables": ["customers", "customers_cards"], "description": "The virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those who have a credit card. The placeholder in the query represents the type of card that is being filtered out.", "virtual_table": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.718", "db_id": "customers_card_transactions", "question": "Return the id and full name of the customer who has the fewest accounts.", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Customers_Cards'.", "Select the columns to display: 'customer_id', 'customer_first_name', and 'customer_last_name'.", "Join the 'Customers' table with the 'Customers_Cards' table on 'customer_id'.", "Group the results by 'customer_id' to aggregate the account counts.", "Order the results by the count of accounts in ascending order to find the customer with the fewest accounts.", "Use a placeholder to limit the results to the top entry."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "description": "The virtual table provides the customer ID and full name (first and last name) of customers from the 'Customers' table who are linked to the fewest accounts. The query joins the 'Customers' and 'Customers_Cards' tables, groups the results by customer ID, and orders them in ascending order based on the count of accounts associated with each customer. A placeholder is used to limit the results to the customer with the fewest accounts.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.728", "db_id": "customers_card_transactions", "question": "What are the ids and first names of customers who do not hold a credit card?", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Customers_Cards'.", "Select the columns to display, 'customer_id' and 'customer_first_name' from the 'Customers' table.", "Use an EXCEPT clause to filter out customers who hold a credit card by joining 'Customers_Cards' with 'Customers' on 'customer_id' and applying a condition for the card type code using a placeholder."], "gold_sql": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  'Credit'", "source_tables": ["customers", "customers_cards"], "description": "The virtual table provides the unique identifiers and first names of customers from the 'Customers' table who do not possess a credit card. The query uses an EXCEPT clause to exclude customers who have a card of a specific type, represented by a placeholder for the card type code.", "virtual_table": "SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.716", "db_id": "customers_card_transactions", "question": "What are the ids and full names of customers who hold two or more cards?", "rationale": ["Identify the relevant tables, which are 'Customers_cards' and 'Customers'.", "Select the columns to display: 'customer_id', 'customer_first_name', and 'customer_last_name'.", "Join the 'Customers_cards' table with the 'Customers' table on the 'customer_id' to link cardholders with their details.", "Group the results by 'customer_id' to aggregate the number of cards held by each customer.", "Add a condition in the HAVING clause to filter customers who hold two or more cards using a placeholder for numeric values."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  2", "source_tables": ["customers", "customers_cards"], "description": "The virtual table provides the customer IDs along with their first and last names from the 'Customers' table for those customers who hold two or more cards. The placeholder in the HAVING clause indicates the minimum number of cards a customer must have to be included in the results.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.743", "db_id": "customers_card_transactions", "question": "What is the transaction type that has processed the greatest total amount in transactions?", "rationale": ["Identify the relevant table, which is 'Financial_Transactions'.", "Select the 'transaction_type' column to display.", "Group the results by 'transaction_type' to aggregate the transaction amounts.", "Order the results by the sum of 'transaction_amount' in descending order to find the greatest total.", "Limit the output to a single result using a placeholder for numeric values."], "gold_sql": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1", "source_tables": ["financial_transactions"], "description": "The virtual table summarizes the transaction types from the 'Financial_Transactions' table, grouping them to calculate the total amount for each type. The result is ordered in descending order based on the summed transaction amounts, with a placeholder to limit the output to the top result.", "virtual_table": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.722", "db_id": "customers_card_transactions", "question": "Return the code of the card type that is most common.", "rationale": ["Identify the relevant table, which is 'Customers_Cards'.", "Select the column to display, 'card_type_code'.", "Group the results by 'card_type_code' to count occurrences.", "Order the results in descending order based on the count of each card type.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "description": "The virtual table summarizes the card type codes from the 'Customers_Cards' table, grouping them to identify the most frequently occurring type. The placeholder in the LIMIT clause indicates the number of top results to return, allowing for flexibility in specifying how many of the most common card types to retrieve.", "virtual_table": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.745", "db_id": "customers_card_transactions", "question": "Show the account id and the number of transactions for each account", "rationale": ["Identify the relevant table, which is 'Financial_Transactions'.", "Select the 'account_id' column and use the count function to calculate the number of transactions for each account.", "Group the results by 'account_id' to ensure that the count is specific to each account."], "gold_sql": "SELECT account_id ,  count(*) FROM Financial_transactions GROUP BY account_id", "source_tables": ["financial_transactions"], "description": "The virtual table summarizes the account IDs along with the count of transactions associated with each account from the 'Financial_Transactions' table. The grouping by account ID allows for the aggregation of transaction counts for each unique account.", "virtual_table": "SELECT account_id ,  count(*) FROM Financial_transactions GROUP BY account_id"}
{"sample_id": "train.694", "db_id": "customers_card_transactions", "question": "What are the ids, full names, and phones of each customer?", "rationale": ["Identify the relevant table, which is 'Customers'.", "Select the columns to display: 'customer_id', 'customer_first_name', 'customer_last_name', and 'customer_phone'.", "No additional filtering conditions are needed, as the query retrieves all customers' information."], "gold_sql": "SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers", "source_tables": ["customers"], "description": "The virtual table provides the unique identifiers, full names, and phone numbers of customers from the 'Customers' table. The placeholders represent the specific values for customer identification and contact information.", "virtual_table": "SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers"}
{"sample_id": "train.688", "db_id": "customers_card_transactions", "question": "What are the full names of customers who have accounts?", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Accounts'.", "Select the columns to display, which are 'customer_first_name' and 'customer_last_name'.", "Use a JOIN operation to link the 'Customers' table with the 'Accounts' table based on the 'customer_id' to filter customers who have accounts."], "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "description": "The virtual table provides the distinct first and last names of customers from the 'Customers' table who are linked to accounts in the 'Accounts' table. The join condition ensures that only customers with existing accounts are included in the results.", "virtual_table": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id"}
{"sample_id": "train.729", "db_id": "customers_card_transactions", "question": "Show all card type codes.", "rationale": ["Identify the relevant table, which is 'Customers_Cards'.", "Select the column to display, 'card_type_code'.", "Use the DISTINCT keyword to ensure that only unique card type codes are returned."], "gold_sql": "SELECT DISTINCT card_type_code FROM Customers_Cards", "source_tables": ["customers_cards"], "description": "The virtual table displays the distinct card type codes from the 'Customers_Cards' table. This allows users to see all unique types of cards available without duplicates.", "virtual_table": "SELECT DISTINCT card_type_code FROM Customers_Cards"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["Identify the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "Select the column to display, 'staff_name' from the 'Staff' table.", "Join the 'Staff' table with the 'Staff_Department_Assignments' table on 'staff_id' to link staff members with their job assignments.", "Group the results by 'staff_id' to aggregate the assignments for each staff member.", "Add a condition to filter for staff members who have more than a specified number of job assignments using a placeholder for numeric values."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "description": "The virtual table provides the names of staff members from the 'Staff' table who have been assigned to multiple jobs. It joins the 'Staff' table with the 'Staff_Department_Assignments' table to correlate staff members with their job assignments. The results are grouped by staff ID, and a condition is applied to filter for those with more than a specified number of assignments, represented by a placeholder for numeric values.", "virtual_table": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["Identify the relevant table, which is 'Customers'.", "Select the columns to display, 'customer_id' and 'customer_name'.", "Add conditions to filter the 'customer_address' for a specific substring using a placeholder for string values and to exclude a specific payment method using another placeholder for string values."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "description": "The virtual table provides the unique identifiers and names of customers from the 'Customers' table who have addresses containing a specific substring and do not use a particular payment method. The placeholders in the WHERE clause allow for filtering based on the address and payment method criteria.", "virtual_table": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4740", "db_id": "department_store", "question": "What are the ids and names of department stores with both marketing and managing departments?", "rationale": ["Identify the relevant tables, which are 'departments' and 'department_stores'.", "Select the columns to display, 'dept_store_id' and 'store_name'.", "Use JOIN to connect the two tables based on the 'dept_store_id'.", "Filter the results to include only those department stores that have both specified department names using INTERSECT and placeholders for the department names."], "gold_sql": "SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  'marketing' INTERSECT SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  'managing'", "source_tables": ["departments", "department_stores"], "description": "The virtual table provides the identifiers and names of department stores that have both marketing and managing departments. It combines data from the 'departments' and 'department_stores' tables, ensuring that only stores with the specified departments are included. The placeholders in the query represent the names of the departments being searched for.", "virtual_table": "SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.dept_store_id ,  T2.store_name FROM departments AS T1 JOIN department_stores AS T2 ON T1.dept_store_id  =  T2.dept_store_id WHERE T1.department_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4791", "db_id": "department_store", "question": "Find the id and name of customers whose address contains WY state and do not use credit card for payment.", "rationale": ["Identify the relevant table, which is 'Customers'.", "Select the columns to display, 'customer_id' and 'customer_name'.", "Add conditions to filter the 'customer_address' for a specific state using a placeholder for string values and to exclude a specific payment method using another placeholder for string values."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "description": "The virtual table describes the unique identifiers and names of customers from the 'Customers' table who have an address containing a specific state and do not use a specific payment method. The placeholders in the WHERE clause represent the state in the address and the payment method code.", "virtual_table": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["Identify the relevant table, which is 'Customers'.", "Select the columns to display, 'customer_name' and 'customer_id'.", "Add a condition to filter the 'customer_address' column using a LIKE clause with a placeholder for string values."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "description": "The virtual table provides the names and unique identifiers of customers from the 'Customers' table whose addresses contain a specific substring. The placeholder in the WHERE clause allows for filtering based on the address criteria.", "virtual_table": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4756", "db_id": "department_store", "question": "Return the id of the staff whose Staff Department Assignment was earlier than that of any Clerical Staff.", "rationale": ["Identify the relevant table, which is 'Staff_Department_Assignments'.", "Select the column to display, 'staff_id'.", "Add a condition to filter the 'date_assigned_to' column to be less than the maximum 'date_assigned_to' from a subquery.", "The subquery selects the maximum assignment end date for staff members with a specific job title, using a placeholder for the job title code."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "description": "The virtual table provides the unique identifiers of staff members from the 'Staff_Department_Assignments' table whose assignment end date is earlier than the latest assignment end date of any staff member with a specific job title. The placeholder in the subquery represents the job title code for Clerical Staff.", "virtual_table": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4717", "db_id": "department_store", "question": "What are the staff ids and genders of all staffs whose job title is Department Manager?", "rationale": ["Identify the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "Select the columns to display, 'staff_id' and 'staff_gender' from the 'Staff' table.", "Join the 'Staff' table with the 'Staff_Department_Assignments' table on the 'staff_id' column to associate staff members with their job titles.", "Add a condition to filter the 'job_title_code' column for the specified job title using a placeholder for string values."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  'Department Manager'", "source_tables": ["staff_department_assignments", "staff"], "description": "The virtual table provides the staff IDs and genders of staff members from the 'Staff' table who hold a specific job title. The join with the 'Staff_Department_Assignments' table allows for filtering based on the job title, represented by a placeholder for string values.", "virtual_table": "SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4759", "db_id": "department_store", "question": "Return the name and gender of the staff who was assigned in 2016.", "rationale": ["Identify the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "Select the columns to display, 'staff_name' and 'staff_gender'.", "Join the 'Staff' table with 'Staff_Department_Assignments' on the 'staff_id' to link staff members with their assignments.", "Add a condition to filter the 'date_assigned_from' column for the specified year using a placeholder for string values."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "description": "The virtual table provides the names and genders of staff members from the 'Staff' table who were assigned to a department during a specific time period in 2016. The placeholder in the WHERE clause allows for filtering based on the assignment date.", "virtual_table": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4794", "db_id": "department_store", "question": "What is the average price of clothes?", "rationale": ["Identify the relevant table, which is 'Products'.", "Select the column to calculate the average, 'product_price'.", "Add a condition to filter the 'product_type_code' column for the specified clothing type using a placeholder for string values."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "description": "The virtual table calculates the average price of products from the 'Products' table, specifically filtering for those that belong to a certain type of clothing. The placeholder in the WHERE clause represents the product type code for the clothing category.", "virtual_table": "SELECT avg(product_price) FROM products WHERE product_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["Identify the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "Select the columns to display, 'staff_id' and 'staff_name'.", "Join the 'Staff' table with 'Staff_Department_Assignments' on the staff ID to correlate staff members with their assignments.", "Order the results by the difference between 'date_assigned_to' and 'date_assigned_from' to find the least amount of time assigned.", "Use a placeholder in the LIMIT clause to specify how many records to return."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "description": "The virtual table provides the staff ID and name of staff members from the 'Staff' table who are assigned to departments, ordered by the duration of their assignments. The placeholder in the LIMIT clause indicates the number of records to return, representing the staff member with the least amount of assignment time.", "virtual_table": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4730", "db_id": "department_store", "question": "Return the name and job title of the staff with the latest date assigned.", "rationale": ["Identify the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "Select the columns to display, 'staff_name' from the 'Staff' table and 'job_title_code' from the 'Staff_Department_Assignments' table.", "Join the two tables on the 'staff_id' to associate staff members with their department assignments.", "Order the results by 'date_assigned_to' in descending order to get the latest assignments first.", "Add a limit to the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "description": "The virtual table provides the names and job titles of staff members from the 'Staff' table, joined with their department assignments from the 'Staff_Department_Assignments' table. The results are ordered by the date of assignment, allowing for the retrieval of the most recently assigned staff members, with a placeholder to limit the number of results returned.", "virtual_table": "SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4729", "db_id": "department_store", "question": "What is the name and job title of the staff who was assigned the latest?", "rationale": ["Identify the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "Select the columns to display, 'staff_name' from the 'Staff' table and 'job_title_code' from the 'Staff_Department_Assignments' table.", "Join the two tables on the 'staff_id' to associate staff members with their department assignments.", "Order the results by 'date_assigned_to' in descending order to get the latest assignments first.", "Use a placeholder in the LIMIT clause to specify how many records to return."], "gold_sql": "SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "description": "The virtual table provides the names and job titles of staff members from the 'Staff' table who have been assigned to departments, sorted by the most recent assignment date. The placeholder in the LIMIT clause indicates the number of records to return, allowing for flexibility in the query results.", "virtual_table": "SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4522", "db_id": "document_management", "question": "What are the usernames and passwords of users that have the most common role?", "rationale": ["Identify the relevant table, which is 'Users'.", "Select the columns to display, 'user_name' and 'password'.", "Group the results by 'role_code' to aggregate users by their roles.", "Order the results by the count of users in each role in descending order to find the most common role.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["users"], "description": "The virtual table provides the usernames and passwords of users from the 'Users' table, grouped by their role. It orders the results by the frequency of each role, allowing the retrieval of the most common role's users. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4503", "db_id": "document_management", "question": "Find the types of documents with more than 4 documents.", "rationale": ["Identify the relevant table, which is 'Documents'.", "Select the column to display, 'document_type_code'.", "Group the results by 'document_type_code' to aggregate the data.", "Add a condition to filter the grouped results using HAVING to count the number of documents and compare it to a placeholder for numeric values."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "description": "The virtual table summarizes the types of documents from the 'Documents' table, grouping them by their document type code. It filters the results to include only those document types that have more than a specified number of associated documents, represented by a placeholder for numeric values.", "virtual_table": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4509", "db_id": "document_management", "question": "What is the structure of the document with the least number of accesses?", "rationale": ["Identify the relevant tables, which are 'Documents' and 'Document_Structures'.", "Join the 'Documents' table with the 'Document_Structures' table on the 'document_structure_code' to access the structure descriptions.", "Group the results by 'document_structure_code' to aggregate the access counts for each document structure.", "Order the results by the count of accesses in descending order to find the least accessed document structure.", "Use a placeholder to limit the number of results returned, focusing on the document structure with the least accesses."], "gold_sql": "SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code  =  t2.document_structure_code GROUP BY t1.document_structure_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["document_structures", "documents"], "description": "The virtual table provides the description of the document structure associated with documents in the database. It retrieves the structure description for the document that has been accessed the least number of times, using a placeholder to specify the limit on the number of results returned.", "virtual_table": "SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code  =  t2.document_structure_code GROUP BY t1.document_structure_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4535", "db_id": "document_management", "question": "Find the average access count of documents with the least popular structure.", "rationale": ["Identify the relevant table, which is 'Documents'.", "Select the average of the 'access_count' column to calculate the average access count.", "Group the results by 'document_structure_code' to categorize the documents by their structure.", "Order the results by the count of documents in ascending order to find the least popular structures.", "Use a placeholder in the LIMIT clause to specify how many of the least popular structures to include in the results."], "gold_sql": "SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["documents"], "description": "The virtual table calculates the average access count of documents grouped by their structure. It identifies the document structure with the least popularity by ordering the groups based on the count of documents in ascending order. The placeholder in the LIMIT clause allows for specifying the number of least popular structures to consider.", "virtual_table": "SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4526", "db_id": "document_management", "question": "What are the names of documents that do not have any images?", "rationale": ["Identify the relevant table, which is 'Documents'.", "Select the column to display, 'document_name'.", "Use a subquery to find document names that have images by joining 'Documents', 'Document_Sections', and 'Document_Sections_Images'.", "Utilize the EXCEPT clause to filter out document names that are present in the subquery, ensuring only those without images are included."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "description": "The virtual table lists the names of documents from the 'Documents' table that do not have any associated images. It uses a subquery to identify documents that have sections linked to images, and the placeholder in the EXCEPT clause ensures that only document names without images are returned.", "virtual_table": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id"}
{"sample_id": "train.4525", "db_id": "document_management", "question": "Find names of the document without any images.", "rationale": ["Identify the relevant table, which is 'Documents'.", "Select the column to display, 'document_name'.", "Use an EXCEPT clause to filter out document names that have associated images by joining 'Documents', 'Document_Sections', and 'Document_Sections_Images' tables."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "description": "The virtual table lists the names of documents from the 'Documents' table that do not have any associated images. It excludes documents that are linked to any images through their sections, ensuring that only those documents without images are displayed.", "virtual_table": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id"}
{"sample_id": "dev.944", "db_id": "dog_kennels", "question": "What are the first name and last name of the professionals who have done treatment with cost below average?", "rationale": ["Identify the relevant tables, which are 'Professionals' and 'Treatments'.", "Select the distinct columns to display, 'first_name' and 'last_name' from the 'Professionals' table.", "Join the 'Professionals' table with the 'Treatments' table to link professionals with the treatments they have administered.", "Add a condition to filter the treatments based on their cost being below the average treatment cost, which is calculated using a subquery."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "description": "The virtual table provides the distinct first and last names of professionals from the 'Professionals' table who have administered treatments with costs below the average treatment cost. The query joins the 'Professionals' and 'Treatments' tables, and includes a subquery to calculate the average treatment cost, using a placeholder for the cost condition.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )"}
{"sample_id": "dev.937", "db_id": "dog_kennels", "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.", "rationale": ["Identify the relevant tables: 'Owners', 'Dogs', and 'Treatments'.", "Select the columns to display: 'owner_id' and 'last_name' from the 'Owners' table.", "Join the 'Dogs' table on the owner ID to link dogs to their respective owners.", "Join the 'Treatments' table on the dog ID to link treatments to the dogs.", "Group the results by owner ID to aggregate treatment costs for each owner.", "Order the results by the count of treatments in descending order to find the owners who spent the most.", "Add a limit to restrict the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "description": "The virtual table provides the owner ID and last name of the owners from the 'Owners' table who have the highest expenditure on treatments for their dogs. The query joins the 'Owners', 'Dogs', and 'Treatments' tables to aggregate treatment costs by owner, with a placeholder to limit the results to a specific number of owners.", "virtual_table": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.925", "db_id": "dog_kennels", "question": "What are the names of the dogs for which the owner has not spend more than 1000 for treatment ?", "rationale": ["Identify the relevant table, which is 'Dogs'.", "Select the column to display, which is 'name'.", "Use a subquery to filter dogs based on their total treatment costs, grouping by 'dog_id'.", "Add a condition in the HAVING clause to ensure the total cost is less than or equal to a specified amount using a placeholder for numeric values."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "description": "The virtual table lists the names of dogs from the 'Dogs' table whose total treatment costs do not exceed a specified amount. The subquery calculates the total treatment costs for each dog, and the placeholder in the HAVING clause allows for filtering based on the treatment cost threshold.", "virtual_table": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["Identify the relevant tables, which are 'Professionals' and 'Treatments'.", "Select the columns to display, 'professional_id' and 'cell_number'.", "Join the 'Professionals' table with the 'Treatments' table on the professional ID to link treatments to professionals.", "Group the results by professional ID to aggregate treatment counts.", "Add a condition to filter professionals who have administered at least a specified number of treatments using a placeholder for numeric values."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "description": "The virtual table describes the professional IDs and cell phone numbers of professionals from the 'Professionals' table who have administered at least a specified number of treatments. The placeholder in the HAVING clause represents the minimum count of treatment types that a professional must have performed.", "virtual_table": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.960", "db_id": "dog_kennels", "question": "List the last name of the owner owning the youngest dog.", "rationale": ["Identify the relevant tables, which are 'Owners' and 'Dogs'.", "Select the 'last_name' column from the 'Owners' table.", "Join the 'Owners' table with the 'Dogs' table using the 'owner_id' to link them.", "Add a condition to filter the results based on the age of the dog, specifically looking for the maximum age using a subquery."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "description": "The virtual table describes the last names of owners from the 'Owners' table who own the youngest dog. It joins the 'Owners' and 'Dogs' tables based on the owner's unique identifier and filters the results to find the owner of the dog with the maximum age, represented by a placeholder in the subquery.", "virtual_table": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )"}
{"sample_id": "dev.921", "db_id": "dog_kennels", "question": "Find the average age of the dogs who went through treatments.", "rationale": ["Identify the relevant tables, which are 'Dogs' and 'Treatments'.", "Select the column to display, which is the average age of the dogs.", "Add a condition to filter the 'Dogs' table for dogs that have treatment records by using a subquery that selects dog_ids from the 'Treatments' table."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "description": "The virtual table provides the average age of dogs from the 'Dogs' table that have undergone treatments. The inner query filters the dogs based on their identifiers found in the 'Treatments' table, ensuring that only those dogs that have received treatments are included in the average calculation.", "virtual_table": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )"}
{"sample_id": "dev.920", "db_id": "dog_kennels", "question": "What is the average age of the dogs who have gone through any treatments?", "rationale": ["Identify the relevant table, which is 'Dogs'.", "Select the column to calculate the average, which is 'age'.", "Add a condition to filter the 'dog_id' column to include only those dogs that have records in the 'Treatments' table using a subquery."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "description": "The virtual table provides the average age of dogs from the 'Dogs' table that have received any treatments. The inner query filters the dogs based on their identifiers found in the 'Treatments' table, ensuring that only those dogs who have undergone treatment are considered in the average calculation.", "virtual_table": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )"}
{"sample_id": "dev.998", "db_id": "dog_kennels", "question": "List the first name of all the professionals along with the description of the treatment they have done.", "rationale": ["Identify the relevant tables: 'Professionals', 'Treatments', and 'Treatment_Types'.", "Select the 'first_name' from the 'Professionals' table and 'treatment_type_description' from the 'Treatment_Types' table.", "Join the 'Professionals' table with the 'Treatments' table using the 'professional_id' to link treatments to professionals.", "Join the 'Treatments' table with the 'Treatment_Types' table using 'treatment_type_code' to get the treatment descriptions.", "Use DISTINCT to ensure that the results do not contain duplicate entries."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "description": "The virtual table provides a list of unique first names of professionals along with the descriptions of the treatments they have administered. It combines data from the 'Professionals' table, the 'Treatments' table, and the 'Treatment_Types' table, linking them through their respective identifiers. This allows for a comprehensive view of which professionals are associated with which treatment types.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables, which are 'Dogs' and 'Treatments'.", "Select the columns to display, 'date_arrived' and 'date_departed' from the 'Dogs' table.", "Join the 'Dogs' table with the 'Treatments' table on the dog identifier to filter for dogs that have received treatments.", "Use DISTINCT to ensure that the results do not contain duplicate date entries."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "description": "The virtual table provides the distinct arriving and departing dates of dogs from the 'Dogs' table that have undergone treatments. It combines data from the 'Dogs' and 'Treatments' tables, linking them through the dog identifier. This allows for filtering the results to only include dogs that have received treatments, with placeholders representing the specific dates.", "virtual_table": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["Identify the relevant tables: 'Student', 'Lives_in', 'Has_amenity', and 'Dorm_amenity'.", "Select the columns to display, which are 'fname' and 'age' from the 'Student' table.", "Join the 'Student' table with the 'Lives_in' table to link students with their respective dormitories.", "Use a subquery to filter out dormitories that have the specified amenity (TV Lounge) by checking against the 'Has_amenity' and 'Dorm_amenity' tables.", "Add a condition to ensure that only students living in dorms without the specified amenity are included in the results."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "description": "The virtual table describes the first names and ages of students from the 'Student' table who reside in dormitories that do not have a specific amenity, in this case, a TV Lounge. The placeholders in the query represent the amenity's name that is being filtered out.", "virtual_table": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5729", "db_id": "dorm_1", "question": "What is the average age and how many male students are there in each city?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the columns to display: count of students and average age.", "Add a condition to filter the 'Sex' column for male students using a placeholder for string values.", "Group the results by 'city_code' to get the data for each city."], "gold_sql": "SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  'M' GROUP BY city_code", "source_tables": ["student"], "description": "The virtual table provides a summary of the count of male students and their average age from the 'Student' table, grouped by the city of residence. The placeholder in the WHERE clause represents the gender of the students being filtered.", "virtual_table": "SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city_code"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the column to display, 'LName'.", "Add conditions to filter the results based on gender, city code, and age using placeholders for string and numeric values."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "description": "The virtual table provides the last names of students from the 'Student' table who meet specific criteria based on their gender, age, or city of residence. The placeholders in the WHERE clause represent the gender, city code, and age conditions that can be modified to filter the results accordingly.", "virtual_table": "SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND city_code  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5699", "db_id": "dorm_1", "question": "What are the names and types of the dorms that have a capacity greater than 300 or less than 100?", "rationale": ["Identify the relevant table, which is 'Dorm'.", "Select the columns to display, 'dorm_name' and 'gender'.", "Add conditions to filter the 'student_capacity' column for values greater than or less than specified thresholds using placeholders for numeric values."], "gold_sql": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100", "source_tables": ["dorm"], "description": "The virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding a specified number or falling below another specified number. The placeholders in the WHERE clause represent the capacity thresholds.", "virtual_table": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] OR student_capacity  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5757", "db_id": "dorm_1", "question": "What are the first names of all students who live in the dorm with the most amenities?", "rationale": ["Identify the relevant tables: 'Student', 'Lives_in', 'Dorm', 'Has_amenity', and 'Dorm_amenity'.", "Select the column to display, which is 'fname' from the 'Student' table.", "Join the 'Student' table with the 'Lives_in' table to connect students with their dormitories.", "Use a subquery to find the dormitory with the most amenities by joining 'Dorm', 'Has_amenity', and 'Dorm_amenity' tables, grouping by dormitory ID, and ordering by the count of amenities.", "Add a condition to filter the dormitory IDs based on the result of the subquery, using a placeholder for the number of top dormitories to consider."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "description": "The virtual table provides the first names of students from the 'Student' table who reside in the dormitory that has the highest number of amenities. The query involves joining the 'Student' table with the 'Lives_in' table to link students to their respective dorms, and it uses a subquery to identify the dormitory with the most amenities by counting the amenities associated with each dormitory. The placeholder in the LIMIT clause indicates the number of top dormitories to consider based on the count of amenities.", "virtual_table": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["Identify the relevant tables: 'Student', 'Lives_in', 'Dorm', 'Has_amenity', and 'Dorm_amenity'.", "Select the column to display, which is 'fname' from the 'Student' table.", "Join the 'Student' table with the 'Lives_in' table to link students with their respective dormitories.", "Use a subquery to find the dormitory with the most amenities by joining 'Dorm', 'Has_amenity', and 'Dorm_amenity' tables, grouping by dormitory ID, and counting the amenities.", "Add a condition to filter the dormitory IDs based on the result of the subquery, using a placeholder for the number of top dormitories to consider."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "description": "The virtual table provides the first names of students from the 'Student' table who reside in the dormitory with the highest number of amenities. It utilizes a subquery to determine which dormitory has the most amenities by counting the amenities associated with each dormitory and ordering them in descending order. The placeholder in the LIMIT clause allows for specifying the number of top dormitories to consider.", "virtual_table": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the relevant tables: 'Student', 'Lives_in', and 'Dorm'.", "Count the total number of students by using the count(*) function.", "Join the 'Student' table with the 'Lives_in' table on the student ID, and then join the result with the 'Dorm' table on the dormitory ID.", "Add a condition to filter the results based on the gender of the dormitory using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "description": "The virtual table provides the total count of students residing in male-designated dormitories. It combines data from the 'Student', 'Lives_in', and 'Dorm' tables, filtering the results based on the gender designation of the dormitory using a placeholder for string values.", "virtual_table": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5688", "db_id": "dorm_1", "question": "Find the average and total capacity of dorms for the students with gender X.", "rationale": ["Identify the relevant table, which is 'Dorm'.", "Select the columns to display, which are the average and total of 'student_capacity'.", "Add a condition to filter the 'gender' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  'X'", "source_tables": ["dorm"], "description": "The virtual table provides the average and total capacity of dormitories from the 'Dorm' table, filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6714", "db_id": "driving_school", "question": "What is the id and detail of the vehicle used in lessons for most of the times?", "rationale": ["Identify the relevant tables, which are 'Vehicles' and 'Lessons'.", "Select the columns to display, 'vehicle_id' and 'vehicle_details'.", "Join the 'Vehicles' table with the 'Lessons' table on the vehicle ID to correlate vehicles with lessons.", "Group the results by vehicle ID to count how many times each vehicle is used in lessons.", "Order the results in descending order based on the count of lessons to find the most frequently used vehicles.", "Add a limit to specify how many of the top vehicles to return, using a placeholder for numeric values."], "gold_sql": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["lessons", "vehicles"], "description": "The virtual table provides the vehicle IDs and their corresponding details from the 'Vehicles' table that are used in lessons. It aggregates the data by counting the number of times each vehicle is associated with lessons, ordering the results to show the most frequently used vehicles first. The placeholder in the LIMIT clause allows for specifying the number of top vehicles to retrieve.", "virtual_table": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6654", "db_id": "driving_school", "question": "Which city lives most of staffs? List the city name and number of staffs.", "rationale": ["Identify the relevant tables, which are 'Addresses' and 'Staff'.", "Join the two tables on the address identifier to associate staff with their respective cities.", "Select the 'city' column and count the number of staff members in each city.", "Group the results by city to aggregate the staff counts.", "Order the results in descending order based on the count of staff members to find the city with the most staff.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.city ,  count(*) FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id GROUP BY T1.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "staff"], "description": "The virtual table provides a summary of the cities where staff members reside, along with the count of staff in each city. It aggregates data from the 'Addresses' and 'Staff' tables, linking them through the staff's address identifier. The result is grouped by city and ordered by the number of staff members, allowing for the identification of the city with the highest staff count, limited to a specified number of results.", "virtual_table": "SELECT T1.city ,  count(*) FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id GROUP BY T1.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6688", "db_id": "driving_school", "question": "Which city does has most number of customers?", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Addresses'.", "Join the 'Customers' table with the 'Addresses' table using the customer_address_id to address_id relationship.", "Select the 'city' column from the 'Addresses' table.", "Group the results by the 'city' to count the number of customers in each city.", "Order the results in descending order based on the count of customers to find the city with the most customers.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "customers"], "description": "The virtual table provides a list of cities from the 'Addresses' table that are associated with customers in the 'Customers' table. It groups the results by city and orders them by the number of customers in each city, allowing the user to identify the city with the highest customer count. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6711", "db_id": "driving_school", "question": "What are the last names that are used by customers and staff?", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Staff'.", "Select the 'last_name' column from both tables.", "Use the INTERSECT operator to find common last names between the two tables."], "gold_sql": "SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff", "source_tables": ["staff", "customers"], "description": "The virtual table presents the last names of individuals from both the 'Customers' and 'Staff' tables, showing the intersection of last names used by customers and staff members. This allows for identifying common last names between these two groups.", "virtual_table": "SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff"}
{"sample_id": "train.6627", "db_id": "driving_school", "question": "What are the details of the car with id 1?", "rationale": ["Identify the relevant table, which is 'Vehicles'.", "Select the column to display, 'vehicle_details'.", "Add a condition to filter the 'vehicle_id' column for the specified vehicle using a placeholder for numeric values."], "gold_sql": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;", "source_tables": ["vehicles"], "description": "The virtual table provides the details of vehicles from the 'Vehicles' table, specifically focusing on the vehicle's information based on a unique identifier. The placeholder in the WHERE clause represents the vehicle's ID.", "virtual_table": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6699", "db_id": "driving_school", "question": "How many lessons have been cancelled?", "rationale": ["Identify the relevant table, which is 'Lessons'.", "Use the count function to aggregate the total number of lessons.", "Add a condition to filter the 'lesson_status_code' column for the specified status using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Lessons WHERE lesson_status_code = 'Cancelled';", "source_tables": ["lessons"], "description": "The virtual table provides a count of lessons from the 'Lessons' table that have a specific status indicating cancellation. The placeholder in the WHERE clause represents the status code for cancelled lessons.", "virtual_table": "SELECT count(*) FROM Lessons WHERE lesson_status_code = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.6698", "db_id": "driving_school", "question": "How many lessons were in cancelled state?", "rationale": ["Identify the relevant table, which is 'Lessons'.", "Select the count of lessons to display.", "Add a condition to filter the 'lesson_status_code' column for the specified status using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Lessons WHERE lesson_status_code = 'Cancelled';", "source_tables": ["lessons"], "description": "The virtual table provides a count of lessons from the 'Lessons' table that are in a specific status, indicated by a placeholder. This allows users to filter the lessons based on their current status, such as 'cancelled'.", "virtual_table": "SELECT count(*) FROM Lessons WHERE lesson_status_code = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.6331", "db_id": "e_government", "question": "What are the names of all cities and states?", "rationale": ["Identify the relevant table, which is 'Addresses'.", "Select the 'town_city' column to retrieve city names.", "Select the 'state_province_county' column to retrieve state names.", "Use the UNION operator to combine the results from both selections, ensuring unique entries."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "description": "The virtual table presents a list of unique town and city names along with their corresponding state, province, or county from the 'Addresses' table. The query combines these two sets of data using a UNION operation to ensure that all entries are included without duplicates.", "virtual_table": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table, which is 'Addresses'.", "Select the 'town_city' column to retrieve city names.", "Select the 'state_province_county' column to retrieve state or county names.", "Use a UNION to combine the results from both selections into a single list."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "description": "The virtual table presents a list of unique town and city names along with their corresponding state, province, or county from the 'Addresses' table. The query combines these two sets of data using a UNION operation, allowing for a comprehensive view of geographical locations represented in the database.", "virtual_table": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses"}
{"sample_id": "train.6323", "db_id": "e_government", "question": "What is the last name of the contact individual from the Labour party organization who was contacted most recently?", "rationale": ["Identify the relevant tables: 'Organizations', 'Organization_Contact_Individuals', and 'Individuals'.", "Select the 'individual_last_name' from the 'Individuals' table.", "Join the tables based on their relationships: 'Organizations' to 'Organization_Contact_Individuals' and 'Organization_Contact_Individuals' to 'Individuals'.", "Add a condition to filter the organization name using a placeholder for string values.", "Sort the results by the contact date in descending order to get the most recent contact.", "Limit the results to one entry to retrieve only the most recent contact individual."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  'Labour Party' ORDER BY t2.date_contact_to DESC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "description": "The virtual table provides the last names of contact individuals associated with a specific organization, in this case, the Labour party. It joins the 'Organizations', 'Organization_Contact_Individuals', and 'Individuals' tables to retrieve the relevant data. The placeholder in the WHERE clause is used to specify the organization's name, while the ORDER BY clause sorts the results by the most recent contact date, limiting the output to the most recent individual.", "virtual_table": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY t2.date_contact_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the relevant tables, which are 'Individuals' and 'Organization_Contact_Individuals'.", "Select the 'individual_last_name' column from the 'Individuals' table and ensure distinct values are returned.", "Join the 'Individuals' table with the 'Organization_Contact_Individuals' table using the 'individual_id' to filter for individuals who are contact persons for organizations."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "description": "The virtual table describes the distinct last names of individuals from the 'Individuals' table who have been identified as contact individuals for organizations. This is achieved by joining the 'Individuals' table with the 'Organization_Contact_Individuals' table based on the unique identifier for individuals, ensuring that only those individuals who have a contact relationship with an organization are included.", "virtual_table": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id"}
{"sample_id": "train.6342", "db_id": "e_government", "question": "Which state can address \"6862 Kaitlyn Knolls\" possibly be in?", "rationale": ["Identify the relevant table, which is 'Addresses'.", "Select the column to display, 'state_province_county'.", "Add a condition to filter the 'line_1_number_building' column using a LIKE clause with a placeholder for string values to accommodate partial matches."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "description": "The virtual table provides a list of possible states, provinces, or counties associated with addresses from the 'Addresses' table that match a specific address line. The placeholder in the WHERE clause allows for the input of a partial or complete address to filter the results accordingly.", "virtual_table": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["Identify the relevant table, which is 'Employee'.", "Select the column to display, 'name'.", "Use an EXCEPT clause to filter out employees who are certified to fly a specific aircraft.", "Join the 'Employee' table with the 'Certificate' and 'Aircraft' tables to find certified employees.", "Add a condition to filter the aircraft name using a placeholder for string values."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "description": "The virtual table describes the names of employees from the 'Employee' table who do not hold a certification for a specific aircraft model. The query uses an EXCEPT clause to exclude those employees who are certified to fly the specified aircraft, represented by a placeholder for the aircraft's name.", "virtual_table": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["Identify the relevant tables, which are 'Flight' and 'Aircraft'.", "Select the 'name' column from the 'Aircraft' table and count the number of flights from the 'Flight' table.", "Join the two tables on the aircraft ID to associate flights with their respective aircraft.", "Group the results by the aircraft ID to get the count of flights for each aircraft name."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "description": "The virtual table provides a summary of aircraft names along with the count of flights associated with each aircraft. It combines data from the 'Flight' and 'Aircraft' tables, linking them through the aircraft ID. The result is grouped by the aircraft ID to aggregate the number of flights for each aircraft name.", "virtual_table": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["Identify the relevant tables: 'Employee', 'Certificate', and 'Aircraft'.", "Select the 'name' column from the 'Employee' table.", "Join the 'Employee' table with the 'Certificate' table on the employee ID, and then join with the 'Aircraft' table on the aircraft ID.", "Add a condition to filter the aircraft distance using a placeholder for numeric values.", "Group the results by employee ID to count the number of certificates each employee holds.", "Order the results by the count of certificates in descending order and limit the output to a specified number using placeholders."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "description": "The virtual table provides the names of employees from the 'Employee' table who hold the most certificates for flying aircraft that can travel a distance greater than a specified value. The query joins the 'Employee', 'Certificate', and 'Aircraft' tables to filter and group the results based on the number of certificates held by each employee, ordering them in descending order. Placeholders are used for the distance threshold and the limit on the number of results returned.", "virtual_table": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.434", "db_id": "flight_1", "question": "What is the name and distance of every aircraft that can cover a distance of more than 5000 and which at least 5 people can fly?", "rationale": ["Identify the relevant tables, which are 'Certificate' and 'Aircraft'.", "Select the column to display, which is 'name' from the 'Aircraft' table.", "Join the 'Certificate' table with the 'Aircraft' table on the aircraft ID to filter the results based on aircraft capabilities.", "Add a condition to filter the 'distance' column for aircraft that can cover more than a specified distance using a placeholder for numeric values.", "Group the results by aircraft ID and ensure that the count of associated certificates meets the minimum passenger requirement using another placeholder for numeric values."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "description": "The virtual table provides the names of aircraft from the 'Aircraft' table that can travel a distance greater than a specified value and can accommodate at least a certain number of passengers. The placeholders in the WHERE clause represent the distance threshold and the minimum number of passengers required.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.437", "db_id": "flight_1", "question": "What is the salary and name of the employee who has the most number of certificates on aircrafts with distance more than 5000?", "rationale": ["Identify the relevant tables: 'Employee', 'Certificate', and 'Aircraft'.", "Join the 'Employee' table with the 'Certificate' table on the employee ID, and then join the 'Certificate' table with the 'Aircraft' table on the aircraft ID.", "Filter the results based on the distance of the aircraft using a placeholder for numeric values.", "Group the results by employee ID to count the number of certificates each employee holds.", "Order the results in descending order based on the count of certificates and limit the output to a specified number using placeholders."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "description": "The virtual table provides the names of employees from the 'Employee' table who hold the most certificates for aircrafts that can travel a distance greater than a specified value. The query joins the 'Employee', 'Certificate', and 'Aircraft' tables to filter and group the results based on the number of certificates held by each employee, ordering them in descending order. Placeholders are used for the distance threshold and the limit on the number of results returned.", "virtual_table": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["Identify the relevant tables, which are 'Certificate' and 'Aircraft'.", "Select the 'name' column from the 'Aircraft' table.", "Join the 'Certificate' table with the 'Aircraft' table on the aircraft ID.", "Group the results by the aircraft ID to count the number of certificates for each aircraft.", "Order the results by the count of certificates in descending order to find the aircraft with the fewest certificates.", "Use a placeholder in the LIMIT clause to allow the user to specify how many results they want."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "description": "The virtual table provides the names of aircraft from the 'Aircraft' table that have the fewest associated certificates. It utilizes a join between the 'Certificate' and 'Aircraft' tables, grouping the results by aircraft ID and ordering them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the number of results to return.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["Identify the relevant table, which is 'Flight'.", "Select the column to display, which is the average of the 'price' column.", "Add conditions to filter the 'origin' and 'destination' columns for the specified locations using placeholders for string values."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "description": "The virtual table provides the average price of flights from a specified origin to a specified destination. The placeholders in the WHERE clause represent the origin and destination locations for the flight.", "virtual_table": "SELECT avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING] AND destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["Identify the relevant table, which is 'Flight'.", "Select the column to display, 'origin'.", "Add a condition to filter the 'destination' column for the specified city using a placeholder for string values."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "description": "The virtual table provides a list of origins for all flights from the 'Flight' table that are destined for a specific location. The placeholder in the WHERE clause represents the destination city.", "virtual_table": "SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.400", "db_id": "flight_1", "question": "What are the numbers of the shortest flights?", "rationale": ["Identify the relevant table, which is 'Flight'.", "Select the column to display, 'flno', which represents the flight numbers.", "Order the results by the 'distance' column in ascending order to find the shortest flights.", "Use a placeholder in the LIMIT clause to specify how many flight numbers to return."], "gold_sql": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT 3", "source_tables": ["flight"], "description": "The virtual table lists the flight numbers from the 'Flight' table, ordered by the distance of the flights in ascending order. The placeholder in the LIMIT clause indicates the maximum number of flight numbers to return, allowing for the selection of the shortest flights.", "virtual_table": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.258", "db_id": "flight_2", "question": "Which airports do not have departing or arriving flights?", "rationale": ["Identify the relevant table, which is 'Airports'.", "Select the column to display, 'AirportName'.", "Add a condition to filter out airports that have any flights by using a subquery that combines both source and destination airports from the 'Flights' table, ensuring that only airports without any flight activity are selected."], "gold_sql": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)", "source_tables": ["airports", "flights"], "description": "The virtual table lists the names of airports from the 'Airports' table that do not have any flights either departing from or arriving at them. The query uses a subquery to identify all airport codes that are involved in flights, and the placeholder in the WHERE clause ensures that only airports without any flight activity are included.", "virtual_table": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)"}
{"sample_id": "dev.243", "db_id": "flight_2", "question": "Find all airlines that have fewer than 200 flights.", "rationale": ["Identify the relevant tables, which are 'airlines' and 'flights'.", "Join the 'airlines' table with the 'flights' table on the airline identifier.", "Select the 'Airline' column from the 'airlines' table.", "Group the results by airline to aggregate flight counts.", "Use the HAVING clause to filter airlines based on the count of flights, using a placeholder for the numeric threshold."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "description": "The virtual table lists the names of airlines from the 'airlines' table that have a flight count below a specified threshold. The placeholder in the HAVING clause indicates the maximum number of flights an airline can have to be included in the results.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.241", "db_id": "flight_2", "question": "Find all airlines that have at least 10 flights.", "rationale": ["Identify the relevant tables, which are 'airlines' and 'flights'.", "Select the column to display, which is 'Airline' from the 'airlines' table.", "Join the 'airlines' table with the 'flights' table on the unique identifier of the airline.", "Group the results by the airline name to aggregate flight counts.", "Add a condition to filter the grouped results to include only those airlines with a flight count greater than a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  10", "source_tables": ["flights", "airlines"], "description": "The virtual table lists the names of airlines from the 'airlines' table that have a specified number of flights. The query joins the 'airlines' and 'flights' tables based on the unique identifier of the airline, grouping the results by airline name and filtering to include only those with a flight count exceeding a placeholder for numeric values.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.244", "db_id": "flight_2", "question": "Which airlines have less than 200 flights?", "rationale": ["Identify the relevant tables, which are 'airlines' and 'flights'.", "Select the column to display, which is 'Airline' from the 'airlines' table.", "Join the 'airlines' table with the 'flights' table on the unique identifier of the airline.", "Group the results by the airline name to aggregate the flight counts.", "Add a condition to filter the grouped results to include only those airlines with a flight count less than the specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "description": "The virtual table lists the names of airlines from the 'airlines' table that operate fewer than a specified number of flights. The query joins the 'airlines' and 'flights' tables based on the airline's unique identifier, grouping the results by airline name and applying a condition to filter those with a flight count below the placeholder value.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.225", "db_id": "flight_2", "question": "What is the code of airport that has the highest number of flights?", "rationale": ["Identify the relevant tables, which are 'airports' and 'flights'.", "Join the two tables on the airport code to include both source and destination airports.", "Group the results by airport code to count the number of flights associated with each airport.", "Order the results in descending order based on the count of flights to find the airport with the highest number.", "Use a placeholder in the LIMIT clause to allow for flexibility in specifying the number of results to return."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "description": "The virtual table provides the airport code of the airport that has the highest number of flights, either as a departure or arrival point. It aggregates data from the 'airports' and 'flights' tables, counting the total flights associated with each airport code and ordering them to identify the one with the most flights. The placeholder in the LIMIT clause allows for specifying how many top results to return.", "virtual_table": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.226", "db_id": "flight_2", "question": "What is the airport code of the airport with the most flights?", "rationale": ["Identify the relevant tables, which are 'airports' and 'flights'.", "Join the two tables on the airport code to include both source and destination airports.", "Group the results by the airport code to count the number of flights associated with each airport.", "Order the results in descending order based on the count of flights to find the airport with the most flights.", "Limit the results to a single entry using a placeholder for numeric values."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "description": "The virtual table provides the airport code of the airport that has the highest number of flights, either as a departure or arrival point. It aggregates data from the 'airports' and 'flights' tables, grouping by airport code and ordering the results by the count of flights, with a limit specified by a placeholder for numeric values.", "virtual_table": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.229", "db_id": "flight_2", "question": "Which airline has most number of flights?", "rationale": ["Identify the relevant tables, which are 'AIRLINES' and 'FLIGHTS'.", "Join the two tables on the unique identifier for airlines to associate each flight with its respective airline.", "Select the 'Airline' column from the 'AIRLINES' table.", "Group the results by the 'Airline' to aggregate the flight counts.", "Order the results by the count of flights in descending order to find the airline with the most flights.", "Add a limit to the results using a placeholder for numeric values."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flights", "airlines"], "description": "The virtual table summarizes the airlines and their corresponding flight counts from the 'AIRLINES' and 'FLIGHTS' tables. It groups the results by airline name and orders them in descending order based on the number of flights, allowing the user to specify a limit on the number of results returned.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.194", "db_id": "flight_2", "question": "Give the airline with abbreviation 'UAL'.", "rationale": ["Identify the relevant table, which is 'airlines'.", "Select the column to display, 'Airline'.", "Add a condition to filter the 'Abbreviation' column for the specified abbreviation using a placeholder for string values."], "gold_sql": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  'UAL'", "source_tables": ["airlines"], "description": "The virtual table provides the name of the airline from the 'airlines' table that corresponds to a specific abbreviation. The placeholder in the WHERE clause represents the abbreviation of the airline.", "virtual_table": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.182", "db_id": "flight_2", "question": "Which abbreviation corresponds to Jetblue Airways?", "rationale": ["Identify the relevant table, which is 'airlines'.", "Select the column to display, 'Abbreviation'.", "Add a condition to filter the 'Airline' column for the specified airline using a placeholder for string values."], "gold_sql": "SELECT Abbreviation FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "description": "The virtual table provides the abbreviation of airlines from the 'airlines' table based on the specified airline name. The placeholder in the WHERE clause represents the name of the airline for which the abbreviation is being queried.", "virtual_table": "SELECT Abbreviation FROM AIRLINES WHERE Airline  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.214", "db_id": "flight_2", "question": "Give the number of Jetblue Airways flights.", "rationale": ["Identify the relevant tables, which are 'flights' and 'airlines'.", "Use a JOIN to connect the 'flights' table with the 'airlines' table based on the airline's unique identifier.", "Select the count of flights from the 'flights' table.", "Add a condition to filter the results based on the airline's name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = 'JetBlue Airways'", "source_tables": ["flights", "airlines"], "description": "The virtual table provides a count of flights operated by a specific airline from the 'flights' table, joined with the 'airlines' table to filter by the airline's name. The placeholder in the WHERE clause represents the name of the airline for which the flight count is requested.", "virtual_table": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.180", "db_id": "flight_2", "question": "What country is Jetblue Airways affiliated with?", "rationale": ["Identify the relevant table, which is 'airlines'.", "Select the column to display, 'Country'.", "Add a condition to filter the 'Airline' column for the specified airline using a placeholder for string values."], "gold_sql": "SELECT Country FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "description": "The virtual table provides information about the country associated with a specific airline. The placeholder in the WHERE clause allows for the input of the airline's name to filter the results accordingly.", "virtual_table": "SELECT Country FROM AIRLINES WHERE Airline  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6852", "db_id": "flight_4", "question": "What is the number of cities in the United States with more than 3 airports?", "rationale": ["Identify the relevant table, which is 'airports'.", "Select the 'city' column to display the cities.", "Add a condition to filter the 'country' column for the specified country using a placeholder for string values.", "Group the results by 'city' to aggregate the data.", "Use the HAVING clause to filter cities that have more than a specified number of airports, using a placeholder for numeric values."], "gold_sql": "SELECT city FROM airports WHERE country  =  'United States' GROUP BY city HAVING count(*)  >  3", "source_tables": ["airports"], "description": "The virtual table provides a list of cities from the 'airports' table located in a specific country, grouped by city. It includes a condition to filter cities that have more than a specified number of airports, represented by a placeholder for numeric values. The placeholder in the WHERE clause indicates the country, while the HAVING clause specifies the minimum number of airports required for the city to be included in the results.", "virtual_table": "SELECT city FROM airports WHERE country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6843", "db_id": "flight_4", "question": "Which countries has the most number of airlines whose active status is 'Y'?", "rationale": ["Identify the relevant table, which is 'airlines'.", "Select the 'country' column to display.", "Add a condition to filter the 'active' column for the specified status using a placeholder for string values.", "Group the results by 'country' to aggregate the counts of active airlines.", "Order the results in descending order based on the count of airlines and limit the output using placeholders."], "gold_sql": "SELECT country FROM airlines WHERE active  =  'Y' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "description": "The virtual table summarizes the countries that have the highest number of active airlines. It filters the airlines based on their active status and groups the results by country, allowing for an ordered list of countries based on the count of active airlines. The placeholders represent the active status and the limit for the number of results to return.", "virtual_table": "SELECT country FROM airlines WHERE active  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6857", "db_id": "flight_4", "question": "List the cities which have more than 2 airports sorted by the number of airports.", "rationale": ["Identify the relevant table, which is 'airports'.", "Select the 'city' column to display the names of cities.", "Group the results by 'city' to aggregate the number of airports per city.", "Add a condition to filter cities that have more than a specified number of airports using a placeholder for numeric values.", "Sort the results by the count of airports in descending order."], "gold_sql": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)", "source_tables": ["airports"], "description": "The virtual table summarizes the cities that have a significant number of airports, specifically those with more than a specified threshold. The results are grouped by city and sorted based on the count of airports in descending order, allowing users to identify cities with a high concentration of airport facilities.", "virtual_table": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER] ORDER BY count(*)"}
{"sample_id": "train.6883", "db_id": "flight_4", "question": "Find the busiest destination airport that runs most number of routes in China.", "rationale": ["Identify the relevant tables, which are 'airports' and 'routes'.", "Select the column to display, which is the airport name from the 'airports' table.", "Join the 'airports' table with the 'routes' table on the destination airport ID to associate routes with airports.", "Add a condition to filter the 'country' column for the specified country using a placeholder for string values.", "Group the results by airport name to aggregate the route counts.", "Order the results by the count of routes in descending order to find the busiest airport.", "Limit the results to return only the top entry."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "The virtual table provides the names of destination airports from the 'airports' table that are located in a specific country, specifically China. It joins the 'routes' table to count the number of routes associated with each airport. The results are grouped by airport name and ordered by the count of routes in descending order, with a limit applied to return only the busiest airport.", "virtual_table": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6868", "db_id": "flight_4", "question": "What is the total number of routes for each country and airline in that country?", "rationale": ["Identify the relevant tables, which are 'airlines' and 'routes'.", "Select the 'country' and 'name' columns from the 'airlines' table.", "Count the number of routes by using the COUNT function.", "Join the 'airlines' table with the 'routes' table on the airline ID to associate routes with their respective airlines.", "Group the results by 'country' and 'name' to get the total number of routes for each airline in each country."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "description": "The virtual table summarizes the total number of routes associated with each airline, categorized by the country where the airline is based. It combines data from the 'airlines' and 'routes' tables, using the airline ID as a link between them. The placeholders represent the country and airline name, while the count reflects the number of routes for each airline in that country.", "virtual_table": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name"}
{"sample_id": "train.6884", "db_id": "flight_4", "question": "What is the name of the airport that is the destination of the most number of routes that start in China?", "rationale": ["Identify the relevant tables, which are 'airports' and 'routes'.", "Join the 'airports' table with the 'routes' table on the destination airport ID.", "Filter the results based on the specified country using a placeholder for string values.", "Group the results by airport name to aggregate the count of routes.", "Order the results in descending order based on the count of routes to find the most popular destination.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "The virtual table provides the names of airports that serve as destinations for routes originating from a specific country. It joins the 'airports' table with the 'routes' table to filter for destination airports based on the country specified. The results are grouped by airport name and ordered by the count of routes, allowing the user to identify the airport with the highest number of routes. The placeholders represent the country name and the limit on the number of results to return.", "virtual_table": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6837", "db_id": "flight_4", "question": "Find the name and city of the airport which is the source for the most number of flight routes.", "rationale": ["Identify the relevant tables, which are 'airports' and 'routes'.", "Select the columns to display: 'name' and 'city' from the 'airports' table, and 'src_apid' from the 'routes' table.", "Join the 'airports' table with the 'routes' table on the airport ID to correlate source airports with their routes.", "Group the results by the source airport ID to count the number of routes for each airport.", "Order the results by the count of routes in descending order to find the airport with the most routes.", "Add a limit to the results to allow the user to specify how many records they want to retrieve."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "The virtual table provides the names and cities of airports that serve as the source for flight routes, along with a count of those routes. It aggregates data from the 'airports' and 'routes' tables, joining them on the airport ID. The results are grouped by the source airport ID and ordered by the number of routes in descending order, allowing the user to specify a limit on the number of records returned.", "virtual_table": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6859", "db_id": "flight_4", "question": "Find the number of routes for each source airport and the airport name.", "rationale": ["Identify the relevant tables, which are 'routes' and 'airports'.", "Select the count of routes and the name of the source airport from the 'airports' table.", "Join the 'airports' table with the 'routes' table on the source airport ID.", "Group the results by the airport name to aggregate the count of routes for each source airport."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name", "source_tables": ["airports", "routes"], "description": "The virtual table summarizes the count of routes originating from each source airport along with the corresponding airport names. It combines data from the 'routes' and 'airports' tables, using a join on the source airport ID, and groups the results by the airport name to provide a count of routes for each airport.", "virtual_table": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name"}
{"sample_id": "train.6860", "db_id": "flight_4", "question": "For each airport name, how many routes start at that airport?", "rationale": ["Identify the relevant tables, which are 'airports' and 'routes'.", "Select the count of routes and the airport name from the 'airports' table.", "Join the 'airports' table with the 'routes' table on the source airport ID to link routes to their respective airports.", "Group the results by the airport name to get the total number of routes for each airport."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name", "source_tables": ["airports", "routes"], "description": "The virtual table provides a count of routes originating from each airport, along with the corresponding airport names. It combines data from the 'airports' table and the 'routes' table, using a join on the source airport ID. The result is grouped by the airport name to aggregate the number of routes for each airport.", "virtual_table": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name"}
{"sample_id": "train.6841", "db_id": "flight_4", "question": "Which countries has the most number of airlines?", "rationale": ["Identify the relevant table, which is 'airlines'.", "Select the 'country' column to display.", "Group the results by 'country' to count the number of airlines in each country.", "Order the results in descending order based on the count of airlines.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "description": "The virtual table summarizes the countries that have the highest number of airlines by grouping the airline data based on the country. The placeholder in the LIMIT clause indicates the maximum number of countries to be returned in the result.", "virtual_table": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6862", "db_id": "flight_4", "question": "For each  airport name, how many routes start at that airport, ordered from most to least?", "rationale": ["Identify the relevant tables, which are 'airports' and 'routes'.", "Select the count of routes and the airport name from the 'airports' table.", "Join the 'airports' table with the 'routes' table on the source airport ID.", "Group the results by the airport name to get the count of routes for each airport.", "Order the results by the count of routes in descending order."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC", "source_tables": ["airports", "routes"], "description": "The virtual table provides a count of routes originating from each airport, along with the corresponding airport names. It aggregates the data from the 'airports' and 'routes' tables, using a join on the source airport ID. The results are grouped by airport name and ordered by the number of routes in descending order.", "virtual_table": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC"}
{"sample_id": "train.6831", "db_id": "flight_4", "question": "Find the name, city, and country of the airport that has the highest latitude.", "rationale": ["Identify the relevant table, which is 'airports'.", "Select the columns to display: 'name', 'city', and 'country'.", "Sort the results by the 'elevation' column in descending order to find the airport with the highest elevation.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT 1", "source_tables": ["airports"], "description": "The virtual table provides the name, city, and country of airports from the 'airports' table, sorted by their elevation in descending order. The placeholder in the LIMIT clause indicates the number of top results to return, which can be adjusted as needed.", "virtual_table": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6835", "db_id": "flight_4", "question": "Find the names of the top 10 airlines that operate the most number of routes.", "rationale": ["Identify the relevant tables, which are 'airlines' and 'routes'.", "Join the 'airlines' table with the 'routes' table on the airline ID to associate each airline with its routes.", "Select the airline name and ID for display.", "Group the results by airline ID to count the number of routes each airline operates.", "Order the results in descending order based on the count of routes to identify the top airlines.", "Use a placeholder in the LIMIT clause to allow the user to specify how many top airlines to return."], "gold_sql": "SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT 10", "source_tables": ["routes", "airlines"], "description": "The virtual table provides the names and unique identifiers of airlines that operate routes, sorted by the number of routes they manage. The placeholder in the LIMIT clause allows for specifying the number of top airlines to retrieve.", "virtual_table": "SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6873", "db_id": "flight_4", "question": "Find the number of routes that have destination John F Kennedy International Airport.", "rationale": ["Identify the relevant tables, which are 'airports' and 'routes'.", "Join the 'airports' table with the 'routes' table on the airport ID to link routes to their destination airports.", "Select the count of routes by using the count(*) function.", "Add a condition to filter the results based on the destination airport's name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'", "source_tables": ["airports", "routes"], "description": "The virtual table summarizes the count of routes from the 'routes' table that have a specific destination airport, identified by its name. The placeholder in the WHERE clause represents the name of the destination airport.", "virtual_table": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6872", "db_id": "flight_4", "question": "What is the number of routes operated by the airline American Airlines whose destinations are in Italy?", "rationale": ["Identify the relevant tables: 'routes', 'airports', and 'airlines'.", "Count the total number of routes by using the count(*) function.", "Join the 'routes' table with the 'airports' table on the destination airport ID to access the country information.", "Join the 'routes' table with the 'airlines' table on the airline ID to filter by the airline's name.", "Add conditions in the WHERE clause to filter by the specified country and airline using placeholders."], "gold_sql": "SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  'Italy' AND T3.name  =  'American Airlines'", "source_tables": ["routes", "airlines", "airports"], "description": "The virtual table summarizes the count of routes from the 'routes' table that are operated by a specific airline and have destinations in a particular country. It joins the 'routes' table with the 'airports' table to filter by the destination country's identifier and with the 'airlines' table to filter by the airline's name. The placeholders in the WHERE clause represent the country and airline name respectively.", "virtual_table": "SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6822", "db_id": "flight_4", "question": "How many airports' names have the word Interanation in them?", "rationale": ["Identify the relevant table, which is 'airports'.", "Select the count of rows that match the condition.", "Add a condition to filter the 'name' column using a LIKE clause with a placeholder for string values."], "gold_sql": "SELECT count(*) FROM airports WHERE name LIKE '%International%'", "source_tables": ["airports"], "description": "The virtual table provides a count of airport names from the 'airports' table that contain a specific substring. The placeholder in the WHERE clause is used to represent the substring that is being searched for within the airport names.", "virtual_table": "SELECT count(*) FROM airports WHERE name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6825", "db_id": "flight_4", "question": "Find the number of routes operated by American Airlines.", "rationale": ["Identify the relevant tables, which are 'airlines' and 'routes'.", "Count the total number of routes by using the count(*) function.", "Join the 'airlines' table with the 'routes' table on the airline ID to associate routes with their respective airlines.", "Add a condition to filter the results based on the airline's name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "description": "The virtual table summarizes the count of routes associated with a specific airline from the 'routes' and 'airlines' tables. It joins these tables based on the airline ID and filters the results to include only those routes operated by the specified airline name.", "virtual_table": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6379", "db_id": "flight_company", "question": "List the name of the pilots who have flied for both a company that mainly provide 'Cargo' services and a company that runs 'Catering services' activities.", "rationale": ["Identify the relevant tables, which are 'operate_company' and 'flight'.", "Select the column to display, which is 'pilot' from the 'flight' table.", "Use JOIN to connect the 'operate_company' and 'flight' tables based on the company ID.", "Apply an INTERSECT operation to find pilots who have flown for both types of companies by filtering the 'principal_activities' column with placeholders for the specified service types."], "gold_sql": "SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  'Cargo' INTERSECT SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  'Catering services'", "source_tables": ["flight", "operate_company"], "description": "The virtual table lists the names of pilots from the 'flight' table who have operated flights for companies that primarily provide specific services. It uses an intersection of two queries to ensure that the pilots have flown for both a company focused on cargo services and another that specializes in catering services. The placeholders in the WHERE clauses represent the types of principal activities of the companies.", "virtual_table": "SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6381", "db_id": "flight_company", "question": "How many companies operates airlines in each airport?", "rationale": ["Identify the relevant tables: 'operate_company', 'flight', and 'airport'.", "Join the 'operate_company' table with the 'flight' table using the company identifier to associate flights with their operating companies.", "Join the resulting table with the 'airport' table using the airport identifier to link flights to their respective airports.", "Count the number of companies for each airport by grouping the results based on the airport's unique identifier."], "gold_sql": "SELECT T3.id ,  count(*) FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id JOIN airport AS T3 ON T2.airport_id  =  T3.id GROUP BY T3.id", "source_tables": ["airport", "flight", "operate_company"], "description": "The virtual table provides a count of operating companies that manage airlines at each airport. It combines data from the 'operate_company', 'flight', and 'airport' tables, linking them through their respective identifiers. The result is grouped by each airport's unique identifier, allowing for a summary of airline operations per airport.", "virtual_table": "SELECT T3.id ,  count(*) FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id JOIN airport AS T3 ON T2.airport_id  =  T3.id GROUP BY T3.id"}
{"sample_id": "train.6371", "db_id": "flight_company", "question": "What are the names and types of the companies that have ever operated a flight?", "rationale": ["Identify the relevant tables, which are 'operate_company' and 'flight'.", "Select the columns to display, 'name' and 'Type' from the 'operate_company' table.", "Use a JOIN operation to connect the 'operate_company' table with the 'flight' table based on the company identifier, ensuring that only companies that have operated flights are included."], "gold_sql": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id", "source_tables": ["flight", "operate_company"], "description": "The virtual table presents the names and types of operating companies from the 'operate_company' table that have been associated with flights recorded in the 'flight' table. The join condition links the companies to their respective flights using the company identifier.", "virtual_table": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id"}
{"sample_id": "train.2225", "db_id": "formula_1", "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the relevant tables, which are 'races' and 'results'.", "Select the average of the 'fastestLapSpeed' from the 'results' table and the 'name' and 'year' from the 'races' table.", "Join the 'races' and 'results' tables on the race identifier to correlate race details with results.", "Add a condition to filter the races based on the specified year using a placeholder for numeric values.", "Group the results by race name to calculate the average speed for each race.", "Order the results by the year of the race."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "description": "The virtual table provides the average fastest lap speed of drivers in races held after a specified year, grouped by the race name and ordered by the year of the race. The placeholders allow users to specify the year for filtering the races.", "virtual_table": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year"}
{"sample_id": "train.2179", "db_id": "formula_1", "question": "Find the id and forenames of drivers who participated both the races with name Australian Grand Prix and the races with name Chinese Grand Prix?", "rationale": ["Identify the relevant tables: 'races', 'results', and 'drivers'.", "Select the columns to display: 'driverId' and 'forename'.", "Join the 'races' table with the 'results' table to link races with their corresponding results.", "Join the 'results' table with the 'drivers' table to get driver information.", "Use the INTERSECT operator to find drivers who participated in both specified races, filtering by race names using placeholders."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "The virtual table provides the driver IDs and forenames of drivers who participated in both the races named 'Australian Grand Prix' and 'Chinese Grand Prix'. It utilizes an INTERSECT operation to ensure that only drivers who appear in both race results are included. The placeholders in the WHERE clauses represent the names of the races being queried.", "virtual_table": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the relevant tables: 'races', 'results', and 'drivers'.", "Select the columns to display, which are 'forename' and 'surname' from the 'drivers' table.", "Join the 'races' table with the 'results' table to link races with their results, and then join with the 'drivers' table to get driver names.", "Use a WHERE clause to filter for the Australian Grand Prix and use EXCEPT to exclude drivers who participated in the Chinese Grand Prix, with placeholders for the race names."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "The virtual table provides the first and last names of drivers who participated in a specific race, in this case, the Australian Grand Prix, while excluding those who participated in another specified race, the Chinese Grand Prix. The placeholders in the query represent the names of the races being filtered.", "virtual_table": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2185", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["Identify the relevant tables, which are 'drivers' and 'driverStandings'.", "Select the 'forename' column from the 'drivers' table and ensure the results are distinct.", "Join the 'drivers' table with the 'driverStandings' table on the driver ID to correlate driver information with their standings.", "Add conditions to filter for drivers who have a winning position, a specified number of wins, and more than a certain number of points using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "description": "The virtual table describes the distinct forenames of drivers from the 'drivers' table who have achieved a winning position in the driver standings. The placeholders in the WHERE clause represent the specific winning position, the number of wins, and the minimum points threshold required for selection.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2180", "db_id": "formula_1", "question": "What is the id and first name of all the drivers who participated in the Australian Grand Prix and the Chinese Grand Prix?", "rationale": ["Identify the relevant tables: 'races', 'results', and 'drivers'.", "Select the columns to display: 'driverId' from the results table and 'forename' from the drivers table.", "Join the 'races' table with the 'results' table on 'raceId' to link races with their results.", "Join the 'results' table with the 'drivers' table on 'driverId' to link results with driver information.", "Use the INTERSECT operator to find drivers who participated in both specified races, filtering by race names using placeholders."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "The virtual table provides the driver IDs and first names of drivers who participated in both the Australian Grand Prix and the Chinese Grand Prix. It combines results from the 'races', 'results', and 'drivers' tables, filtering based on the race names specified in the placeholders.", "virtual_table": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2181", "db_id": "formula_1", "question": "What are the forenames and surnames of drivers who participated in the races named Australian Grand Prix but not the races named Chinese Grand Prix?", "rationale": ["Identify the relevant tables: 'races', 'results', and 'drivers'.", "Join the 'races' table with the 'results' table to link races with their results.", "Join the 'results' table with the 'drivers' table to get driver information.", "Use a WHERE clause to filter for the 'Australian Grand Prix' race name using a placeholder.", "Use an EXCEPT clause to exclude drivers from the 'Chinese Grand Prix' race name, also using a placeholder."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "The virtual table provides the forenames and surnames of drivers who participated in specific races. It includes drivers from the 'races' table filtered by the race names, specifically including those from the 'Australian Grand Prix' while excluding those from the 'Chinese Grand Prix'. The placeholders in the query represent the names of the races.", "virtual_table": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2190", "db_id": "formula_1", "question": "For each constructor id, how many races are there?", "rationale": ["Identify the relevant table, which is 'constructorStandings'.", "Count the number of races for each constructor using the count(*) function.", "Group the results by 'constructorId' to aggregate the race counts for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "description": "The virtual table summarizes the count of races associated with each constructor from the 'constructorStandings' table. The results are grouped by the constructor identifier, allowing users to see how many races each constructor has participated in.", "virtual_table": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid"}
{"sample_id": "train.2184", "db_id": "formula_1", "question": "What are all the different first names of the drivers who are in position as standing and won?", "rationale": ["Identify the relevant tables, which are 'drivers' and 'driverstandings'.", "Select the 'forename' column from the 'drivers' table, ensuring distinct values are returned.", "Join the 'drivers' table with the 'driverstandings' table on the 'driverId' to correlate driver information with their standings.", "Add conditions to filter the results based on the specified standing position and the number of wins using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "description": "The virtual table provides a list of distinct first names of drivers from the 'drivers' table who are currently in a specific standing position and have achieved a certain number of wins. The placeholders in the WHERE clause allow for filtering based on the driver's standing position and the number of wins they have.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2189", "db_id": "formula_1", "question": "What are the numbers of races for each constructor id?", "rationale": ["Identify the relevant table, which is 'constructorStandings'.", "Select the count of races and the constructor ID to display.", "Group the results by the constructor ID to aggregate the race counts for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "description": "The virtual table summarizes the total number of races associated with each constructor from the 'constructorStandings' table. The results are grouped by the constructor's unique identifier, allowing for an aggregated count of races per constructor.", "virtual_table": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid"}
{"sample_id": "train.2176", "db_id": "formula_1", "question": "What are the names and years of all races that had a driver with the last name Lewis?", "rationale": ["Identify the relevant tables: 'results' for race results, 'races' for race details, and 'drivers' for driver information.", "Select the columns to display: 'name' and 'year' from the 'races' table.", "Join the 'results' table with the 'races' table on 'raceId' to connect race results to their respective races.", "Join the 'results' table with the 'drivers' table on 'driverId' to connect race results to the drivers.", "Add a condition to filter the driver's first name using a placeholder for string values."], "gold_sql": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = 'Lewis'", "source_tables": ["results", "drivers", "races"], "description": "The virtual table provides the names and years of races from the 'races' table that involved a specific driver. It combines data from the 'results' table to link drivers to their respective races, filtering based on the driver's first name using a placeholder for string values.", "virtual_table": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2167", "db_id": "formula_1", "question": "What is the id and family name of the driver who has the longest laptime?", "rationale": ["Identify the relevant tables, which are 'drivers' and 'lapTimes'.", "Select the columns to display, 'driverId' and 'surname'.", "Join the 'drivers' table with the 'lapTimes' table on the 'driverId' to correlate drivers with their lap times.", "Order the results by the 'milliseconds' column in descending order to find the longest lap time.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "description": "The virtual table provides the driver ID and surname of drivers from the 'drivers' table who have recorded lap times in the 'lapTimes' table. The results are ordered by the lap time in milliseconds in descending order, allowing the identification of the driver with the longest lap time. The placeholder in the LIMIT clause indicates the number of results to return.", "virtual_table": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables, which are 'races' and 'results'.", "Select the maximum value of the 'fastestLapSpeed' from the 'results' table.", "Join the 'races' table with the 'results' table on the race identifier to correlate race details with results.", "Add conditions to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "The virtual table provides the maximum fastest lap speed recorded during a specific race, identified as the Monaco Grand Prix in a particular year. It combines data from the 'races' table and the 'results' table, using placeholders to filter by the year and the race name.", "virtual_table": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2168", "db_id": "formula_1", "question": "What is the id and last name of the driver with the longest laptime?", "rationale": ["Identify the relevant tables, which are 'drivers' and 'lapTimes'.", "Select the columns to display, 'driverId' and 'surname'.", "Join the 'drivers' table with the 'lapTimes' table on the 'driverId' to correlate drivers with their lap times.", "Order the results by the 'milliseconds' column in descending order to find the longest lap time.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "description": "The virtual table provides the driver ID and last name of drivers from the 'drivers' table who have recorded lap times in the 'lapTimes' table. The results are ordered by the lap time in milliseconds in descending order, allowing the identification of the driver with the longest lap time. The placeholder in the LIMIT clause indicates the number of results to return.", "virtual_table": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables, which are 'races' and 'results'.", "Select the average of the 'fastestLapSpeed' from the 'results' table.", "Join the 'races' table with the 'results' table on the race identifier to correlate race data with results.", "Add conditions to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "The virtual table provides the average fastest lap speed recorded during a specific race, identified as the Monaco Grand Prix in a particular year. It combines data from the 'races' and 'results' tables, where the year and race name are specified using placeholders for numeric and string values, respectively.", "virtual_table": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6017", "db_id": "game_1", "question": "What is the first name and last name of the student who have most number of sports?", "rationale": ["Identify the relevant tables, which are 'SportsInfo' and 'Student'.", "Join the 'SportsInfo' table with the 'Student' table using the 'StuID' column to link students with their sports participation.", "Select the columns to display, 'Fname' and 'Lname' from the 'Student' table.", "Group the results by 'StuID' to count the number of sports each student is involved in.", "Order the results in descending order based on the count of sports to find the student with the most participation.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo", "student"], "description": "The virtual table describes the first and last names of students from the 'Student' table who are involved in sports, sorted by the number of sports they participate in. The placeholder in the LIMIT clause indicates the maximum number of students to return based on their sports participation count.", "virtual_table": "SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6029", "db_id": "game_1", "question": "Show total hours per week and number of games played for student David Shieber.", "rationale": ["Identify the relevant tables, which are 'SportsInfo' and 'Student'.", "Select the aggregated columns to display: total hours per week and total games played.", "Join the 'SportsInfo' table with the 'Student' table on the student identifier (StuID).", "Add conditions to filter the results based on the specified student's first and last names using placeholders for string values."], "gold_sql": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.Fname  =  'David' AND T2.Lname  =  'Shieber'", "source_tables": ["sportsinfo", "student"], "description": "The virtual table summarizes the total hours per week dedicated to sports and the total number of games played by a specific student. It combines data from the 'SportsInfo' table and the 'Student' table, using the student's first and last names as criteria for filtering the results.", "virtual_table": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.Fname  =  [PLACEHOLDER-TYPE:STRING] AND T2.Lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6025", "db_id": "game_1", "question": "Show student ids who are female and play football.", "rationale": ["Identify the relevant tables, which are 'Student' and 'SportsInfo'.", "Select the column to display, 'StuID', from both tables.", "Add a condition to filter the 'sex' column for female students using a placeholder for string values.", "Use an INTERSECT to combine results from both queries, ensuring that only student IDs that meet both criteria are returned."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "description": "The virtual table provides a list of student IDs from the 'Student' table who are identified as female and also participate in football, as indicated in the 'SportsInfo' table. The placeholders in the WHERE clause represent the gender and the sport name being queried.", "virtual_table": "SELECT StuID FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6019", "db_id": "game_1", "question": "Which sport has most number of students on scholarship?", "rationale": ["Identify the relevant table, which is 'SportsInfo'.", "Select the column to display, 'SportName'.", "Add a condition to filter the 'OnScholarship' column for students who are on scholarship using a placeholder for string values.", "Group the results by 'SportName' to aggregate the data.", "Order the results by the count of students in descending order to find the sport with the most students on scholarship.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "description": "The virtual table summarizes the names of sports from the 'SportsInfo' table where students are on a sports scholarship. The query groups the results by sport name and orders them by the count of students in descending order, allowing the identification of the sport with the highest number of students on scholarship. Placeholders are used for the scholarship status and the limit on the number of results returned.", "virtual_table": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sportname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6013", "db_id": "game_1", "question": "Show all student IDs with the number of sports and total number of games played", "rationale": ["Identify the relevant table, which is 'SportsInfo'.", "Select the 'StuID' column to display the unique student identifiers.", "Use the COUNT function to count the number of sports for each student.", "Use the SUM function to calculate the total number of games played by each student.", "Group the results by 'StuID' to ensure each student's data is aggregated correctly."], "gold_sql": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID", "source_tables": ["sportsinfo"], "description": "The virtual table summarizes the unique student identifiers along with the count of sports each student participates in and the total number of games they have played. The data is aggregated from the 'SportsInfo' table, grouping the results by each student's ID.", "virtual_table": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID"}
{"sample_id": "train.6024", "db_id": "game_1", "question": "What are the student ids for those on scholarship in major number 600?", "rationale": ["Identify the relevant tables, which are 'Student' and 'SportsInfo'.", "Select the 'StuID' column from both tables to find the student identifiers.", "Add a condition to filter the 'major' column in the 'Student' table using a placeholder for numeric values.", "Add a condition to filter the 'OnScholarship' column in the 'SportsInfo' table using a placeholder for string values.", "Use the INTERSECT operator to find common student IDs from both queries."], "gold_sql": "SELECT StuID FROM Student WHERE major  =  600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "description": "The virtual table identifies the unique student identifiers from the 'Student' table for students who are enrolled in a specific major and are also participating in sports on a scholarship. The placeholders in the query represent the major number and the scholarship status.", "virtual_table": "SELECT StuID FROM Student WHERE major  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6027", "db_id": "game_1", "question": "Show all male student ids who don't play football.", "rationale": ["Identify the relevant table, which is 'Student', to retrieve student IDs.", "Filter the results to include only male students by using a placeholder for the gender.", "Use the EXCEPT clause to exclude student IDs from the 'SportsInfo' table where the sport name matches football, using a placeholder for the sport name."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "description": "The virtual table lists the unique identifiers of male students from the 'Student' table who are not involved in playing football. The placeholders in the query represent the gender and the sport name, allowing for flexible input to filter the results accordingly.", "virtual_table": "SELECT StuID FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5985", "db_id": "game_1", "question": "Which game type has most number of games?", "rationale": ["Identify the relevant table, which is 'Video_Games'.", "Select the 'GType' column to display the types of games.", "Group the results by 'GType' to aggregate the data based on game genres.", "Order the results by the count of games in each genre in descending order to find the most common type.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["video_games"], "description": "The virtual table summarizes the types of video games from the 'Video_Games' table, grouping them by their genre. It orders the results by the count of games in each genre in descending order, allowing the user to identify the game type with the highest number of entries. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6031", "db_id": "game_1", "question": "Show total hours per week and number of games played for students under 20.", "rationale": ["Identify the relevant tables, which are 'SportsInfo' and 'Student'.", "Select the columns to display, which are the sum of 'HoursPerWeek' and 'GamesPlayed'.", "Join the 'SportsInfo' table with the 'Student' table on the 'StuID' column to correlate sports participation with student information.", "Add a condition to filter the results based on the 'Age' column from the 'Student' table, using a placeholder for numeric values."], "gold_sql": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  20", "source_tables": ["sportsinfo", "student"], "description": "The virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by students who are under a specific age. The placeholders in the WHERE clause represent the age limit for the students.", "virtual_table": "SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5986", "db_id": "game_1", "question": "What type has the most games?", "rationale": ["Identify the relevant table, which is 'Video_Games'.", "Select the 'GType' column to display the types of games.", "Group the results by 'GType' to aggregate the count of games for each type.", "Order the results in descending order based on the count of games.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["video_games"], "description": "The virtual table summarizes the types of video games from the 'Video_Games' table, grouping them by genre and ordering them by the count of games in each genre. The placeholder in the LIMIT clause indicates the number of top genres to return.", "virtual_table": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6001", "db_id": "game_1", "question": "How many students play sports?", "rationale": ["Identify the relevant table, which is 'SportsInfo'.", "Count the distinct 'StuID' to determine the number of unique students participating in sports."], "gold_sql": "SELECT count(DISTINCT StuID) FROM Sportsinfo", "source_tables": ["sportsinfo"], "description": "The virtual table provides a count of unique students from the 'SportsInfo' table who are participating in sports activities. This count reflects the number of distinct student identifiers, indicating how many students are involved in sports.", "virtual_table": "SELECT count(DISTINCT StuID) FROM Sportsinfo"}
{"sample_id": "train.5978", "db_id": "game_1", "question": "What are the names of all video games that are collectible cards?", "rationale": ["Identify the relevant table, which is 'Video_Games'.", "Select the column to display, 'GName'.", "Add a condition to filter the 'GType' column for the specified genre using a placeholder for string values."], "gold_sql": "SELECT gname FROM Video_games WHERE gtype  =  'Collectible card game'", "source_tables": ["video_games"], "description": "The virtual table lists the names of video games from the 'Video_Games' table that fall under a specific genre. The placeholder in the WHERE clause represents the type of game being queried.", "virtual_table": "SELECT gname FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5977", "db_id": "game_1", "question": "Show all video games with type Collectible card game.", "rationale": ["Identify the relevant table, which is 'Video_Games'.", "Select the column to display, 'GName'.", "Add a condition to filter the 'GType' column for the specified game type using a placeholder for string values."], "gold_sql": "SELECT gname FROM Video_games WHERE gtype  =  'Collectible card game'", "source_tables": ["video_games"], "description": "The virtual table lists the names of video games from the 'Video_Games' table that fall under a specific genre. The placeholder in the WHERE clause represents the type of video game being queried.", "virtual_table": "SELECT gname FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6003", "db_id": "game_1", "question": "List ids for all student who are on scholarship.", "rationale": ["Identify the relevant table, which is 'SportsInfo'.", "Select the column to display, 'StuID'.", "Add a condition to filter the 'OnScholarship' column for students who are on scholarship using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "description": "The virtual table lists the unique identifiers of students from the 'SportsInfo' table who are participating in sports and are indicated as being on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.", "virtual_table": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["Identify the relevant tables, which are 'Medication' and 'Prescribes'.", "Select the count of prescriptions and the brand name from the 'Medication' table.", "Join the 'Medication' table with the 'Prescribes' table on the medication code to link prescriptions to their respective medications.", "Group the results by the brand name to aggregate the count of prescriptions for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "description": "The virtual table summarizes the count of medications prescribed, grouped by their brand names. It combines data from the 'Medication' table, which contains details about each medication including its unique code and brand name, with the 'Prescribes' table that records the prescriptions made by physicians. The count reflects the total number of prescriptions for each brand, providing insights into medication usage.", "virtual_table": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand"}
{"sample_id": "train.3985", "db_id": "hospital_1", "question": "What procedures cost less than 5000 and have John Wen as a trained physician?", "rationale": ["Identify the relevant tables: 'Procedures', 'Physician', and 'Trained_In'.", "Select the 'name' column from the 'Procedures' table where the 'cost' is less than a specified number.", "Use an INTERSECT to combine this with another selection that finds procedures associated with the physician named John Wen.", "Join the 'Physician' table with the 'Trained_In' table to find the treatments they are certified in, and then join with the 'Procedures' table to get the names of those procedures.", "The placeholders represent the cost limit and the physician's name for dynamic querying."], "gold_sql": "SELECT name FROM procedures WHERE cost  <  5000 INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "description": "The virtual table provides a list of medical procedures from the 'Procedures' table that are priced below a specified amount. Additionally, it intersects this list with the names of procedures that have been performed by a physician named John Wen, who is identified in the 'Physician' table and is linked to the procedures through the 'Trained_In' table. The placeholders in the query allow for dynamic input of the cost limit and the physician's name.", "virtual_table": "SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3928", "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["Identify the relevant tables, which are 'Physician' and 'Patient'.", "Select the 'name' column from the 'Physician' table and count the number of patients from the 'Patient' table.", "Join the two tables on the condition that the physician's employee ID matches the patient's primary care physician identifier.", "Group the results by the physician's employee ID to aggregate the patient counts for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "description": "The virtual table provides the names of physicians along with the count of patients they are responsible for. It combines data from the 'Physician' table and the 'Patient' table, linking them through the primary care physician identifier. The result is grouped by each physician to show the total number of patients associated with them.", "virtual_table": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["Identify the relevant table, which is 'Affiliated_With'.", "Select the columns to display, 'physician' and 'department'.", "Add a condition to filter the 'primaryaffiliation' column for the specified primary affiliation using a placeholder for numeric values."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "description": "The virtual table lists the employee IDs of physicians along with the department IDs of their primary affiliations. The placeholder in the WHERE clause indicates that the query will filter for primary affiliations based on a specific numeric value.", "virtual_table": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["Identify the relevant tables, which are 'Department' and 'Physician'.", "Select the columns to display, 'name' and 'position' from the 'Physician' table.", "Join the 'Department' table with the 'Physician' table on the head of the department.", "Group the results by department ID to aggregate the number of employees in each department.", "Order the results by the count of employees in ascending order to find the department with the least number of employees.", "Add a limit to the results using a placeholder for numeric values."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "description": "The virtual table describes the names and positions of heads of departments from the 'Department' and 'Physician' tables. It joins these tables based on the head of the department and groups the results by department ID. The results are ordered by the count of employees in each department, allowing for the identification of the head of the department with the least number of employees, with a placeholder to limit the number of results returned.", "virtual_table": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3934", "db_id": "hospital_1", "question": "Find the number of rooms for different block code?", "rationale": ["Identify the relevant tables, which are 'Block' and 'Room'.", "Count the number of rooms by using the count(*) function.", "Join the 'Block' table with the 'Room' table based on the block floor and block code to correlate the data.", "Group the results by the block code to get the count for each unique block code."], "gold_sql": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode", "source_tables": ["block", "room"], "description": "The virtual table summarizes the count of rooms associated with different block codes from the 'Block' and 'Room' tables. It groups the results by block code, allowing for an overview of how many rooms correspond to each unique block code. The placeholders in the query represent the block code values used for grouping.", "virtual_table": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode"}
{"sample_id": "train.3903", "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["Identify the relevant tables, which are 'Department' and 'Physician'.", "Select the columns to display, 'name' and 'position' from the 'Physician' table.", "Join the 'Department' table with the 'Physician' table on the head of the department.", "Group the results by department ID to count the number of employees in each department.", "Order the results by the count of employees in ascending order to find the department with the least employees.", "Limit the results to one entry using a placeholder for numeric values."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "description": "The virtual table provides the names and positions of physicians who are heads of departments, specifically focusing on the department that has the least number of employees. The query utilizes a join between the 'Department' and 'Physician' tables, grouping the results by department ID and ordering them by the count of employees in each department, with a limit set by a placeholder for numeric values.", "virtual_table": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3945", "db_id": "hospital_1", "question": "How many medications are prescribed for each brand?", "rationale": ["Identify the relevant tables, which are 'Medication' and 'Prescribes'.", "Select the count of prescriptions and the brand name from the 'Medication' table.", "Join the 'Medication' table with the 'Prescribes' table on the medication code to link prescriptions to their respective medications.", "Group the results by the brand name to aggregate the count of prescriptions for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "description": "The virtual table summarizes the count of medications prescribed, grouped by their brand names. It combines data from the 'Medication' table, which includes details about each medication such as its unique code and brand name, with the 'Prescribes' table that records the prescriptions made by physicians. The count reflects the total number of prescriptions for each brand, providing insights into the usage of different medication brands.", "virtual_table": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand"}
{"sample_id": "train.3924", "db_id": "hospital_1", "question": "Find the patient who most recently stayed in room 111.", "rationale": ["Identify the relevant table, which is 'Stay'.", "Select the column to display, 'Patient'.", "Add a condition to filter the 'Room' column for the specified room using a placeholder for numeric values.", "Order the results by 'StayStart' in descending order to get the most recent stay.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT patient FROM stay WHERE room  =  111 ORDER BY staystart DESC LIMIT 1", "source_tables": ["stay"], "description": "The virtual table provides information about patients who have stayed in a specific room, ordered by the start date of their stay. The placeholders allow for specifying the room number and the limit on the number of results returned.", "virtual_table": "SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3964", "db_id": "hospital_1", "question": "What nurses are on call with block floor 1 and block code 1? Tell me their names.", "rationale": ["Identify the relevant table, which is 'On_Call'.", "Select the column to display, 'Nurse'.", "Add conditions to filter the 'BlockFloor' and 'BlockCode' columns for the specified statuses using placeholders for numeric values."], "gold_sql": "SELECT nurse FROM on_call WHERE blockfloor  =  1 AND blockcode  =  1", "source_tables": ["on_call"], "description": "The virtual table lists the identifiers of nurses who are currently on call, filtered by specific conditions regarding the blocked floor and blocked code statuses. The placeholders in the WHERE clause represent the respective statuses for the blocked floor and code.", "virtual_table": "SELECT nurse FROM on_call WHERE blockfloor  =  [PLACEHOLDER-TYPE:NUMBER] AND blockcode  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3901", "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["Identify the relevant table, which is 'Department'.", "Select the 'head' column to get the employee ID of the department head.", "Group the results by 'DepartmentID' to aggregate the employee counts.", "Order the groups by the count of employees in ascending order to find the department with the least employees.", "Use a placeholder to limit the result to the top entry, which corresponds to the department with the least employees."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "description": "The virtual table provides the employee ID of the head of the department that has the least number of employees. It groups the departments by their unique identifier and orders them based on the count of employees in each department, using a placeholder to limit the result to the department with the fewest employees.", "virtual_table": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3941", "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["Identify the relevant tables: 'Physician', 'Prescribes', and 'Medication'.", "Select the distinct names of physicians from the 'Physician' table.", "Join the 'Physician' table with the 'Prescribes' table on the physician's identifier to connect physicians with their prescribed medications.", "Join the 'Prescribes' table with the 'Medication' table on the medication code to filter for the specific medication name using a placeholder."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "description": "The virtual table lists the distinct names of physicians from the 'Physician' table who have prescribed a specific medication. The query joins the 'Physician' table with the 'Prescribes' table to link physicians with their prescriptions, and further joins with the 'Medication' table to filter by the medication name using a placeholder.", "virtual_table": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3940", "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["Identify the relevant tables: 'Physician', 'Prescribes', and 'Medication'.", "Select the distinct names of physicians from the 'Physician' table.", "Join the 'Physician' table with the 'Prescribes' table on the physician's identifier to find which medications they have prescribed.", "Join the resulting table with the 'Medication' table to filter for the specific medication name using a placeholder."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "description": "The virtual table provides the distinct names of physicians from the 'Physician' table who have prescribed a specific medication. The query joins the 'Physician' table with the 'Prescribes' table to link physicians with their prescriptions, and then further joins with the 'Medication' table to filter by the medication's name using a placeholder.", "virtual_table": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3973", "db_id": "hospital_1", "question": "Which physicians are trained in procedures that are more expensive than 5000?", "rationale": ["Identify the relevant tables: 'Physician', 'Trained_In', and 'Procedures'.", "Select the 'name' column from the 'Physician' table to display the names of the physicians.", "Join the 'Trained_In' table on the physician's identifier to link physicians with their training.", "Join the 'Procedures' table on the procedure code to access the cost of the procedures.", "Add a condition to filter the procedures based on their cost using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "description": "The virtual table describes the names of physicians from the 'Physician' table who are trained in specific procedures that exceed a certain cost. The query joins the 'Physician', 'Trained_In', and 'Procedures' tables to filter the results based on the cost of the procedures, with a placeholder representing the cost threshold.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3905", "db_id": "hospital_1", "question": "List the names of patients who have made appointments.", "rationale": ["Identify the relevant tables, which are 'Appointment' and 'Patient'.", "Select the column to display, 'name' from the 'Patient' table.", "Join the 'Appointment' table with the 'Patient' table using the patient identifier to filter for patients who have made appointments."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "description": "The virtual table lists the names of patients from the 'Patient' table who have made appointments. It joins the 'Appointment' table with the 'Patient' table based on the patient identifier, ensuring that only those patients who have corresponding appointment records are included.", "virtual_table": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn"}
{"sample_id": "train.3949", "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["Identify the relevant table, which is 'Undergoes'.", "Select the column to display, 'Patient'.", "Order the results by 'DateUndergoes' to get the most recent treatments.", "Use a placeholder in the LIMIT clause to specify how many recent treatments to return."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "description": "The virtual table provides a list of patients who are undergoing treatments, ordered by the date of the procedures performed. The placeholder in the LIMIT clause indicates the number of most recent treatments to retrieve.", "virtual_table": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3972", "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["Identify the relevant tables: 'Physician', 'Trained_In', and 'Procedures'.", "Select the column to display, which is the 'name' of the physician from the 'Physician' table.", "Join the 'Physician' table with the 'Trained_In' table on the physician's identifier to find trained physicians.", "Join the 'Trained_In' table with the 'Procedures' table on the procedure code to access procedure details.", "Add a condition to filter the procedures based on their cost using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "description": "The virtual table describes the names of physicians from the 'Physician' table who are trained in specific procedures. It joins the 'Physician' table with the 'Trained_In' table to link physicians with their training, and further joins with the 'Procedures' table to filter based on the cost of the procedures. The placeholder in the WHERE clause represents the cost threshold for the procedures.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3911", "db_id": "hospital_1", "question": "What are the names of all the physicians who took appointments.", "rationale": ["Identify the relevant tables, which are 'Appointment' and 'Physician'.", "Select the 'name' column from the 'Physician' table.", "Join the 'Appointment' table with the 'Physician' table using the physician's unique identifier to filter for those who have taken appointments."], "gold_sql": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID", "source_tables": ["physician", "appointment"], "description": "The virtual table provides the names of physicians from the 'Physician' table who have conducted appointments. It joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, ensuring that only those physicians who have taken appointments are included in the results.", "virtual_table": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID"}
{"sample_id": "train.3910", "db_id": "hospital_1", "question": "List the name of physicians who took some appointment.", "rationale": ["Identify the relevant tables, which are 'Appointment' and 'Physician'.", "Select the column to display, which is 'Name' from the 'Physician' table.", "Join the 'Appointment' table with the 'Physician' table on the physician's identifier to filter the results based on appointments."], "gold_sql": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID", "source_tables": ["physician", "appointment"], "description": "The virtual table lists the names of physicians from the 'Physician' table who have conducted appointments. It joins the 'Appointment' table to filter the physicians based on their involvement in appointments, using a placeholder for the physician's identifier.", "virtual_table": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', 'salary', and 'department_id'.", "Use the MAX function to find the highest salary within each department.", "Group the results by 'department_id' to ensure that the highest salary is calculated for each department."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "The virtual table displays the department ID, full name (first and last name), and salary of employees who have the highest salary in each department. The use of the MAX function allows for the identification of the top earners within their respective departments, while the GROUP BY clause ensures that the results are organized by department.", "virtual_table": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the column to display, 'department_id', ensuring uniqueness with DISTINCT.", "Group the results by 'department_id' and 'manager_id' to aggregate employee counts per manager.", "Add a condition in the HAVING clause to filter groups where the count of 'employee_id' is greater than or equal to a specified number using a placeholder."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "description": "The virtual table provides a list of unique department identifiers from the 'employees' table, specifically for departments where the count of employees managed by a manager is four or more. The placeholder in the HAVING clause indicates the minimum number of employees required for the condition.", "virtual_table": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'hire_date'.", "Add a condition to filter the 'department_id' by using a subquery that selects the 'department_id' of an employee with a specific first name, using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "description": "The virtual table provides the first and last names along with the hire dates of employees from the 'employees' table who work in the same department as a specified employee. The placeholder in the subquery represents the first name of the employee used to identify the department.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.3510", "db_id": "hr_1", "question": "What are the employee ids, full names, and job ids for employees who make more than the highest earning employee with title PU_MAN?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', 'last_name', and 'job_id'.", "Add a condition to filter the results based on salary, comparing it to the maximum salary of a specific job title using a subquery with a placeholder for the job ID."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "description": "The virtual table provides a list of employee IDs, full names (first and last names), and job IDs from the 'employees' table. It filters the results to include only those employees whose salary exceeds the maximum salary of a specific job title, represented by a placeholder for the job ID.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3474", "db_id": "hr_1", "question": "What are the full names and department ids for the lowest paid employees across all departments.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'department_id'.", "Use a subquery to find the minimum salary for each department, filtering the main query to include only those employees whose salary matches the minimum salary for their department."], "gold_sql": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)", "source_tables": ["employees"], "description": "The virtual table presents the first and last names along with the department IDs of employees from the 'employees' table who are the lowest paid within their respective departments. The query utilizes a subquery to determine the minimum salary for each department, ensuring that only those employees with the lowest salaries are included in the results.", "virtual_table": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'hire_date'.", "Add a condition to filter employees based on the department_id of another employee with a specified first name using a subquery.", "Ensure to exclude the specified employee by adding a condition that checks the first name is not equal to the specified name."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "description": "The virtual table provides the first names, last names, and hire dates of employees from the 'employees' table who work in the same department as a specified employee, excluding that employee. The placeholders in the WHERE clause represent the first name of the employee to match and the first name of the employee to exclude.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  [PLACEHOLDER-TYPE:STRING]) AND first_name != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3509", "db_id": "hr_1", "question": "display the employee number, name( first name and last name ) and job title for all employees whose salary is more than any salary of those employees whose job title is PU_MAN.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', 'last_name', and 'job_id'.", "Add a condition to filter employees whose salary is greater than the maximum salary of those with a specific job title, using a subquery and a placeholder for the job title."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "description": "The virtual table presents the employee number, first name, last name, and job title of employees from the 'employees' table who earn a salary greater than the maximum salary of employees holding the job title specified by the placeholder. This allows for a comparison of salaries based on job titles.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3451", "db_id": "hr_1", "question": "Find the ids of the departments where any manager is managing 4 or more employees.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the column to display, 'department_id', ensuring uniqueness with DISTINCT.", "Group the results by 'department_id' and 'manager_id' to aggregate employee counts for each manager in each department.", "Add a condition in the HAVING clause to filter groups where the count of 'employee_id' is greater than or equal to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "description": "The virtual table lists the unique identifiers of departments from the 'employees' table where the count of employees managed by each manager is four or more. The placeholder in the HAVING clause indicates the minimum number of employees required for a manager to be considered.", "virtual_table": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3457", "db_id": "hr_1", "question": "display job ID for those jobs that were done by two or more for more than 300 days.", "rationale": ["Identify the relevant table, which is 'job_history'.", "Select the column to display, 'job_id'.", "Add a condition to filter the job history based on the duration of jobs held using placeholders for numeric values.", "Group the results by 'job_id' to aggregate the data.", "Use the HAVING clause to filter groups that have two or more records, indicating that the job was held by multiple employees."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "description": "The virtual table displays the job IDs from the 'job_history' table for jobs that have been held by two or more employees for a duration exceeding a specified number of days. The placeholders in the WHERE clause and HAVING clause represent the minimum duration in days and the minimum count of employees, respectively.", "virtual_table": "SELECT job_id FROM job_history WHERE end_date - start_date  > [PLACEHOLDER-TYPE:NUMBER] GROUP BY job_id HAVING COUNT(*) >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', 'hire_date', 'salary', and 'department_id'.", "Add a condition to filter the 'first_name' column to exclude names containing the letter 'M' using a placeholder for string values.", "Specify the ordering of the results by 'department_id' in ascending order."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "description": "The virtual table provides the first name, last name, hire date, salary, and department ID of employees from the 'employees' table who do not have the letter 'M' in their first name. The placeholder in the WHERE clause is used to filter out those employees based on the specified condition, and the results are ordered by department ID in ascending order.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY department_id"}
{"sample_id": "train.3516", "db_id": "hr_1", "question": "What are the department ids, full names, and salaries for employees who make the most in their departments?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', 'salary', and 'department_id'.", "Use the MAX function to find the highest salary within each department.", "Group the results by 'department_id' to ensure that the maximum salary is calculated for each department."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "The virtual table provides the department IDs, full names, and salaries of employees from the 'employees' table, specifically focusing on those who earn the highest salary within their respective departments. The use of a placeholder allows for the aggregation of salaries to identify the maximum salary per department.", "virtual_table": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id"}
{"sample_id": "train.3417", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', 'hire_date', 'salary', and 'department_id'.", "Add a condition to filter the 'first_name' column to exclude names containing the letter 'M' using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "description": "The virtual table displays the first and last names, hire date, salary, and department number of employees from the 'employees' table who do not have the letter 'M' in their first name. The placeholder in the WHERE clause is used to filter the first names accordingly.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3428", "db_id": "hr_1", "question": "Return the full names and salaries for employees with first names that end with the letter m.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'salary'.", "Add a condition to filter the 'first_name' column using a LIKE clause with a placeholder for string values to match names ending with a specific letter."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE '%m'", "source_tables": ["employees"], "description": "The virtual table provides the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause is used to filter the first names based on the specified condition.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3408", "db_id": "hr_1", "question": "What are the full names and salaries for any employees earning less than 6000?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'salary'.", "Add a condition to filter the 'salary' column for values less than a specified number using a placeholder for numeric values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "description": "The virtual table presents the first and last names along with the salaries of employees from the 'employees' table who earn below a specified salary threshold. The placeholder in the WHERE clause indicates the maximum salary limit for filtering the results.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3464", "db_id": "hr_1", "question": "Give the name of each department and the number of employees in each.", "rationale": ["Identify the relevant tables, which are 'employees' and 'departments'.", "Join the two tables on the 'department_id' to associate employees with their respective departments.", "Select the 'department_name' from the 'departments' table and count the number of employees from the 'employees' table.", "Group the results by 'department_name' to get the count of employees for each department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "description": "The virtual table provides a summary of each department along with the count of employees associated with that department. It combines data from the 'employees' and 'departments' tables, linking them through the department identifier. The result will display the department names and the corresponding number of employees in each department.", "virtual_table": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name"}
{"sample_id": "train.3508", "db_id": "hr_1", "question": "What are the employee ids and job ids for employees who make less than the lowest earning employee with title MK_MAN?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display, 'employee_id' and 'job_id'.", "Add a condition to filter the 'salary' column to find employees earning less than a specified minimum salary.", "Use a subquery to determine the minimum salary for a specific job title, represented by a placeholder for string values."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "description": "The virtual table provides the employee IDs and job IDs of employees from the 'employees' table who earn less than a specified minimum salary associated with a particular job title. The placeholder in the subquery represents the job ID for which the minimum salary is being compared.", "virtual_table": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table, which is 'jobs'.", "Select the columns to display, 'job_title' and the difference between 'max_salary' and 'min_salary' to represent the salary range.", "Add a condition to filter the 'max_salary' column for the specified range using placeholders for numeric values."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "description": "The virtual table presents the job titles along with the salary range for jobs from the 'jobs' table, specifically focusing on those jobs where the maximum salary falls within a specified range. The placeholders in the WHERE clause allow for dynamic input of the maximum salary limits.", "virtual_table": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the relevant tables: 'employees', 'departments', and 'locations'.", "Select the columns to display: 'first_name', 'last_name', and 'salary'.", "Join the 'employees' table with the 'departments' table on 'department_id' to associate employees with their departments.", "Join the 'departments' table with the 'locations' table on 'location_id' to access location details.", "Add a condition to filter the results based on the 'city' column in the 'locations' table using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "description": "The virtual table provides the first names, last names, and salaries of employees from the 'employees' table who are located in a specific city. The query joins the 'employees' table with the 'departments' table to link employees to their respective departments, and then further joins with the 'locations' table to filter based on the city. The placeholder in the WHERE clause represents the city name.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3472", "db_id": "hr_1", "question": "What is the minimum salary in each department?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the minimum salary using the MIN function and include the department identifier.", "Group the results by 'department_id' to ensure the minimum salary is calculated for each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "The virtual table summarizes the minimum salary for each department from the 'employees' table. It groups the results by the department identifier, allowing for the calculation of the minimum salary within each distinct department.", "virtual_table": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id"}
{"sample_id": "train.3463", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["Identify the relevant tables, which are 'employees' and 'departments'.", "Select the 'department_name' from the 'departments' table and count the number of employees from the 'employees' table.", "Join the two tables on the 'department_id' to associate employees with their respective departments.", "Group the results by 'department_name' to aggregate the employee counts for each department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "description": "The virtual table displays the names of departments along with the count of employees associated with each department. It combines data from the 'employees' and 'departments' tables, linking them through the department identifier. The result is grouped by department name to provide a summary of employee distribution across departments.", "virtual_table": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name"}
{"sample_id": "train.3447", "db_id": "hr_1", "question": "display the employee ID for each employee and the date on which he ended his previous job.", "rationale": ["Identify the relevant table, which is 'job_history'.", "Select the 'employee_id' and the maximum 'end_date' to show when each employee ended their previous job.", "Use the GROUP BY clause to ensure that the results are aggregated by each employee's ID, allowing for the retrieval of the latest end date for each employee."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "description": "The virtual table displays the employee IDs along with the maximum end dates of their previous jobs from the 'job_history' table. The grouping by employee ID allows for the retrieval of the latest end date for each employee's job history.", "virtual_table": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["Identify the relevant table, which is 'job_history'.", "Select the 'employee_id' and the maximum 'end_date' to find the last job's end date for each employee.", "Use the GROUP BY clause to group the results by 'employee_id' to ensure each employee's last job end date is displayed."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "description": "The virtual table provides a list of employee IDs along with the maximum end dates of their employment from the job history records. The placeholder in the query allows for grouping the results by each employee's ID to ensure that the latest end date for each employee is retrieved.", "virtual_table": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display, 'employee_id' and 'job_id'.", "Add a condition to filter the 'salary' column to be less than the minimum salary of employees with a specific job title using a subquery and a placeholder for string values."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "description": "The virtual table displays the employee numbers and job IDs of employees from the 'employees' table whose salaries are less than the minimum salary of employees holding a specific job title. The placeholder in the subquery represents the job title to be compared against.", "virtual_table": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3498", "db_id": "hr_1", "question": "What are the ids for employees who do not work in departments with managers that have ids between 100 and 200?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select all columns to display employee identifiers.", "Add a condition to filter out department identifiers that fall within a specific range of manager identifiers using a subquery.", "The subquery selects department identifiers from the 'departments' table where the manager's identifier is between two specified numeric values, represented by placeholders."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "description": "The virtual table contains the identifiers of employees from the 'employees' table who are not associated with any departments managed by individuals whose identifiers fall within a specified range. The subquery filters the departments based on the manager's identifier, using placeholders for numeric values to define the range.", "virtual_table": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.3481", "db_id": "hr_1", "question": "get the details of employees who manage a department.", "rationale": ["Identify the relevant tables, which are 'employees' and 'departments'.", "Select all columns from the 'employees' table and join it with the 'departments' table based on the condition that the employee's ID matches the manager ID in the departments table.", "Use DISTINCT to ensure that each employee is listed only once, even if they manage multiple departments."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "description": "The virtual table provides details of employees from the 'employees' table who are also managers of departments from the 'departments' table. It combines information from both tables by matching the employee's ID with the manager ID in the departments table, ensuring that only those employees who manage a department are included in the results.", "virtual_table": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id"}
{"sample_id": "train.3497", "db_id": "hr_1", "question": "Find the ids of the employees who does not work in those departments where some employees works whose manager id within the range 100 and 200.", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the column to display, which is the employee identifier.", "Add a condition to filter out department IDs that are managed by managers within a specified range using a subquery with placeholders for numeric values."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "description": "The virtual table contains the identifiers of employees from the 'employees' table who do not belong to departments managed by individuals whose manager IDs fall within a specified numeric range. The inner query filters departments based on the manager ID range, while the outer query excludes those departments from the employee selection.", "virtual_table": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.3466", "db_id": "hr_1", "question": "What is all the job history info done by employees earning a salary greater than or equal to 12000?", "rationale": ["Identify the relevant tables, which are 'job_history' and 'employees'.", "Select all columns from the job history records.", "Join the 'job_history' table with the 'employees' table based on the employee identifier.", "Add a condition to filter the results based on the salary of the employees using a placeholder for numeric values."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "description": "The virtual table contains all job history records for employees from the 'job_history' table, joined with the 'employees' table. It filters the results to include only those employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary requirement.", "virtual_table": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the relevant tables: 'employees', 'departments', 'locations', and 'countries'.", "Select the columns to display: 'first_name', 'last_name', 'employee_id', and 'country_name'.", "Join the 'employees' table with 'departments' using 'department_id'.", "Join the 'departments' table with 'locations' using 'location_id'.", "Join the 'locations' table with 'countries' using 'country_id' to get the country name."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "description": "The virtual table displays the first and last names of employees along with their unique employee ID and the name of the country where they are currently working. It combines data from the 'employees', 'departments', 'locations', and 'countries' tables, linking them through their respective identifiers to provide a comprehensive view of employee information and their geographical location.", "virtual_table": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id"}
{"sample_id": "train.2590", "db_id": "inn_1", "question": "List the names and decor of rooms that have a king bed. Sort the list by their price.", "rationale": ["Identify the relevant table, which is 'Rooms'.", "Select the columns to display, 'roomName' and 'decor'.", "Add a condition to filter the 'bedType' column for the specified bed type using a placeholder for string values.", "Include an ORDER BY clause to sort the results by 'basePrice' to ensure the list is organized by price."], "gold_sql": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;", "source_tables": ["rooms"], "description": "The virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that feature a specific type of bed. The results are sorted by the base price of the rooms, allowing for an organized view based on cost. The placeholder in the WHERE clause represents the type of bed being queried.", "virtual_table": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;"}
{"sample_id": "train.2582", "db_id": "inn_1", "question": "Which room has the highest rate? List the room's full name, rate, check in and check out date.", "rationale": ["Identify the relevant tables, which are 'Rooms' and 'Reservations'.", "Select the columns to display: 'roomName' from 'Rooms', and 'Rate', 'CheckIn', and 'CheckOut' from 'Reservations'.", "Join the 'Rooms' table with the 'Reservations' table using the foreign key relationship on 'Room' and 'RoomId'.", "Group the results by the room to aggregate the rates correctly.", "Order the results by the rate in descending order to find the highest rate.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "The virtual table provides information about rooms and their associated reservations, specifically focusing on the room's name, the rate charged for the reservation, and the check-in and check-out dates. The query retrieves this data by joining the 'Rooms' and 'Reservations' tables, filtering to show the room with the highest rate, and limiting the results to a specified number.", "virtual_table": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2619", "db_id": "inn_1", "question": "How many rooms have king beds? Report the number for each decor type.", "rationale": ["Identify the relevant table, which is 'Rooms'.", "Select the column 'decor' to group the results by room decor type.", "Use the count function to tally the number of rooms for each decor type.", "Add a condition to filter the 'bedType' column for king beds using a placeholder for string values.", "Group the results by the 'decor' column to get the count for each decor type."], "gold_sql": "SELECT decor ,  count(*) FROM Rooms WHERE bedType = 'King' GROUP BY decor;", "source_tables": ["rooms"], "description": "The virtual table summarizes the count of rooms categorized by their decor type from the 'Rooms' table, specifically filtering for rooms that have king beds. The placeholder in the WHERE clause represents the type of bed being queried.", "virtual_table": "SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["Identify the relevant tables, which are 'Rooms' and 'Reservations'.", "Select the 'roomName' from the 'Rooms' table and count the number of reservations from the 'Reservations' table.", "Join the two tables on the room identifier to associate reservations with their respective rooms.", "Group the results by the room identifier to aggregate the count of reservations for each room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "description": "The virtual table summarizes the names of rooms along with the count of reservations made for each room. It combines data from the 'Rooms' table and the 'Reservations' table, linking them through the room identifier. The count reflects the total number of reservations associated with each room, grouped by the room's unique identifier.", "virtual_table": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room"}
{"sample_id": "train.2578", "db_id": "inn_1", "question": "How many kids stay in the rooms reserved by ROY SWEAZY?", "rationale": ["Identify the relevant table, which is 'Reservations'.", "Select the column to display, 'kids'.", "Add conditions to filter the 'FirstName' and 'LastName' columns for the specified guest using placeholders for string values."], "gold_sql": "SELECT kids FROM Reservations WHERE FirstName = 'ROY' AND LastName  =  'SWEAZY';", "source_tables": ["reservations"], "description": "The virtual table provides information about the number of kids staying in rooms reserved by guests from the 'Reservations' table. The placeholders in the WHERE clause represent the first and last names of the guest, allowing for specific queries based on the guest's identity.", "virtual_table": "SELECT kids FROM Reservations WHERE FirstName = [PLACEHOLDER-TYPE:STRING] AND LastName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2604", "db_id": "inn_1", "question": "Find the first and last names of people who payed more than the rooms' base prices.", "rationale": ["Identify the relevant tables, which are 'Reservations' and 'Rooms'.", "Select the columns to display, 'firstname' and 'lastname' from the 'Reservations' table.", "Join the 'Reservations' table with the 'Rooms' table on the room identifier to access room details.", "Add a condition to filter the results where the rate paid exceeds the base price of the room using a placeholder for numeric values."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "description": "The virtual table describes the first and last names of guests from the 'Reservations' table who have paid more than the base prices of the rooms they reserved. The placeholder in the WHERE clause represents the difference between the reservation rate and the room's base price, allowing for a dynamic comparison based on user input.", "virtual_table": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2600", "db_id": "inn_1", "question": "What kind of decor has the least number of reservations?", "rationale": ["Identify the relevant tables, which are 'Reservations' and 'Rooms'.", "Select the 'decor' column from the 'Rooms' table.", "Join the 'Reservations' table with the 'Rooms' table using the room identifier.", "Group the results by the 'decor' column to aggregate the reservation counts.", "Order the results by the count of reservations in ascending order to find the least reserved decor.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "The virtual table summarizes the types of decor from the 'Rooms' table that are associated with the least number of reservations. It joins the 'Reservations' and 'Rooms' tables based on the room identifier, groups the results by the decor type, and orders them in ascending order of their reservation count. The placeholder in the LIMIT clause indicates the maximum number of decor types to return.", "virtual_table": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2605", "db_id": "inn_1", "question": "What are the first and last names of people who payed more than the rooms' base prices?", "rationale": ["Identify the relevant tables, which are 'Reservations' and 'Rooms'.", "Select the columns to display, 'firstname' and 'lastname' from the 'Reservations' table.", "Join the 'Reservations' table with the 'Rooms' table on the room identifier to access room pricing information.", "Add a condition to filter the results where the rate paid exceeds the base price of the room using a placeholder for numeric values."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "description": "The virtual table describes the first and last names of guests from the 'Reservations' table who have paid a rate exceeding the base price of the rooms they reserved. The placeholder in the WHERE clause represents the difference between the rate charged and the base price, allowing for a specific numeric threshold to be set.", "virtual_table": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2601", "db_id": "inn_1", "question": "What is the least popular kind of decor?", "rationale": ["Identify the relevant tables, which are 'Rooms' and 'Reservations'.", "Join the 'Reservations' table with the 'Rooms' table on the room identifier to access decor information.", "Select the 'decor' column from the 'Rooms' table.", "Group the results by the 'decor' column to count occurrences.", "Order the results by the count of decor types in ascending order to find the least popular.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "The virtual table provides a list of room decor types from the 'Rooms' table, grouped by their description. It identifies the least popular kind of decor by counting the occurrences of each decor type in the 'Reservations' table, ordering them in ascending order, and limiting the results to a specified number. The placeholder in the LIMIT clause allows for customization of how many decor types to retrieve.", "virtual_table": "SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2615", "db_id": "inn_1", "question": "Which room has the highest base price?", "rationale": ["Identify the relevant table, which is 'Rooms'.", "Select the columns to display, 'RoomId' and 'roomName'.", "Order the results by 'basePrice' in descending order to find the highest price.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT 1;", "source_tables": ["rooms"], "description": "The virtual table provides information about rooms from the 'Rooms' table, specifically their unique identifiers and names. The results are ordered by the base price in descending order, allowing the user to identify the room with the highest base price. The placeholder in the LIMIT clause indicates the number of results to return.", "virtual_table": "SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2602", "db_id": "inn_1", "question": "List how many times the number of people in the room reached the maximum occupancy of the room. The number of people include adults and kids.", "rationale": ["Identify the relevant tables, which are 'Reservations' and 'Rooms'.", "Join the two tables on the room identifier to correlate reservations with their respective rooms.", "Count the number of records that meet the condition where the sum of adults and kids equals the maximum occupancy of the room."], "gold_sql": "SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;", "source_tables": ["rooms", "reservations"], "description": "The virtual table summarizes the count of reservations where the total number of occupants, including both adults and kids, matches the maximum occupancy allowed for each room. It combines data from the 'Reservations' and 'Rooms' tables, using a join on the room identifier, and applies a condition to ensure that the sum of adults and kids equals the maximum occupancy.", "virtual_table": "SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;"}
{"sample_id": "train.2589", "db_id": "inn_1", "question": "Find the total number of king beds available.", "rationale": ["Identify the relevant table, which is 'Rooms'.", "Select the sum of the 'beds' column to calculate the total number of beds.", "Add a condition to filter the 'bedType' column for the specified bed type using a placeholder for string values."], "gold_sql": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  'King';", "source_tables": ["rooms"], "description": "The virtual table summarizes the total number of beds available in the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.", "virtual_table": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2609", "db_id": "inn_1", "question": "How many rooms have a king bed?", "rationale": ["Identify the relevant table, which is 'Rooms'.", "Select the count of rooms by using the count(*) function.", "Add a condition to filter the 'bedType' column for the specified bed type using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Rooms WHERE bedType  =  'King';", "source_tables": ["rooms"], "description": "The virtual table provides a count of rooms from the 'Rooms' table that feature a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.", "virtual_table": "SELECT count(*) FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.1513", "db_id": "insurance_and_eClaims", "question": "Find all the policy types that are used by more than 2 customers.", "rationale": ["Identify the relevant table, which is 'Policies'.", "Select the column to display, 'policy_type_code'.", "Group the results by 'policy_type_code' to aggregate the data.", "Add a condition to filter the grouped results using the HAVING clause to only include policy types that have a count greater than a specified number, represented by a placeholder for numeric values."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"], "description": "The virtual table summarizes the policy types from the 'Policies' table that are associated with more than a specified number of customers. The placeholder in the HAVING clause indicates the minimum count of customers required for a policy type to be included in the results.", "virtual_table": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1536", "db_id": "insurance_and_eClaims", "question": "What are the names of the customers and staff members?", "rationale": ["Identify the relevant tables, which are 'Customers' and 'Staff'.", "Select the column 'Customer_Details' from the 'Customers' table.", "Select the column 'Staff_Details' from the 'Staff' table.", "Use the UNION operator to combine the results from both selections, ensuring that the output includes names from both customers and staff."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "description": "The virtual table presents a unified view of customer and staff details by combining the 'Customer_Details' from the 'Customers' table and 'Staff_Details' from the 'Staff' table. This allows for a comprehensive list of names from both entities.", "virtual_table": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff"}
{"sample_id": "train.1518", "db_id": "insurance_and_eClaims", "question": "How much amount in total were claimed in the most recently created document?", "rationale": ["Identify the relevant tables, which are 'Claim_Headers' and 'Claims_Documents'.", "Calculate the total amount claimed by summing the 'amount_claimed' column from 'Claim_Headers'.", "Join 'Claim_Headers' with 'Claims_Documents' on the claim identifier to link claims with their documents.", "Add a condition to filter the results based on the creation date of the most recent document using a subquery with a placeholder for numeric values."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "description": "The virtual table summarizes the total amount claimed from the 'Claim_Headers' table, specifically focusing on claims associated with the most recently created document in the 'Claims_Documents' table. The placeholder in the subquery represents the limit for retrieving the latest document's creation date.", "virtual_table": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.1545", "db_id": "insurance_and_eClaims", "question": "Which customer is associated with the latest policy?", "rationale": ["Identify the relevant tables, which are 'Policies' and 'Customers'.", "Select the 'customer_details' from the 'Customers' table.", "Join the 'Policies' table with the 'Customers' table on the 'customer_id' to link policies to their respective customers.", "Use a subquery to find the maximum 'start_date' from the 'Policies' table to filter for the latest policy."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "description": "The virtual table provides the detailed information about customers associated with their insurance policies, specifically focusing on the customer linked to the most recent policy based on the start date. The query utilizes a subquery to determine the maximum start date of policies, ensuring that the result reflects the latest policy's customer details.", "virtual_table": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)"}
{"sample_id": "train.1511", "db_id": "insurance_and_eClaims", "question": "Which type of policy is most frequently used? Give me the policy type code.", "rationale": ["Identify the relevant table, which is 'Policies'.", "Select the column to display, 'policy_type_code'.", "Group the results by 'policy_type_code' to count occurrences.", "Order the results in descending order based on the count of each policy type.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"], "description": "The virtual table summarizes the policy type codes from the 'Policies' table, grouping them to identify the most frequently used policy type. The placeholder in the LIMIT clause allows for specifying the number of top results to return.", "virtual_table": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1528", "db_id": "insurance_and_eClaims", "question": "Which claim processing stage has the most claims? Show the claim status name.", "rationale": ["Identify the relevant tables, which are 'claims_processing' and 'claims_processing_stages'.", "Select the column to display, 'claim_status_name' from the 'claims_processing_stages' table.", "Join the two tables on the claim stage identifier to associate claims with their processing stages.", "Group the results by the claim stage identifier to count the number of claims per stage.", "Order the results by the count of claims in descending order to find the stage with the most claims.", "Add a limit to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"], "description": "The virtual table provides the claim status names associated with different claim processing stages from the 'claims_processing' and 'claims_processing_stages' tables. It groups the results by the claim stage identifier and orders them by the count of claims in descending order, allowing the user to identify the stage with the most claims. The placeholder in the LIMIT clause represents the number of top stages to return.", "virtual_table": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables, which are 'Policies' and 'Customers'.", "Join the 'Policies' table with the 'Customers' table on the 'Customer_ID' to link policies to their respective customers.", "Select the 'Customer_Details' from the 'Customers' table.", "Add a condition to filter the results to only include the policy with the maximum start date using a subquery."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "description": "The virtual table provides the detailed information about customers from the 'Customers' table who have the most recently started insurance policy. The query uses a subquery to find the maximum start date from the 'Policies' table, ensuring that only the customer associated with the latest policy is selected.", "virtual_table": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)"}
{"sample_id": "train.1515", "db_id": "insurance_and_eClaims", "question": "Find the total and average amount paid in claim headers.", "rationale": ["Identify the relevant table, which is 'Claim_Headers'.", "Select the columns to display, which are the sum and average of the 'Amount_Piad' column.", "The query aggregates the total and average amounts paid, providing insights into the financial aspects of claims."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "description": "The virtual table summarizes the total and average amounts paid from the 'Claim_Headers' table. It provides aggregated financial data related to claims, specifically focusing on the 'Amount_Piad' column, which represents the total amount that has been paid out for claims. This allows users to analyze the financial performance of claims processed.", "virtual_table": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers"}
{"sample_id": "train.897", "db_id": "insurance_fnol", "question": "What are all the customer phone numbers under the most popular policy type?", "rationale": ["Identify the relevant table, which is 'Available_Policies'.", "Select the column to display, 'Customer_Phone'.", "Add a condition to filter the 'policy_type_code' column based on a subquery that groups policy types and orders them by their count, using a placeholder for the limit to specify how many top policy types to consider."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "description": "The virtual table provides a list of customer phone numbers from the 'Available_Policies' table that are associated with the most popular policy type. The placeholder in the subquery represents the limit for selecting the most frequent policy type based on the count of occurrences.", "virtual_table": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.898", "db_id": "insurance_fnol", "question": "Find the phone numbers of customers using the most common policy type among the available policies.", "rationale": ["Identify the relevant table, which is 'Available_Policies'.", "Select the column to display, 'Customer_Phone'.", "Add a condition to filter the 'policy_type_code' column based on the most common policy type, using a subquery that groups and counts the policy types, ordering them by frequency and limiting the result with a placeholder for numeric values."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "description": "The virtual table provides the contact phone numbers of customers from the 'Available_Policies' table who are associated with the most common type of insurance policy. The placeholder in the subquery represents the limit for selecting the most frequent policy type.", "virtual_table": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.930", "db_id": "insurance_fnol", "question": "What is the ordered list of customer ids?", "rationale": ["Identify the relevant table, which is 'Customers'.", "Select the columns to display, 'Customer_ID' and 'Customer_name'.", "Add an ORDER BY clause to sort the results by 'Customer_ID' in ascending order."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers ORDER BY customer_id ASC", "source_tables": ["customers"], "description": "The virtual table contains the customer IDs and names from the 'Customers' table, sorted in ascending order by customer ID. This allows for an organized view of customer information based on their unique identifiers.", "virtual_table": "SELECT customer_id ,  customer_name FROM customers ORDER BY customer_id ASC"}
{"sample_id": "train.895", "db_id": "insurance_fnol", "question": "Which policy type has the most records in the database?", "rationale": ["Identify the relevant table, which is 'Available_Policies'.", "Select the column to display, 'policy_type_code'.", "Group the results by 'policy_type_code' to count occurrences.", "Order the results in descending order based on the count of records.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "description": "The virtual table summarizes the policy types from the 'Available_Policies' table, grouping them to count the number of records for each type. The placeholder in the LIMIT clause indicates the maximum number of policy types to return, allowing for the identification of the most frequently occurring policy type.", "virtual_table": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.893", "db_id": "insurance_fnol", "question": "What are the customer phone numbers under the policy \"Life Insurance\"?", "rationale": ["Identify the relevant table, which is 'Available_Policies'.", "Select the column to display, 'Customer_Phone'.", "Add a condition to filter the 'policy_type_code' column for the specified policy type using a placeholder for string values."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "description": "The virtual table contains the customer phone numbers from the 'Available_Policies' table that are associated with a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code being queried.", "virtual_table": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3861", "db_id": "insurance_policies", "question": "Give me the claim date, settlement date for all the claims whose claimed amount is larger than the average.", "rationale": ["Identify the relevant table, which is 'Claims'.", "Select the columns to display, 'Date_Claim_Made' and 'Date_Claim_Settled'.", "Add a condition to filter the 'Amount_Claimed' column to include only those claims that are greater than the average claimed amount, using a subquery to calculate the average."], "gold_sql": "SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )", "source_tables": ["claims"], "description": "The virtual table provides the claim and settlement dates for all claims from the 'Claims' table where the claimed amount exceeds the average claimed amount. The query uses a subquery to calculate the average of the 'Amount_Claimed' column, and the placeholder in the WHERE clause represents this average value.", "virtual_table": "SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )"}
{"sample_id": "train.3895", "db_id": "insurance_policies", "question": "Which claims had exactly one settlement? For each, tell me the the date the claim was made, the date it was settled and the amount settled.", "rationale": ["Identify the relevant tables, which are 'Claims' and 'Settlements'.", "Select the columns to display: 'claim_id', 'date_claim_made', and 'Date_Claim_Settled'.", "Join the 'Claims' table with the 'Settlements' table on the 'Claim_id' to link claims with their settlements.", "Group the results by 'claim_id' to aggregate the settlements for each claim.", "Add a condition in the HAVING clause to filter for claims that have exactly one settlement using a placeholder for numeric values."], "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"], "description": "The virtual table provides information about claims that have exactly one associated settlement. It includes the unique identifier for each claim, the date the claim was made, and the date it was settled. The placeholder in the HAVING clause indicates the specific number of settlements to filter the results.", "virtual_table": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3880", "db_id": "insurance_policies", "question": "With which kind of payment method were the least number of payments processed?", "rationale": ["Identify the relevant table, which is 'Payments'.", "Select the column to display, 'Payment_Method_Code'.", "Group the results by 'Payment_Method_Code' to aggregate the payment counts.", "Order the results by the count of payments in ascending order to find the least used method.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"], "description": "The virtual table summarizes the payment methods used in the 'Payments' table, grouping the records by the payment method code. It orders the results by the count of payments processed for each method in ascending order, allowing the identification of the payment method with the least number of transactions. The placeholder in the LIMIT clause indicates the number of results to return, which can be adjusted as needed.", "virtual_table": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3859", "db_id": "insurance_policies", "question": "Find the claimed amount in the claim with the least amount settled. Show both the settlement amount and claim amount.", "rationale": ["Identify the relevant table, which is 'Claims'.", "Select the columns to display, 'Amount_Settled' and 'Amount_Claimed'.", "Order the results by 'Amount_Settled' in ascending order to find the claim with the least settled amount.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT 1", "source_tables": ["claims"], "description": "The virtual table presents the claimed amounts from the 'Claims' table, specifically focusing on the claim that has the least amount settled. It includes both the total amount claimed in the claim and the total amount settled for that claim. The placeholder in the LIMIT clause indicates that the user can specify how many records to retrieve, which in this case is limited to the one with the least settled amount.", "virtual_table": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3886", "db_id": "insurance_policies", "question": "Which kind of policy type was chosen by the most customers?", "rationale": ["Identify the relevant table, which is 'Customer_Policies'.", "Select the column to display, 'Policy_Type_Code'.", "Group the results by 'Policy_Type_Code' to aggregate the data based on policy types.", "Order the results by the count of customers for each policy type in descending order to find the most chosen policy type.", "Add a limit to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "description": "The virtual table summarizes the different types of insurance policies selected by customers from the 'Customer_Policies' table. It groups the policies by their type code and orders them based on the number of customers who chose each type, allowing for the identification of the most popular policy type. The placeholder in the LIMIT clause indicates the maximum number of policy types to return.", "virtual_table": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3887", "db_id": "insurance_policies", "question": "Find the policy type the most customers choose.", "rationale": ["Identify the relevant table, which is 'Customer_Policies'.", "Select the column to display, 'Policy_Type_Code'.", "Group the results by 'Policy_Type_Code' to aggregate the data based on policy types.", "Order the results by the count of customers for each policy type in descending order to find the most chosen types.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "description": "The virtual table summarizes the policy types chosen by customers from the 'Customer_Policies' table. It groups the results by the policy type code and orders them by the number of customers selecting each type, allowing for the identification of the most popular policy types. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3857", "db_id": "insurance_policies", "question": "Find the settlement amount of the claim with the largest claim amount. Show both the settlement amount and claim amount.", "rationale": ["Identify the relevant table, which is 'Claims'.", "Select the columns to display, 'Amount_Settled' and 'Amount_Claimed'.", "Order the results by 'Amount_Claimed' in descending order to get the largest claim amount first.", "Limit the results to a specific number of records using a placeholder for numeric values."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"], "description": "The virtual table provides the settlement amount and the claim amount for claims in the 'Claims' table, specifically focusing on the claim with the highest amount claimed. The placeholder in the LIMIT clause indicates that the user can specify how many records to retrieve, which in this case is limited to the top claim based on the amount claimed.", "virtual_table": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3879", "db_id": "insurance_policies", "question": "Which payment method is used the most often?", "rationale": ["Identify the relevant table, which is 'Payments'.", "Select the column to display, 'Payment_Method_Code'.", "Group the results by 'Payment_Method_Code' to count occurrences.", "Order the results in descending order based on the count of each payment method.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "description": "The virtual table summarizes the payment methods used in the 'Payments' table, grouping them by their method codes. It orders the results by the frequency of each payment method, allowing users to identify the most commonly used method. The placeholder in the LIMIT clause indicates the number of top payment methods to retrieve.", "virtual_table": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3892", "db_id": "insurance_policies", "question": "List the details of the customers who do not have any policies.", "rationale": ["Identify the relevant table, which is 'Customers'.", "Select the column to display, 'customer_details'.", "Use an EXCEPT clause to filter out customers who have policies by joining 'Customers' with 'Customer_Policies' on 'customer_id' and excluding those results."], "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"], "description": "The virtual table provides a list of customer details from the 'Customers' table, specifically focusing on those customers who do not have any associated insurance policies. The query utilizes an EXCEPT clause to exclude customers who are linked to any records in the 'Customer_Policies' table, ensuring that only those without policies are included.", "virtual_table": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id"}
{"sample_id": "train.2262", "db_id": "machine_repair", "question": "What are the starting years shared by the technicians from the team \"CLE\" or \"CWS\"?", "rationale": ["Identify the relevant table, which is 'technician'.", "Select the column to display, 'Starting_Year'.", "Use the INTERSECT operator to find common starting years between the two specified teams, using placeholders for the team identifiers."], "gold_sql": "SELECT Starting_Year FROM technician WHERE Team  =  'CLE' INTERSECT SELECT Starting_Year FROM technician WHERE Team  =  'CWS'", "source_tables": ["technician"], "description": "The virtual table presents the starting years of technicians from the 'technician' table who belong to either the 'CLE' or 'CWS' teams. The placeholders in the WHERE clauses represent the team identifiers for filtering the results.", "virtual_table": "SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2258", "db_id": "machine_repair", "question": "What are the names of the technicians  and how many machines are they assigned to repair?", "rationale": ["Identify the relevant tables, which are 'repair_assignment' and 'technician'.", "Select the 'Name' column from the 'technician' table and count the number of assignments from the 'repair_assignment' table.", "Join the two tables on the technician ID to link technicians with their repair assignments.", "Group the results by technician names to aggregate the count of machines assigned to each technician."], "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name", "source_tables": ["repair_assignment", "technician"], "description": "The virtual table provides the names of technicians along with the count of machines they are assigned to repair. It combines data from the 'repair_assignment' and 'technician' tables, grouping the results by technician names to show how many machines each technician is responsible for.", "virtual_table": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name"}
{"sample_id": "train.2256", "db_id": "machine_repair", "question": "What are the names of the technicians that are assigned to repair machines with more point values than 70?", "rationale": ["Identify the relevant tables: 'repair_assignment', 'machine', and 'technician'.", "Join the tables based on their relationships: 'repair_assignment' links to 'machine' through 'machine_id' and to 'technician' through 'technician_id'.", "Select the 'Name' column from the 'technician' table to display the names of the technicians.", "Add a condition to filter the machines based on their 'value_points' using a placeholder for numeric values."], "gold_sql": "SELECT T3.Name FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID WHERE T2.value_points  >  70", "source_tables": ["machine", "repair_assignment", "technician"], "description": "The virtual table describes the names of technicians from the 'technician' table who are assigned to repair tasks for machines that have a value point greater than a specified threshold. The placeholders in the WHERE clause represent the numeric value for the machine's point value.", "virtual_table": "SELECT T3.Name FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID WHERE T2.value_points  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2248", "db_id": "machine_repair", "question": "What are the teams with the most technicians?", "rationale": ["Identify the relevant table, which is 'technician'.", "Select the 'Team' column to display the teams.", "Group the results by the 'Team' column to aggregate the count of technicians in each team.", "Order the results in descending order based on the count of technicians to find the teams with the most technicians.", "Add a limit to restrict the number of teams returned, using a placeholder for numeric values."], "gold_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["technician"], "description": "The virtual table summarizes the teams from the 'technician' table, grouping them by their identifiers. It orders the teams based on the count of technicians in each team, allowing for the identification of the teams with the highest number of technicians. The placeholder in the LIMIT clause represents the maximum number of teams to be displayed.", "virtual_table": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2244", "db_id": "machine_repair", "question": "What is the starting year for the oldest technician?", "rationale": ["Identify the relevant table, which is 'technician'.", "Select the column to display, 'Starting_Year'.", "Sort the results by the 'Age' column in descending order to find the oldest technician.", "Limit the results to one record using a placeholder for numeric values."], "gold_sql": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "source_tables": ["technician"], "description": "The virtual table provides the starting year of technicians from the 'technician' table, sorted by their age in descending order. The placeholder in the LIMIT clause indicates the number of records to return, which in this case is set to retrieve the oldest technician's starting year.", "virtual_table": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1092", "db_id": "match_season", "question": "Show the country names and the corresponding number of players.", "rationale": ["Identify the relevant tables, which are 'country' and 'match_season'.", "Select the 'Country_name' from the 'country' table and count the number of players from the 'match_season' table.", "Join the two tables on the country identifier to associate players with their respective countries.", "Group the results by 'Country_name' to aggregate the player counts for each country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "description": "The virtual table provides a summary of country names along with the count of players associated with each country. It combines data from the 'country' table and the 'match_season' table, linking them through the country identifier. The result is grouped by country name to show the total number of players representing each country.", "virtual_table": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name"}
{"sample_id": "train.1109", "db_id": "match_season", "question": "Return the colleges that have players who play the Midfielder position, as well as players who play the Defender position.", "rationale": ["Identify the relevant table, which is 'match_season'.", "Select the column to display, 'College'.", "Use the INTERSECT operation to combine results from two queries, each filtering for a specific player position using placeholders for string values."], "gold_sql": "SELECT College FROM match_season WHERE POSITION  =  'Midfielder' INTERSECT SELECT College FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "description": "The virtual table provides a list of colleges attended by players from the 'match_season' table who play either the Midfielder or Defender position. The query uses an INTERSECT operation to ensure that only colleges with players in both specified positions are included, with placeholders representing the positions being filtered.", "virtual_table": "SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1064", "db_id": "match_season", "question": "Show the draft pick numbers and draft classes of players whose positions are defenders.", "rationale": ["Identify the relevant table, which is 'match_season'.", "Select the columns to display, 'Draft_Pick_Number' and 'Draft_Class'.", "Add a condition to filter the 'Position' column for the specified position using a placeholder for string values."], "gold_sql": "SELECT Draft_Pick_Number ,  Draft_Class FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "description": "The virtual table provides information about the draft pick numbers and draft classes of players from the 'match_season' table who play in a specific position. The placeholder in the WHERE clause represents the position of the players.", "virtual_table": "SELECT Draft_Pick_Number ,  Draft_Class FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1093", "db_id": "match_season", "question": "How many players are from each country?", "rationale": ["Identify the relevant tables, which are 'country' and 'match_season'.", "Select the 'Country_name' from the 'country' table and count the number of players from the 'match_season' table.", "Join the two tables on the country identifier to link players to their respective countries.", "Group the results by 'Country_name' to get the count of players for each country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "description": "The virtual table summarizes the count of players associated with each country by joining the 'country' and 'match_season' tables. It displays the country names alongside the total number of players representing each country. The grouping is done based on the country names to aggregate the player counts accordingly.", "virtual_table": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name"}
{"sample_id": "train.1083", "db_id": "match_season", "question": "Who are the different players, what season do they play in, and what is the name of the team they are on?", "rationale": ["Identify the relevant tables, which are 'match_season' and 'team'.", "Select the columns to display: 'Season' and 'Player' from 'match_season', and 'Name' from 'team'.", "Join the 'match_season' table with the 'team' table on the 'Team' column to link players with their respective teams."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "description": "The virtual table provides information about players, the seasons they participate in, and the names of the teams they are associated with. It combines data from the 'match_season' table, which includes details about the season and player, with the 'team' table to retrieve the corresponding team names.", "virtual_table": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id"}
{"sample_id": "train.1080", "db_id": "match_season", "question": "How many distinct official languages are there among countries of players whose positions are defenders.", "rationale": ["Identify the relevant tables, which are 'country' and 'match_season'.", "Join the 'country' table with the 'match_season' table on the country identifier.", "Count the distinct values of the 'Official_native_language' column from the 'country' table.", "Add a condition to filter the 'Position' column in the 'match_season' table using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT T1.Official_native_language) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "description": "The virtual table counts the distinct official languages from the 'country' table for players in the 'match_season' table who play in a specific position. The placeholder in the WHERE clause represents the position of the players, specifically filtering for defenders.", "virtual_table": "SELECT count(DISTINCT T1.Official_native_language) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1082", "db_id": "match_season", "question": "Show the season, the player, and the name of the team that players belong to.", "rationale": ["Identify the relevant tables, which are 'match_season' and 'team'.", "Select the columns to display: 'Season' and 'Player' from 'match_season', and 'Name' from 'team'.", "Join the two tables on the 'Team' column from 'match_season' and 'Team_id' from 'team' to associate players with their teams."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "description": "The virtual table presents the season, player names, and their corresponding team names by joining the 'match_season' and 'team' tables. The placeholders represent the specific season and player details, allowing for dynamic queries based on user input.", "virtual_table": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id"}
{"sample_id": "train.1094", "db_id": "match_season", "question": "Return all players sorted by college in ascending alphabetical order.", "rationale": ["Identify the relevant table, which is 'match_season'.", "Select the column to display, which is 'player'.", "Add an ORDER BY clause to sort the results based on the 'College' column in ascending order."], "gold_sql": "SELECT player FROM match_season ORDER BY College ASC", "source_tables": ["match_season"], "description": "The virtual table lists the names of players from the 'match_season' table, sorted in ascending alphabetical order based on the college they attended. This allows for easy identification of players associated with different colleges.", "virtual_table": "SELECT player FROM match_season ORDER BY College ASC"}
{"sample_id": "train.2528", "db_id": "movie_1", "question": "What are the names of reviewers who had rated 3 star and 4 star?", "rationale": ["Identify the relevant tables, which are 'Rating' and 'Reviewer'.", "Select the column to display, which is 'name' from the 'Reviewer' table.", "Join the 'Rating' table with the 'Reviewer' table using the reviewer's identifier (rID).", "Add conditions to filter the ratings for 3 stars and 4 stars using placeholders for numeric values.", "Use the INTERSECT operator to ensure that only reviewers who rated both 3 stars and 4 stars are included."], "gold_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4", "source_tables": ["rating", "reviewer"], "description": "The virtual table presents the names of reviewers who have given ratings of 3 stars and 4 stars. It combines data from the 'Rating' and 'Reviewer' tables, using the reviewer's identifier to link the two tables. The placeholders in the query represent the star ratings being filtered.", "virtual_table": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2503", "db_id": "movie_1", "question": "For each director, what are the titles and ratings for all the movies they reviewed?", "rationale": ["Identify the relevant tables, which are 'Rating' and 'Movie'.", "Select the columns to display: 'title' from the 'Movie' table, 'stars' from the 'Rating' table, and 'director' from the 'Movie' table.", "Use a JOIN operation to link the 'Rating' and 'Movie' tables based on the movie identifier (mID).", "Add a condition to filter out a specific director using a placeholder for string values.", "Group the results by director to aggregate the maximum rating for each director's movies."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "description": "The virtual table provides a summary of movie titles, their directors, and the maximum ratings given by reviewers for each director. The placeholders in the WHERE clause allow for filtering out a specific director's movies, enabling users to focus on the ratings of other directors' films.", "virtual_table": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != [PLACEHOLDER-TYPE:STRING] GROUP BY director"}
{"sample_id": "train.2531", "db_id": "movie_1", "question": "What are the names of all movies that received 3 or 4 stars?", "rationale": ["Identify the relevant tables, which are 'Rating' and 'Movie'.", "Select the column to display, which is 'title' from the 'Movie' table.", "Join the 'Rating' table with the 'Movie' table on the movie identifier 'mID'.", "Add conditions to filter the 'stars' column for the specified star ratings using placeholders for numeric values.", "Use the INTERSECT operator to combine the results of two separate queries, each targeting a different star rating."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "source_tables": ["rating", "movie"], "description": "The virtual table presents the titles of movies from the 'Movie' table that have received ratings of either 3 or 4 stars. The query utilizes an intersection of two selections, each filtering the ratings based on the specified star values, represented by placeholders for numeric values.", "virtual_table": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2502", "db_id": "movie_1", "question": "For each director, return the director's name together with the title of the movie they directed that received the highest rating among all of their movies, and the value of that rating. Ignore movies whose director is NULL.", "rationale": ["Identify the relevant tables, which are 'Rating' and 'Movie'.", "Select the columns to display: 'title' from the 'Movie' table, 'stars' from the 'Rating' table, and 'director' from the 'Movie' table.", "Use a JOIN operation to connect the 'Rating' and 'Movie' tables based on the movie identifier (mID).", "Add a condition to exclude directors who are NULL.", "Group the results by director to find the maximum rating for each director's movies."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "description": "The virtual table provides a list of directors along with the titles of their highest-rated movies and the corresponding rating values. It filters out any movies directed by NULL directors and groups the results by each director to ensure that only the top-rated movie per director is displayed.", "virtual_table": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != [PLACEHOLDER-TYPE:STRING] GROUP BY director"}
{"sample_id": "train.2515", "db_id": "movie_1", "question": "What is the average rating for each movie that has never been reviewed by Brittany Harris?", "rationale": ["Identify the relevant tables, which are 'Rating' and 'Reviewer'.", "Select the column 'mID' and calculate the average of 'stars' for the ratings.", "Use a subquery to find all 'mID's that have been reviewed by the specified reviewer, filtering them out from the main query using the NOT IN clause.", "Group the results by 'mID' to get the average rating for each movie."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris') GROUP BY mID", "source_tables": ["rating", "reviewer"], "description": "The virtual table provides the average rating of movies from the 'Rating' table that have not been reviewed by a specific reviewer. It filters out movies based on the reviewer's name using a subquery, ensuring that only movies without reviews from that reviewer are included in the average calculation.", "virtual_table": "SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]) GROUP BY mID"}
{"sample_id": "train.2507", "db_id": "movie_1", "question": "For each director, what is the title and score of their most poorly rated movie?", "rationale": ["Identify the relevant tables, which are 'Movie' and 'Rating'.", "Select the columns to display: 'title' from the 'Movie' table and 'stars' from the 'Rating' table.", "Join the 'Rating' table with the 'Movie' table on the movie identifier 'mID'.", "Group the results by the 'director' to ensure we get one entry per director.", "Use the aggregate function 'min' to find the lowest star rating for each director's movies."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director", "source_tables": ["rating", "movie"], "description": "The virtual table provides the title and score of the most poorly rated movie for each director from the 'Movie' and 'Rating' tables. It aggregates the ratings by director and identifies the minimum star rating for their movies, using placeholders to represent the relevant data.", "virtual_table": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director"}
{"sample_id": "train.2514", "db_id": "movie_1", "question": "Find the average rating star for each movie that are not reviewed by Brittany Harris.", "rationale": ["Identify the relevant tables, which are 'Rating' and 'Reviewer'.", "Select the column 'mID' and calculate the average of 'stars' for the ratings.", "Use a subquery to find 'mID' values that have been reviewed by the specified reviewer, filtering them out from the main query using a NOT IN clause.", "Group the results by 'mID' to get the average rating for each movie."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris') GROUP BY mID", "source_tables": ["rating", "reviewer"], "description": "The virtual table summarizes the average star ratings for movies from the 'Rating' table that have not been reviewed by a specific reviewer. It filters out movies based on the reviewer's name using a subquery, ensuring that only those movies without reviews from the specified reviewer are included in the average calculation.", "virtual_table": "SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]) GROUP BY mID"}
{"sample_id": "train.2518", "db_id": "movie_1", "question": "Find the average rating star for each movie that received at least 2 ratings.", "rationale": ["Identify the relevant table, which is 'Rating'.", "Select the columns to display, 'mID' and the average of 'stars'.", "Group the results by 'mID' to calculate the average rating for each movie.", "Add a condition to filter the results to include only those movies that have received at least a specified number of ratings using a placeholder for numeric values."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2", "source_tables": ["rating"], "description": "The virtual table summarizes the average star ratings for movies from the 'Rating' table. It includes the movie identifier and the average rating, filtered to only include movies that have received a minimum number of ratings, as specified by a placeholder for numeric values.", "virtual_table": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2496", "db_id": "movie_1", "question": "Find the movies with the highest average rating. Return the movie titles and average rating.", "rationale": ["Identify the relevant tables, which are 'Movie' and 'Rating'.", "Select the 'title' from the 'Movie' table and calculate the average of 'stars' from the 'Rating' table.", "Join the 'Rating' table with the 'Movie' table on the movie identifier 'mID'.", "Group the results by 'mID' to ensure the average rating is calculated for each movie.", "Order the results by the average rating in descending order to get the highest rated movies first.", "Add a limit to the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT 1", "source_tables": ["rating", "movie"], "description": "The virtual table provides a list of movie titles along with their average ratings from the 'Movie' and 'Rating' tables. It calculates the average rating for each movie and sorts the results in descending order, allowing the user to specify a limit on the number of movies returned.", "virtual_table": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2483", "db_id": "movie_1", "question": "What are the names of all the reviewers and movie names?", "rationale": ["Identify the relevant tables, which are 'Reviewer' and 'Movie'.", "Select the column 'name' from the 'Reviewer' table and 'title' from the 'Movie' table.", "Use the UNION operator to combine the results from both tables into a single output, allowing for a comprehensive view of both reviewers and movies."], "gold_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "source_tables": ["movie", "reviewer"], "description": "The virtual table presents a combined list of reviewer names and movie titles from the 'Reviewer' and 'Movie' tables. The use of UNION allows for the merging of these two distinct sets of data into a single output, ensuring that both reviewer names and movie titles are included in the result.", "virtual_table": "SELECT name FROM Reviewer UNION SELECT title FROM Movie"}
{"sample_id": "train.2499", "db_id": "movie_1", "question": "What are the titles and average ratings for all movies that have the lowest average rating?", "rationale": ["Identify the relevant tables, which are 'Movie' and 'Rating'.", "Select the 'title' from the 'Movie' table and calculate the average of 'stars' from the 'Rating' table.", "Join the two tables on the movie identifier 'mID'.", "Group the results by 'mID' to calculate the average rating for each movie.", "Order the results by the average rating in ascending order to find the lowest ratings.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT 1", "source_tables": ["rating", "movie"], "description": "The virtual table summarizes the titles of movies along with their average ratings from the 'Movie' and 'Rating' tables. It calculates the average rating for each movie and orders the results to show those with the lowest average ratings, limited by a specified number of entries.", "virtual_table": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2497", "db_id": "movie_1", "question": "What are the movie titles with the highest average rating and what are those ratings?", "rationale": ["Identify the relevant tables, which are 'Movie' and 'Rating'.", "Select the 'title' from the 'Movie' table and calculate the average of 'stars' from the 'Rating' table.", "Join the 'Rating' table with the 'Movie' table on the movie identifier 'mID'.", "Group the results by 'mID' to calculate the average rating for each movie.", "Order the results by the average rating in descending order to get the highest ratings first.", "Use a placeholder in the LIMIT clause to specify how many top-rated movies to return."], "gold_sql": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT 1", "source_tables": ["rating", "movie"], "description": "The virtual table summarizes the titles of movies along with their average ratings from the 'Movie' and 'Rating' tables. It calculates the average rating for each movie and orders the results to show the movies with the highest average ratings first. The placeholder in the LIMIT clause allows for specifying the number of top-rated movies to retrieve.", "virtual_table": "SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2517", "db_id": "movie_1", "question": "What are the ids of all moviest hat have not been reviewed by Britanny Harris?", "rationale": ["Identify the relevant table, which is 'Rating', to find movie IDs.", "Use the EXCEPT clause to exclude movie IDs that have been reviewed by a specific reviewer.", "Join the 'Rating' table with the 'Reviewer' table to filter based on the reviewer's name using a placeholder for string values."], "gold_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris'", "source_tables": ["rating", "reviewer"], "description": "The virtual table lists the unique identifiers of movies from the 'Rating' table that have not received any reviews from a specific reviewer. The placeholder in the query represents the reviewer's name, allowing for dynamic filtering based on the reviewer's identity.", "virtual_table": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2508", "db_id": "movie_1", "question": "What is the name of the movie that is rated by most of times?", "rationale": ["Identify the relevant tables, which are 'Rating' and 'Movie'.", "Join the 'Rating' table with the 'Movie' table on the movie identifier to access movie titles.", "Group the results by the movie identifier to count the number of ratings for each movie.", "Order the results in descending order based on the count of ratings to find the most rated movies.", "Use a placeholder in the LIMIT clause to specify how many top-rated movies to return."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "description": "The virtual table provides the titles of movies from the 'Movie' table that have received the highest number of ratings. It joins the 'Rating' table to count the ratings for each movie, grouping the results by movie identifier. The placeholder in the LIMIT clause indicates the maximum number of movie titles to return.", "virtual_table": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2476", "db_id": "movie_1", "question": "Find the names of all reviewers who rated Gone with the Wind.", "rationale": ["Identify the relevant tables: 'Rating', 'Movie', and 'Reviewer'.", "Select the column to display, which is the 'name' of the reviewer, ensuring distinct names are retrieved.", "Join the 'Rating' table with the 'Movie' table on the movie ID, and then join the 'Reviewer' table on the reviewer ID.", "Add a condition to filter the 'title' column in the 'Movie' table for the specified movie using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  'Gone with the Wind'", "source_tables": ["rating", "movie", "reviewer"], "description": "The virtual table describes the distinct names of reviewers who have rated a specific movie from the 'Rating', 'Movie', and 'Reviewer' tables. The placeholders in the WHERE clause represent the title of the movie being queried.", "virtual_table": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2511", "db_id": "movie_1", "question": "What are the titles of all movies that have between 3 and 5 stars?", "rationale": ["Identify the relevant tables, which are 'Rating' and 'Movie'.", "Select the column to display, 'title' from the 'Movie' table.", "Join the 'Rating' table with the 'Movie' table on the movie identifier 'mID'.", "Add a condition to filter the 'stars' column for the specified range using placeholders for numeric values."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN 3 AND 5", "source_tables": ["rating", "movie"], "description": "The virtual table presents the titles of movies from the 'Movie' table that have received ratings between a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.", "virtual_table": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2460", "db_id": "movie_1", "question": "Find the names of all reviewers who have ratings with a NULL value for the date.", "rationale": ["Identify the relevant tables, which are 'Reviewer' and 'Rating'.", "Select the 'name' column from the 'Reviewer' table and ensure distinct values are returned.", "Join the 'Reviewer' table with the 'Rating' table on the reviewer ID to link ratings to reviewers.", "Add a condition to filter the 'ratingDate' column for NULL values using a placeholder for string values."], "gold_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  'null'", "source_tables": ["rating", "reviewer"], "description": "The virtual table contains the distinct names of reviewers from the 'Reviewer' table who have submitted ratings with a NULL value for the rating date. The placeholder in the WHERE clause is used to filter for ratings that do not have a specified date.", "virtual_table": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2434", "db_id": "movie_1", "question": "Find the titles of all movies directed by steven spielberg.", "rationale": ["Identify the relevant table, which is 'Movie'.", "Select the column to display, 'title'.", "Add a condition to filter the 'director' column for the specified director using a placeholder for string values."], "gold_sql": "SELECT title FROM Movie WHERE director = 'Steven Spielberg'", "source_tables": ["movie"], "description": "The virtual table contains the titles of movies from the 'Movie' table that are directed by a specific individual. The placeholder in the WHERE clause represents the name of the director.", "virtual_table": "SELECT title FROM Movie WHERE director = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3604", "db_id": "music_1", "question": "What is the shortest and most poorly rated song for each genre, ordered alphabetically by genre?", "rationale": ["Identify the relevant tables, which are 'files' and 'song'.", "Select the minimum duration from the 'files' table and the minimum rating from the 'song' table, along with the genre associated with each song.", "Join the 'files' table with the 'song' table on the file identifier to correlate song details with their respective audio files.", "Group the results by the genre to aggregate the minimum values for each genre.", "Order the final results alphabetically by genre name."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "description": "The virtual table summarizes the shortest duration and the lowest rating of songs from the 'song' table, grouped by their respective genres. It joins the 'files' table to access the duration of the songs and filters the results to show the minimum duration and rating for each genre. The results are ordered alphabetically by genre name.", "virtual_table": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["Identify the relevant tables, which are 'files' and 'song'.", "Select the minimum duration from the 'files' table and the minimum rating from the 'song' table.", "Join the two tables on the file identifier to correlate songs with their respective files.", "Group the results by the genre of the songs to aggregate the data accordingly.", "Order the final results by genre to present the data in a structured manner."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "description": "The virtual table summarizes the shortest duration and lowest rating of songs from the 'song' table, grouped by genre. It combines data from the 'files' table to obtain the duration of each song and filters the results based on the genre. The results are ordered by genre for better organization.", "virtual_table": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["Identify the relevant tables, which are 'files' and 'song'.", "Select the columns to display: 'duration', 'file_size', and 'formats' from the 'files' table.", "Join the 'files' table with the 'song' table on the file identifier 'f_id'.", "Add a condition to filter the songs by the specified genre using a placeholder for string values.", "Order the results by the song title in alphabetical order."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "description": "The virtual table provides the duration, file size, and formats of audio files associated with songs from the 'files' and 'song' tables. It specifically filters for songs belonging to a particular genre, represented by a placeholder, and orders the results alphabetically by the song title.", "virtual_table": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T2.song_name"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["Identify the relevant tables, which are 'files' and 'song'.", "Select the maximum values for 'duration' and 'resolution' from the respective tables.", "Join the 'files' table with the 'song' table on the file identifier 'f_id'.", "Group the results by the 'languages' column from the 'song' table.", "Order the results by the 'languages' column to ensure a sorted output."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "description": "The virtual table provides the maximum duration and resolution of songs from the 'files' and 'song' tables, grouped by the languages in which the songs are available. The placeholders in the query allow for dynamic grouping and ordering based on the specified languages.", "virtual_table": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages"}
{"sample_id": "train.3587", "db_id": "music_1", "question": "What is the language that was used most often in songs with resolution above 500?", "rationale": ["Identify the relevant table, which is 'song'.", "Select the column to display, 'artist_name'.", "Add a condition to filter the 'resolution' column for values above a specified threshold using a placeholder for numeric values.", "Group the results by the 'languages' column to aggregate the data based on language usage.", "Order the results by the count of occurrences in descending order to find the most frequent language.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT artist_name FROM song WHERE resolution  >  500 GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "description": "The virtual table summarizes the artist names from the 'song' table, filtered by a specified audio resolution threshold. It groups the results by the languages in which the songs are available and orders them by the frequency of occurrence, allowing users to identify the most commonly used language in songs that meet the resolution criteria. The placeholders represent the resolution limit and the number of results to return.", "virtual_table": "SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3620", "db_id": "music_1", "question": "What are the top 3 artists with the largest number of songs in the language Bangla?", "rationale": ["Identify the relevant tables, which are 'artist' and 'song'.", "Join the 'artist' table with the 'song' table on the artist's name to correlate artists with their songs.", "Filter the results based on the specified language using a placeholder for string values.", "Group the results by artist name to count the number of songs per artist.", "Order the results by the count of songs in descending order to find the top artists.", "Limit the results to the top specified number of artists."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "description": "The virtual table lists the names of artists from the 'artist' table who have performed songs in a specific language. It joins the 'artist' and 'song' tables based on the artist's name, filtering the results to include only those songs that are available in the specified language. The results are grouped by artist name and ordered by the count of songs in descending order, with a limit on the number of artists returned.", "virtual_table": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3588", "db_id": "music_1", "question": "What is the name of the artist, for each language, that has the most songs with a higher resolution than 500?", "rationale": ["Identify the relevant table, which is 'song'.", "Select the column to display, 'artist_name'.", "Add a condition to filter the 'resolution' column for songs with a resolution greater than a specified number using a placeholder for numeric values.", "Group the results by 'languages' to get the count of songs per language.", "Order the results by the count of songs in descending order to find the artist with the most songs.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT artist_name FROM song WHERE resolution  >  500 GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "description": "The virtual table provides the names of artists from the 'song' table who have the most songs available in various languages, specifically those songs that have a resolution higher than a specified value. The placeholders in the WHERE clause and LIMIT allow for dynamic input of the resolution threshold and the number of results to return.", "virtual_table": "SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3569", "db_id": "music_1", "question": "Find the distinct names of all songs that have a higher resolution than some songs in English.", "rationale": ["Identify the relevant table, which is 'song'.", "Select the column to display, 'song_name', ensuring distinct values are returned.", "Add a condition to filter songs based on their resolution compared to the minimum resolution of songs in a specified language using a placeholder for string values."], "gold_sql": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  'english')", "source_tables": ["song"], "description": "The virtual table provides a list of distinct song names from the 'song' table that have a higher audio resolution than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the comparison is made.", "virtual_table": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.3575", "db_id": "music_1", "question": "List the name and gender for all artists who released songs in March.", "rationale": ["Identify the relevant tables, which are 'artist' and 'song'.", "Select the columns to display, 'artist_name' and 'gender' from the 'artist' table.", "Join the 'artist' table with the 'song' table on the 'artist_name' column to associate artists with their songs.", "Add a condition to filter the 'releasedate' column in the 'song' table to match the specified month using a placeholder for string values."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "description": "The virtual table provides the names and genders of artists from the 'artist' table who have released songs in a specific month. The placeholder in the WHERE clause is used to filter the release date of the songs based on the specified month.", "virtual_table": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3570", "db_id": "music_1", "question": "What are the different names for all songs that have a higher resolution than English songs?", "rationale": ["Identify the relevant table, which is 'song'.", "Select the distinct column 'song_name' to ensure unique song titles are returned.", "Add a condition to filter songs based on their resolution compared to the minimum resolution of songs in a specified language using a subquery with a placeholder for string values."], "gold_sql": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  'english')", "source_tables": ["song"], "description": "The virtual table presents the distinct names of songs from the 'song' table that have a higher audio resolution than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the resolution is being compared.", "virtual_table": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["Identify the relevant table, which is 'files'.", "Select the 'formats' column to display the file formats.", "Group the results by the 'formats' column to aggregate the data.", "Order the results by the count of files for each format in descending order to find the most used format.", "Add a limit to specify how many top formats to return using a placeholder for numeric values."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "description": "The virtual table summarizes the file formats available in the 'files' table, grouped by format type. It orders the results by the count of files associated with each format in descending order, allowing the user to identify the most commonly used file format. The placeholder in the LIMIT clause indicates the number of top formats to retrieve.", "virtual_table": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3551", "db_id": "music_1", "question": "What is the most popular file format?", "rationale": ["Identify the relevant table, which is 'files'.", "Select the 'formats' column to display the available file formats.", "Group the results by 'formats' to count occurrences of each format.", "Order the results in descending order based on the count of each format to find the most popular one.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "description": "The virtual table summarizes the different file formats available in the 'files' table, grouping them to identify the most popular format based on the count of occurrences. The placeholder in the LIMIT clause allows for specifying the number of top formats to retrieve.", "virtual_table": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["Identify the relevant tables, which are 'song' and 'files'.", "Select the column to display, 'artist_name' from the 'song' table.", "Join the 'song' table with the 'files' table on the file identifier 'f_id' to access the duration of the songs.", "Order the results by the duration of the songs in ascending order to find the shortest songs.", "Use a placeholder in the LIMIT clause to specify how many artist names to return."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "description": "The virtual table provides the names of artists from the 'song' table who performed the shortest songs, by joining with the 'files' table to access the duration of each song. The placeholder in the LIMIT clause allows for specifying the number of results to return.", "virtual_table": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
