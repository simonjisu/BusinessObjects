{"sample_id": "train.3530", "db_id": "music_1", "question": "What is the name of the song that was released most recently?", "rationale": ["Identify the relevant table, which is 'song'.", "Select the columns to display, 'song_name' and 'releasedate'.", "Order the results by 'releasedate' in descending order to get the most recent songs.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT song_name ,  releasedate FROM song ORDER BY releasedate DESC LIMIT 1", "source_tables": ["song"], "description": "The virtual table provides the title of songs along with their release dates from the 'song' table, ordered by the release date in descending order. The placeholder in the LIMIT clause indicates the number of most recent songs to retrieve.", "virtual_table": "SELECT song_name ,  releasedate FROM song ORDER BY releasedate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["Identify the relevant tables, which are 'artist' and 'song'.", "Select the 'country' column from the 'artist' table.", "Join the 'artist' table with the 'song' table on the 'artist_name' column to link artists with their songs.", "Add conditions to filter the results based on the specified gender and language using placeholders for string values."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "description": "The virtual table provides information about the countries of female artists who have performed songs in a specific language. It combines data from the 'artist' table, which includes details about the artist's gender and country, with the 'song' table, which contains information about the languages in which the songs are available. The placeholders in the WHERE clause allow for filtering by gender and language.", "virtual_table": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING] AND T2.languages  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3541", "db_id": "music_1", "question": "What is the name of the artist who produced the shortest song?", "rationale": ["Identify the relevant tables, which are 'song' and 'files'.", "Join the two tables on the file identifier 'f_id' to access both song and file details.", "Select the 'artist_name' from the 'song' table.", "Order the results by the 'duration' from the 'files' table to find the shortest song.", "Use a placeholder to limit the results to the top entry."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "description": "The virtual table identifies the artist associated with the shortest song by joining the 'song' and 'files' tables. It selects the artist's name and orders the results based on the duration of the songs, using a placeholder to limit the number of results returned.", "virtual_table": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3546", "db_id": "music_1", "question": "What is the count of the songs that last approximately 4 minutes?", "rationale": ["Identify the relevant table, which is 'files'.", "Select the count of all entries in the table.", "Add a condition to filter the 'duration' column for songs that last approximately 4 minutes using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "description": "The virtual table provides a count of audio files from the 'files' table that have a duration matching a specific pattern. The placeholder in the WHERE clause allows for filtering based on the duration of the songs, which is expressed as a string.", "virtual_table": "SELECT count(*) FROM files WHERE duration LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3531", "db_id": "music_1", "question": "What is the id of the longest song?", "rationale": ["Identify the relevant table, which is 'files'.", "Select the column to display, 'f_id', which is the unique identifier for the file.", "Order the results by the 'duration' column in descending order to find the longest song.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "description": "The virtual table provides the unique identifier for audio files from the 'files' table, specifically focusing on the longest song by ordering the results based on the duration of the songs in descending order. The placeholder in the LIMIT clause indicates the number of results to return, which can be adjusted as needed.", "virtual_table": "SELECT f_id FROM files ORDER BY duration DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["Identify the relevant table, which is 'song'.", "Select the column to display, 'languages'.", "Group the results by 'languages' to count occurrences.", "Order the results in descending order based on the count of occurrences.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "description": "The virtual table summarizes the languages used in songs from the 'song' table, grouping them to identify the most frequently occurring languages. The placeholder in the LIMIT clause allows for specifying the number of top languages to retrieve based on their occurrence count.", "virtual_table": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["Identify the relevant tables, which are 'artist' and 'song'.", "Select the 'country' column from the 'artist' table.", "Join the 'artist' table with the 'song' table on the 'artist_name' column to link artists with their songs.", "Add conditions to filter the 'gender' column for female artists and the 'languages' column for the specified language using placeholders for string values."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "description": "The virtual table describes the country of origin of female artists from the 'artist' table who have produced songs in a specific language. The placeholders in the WHERE clause represent the gender of the artist and the language of the song.", "virtual_table": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING] AND T2.languages  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["Identify the relevant tables, which are 'artist' and 'song'.", "Select the columns to display, 'gender' and 'artist_name' from the 'artist' table.", "Join the 'artist' table with the 'song' table on the 'artist_name' column to associate artists with their songs.", "Order the results by the 'resolution' column from the 'song' table to find the song with the smallest resolution.", "Limit the results to a single entry using a placeholder for numeric values."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "description": "The virtual table describes the gender and name of artists from the 'artist' table who performed songs from the 'song' table. The results are ordered by the resolution of the songs, allowing the user to retrieve the artist associated with the song that has the smallest resolution, as indicated by the placeholder for limiting the number of results.", "virtual_table": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["Identify the relevant table, which is 'files'.", "Select the count of records to display the total number of songs.", "Add a condition to filter the 'duration' column for the specified duration using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "description": "The virtual table provides a count of audio files from the 'files' table that match a specific duration. The placeholder in the WHERE clause represents the duration of the audio files being queried.", "virtual_table": "SELECT count(*) FROM files WHERE duration LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6191", "db_id": "music_4", "question": "Show the famous titles of the artists with both volumes that lasted more than 2 weeks on top and volumes that lasted less than 2 weeks on top.", "rationale": ["Identify the relevant tables, which are 'artist' and 'volume'.", "Select the column to display, 'Famous_Title', from the 'artist' table.", "Join the 'artist' table with the 'volume' table using the 'Artist_ID' to link them.", "Add conditions to filter the results based on the number of weeks the songs stayed at the top, using placeholders for numeric values.", "Use the INTERSECT operator to find titles that meet both conditions."], "gold_sql": "SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  >  2 INTERSECT SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  <  2", "source_tables": ["artist", "volume"], "description": "The virtual table presents the famous titles of artists from the 'artist' table who have achieved recognition in both categories: those whose songs have spent more than a specified number of weeks at the top and those whose songs have spent less than a specified number of weeks at the top. The placeholders in the query represent the numeric values for the weeks on top.", "virtual_table": "SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6156", "db_id": "music_4", "question": "Return the categories of music festivals that have the result \"Awarded\".", "rationale": ["Identify the relevant table, which is 'music_festival'.", "Select the column to display, 'Category'.", "Add a condition to filter the 'Result' column for the specified outcome using a placeholder for string values."], "gold_sql": "SELECT Category FROM music_festival WHERE RESULT  =  'Awarded'", "source_tables": ["music_festival"], "description": "The virtual table provides a list of categories from the 'music_festival' table where the outcome of the festival participation is specified as awarded. The placeholder in the WHERE clause represents the result status of the festival.", "virtual_table": "SELECT Category FROM music_festival WHERE RESULT  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6167", "db_id": "music_4", "question": "Please show the songs that have result \"nominated\" at music festivals.", "rationale": ["Identify the relevant tables, which are 'music_festival' and 'volume'.", "Select the 'Song' column from the 'volume' table.", "Join the 'music_festival' table with the 'volume' table using the volume identifier.", "Add a condition to filter the results based on the specified result status using a placeholder for string values."], "gold_sql": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  'Nominated'", "source_tables": ["music_festival", "volume"], "description": "The virtual table displays the songs that have received a 'nominated' result at music festivals. It combines data from the 'music_festival' and 'volume' tables, linking them through the volume identifier. The placeholder in the WHERE clause represents the specific result status being queried.", "virtual_table": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6195", "db_id": "music_4", "question": "What is the issue date of the volume with the minimum weeks on top?", "rationale": ["Identify the relevant table, which is 'volume'.", "Select the column to display, 'Issue_Date'.", "Order the results by 'Weeks_on_Top' in ascending order to find the volume with the minimum weeks on top.", "Limit the results to one record using a placeholder for numeric values."], "gold_sql": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1", "source_tables": ["volume"], "description": "The virtual table provides the issue date of the volume from the 'volume' table that has the least number of weeks at the top of the charts. The placeholder in the LIMIT clause indicates the number of records to return, which is set to one in this case.", "virtual_table": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6187", "db_id": "music_4", "question": "What is the song in the volume with the maximum weeks on top?", "rationale": ["Identify the relevant table, which is 'volume'.", "Select the 'Song' column to display the song identifiers.", "Order the results by 'Weeks_on_Top' in descending order to prioritize songs with the most weeks at the top.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "source_tables": ["volume"], "description": "The virtual table contains the song identifiers from the 'volume' table, ordered by the number of weeks each song has spent at the top of the charts. The placeholder in the LIMIT clause indicates the maximum number of results to return, which is determined by the user.", "virtual_table": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6180", "db_id": "music_4", "question": "Return the famous release date for the oldest artist.", "rationale": ["Identify the relevant table, which is 'artist'.", "Select the column to display, 'Famous_Release_date'.", "Order the results by the 'Age' column in descending order to find the oldest artist.", "Limit the results to one entry using a placeholder for numeric values."], "gold_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1", "source_tables": ["artist"], "description": "The virtual table provides the famous release date of artists from the 'artist' table, specifically focusing on the oldest artist. The query orders the artists by age in descending order and limits the result to the oldest artist using a numeric placeholder.", "virtual_table": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4445", "db_id": "network_2", "question": "What are the names of every person who has a friend over 40 and under 30?", "rationale": ["Identify the relevant tables, which are 'Person' and 'PersonFriend'.", "Select the column to display, which is 'name' from the 'Person' table.", "Join the 'Person' table with the 'PersonFriend' table on the name column to link individuals with their friends.", "Use subqueries to filter friends based on the specified age conditions, one for friends over a certain age and another for friends under a certain age.", "Utilize the INTERSECT operator to find names that meet both conditions."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "description": "The virtual table identifies the names of individuals from the 'Person' table who have friends that fall into two specific age categories: those over a certain age and those under a certain age. The query utilizes a join between the 'Person' and 'PersonFriend' tables to establish the relationship between individuals and their friends, and it employs subqueries to filter friends based on the specified age criteria.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4443", "db_id": "network_2", "question": "What are the different names and ages of every friend of either Dan or alice?", "rationale": ["Identify the relevant tables, which are 'Person' and 'PersonFriend'.", "Select the columns to display, 'name' and 'age', ensuring they are distinct.", "Join the 'Person' table with the 'PersonFriend' table on the name column to associate friends with their respective individuals.", "Add a condition to filter the 'friend' column for the specified individuals using placeholders for string values."], "gold_sql": "SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' OR T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "description": "The virtual table presents the distinct names and ages of friends associated with specific individuals from the 'Person' table. It combines data from both the 'Person' and 'PersonFriend' tables, filtering for friends of the specified individuals. The placeholders in the WHERE clause represent the names of the individuals whose friends are being queried.", "virtual_table": "SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] OR T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4480", "db_id": "network_2", "question": "What is the total number of people who has no friend living in the city of Austin.", "rationale": ["Identify the relevant table, which is 'PersonFriend'.", "Count the distinct names to find the total number of people without friends in the specified city.", "Add a condition to filter out friends based on their city of residence using a subquery and a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "description": "The virtual table provides a count of distinct individuals from the 'PersonFriend' table who do not have any friends residing in a specified city. The placeholder in the WHERE clause represents the name of the city to filter the results accordingly.", "virtual_table": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4478", "db_id": "network_2", "question": "Which person whose friends have the oldest average age?", "rationale": ["Identify the relevant tables, which are 'Person' and 'PersonFriend'.", "Select the column 'name' from 'PersonFriend' and calculate the average age from 'Person'.", "Join the two tables on the condition that the friend's name in 'PersonFriend' matches the name in 'Person'.", "Group the results by the person's name to calculate the average age of their friends.", "Order the results by the average age in descending order to find the person with the oldest average age of friends.", "Add a limit to the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT 1", "source_tables": ["personfriend", "person"], "description": "The virtual table summarizes the names of individuals from the 'Person' table along with the average age of their friends. It combines data from the 'Person' and 'PersonFriend' tables, grouping the results by each person's name and ordering them by the average age of their friends in descending order. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4444", "db_id": "network_2", "question": "Find the name of the person who has friends with age above 40 and under age 30?", "rationale": ["Identify the relevant tables, which are 'Person' and 'PersonFriend'.", "Select the column to display, which is 'name' from the 'Person' table.", "Join the 'Person' table with the 'PersonFriend' table on the name column to relate individuals with their friends.", "Use subqueries to filter friends based on age criteria, with placeholders for the specific age values."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "description": "The virtual table describes the names of individuals from the 'Person' table who have friends that fall within two specific age ranges: those older than a certain age and those younger than another age. The placeholders in the query represent the age limits for filtering friends' ages.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4467", "db_id": "network_2", "question": "Whare the names, friends, and ages of all people who are older than the average age of a person?", "rationale": ["Identify the relevant tables, which are 'Person' and 'PersonFriend'.", "Select the columns to display: 'name' and 'friend' from 'PersonFriend', and 'age' from 'Person'.", "Join the two tables on the condition that the name in 'Person' matches the friend in 'PersonFriend'.", "Add a condition to filter the results where the age from 'Person' is greater than the average age calculated from the 'Person' table."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "description": "The virtual table provides a list of distinct names, friends, and ages of individuals from the 'Person' and 'PersonFriend' tables. It specifically filters for those individuals whose age exceeds the average age of all persons in the database. The placeholders in the query represent the necessary conditions and values for the age comparison.", "virtual_table": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)"}
{"sample_id": "train.4475", "db_id": "network_2", "question": "What are the names, ages, and jobs of all people who are friends with Alice for the longest amount of time?", "rationale": ["Identify the relevant tables, which are 'Person' and 'PersonFriend'.", "Select the columns to display: 'name', 'age', and 'job' from the 'Person' table.", "Join the 'Person' table with the 'PersonFriend' table on the person's name.", "Add a condition to filter the 'friend' column for the specified friend using a placeholder for string values.", "Use a subquery to find the maximum year of friendship for the specified friend, ensuring we only get the longest friendships."], "gold_sql": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend", "person"], "description": "The virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a friendship with a specified person for the longest duration. The query joins the 'Person' and 'PersonFriend' tables based on the person's name and filters the results to include only those friends of the specified individual, while also determining the maximum year of friendship established.", "virtual_table": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4481", "db_id": "network_2", "question": "What is the total number of people who have no friends living in Austin?", "rationale": ["Identify the relevant tables, which are 'PersonFriend' and 'Person'.", "Use the count function to determine the total number of distinct names from 'PersonFriend'.", "Add a condition to filter out friends based on the city specified using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "description": "The virtual table provides a count of distinct individuals from the 'PersonFriend' table who do not have any friends listed in the 'Person' table and reside in a specific city. The placeholder in the WHERE clause represents the name of the city.", "virtual_table": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4469", "db_id": "network_2", "question": "Which friend of Zach has the longest-lasting friendship?", "rationale": ["Identify the relevant table, which is 'PersonFriend'.", "Select the column to display, 'friend'.", "Add a condition to filter the 'name' column for the specified person using a placeholder for string values.", "Incorporate a subquery to find the maximum year of friendship for the specified person, ensuring we identify the longest-lasting friendship."], "gold_sql": "SELECT friend FROM PersonFriend WHERE name =  'Zach' AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  'Zach')", "source_tables": ["personfriend"], "description": "The virtual table provides the names of friends from the 'PersonFriend' table for a specific person, along with a condition to find the friend with the longest-lasting friendship. The placeholder in the WHERE clause represents the person's name, and the subquery identifies the maximum year of friendship established.", "virtual_table": "SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4410", "db_id": "network_2", "question": "Who is the oldest person whose job is student?", "rationale": ["Identify the relevant table, which is 'Person'.", "Select the column to display, 'name'.", "Add conditions to filter the 'job' column for the specified job title using a placeholder for string values.", "Incorporate a subquery to find the maximum age of individuals with the specified job title, ensuring that the outer query only returns the name of the oldest student."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "description": "The virtual table provides the names of individuals from the 'Person' table who are identified as students and are the oldest among that group. The query includes a condition to filter by job title and a subquery to determine the maximum age of individuals with that job title, using placeholders for the job title.", "virtual_table": "SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4411", "db_id": "network_2", "question": "What is the name of the oldest student?", "rationale": ["Identify the relevant table, which is 'Person'.", "Select the column to display, 'name'.", "Add a condition to filter the 'job' column for the specified job title using a placeholder for string values.", "Incorporate a subquery to find the maximum age for individuals with the specified job title, ensuring that the main query only returns the oldest individual(s)."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "description": "The virtual table provides the names of individuals from the 'Person' table who hold a specific job title and are the oldest among those with the same job. The query includes a subquery that determines the maximum age for the specified job title, ensuring that only the oldest individual(s) are selected.", "virtual_table": "SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4473", "db_id": "network_2", "question": "What are the names of all people who are friends with Alice for the shortest amount of time?", "rationale": ["Identify the relevant table, which is 'PersonFriend'.", "Select the column to display, 'name', which represents the names of people who are friends.", "Add a condition to filter the 'friend' column for the specified friend's name using a placeholder for string values.", "Incorporate a subquery to find the minimum year of friendship for the specified friend, ensuring that only the shortest friendships are included."], "gold_sql": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend"], "description": "The virtual table provides the names of individuals who are friends with a specified person, filtered to show only those friendships that have lasted for the shortest duration. The query utilizes a placeholder for the friend's name and another placeholder to determine the minimum year of friendship established.", "virtual_table": "SELECT name FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4455", "db_id": "network_2", "question": "What are the names of all of Bob's friends?", "rationale": ["Identify the relevant tables, which are 'Person' and 'PersonFriend'.", "Select the column to display, which is 'name' from the 'Person' table.", "Join the 'Person' table with the 'PersonFriend' table on the name column to link friends with their respective persons.", "Add a condition to filter the 'friend' column for the specified person's name using a placeholder for string values."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "description": "The virtual table describes the names of individuals from the 'Person' table who are friends of a specific person. The join operation connects the 'Person' table with the 'PersonFriend' table based on the person's name, and the placeholder in the WHERE clause represents the name of the person whose friends are being queried.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4454", "db_id": "network_2", "question": "Find the name of persons who are friends with Bob.", "rationale": ["Identify the relevant tables, which are 'Person' and 'PersonFriend'.", "Select the column to display, 'name' from the 'Person' table.", "Join the 'Person' table with the 'PersonFriend' table on the name column to establish the relationship between persons and their friends.", "Add a condition to filter the 'friend' column for the specified friend's name using a placeholder for string values."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "description": "The virtual table describes the names of persons from the 'Person' table who are friends with a specific individual. The placeholder in the WHERE clause represents the name of the friend being queried.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2072", "db_id": "party_people", "question": "How many events are there for each party?", "rationale": ["Identify the relevant tables, which are 'party_events' and 'party'.", "Join the 'party_events' table with the 'party' table using the party identifier to associate events with their respective parties.", "Select the 'party_name' from the 'party' table and count the number of events from the 'party_events' table.", "Group the results by the party identifier to get the count of events for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "description": "The virtual table summarizes the count of events organized by each political party. It combines data from the 'party_events' table, which records the events, and the 'party' table, which contains information about the political parties. The result includes the party names along with the total number of events associated with each party, grouped by the party identifier.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2057", "db_id": "party_people", "question": "Show all party names and the number of members in each party.", "rationale": ["Identify the relevant tables, which are 'Member' and 'party'.", "Select the 'party_name' from the 'party' table and count the number of members from the 'Member' table.", "Join the 'Member' table with the 'party' table using the party identifier to associate members with their respective parties.", "Group the results by the party identifier to aggregate the member count for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "description": "The virtual table presents the names of political parties along with the count of their respective members. It combines data from the 'Member' and 'party' tables, linking them through the party identifier. The result is grouped by each party to provide a total count of members associated with each party name.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2082", "db_id": "party_people", "question": "Count the number of Annual Meeting events that took place in the region of the United Kingdom.", "rationale": ["Identify the relevant tables: 'region', 'party', and 'party_events'.", "Join the 'region' table with the 'party' table on the 'Region_ID' to associate parties with their respective regions.", "Join the resulting table with the 'party_events' table on the 'Party_ID' to link events to the parties.", "Use the COUNT function to count the number of events that match the specified criteria.", "Add conditions to filter the results based on the region's name and the event's name using placeholders for string values."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "description": "The virtual table counts the total number of Annual Meeting events organized by political parties in a specified region. It combines data from the 'region', 'party', and 'party_events' tables, filtering based on the region's name and the event's name using placeholders for both values.", "virtual_table": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2049", "db_id": "party_people", "question": "Show all ministers who do not belong to Progress Party.", "rationale": ["Identify the relevant table, which is 'party'.", "Select the column to display, 'minister'.", "Add a condition to filter out the ministers belonging to the specified party using a placeholder for string values."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "description": "The virtual table presents the identifiers of ministers from the 'party' table who are not associated with a specific political party. The placeholder in the WHERE clause allows for the specification of the party name to exclude from the results.", "virtual_table": "SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.315", "db_id": "product_catalog", "question": "What are the entry names of catalog with the attribute possessed by most entries.", "rationale": ["Identify the relevant tables, which are 'Catalog_Contents' and 'Catalog_Contents_Additional_Attributes'.", "Select the column 'catalog_entry_name' from 'Catalog_Contents'.", "Join 'Catalog_Contents' with 'Catalog_Contents_Additional_Attributes' on 'catalog_entry_id' to link entries with their attributes.", "Use a subquery to find the most common 'attribute_value' by grouping and counting entries, ordering them in descending order.", "Add a condition to filter the results based on the most common attribute value, with a placeholder for limiting the number of results."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "description": "The virtual table provides the names of catalog entries from the 'Catalog_Contents' table that are associated with the attribute that is possessed by the most entries. The query uses a subquery to determine the most common attribute value based on the count of entries, with a placeholder for limiting the results to a specific number.", "virtual_table": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.316", "db_id": "product_catalog", "question": "Find the entry names of the catalog with the attribute that have the most entries.", "rationale": ["Identify the relevant tables, which are 'Catalog_Contents' and 'Catalog_Contents_Additional_Attributes'.", "Select the column to display, 'catalog_entry_name', from 'Catalog_Contents'.", "Join 'Catalog_Contents' with 'Catalog_Contents_Additional_Attributes' on 'catalog_entry_id' to link entries with their attributes.", "Use a subquery to find the attribute value that has the most entries by grouping and counting occurrences, ordering them in descending order, and limiting the results with a placeholder for numeric values."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "description": "The virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with the attribute having the highest number of entries. The query utilizes a join between 'Catalog_Contents' and 'Catalog_Contents_Additional_Attributes' to filter entries based on the most frequent attribute value, with a placeholder for the limit on the number of entries to consider.", "virtual_table": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.332", "db_id": "product_catalog", "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.", "rationale": ["Identify the relevant table, which is 'Catalog_Contents'.", "Select the column to display, 'catalog_entry_name'.", "Add conditions to filter the entries based on the length and width measurements using placeholders for numeric values."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "description": "The virtual table presents the names of catalog entries from the 'Catalog_Contents' table that have a length measurement below a specified value or above another specified value. The placeholders in the WHERE clause represent the numeric thresholds for length and width.", "virtual_table": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  [PLACEHOLDER-TYPE:NUMBER] OR width  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.331", "db_id": "product_catalog", "question": "Find the names of the products with length smaller than 3 or height greater than 5.", "rationale": ["Identify the relevant table, which is 'Catalog_Contents'.", "Select the column to display, 'catalog_entry_name'.", "Add conditions to filter the entries based on the 'length' and 'height' columns using placeholders for numeric values."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "description": "The virtual table presents the names of products from the 'Catalog_Contents' table that meet specific dimensional criteria. The placeholders in the WHERE clause allow for the input of numeric values to filter products based on their length and height measurements.", "virtual_table": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  [PLACEHOLDER-TYPE:NUMBER] OR width  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.311", "db_id": "product_catalog", "question": "Which catalog publisher has published the most catalogs?", "rationale": ["Identify the relevant table, which is 'Catalogs'.", "Select the 'catalog_publisher' column to display the names of the publishers.", "Group the results by 'catalog_publisher' to count the number of catalogs each has published.", "Order the results by the count of catalogs in descending order to find the publisher with the most catalogs.", "Add a limit to restrict the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT 1", "source_tables": ["catalogs"], "description": "The virtual table summarizes the catalog publishers from the 'Catalogs' table, grouping them by the publisher's name and counting the number of catalogs each has published. The result is ordered in descending order to identify the publisher with the highest count, with a placeholder to limit the number of results returned.", "virtual_table": "SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.317", "db_id": "product_catalog", "question": "What is the entry name of the most expensive catalog (in USD)?", "rationale": ["Identify the relevant table, which is 'Catalog_Contents'.", "Select the column to display, 'catalog_entry_name'.", "Order the results by 'price_in_dollars' in descending order to get the most expensive entries first.", "Use a placeholder in the LIMIT clause to specify how many entries to return."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1", "source_tables": ["catalog_contents"], "description": "The virtual table provides the names of catalog entries from the 'Catalog_Contents' table, ordered by their price in US dollars. The placeholder in the LIMIT clause indicates the number of entries to return, allowing for flexibility in specifying how many of the most expensive entries to retrieve.", "virtual_table": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.320", "db_id": "product_catalog", "question": "Find the level name of the catalog with the lowest price (in USD).", "rationale": ["Identify the relevant tables, which are 'Catalog_Contents' and 'Catalog_Structure'.", "Select the column to display, 'catalog_level_name' from 'Catalog_Structure'.", "Join the two tables on the 'catalog_level_number' to relate the catalog entries to their respective levels.", "Order the results by 'price_in_dollars' to find the lowest price.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT 1", "source_tables": ["catalog_structure", "catalog_contents"], "description": "The virtual table describes the catalog level names from the 'Catalog_Contents' table, joined with the 'Catalog_Structure' table, ordered by the price in US dollars. The placeholder in the LIMIT clause indicates the number of results to return, which corresponds to the catalog entry with the lowest price.", "virtual_table": "SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5589", "db_id": "products_gen_characteristics", "question": "What are the names of products that are not 'white' in color and are not measured by the unit 'Handful'?", "rationale": ["Identify the relevant tables, which are 'Products', 'Ref_Product_Categories', and 'Ref_Colors'.", "Select the column to display, 'product_name' from the 'Products' table.", "Join the 'Products' table with 'Ref_Product_Categories' and 'Ref_Colors' to access the necessary attributes for filtering.", "Add conditions to filter the results based on the specified color and unit of measure using placeholders for string values."], "gold_sql": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  'white' AND t2.unit_of_measure != 'Handful'", "source_tables": ["products", "ref_colors", "ref_product_categories"], "description": "The virtual table describes the names of products from the 'Products' table that are filtered based on their color and unit of measure. The placeholders in the WHERE clause represent the specific color description and the unit of measure that should not be matched.", "virtual_table": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the relevant tables, which are 'Products' and 'Ref_Product_Categories'.", "Select the columns to display, 'unit_of_measure' and 'product_category_code'.", "Join the 'Products' table with 'Ref_Product_Categories' on the product category code to access the unit of measurement.", "Add a condition to filter the 'Products' table for the specified product name using a placeholder for string values."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "description": "The virtual table provides the unit of measurement and product category code for products listed in the 'Products' table, specifically for a product with a given name. The placeholder in the WHERE clause represents the name of the product being queried.", "virtual_table": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["Identify the relevant tables, which are 'Products' and 'Ref_Colors'.", "Join the 'Products' table with 'Ref_Colors' on the 'color_code' to access color descriptions.", "Group the results by 'color_description' to aggregate the data based on color.", "Order the results by the count of products associated with each color description in descending order.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "description": "The virtual table describes the color descriptions associated with products from the 'Products' table. It aggregates the colors by their descriptions and orders them by the count of products associated with each color, allowing for the retrieval of the most common color descriptions based on the specified limit.", "virtual_table": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5576", "db_id": "products_gen_characteristics", "question": "Count the products that have the color description \"white\" or have the characteristic name \"hot\".", "rationale": ["Identify the relevant tables: 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors'.", "Count the total number of products by using the count(*) function.", "Join 'Products' with 'Product_Characteristics' to link products to their characteristics.", "Join 'Product_Characteristics' with 'Characteristics' to access the characteristic names.", "Join 'Products' with 'Ref_Colors' to filter products based on their color description.", "Add a condition in the WHERE clause to filter products that match either the specified color description or characteristic name using placeholders."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "description": "The virtual table counts the total number of products from the 'Products' table that either have a specific color description or a specific characteristic name. It joins multiple tables: 'Product_Characteristics' to link products with their characteristics, 'Characteristics' to access the characteristic names, and 'Ref_Colors' to filter by color description. The placeholders in the WHERE clause represent the color description and characteristic name to be specified by the user.", "virtual_table": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5562", "db_id": "products_gen_characteristics", "question": "List all characteristics of product named \"sesame\" with type code \"Grade\".", "rationale": ["Identify the relevant tables: 'Products', 'Product_Characteristics', and 'Characteristics'.", "Select the column to display, which is 'characteristic_name' from the 'Characteristics' table.", "Join the 'Products' table with 'Product_Characteristics' on 'product_id' to link products with their characteristics.", "Join 'Product_Characteristics' with 'Characteristics' on 'characteristic_id' to access characteristic details.", "Add conditions to filter the results based on the specified product name and characteristic type code using placeholders for string values."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame' AND t3.characteristic_type_code  =  'Grade'", "source_tables": ["products", "characteristics", "product_characteristics"], "description": "The virtual table describes the names of characteristics associated with a specific product from the 'Products' table, filtered by the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.", "virtual_table": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["Identify the relevant tables, which are 'Products' and 'Ref_Colors'.", "Join the 'Products' table with the 'Ref_Colors' table on the color code to access color descriptions.", "Group the results by color description to count the number of products associated with each color.", "Order the results in ascending order based on the count of products to find the least used colors.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "description": "The virtual table describes the color descriptions from the 'Ref_Colors' table that are associated with the least number of products in the 'Products' table. The placeholder in the LIMIT clause represents the number of colors to retrieve, allowing for flexibility in specifying how many of the least used colors to return.", "virtual_table": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant table, which is 'Ref_Product_Categories'.", "Select the column to display, 'unit_of_measure'.", "Add a condition to filter the 'product_category_code' column for the specified product category using a placeholder for string values."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "description": "The virtual table provides the unit of measure for products categorized under a specific product category. The placeholder in the WHERE clause represents the unique code for the product category, allowing users to specify which category they are interested in.", "virtual_table": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5526", "db_id": "products_gen_characteristics", "question": "Find the names of all the product characteristics.", "rationale": ["Identify the relevant table, which is 'Characteristics'.", "Select the column to display, 'characteristic_name'.", "Use DISTINCT to ensure that only unique characteristic names are returned."], "gold_sql": "SELECT DISTINCT characteristic_name FROM CHARACTERISTICS", "source_tables": ["characteristics"], "description": "The virtual table contains the distinct names of product characteristics from the 'Characteristics' table. This table allows users to retrieve unique characteristic names without duplicates.", "virtual_table": "SELECT DISTINCT characteristic_name FROM CHARACTERISTICS"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["Identify the relevant tables, which are 'railway' and 'train'.", "Select the columns to display, 'Railway_ID' and 'Builder'.", "Join the 'railway' table with the 'train' table on the Railway_ID to associate trains with their respective railways.", "Group the results by Railway_ID to count the number of trains associated with each railway.", "Order the results by the count of trains in descending order to find the railway with the most trains.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "description": "The virtual table provides the Railway_ID and Builder of railways from the 'railway' table that are linked to the highest number of trains. The results are grouped by Railway_ID and ordered by the count of associated trains in descending order, with a limit set by a placeholder for numeric values.", "virtual_table": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["Identify the relevant table, which is 'railway'.", "Select the 'Builder' column to display the names of builders.", "Group the results by 'Builder' to count occurrences.", "Order the results in descending order based on the count of builders to find the most common one.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "description": "The virtual table summarizes the builders of railways from the 'railway' table, grouping them to identify the most frequently occurring builder. The placeholder in the LIMIT clause allows for specifying the number of top builders to display.", "virtual_table": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["Identify the relevant table, which is 'railway'.", "Select the column to display, 'Builder'.", "Add an order clause to sort the results in ascending order based on the 'Builder' column."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "description": "The virtual table lists the names of builders from the 'railway' table, sorted in ascending alphabetical order. This allows users to view the builders associated with various railways in a structured manner.", "virtual_table": "SELECT Builder FROM railway ORDER BY Builder ASC"}
{"sample_id": "train.1300", "db_id": "soccer_1", "question": "List the names of all left-footed players who have overall rating between 85 and 90.", "rationale": ["Identify the relevant tables, which are 'Player' and 'Player_Attributes'.", "Select the 'player_name' column from the 'Player' table.", "Join the 'Player' table with the 'Player_Attributes' table using the 'player_api_id'.", "Add conditions to filter for left-footed players and to check if their overall rating falls within the specified range using placeholders for string and numeric values."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot  =  'left' AND T2.overall_rating  >=  85 AND T2.overall_rating  <=  90", "source_tables": ["player_attributes", "player"], "description": "The virtual table lists the distinct names of players from the 'Player' table who are left-footed and have an overall skill rating within a specified range. The placeholders in the WHERE clause represent the preferred foot and the range of overall ratings.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING] AND T2.overall_rating  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.overall_rating  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1299", "db_id": "soccer_1", "question": "List the names of all players who have a crossing score higher than 90 and prefer their right foot.", "rationale": ["Identify the relevant tables, which are 'Player' and 'Player_Attributes'.", "Select the 'player_name' column from the 'Player' table.", "Join the 'Player' table with the 'Player_Attributes' table using the 'player_api_id' to link player attributes to their respective players.", "Add conditions to filter players based on their crossing score and preferred foot, using placeholders for the numeric and string values."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  90 AND T2.preferred_foot  =  'right'", "source_tables": ["player_attributes", "player"], "description": "The virtual table lists the names of players from the 'Player' table who have a crossing score exceeding a specified threshold and prefer using their right foot. The placeholders in the WHERE clause allow for dynamic input of the crossing score and preferred foot type.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  [PLACEHOLDER-TYPE:NUMBER] AND T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1298", "db_id": "soccer_1", "question": "What are the names of players who have the best dribbling?", "rationale": ["Identify the relevant tables, which are 'Player' and 'Player_Attributes'.", "Select the 'player_name' column from the 'Player' table.", "Join the 'Player' table with the 'Player_Attributes' table on the 'player_api_id' to access player attributes.", "Use a subquery to find the maximum dribbling skill from the 'Player_Attributes' table.", "Add a condition to filter the results to include only players with the highest dribbling skill."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.dribbling  =  ( SELECT max(overall_rating) FROM Player_Attributes)", "source_tables": ["player_attributes", "player"], "description": "The virtual table provides the names of players from the 'Player' table who possess the highest dribbling skill. It joins the 'Player' table with the 'Player_Attributes' table to access the dribbling attribute and filters the results to include only those players whose dribbling skill matches the maximum value found in the 'Player_Attributes' table.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.dribbling  =  ( SELECT max(overall_rating) FROM Player_Attributes)"}
{"sample_id": "train.1306", "db_id": "soccer_1", "question": "List the names and birthdays of the top five players in terms of potential.", "rationale": ["Identify the relevant tables, which are 'Player' and 'Player_Attributes'.", "Select the columns to display, 'player_name' and 'birthday'.", "Join the 'Player' table with the 'Player_Attributes' table on the 'player_api_id' to access potential ratings.", "Order the results by the 'potential' column in descending order to get the top players.", "Use a placeholder in the LIMIT clause to specify the number of top players to return."], "gold_sql": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT 5", "source_tables": ["player_attributes", "player"], "description": "The virtual table provides the names and birthdays of players from the 'Player' table, specifically focusing on the top five players based on their potential skill rating. The query joins the 'Player' table with the 'Player_Attributes' table to access the potential ratings, and the placeholder in the LIMIT clause allows for specifying the number of top players to retrieve.", "virtual_table": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1296", "db_id": "soccer_1", "question": "What is the maximum and minimum height of all players?", "rationale": ["Identify the relevant table, which is 'Player'.", "Select the maximum and minimum values of the 'height' column.", "Use aggregate functions to calculate the maximum and minimum height of all players."], "gold_sql": "SELECT max(weight) ,  min(weight) FROM Player", "source_tables": ["player"], "description": "The virtual table provides the maximum and minimum height of players from the 'Player' table. The placeholders in the SELECT statement represent the aggregate functions for height values.", "virtual_table": "SELECT max(weight) ,  min(weight) FROM Player"}
{"sample_id": "train.1305", "db_id": "soccer_1", "question": "Who are the top 3 players in terms of overall rating?", "rationale": ["Identify the relevant tables, which are 'Player' and 'Player_Attributes'.", "Join the 'Player' table with 'Player_Attributes' on the 'player_api_id' to access player names and their overall ratings.", "Select the 'player_name' column to display the names of the players.", "Order the results by 'overall_rating' in descending order to get the top players.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY overall_rating DESC LIMIT 3", "source_tables": ["player_attributes", "player"], "description": "The virtual table lists the names of players from the 'Player' table who have the highest overall skill ratings. The results are ordered in descending order based on the overall rating, and the number of players returned is determined by a placeholder for numeric values.", "virtual_table": "SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY overall_rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5015", "db_id": "soccer_2", "question": "For each position, what is the maximum number of  hours for students who spent more than 1000 hours training?", "rationale": ["Identify the relevant tables, which are 'Player' and 'Tryout'.", "Select the maximum hours from the 'HS' column in the 'Player' table and group the results by the 'pPos' column from the 'Tryout' table.", "Add a condition to filter players based on their training hours using a placeholder for numeric values."], "gold_sql": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  1000 GROUP BY T2.pPos", "source_tables": ["player", "tryout"], "description": "The virtual table summarizes the maximum hours of training for players based on their positions. It combines data from the 'Player' and 'Tryout' tables, filtering for players who have trained for more than a specified number of hours. The placeholder in the WHERE clause represents the threshold of training hours.", "virtual_table": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos"}
{"sample_id": "train.5014", "db_id": "soccer_2", "question": "What is the maximum training hours for the students whose training hours is greater than 1000 in different positions?", "rationale": ["Identify the relevant tables, which are 'Player' and 'Tryout'.", "Select the maximum training hours and the position from the respective tables.", "Join the 'Player' and 'Tryout' tables on the player ID to correlate players with their tryout positions.", "Add a condition to filter players based on their training hours using a placeholder for numeric values.", "Group the results by the position to get the maximum training hours for each position."], "gold_sql": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  1000 GROUP BY T2.pPos", "source_tables": ["player", "tryout"], "description": "The virtual table summarizes the maximum training hours of players from the 'Player' table who have training hours exceeding a specified threshold. It groups the results by the position the players are trying out for, as indicated in the 'Tryout' table. The placeholder in the WHERE clause represents the minimum training hours required for the selection.", "virtual_table": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["Identify the relevant table, which is 'College'.", "Select the distinct 'state' column to avoid duplicates.", "Add a condition to filter the 'enr' column for colleges with enrollment numbers less than a subquery that retrieves the maximum enrollment number from the 'College' table."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "description": "The virtual table provides a list of distinct states where colleges have enrollment numbers that are less than the maximum enrollment number found among all colleges. This allows users to identify states with colleges that have relatively lower student enrollments compared to the highest enrollment college.", "virtual_table": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)"}
{"sample_id": "train.4993", "db_id": "soccer_2", "question": "What is the name of the school with smallest enrollment size per state?", "rationale": ["Identify the relevant table, which is 'College'.", "Select the columns to display: 'cName', 'state', and the minimum enrollment number 'min(enr)'.", "Group the results by the 'state' column to find the college with the smallest enrollment size in each state."], "gold_sql": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state", "source_tables": ["college"], "description": "The virtual table summarizes the names of colleges along with their respective states and the minimum enrollment size for each state. The query groups the results by state, allowing for the identification of the college with the smallest enrollment in each state.", "virtual_table": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["Identify the relevant tables, which are 'College' and 'Tryout'.", "Select the columns to display, 'state' and 'enr' from the 'College' table.", "Join the 'College' table with the 'Tryout' table on the college name to filter the results based on tryout decisions.", "Add a condition to filter the results based on the decision made during the tryouts using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "description": "The virtual table provides a distinct list of states and enrollment numbers of colleges from the 'College' table that have accepted students during tryouts. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.", "virtual_table": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5035", "db_id": "soccer_2", "question": "What are the names of all the states with college students playing in the mid position but no goalies?", "rationale": ["Identify the relevant tables, which are 'College' and 'Tryout'.", "Join the 'College' table with the 'Tryout' table based on the college name to access the states of colleges with players trying out.", "Filter the results to include only those players trying out for a specified position using a placeholder for string values.", "Use the EXCEPT clause to exclude states where players are trying out for the goalie position, again using a placeholder for string values."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie'", "source_tables": ["tryout", "college"], "description": "The virtual table provides a list of states where colleges have students participating in tryouts for a specific position, excluding those states where students are trying out for the goalie position. The placeholders in the query represent the positions of interest for filtering the results.", "virtual_table": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["Identify the relevant tables, which are 'College' and 'Tryout'.", "Select the columns to display, 'state' and 'enr' from the 'College' table.", "Join the 'College' table with the 'Tryout' table on the college name to correlate colleges with their tryout results.", "Add a condition to filter the results based on the tryout decision using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "description": "The virtual table provides a distinct list of states and enrollment numbers of colleges from the 'College' table that have students accepted based on their tryout decisions. The placeholder in the WHERE clause represents the decision status of the tryout.", "virtual_table": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4992", "db_id": "soccer_2", "question": "What is the name of school that has the smallest enrollment in each state?", "rationale": ["Identify the relevant table, which is 'College'.", "Select the columns to display: 'cName', 'state', and the minimum enrollment number 'min(enr)'.", "Group the results by the 'state' column to find the college with the smallest enrollment in each state."], "gold_sql": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state", "source_tables": ["college"], "description": "The virtual table provides the names of colleges along with their respective states and the minimum enrollment numbers for each state. The query groups the results by state to identify the college with the smallest enrollment in each state.", "virtual_table": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["Identify the relevant tables, which are 'Player' and 'Tryout'.", "Select the columns to display, 'pName' and 'HS' from the 'Player' table.", "Join the 'Player' table with the 'Tryout' table on the player ID to correlate players with their tryout results.", "Add a condition to filter the 'decision' column in the 'Tryout' table for a specific value using a placeholder for string values."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "description": "The virtual table presents the names and high schools of players from the 'Player' table who participated in tryouts and received a positive decision. The placeholder in the WHERE clause indicates the decision status that is being filtered for.", "virtual_table": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["Identify the relevant tables, which are 'Tryout' and 'Player'.", "Select the minimum time spent practicing, represented by the 'HS' column from the 'Player' table, and the position from the 'Tryout' table.", "Join the 'Tryout' and 'Player' tables on the player identifier 'pID' to correlate players with their tryout positions.", "Group the results by the position to get the minimum practice time for each position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "description": "The virtual table summarizes the minimum time students spent practicing for each position from the tryout data. It combines information from the 'Tryout' and 'Player' tables, linking players to their respective tryouts based on their unique identifiers. The result is grouped by position, allowing for an analysis of practice time across different roles.", "virtual_table": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["Identify the relevant table, which is 'Tryout'.", "Select the column 'pPos' to display the positions players are trying out for.", "Group the results by 'pPos' to aggregate the data based on positions.", "Order the results by the count of players in each position in descending order to find the most popular position.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "description": "The virtual table summarizes the positions that players are trying out for in the 'Tryout' table. It groups the results by position and orders them by the count of players in each position, allowing users to identify the most popular position at tryouts. The placeholder in the LIMIT clause indicates the number of top positions to return.", "virtual_table": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5002", "db_id": "soccer_2", "question": "Find the name and hours of the students whose tryout decision is yes.", "rationale": ["Identify the relevant tables, which are 'Player' and 'Tryout'.", "Select the columns to display, 'pName' and 'HS' from the 'Player' table.", "Join the 'Player' table with the 'Tryout' table on the player ID to correlate players with their tryout decisions.", "Add a condition to filter the 'decision' column in the 'Tryout' table for the specified decision using a placeholder for string values."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "description": "The virtual table describes the names and high schools of players from the 'Player' table who have a positive decision regarding their tryout. The placeholder in the WHERE clause represents the decision status, allowing for filtering based on the specified value.", "virtual_table": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["Identify the relevant table, which is 'Tryout'.", "Select the column 'pPos' to display the positions players are trying out for.", "Group the results by 'pPos' to aggregate the data based on positions.", "Order the results by the count of players in each position in descending order to find the most popular position.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "description": "The virtual table summarizes the positions that players are trying out for in the 'Tryout' table. It groups the results by position and orders them by the count of players in each position, allowing users to identify the most popular position based on the number of participants. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["Identify the relevant tables, which are 'Tryout' and 'Player'.", "Select the minimum hours from the 'Player' table and the position from the 'Tryout' table.", "Join the two tables on the player ID to correlate players with their tryout positions.", "Group the results by the position to get the minimum hours for each position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "description": "The virtual table summarizes the minimum hours of students participating in tryouts for different positions. It combines data from the 'Tryout' and 'Player' tables, grouping the results by the position each player is trying out for. The placeholder in the SELECT clause represents the minimum hours associated with the players' high school attendance.", "virtual_table": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["Identify the relevant tables, which are 'Player' and 'Tryout'.", "Select the column to display, 'pName' from the 'Player' table.", "Join the 'Player' table with the 'Tryout' table on the player ID to correlate players with their tryout results.", "Add conditions to filter the results based on the decision made in the tryout and the specific position using placeholders for string values."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "description": "The virtual table describes the names of players from the 'Player' table who have successfully tried out for a specific position. It combines data from the 'Player' and 'Tryout' tables, filtering based on the decision made regarding the tryout and the position the player is trying out for. The placeholders in the WHERE clause represent the decision status and the position of interest.", "virtual_table": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING] AND T2.pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4957", "db_id": "soccer_2", "question": "What are the names and number of hours spent training for each player who trains for less than 1500 hours?", "rationale": ["Identify the relevant table, which is 'Player'.", "Select the columns to display, 'pName' and 'HS'.", "Add a condition to filter the training hours using a placeholder for numeric values."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "description": "The virtual table presents the names of players along with the high school they attended, filtered to include only those players who have trained for fewer hours than a specified threshold. The placeholder in the WHERE clause represents the maximum number of training hours.", "virtual_table": "SELECT pName ,  HS FROM Player WHERE HS  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5010", "db_id": "soccer_2", "question": "Find the average and maximum hours for the students whose tryout decision is yes.", "rationale": ["Identify the relevant tables, which are 'Player' and 'Tryout'.", "Select the aggregate functions to calculate the average and maximum hours from the 'HS' column in the 'Player' table.", "Join the 'Player' table with the 'Tryout' table using the player identifier 'pID'.", "Add a condition to filter the results based on the 'decision' column in the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "description": "The virtual table provides the average and maximum hours associated with players from the 'Player' table who have a specific tryout decision. The join between the 'Player' and 'Tryout' tables is based on the unique player identifier, and the placeholder in the WHERE clause represents the decision status of the tryout.", "virtual_table": "SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5009", "db_id": "soccer_2", "question": "In which state is the college that Charles attends?", "rationale": ["Identify the relevant tables: 'College', 'Tryout', and 'Player'.", "Select the 'state' column from the 'College' table.", "Join the 'Tryout' table on the college name to connect players to their respective colleges.", "Join the 'Player' table on the player ID to filter by a specific player's name using a placeholder."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  'Charles'", "source_tables": ["player", "tryout", "college"], "description": "The virtual table provides the state of the college that a specific player, identified by their name, attends. It combines data from the 'College', 'Tryout', and 'Player' tables, linking them through the college name and player ID. The placeholder in the WHERE clause represents the player's name.", "virtual_table": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["Identify the relevant table, which is 'Player'.", "Select the average of the training hours, represented by the 'HS' column.", "The query aims to calculate the average value of the training hours for all players."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "description": "The virtual table provides the average training hours of players from the 'Player' table. The placeholder in the SELECT clause represents the training hours of players, which is derived from the high school they attended.", "virtual_table": "SELECT avg(HS) FROM Player"}
{"sample_id": "train.4950", "db_id": "soccer_2", "question": "How many players have more than 1000 hours of training?", "rationale": ["Identify the relevant table, which is 'Player'.", "Select the count of players by using count(*) function.", "Add a condition to filter the 'HS' column for training hours greater than the specified number using a placeholder for numeric values."], "gold_sql": "SELECT count(*) FROM Player WHERE HS  >  1000", "source_tables": ["player"], "description": "The virtual table provides a count of players from the 'Player' table who have a high school training hours exceeding a specified number. The placeholder in the WHERE clause represents the threshold for training hours.", "virtual_table": "SELECT count(*) FROM Player WHERE HS  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4964", "db_id": "soccer_2", "question": "How many students whose are playing the role of goalie?", "rationale": ["Identify the relevant table, which is 'Tryout'.", "Select the count of players by using the count(*) function.", "Add a condition to filter the 'pPos' column for the specified position using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM tryout WHERE pPos  =  'goalie'", "source_tables": ["tryout"], "description": "The virtual table provides a count of players from the 'Tryout' table who are trying out for the position of goalie. The placeholder in the WHERE clause represents the specific position being queried.", "virtual_table": "SELECT count(*) FROM tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["Identify the relevant table, which is 'Player'.", "Select the aggregate functions to calculate the average, maximum, and minimum training hours.", "Use the 'HS' column to represent the training hours, applying the aggregate functions accordingly."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "description": "The virtual table summarizes the average, maximum, and minimum training hours of players from the 'Player' table. The placeholder in the SELECT clause represents the training hours of the players, which is derived from the high school column, indicating the training hours associated with each player's high school.", "virtual_table": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["Identify the relevant tables, which are 'Player' and 'Tryout'.", "Select the average of the hours spent practicing, represented by the 'HS' column from the 'Player' table.", "Join the 'Player' table with the 'Tryout' table on the player ID to correlate players with their tryout decisions.", "Add a condition to filter the results based on the decision status using a placeholder for string values."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "description": "The virtual table provides the average number of hours spent practicing by players from the 'Player' table who were rejected in their tryouts. The placeholder in the WHERE clause represents the decision status of the players' tryouts.", "virtual_table": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4951", "db_id": "soccer_2", "question": "How many different players trained for more than 1000 hours?", "rationale": ["Identify the relevant table, which is 'Player'.", "Select the count of players as the output.", "Add a condition to filter the 'HS' column for training hours using a placeholder for numeric values."], "gold_sql": "SELECT count(*) FROM Player WHERE HS  >  1000", "source_tables": ["player"], "description": "The virtual table counts the number of players from the 'Player' table who have trained for a specified number of hours. The placeholder in the WHERE clause represents the threshold of training hours that players must exceed.", "virtual_table": "SELECT count(*) FROM Player WHERE HS  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["Identify the relevant table, which is 'College'.", "Select the column to calculate the average, which is 'enr'.", "Use the AVG function to compute the average enrollment number across all colleges."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "description": "The virtual table provides the average enrollment number of students from the 'College' table. This average is calculated across all colleges, giving insight into the typical student population at these institutions.", "virtual_table": "SELECT avg(enr) FROM College"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["Identify the relevant table, which is 'Tryout'.", "Select the count of records to determine how many players were accepted.", "Add a condition to filter the 'decision' column for the specified acceptance status using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "description": "The virtual table provides a count of players from the 'Tryout' table who received an acceptance decision after their tryout. The placeholder in the WHERE clause represents the specific decision status being queried.", "virtual_table": "SELECT count(*) FROM tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant table, which is 'Tryout'.", "Use a subquery to select the college names where players are trying out for the specified positions.", "Utilize the INTERSECT operator to find colleges that have players in both positions.", "Count the distinct colleges that meet the criteria."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "description": "The virtual table counts the number of colleges from the 'Tryout' table where students are trying out for both the goalie and mid positions. The placeholders in the query represent the specific positions being queried.", "virtual_table": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5000", "db_id": "soccer_2", "question": "Find the name of all students who were in the tryout sorted in alphabetic order.", "rationale": ["Identify the relevant tables, which are 'Player' and 'Tryout'.", "Select the column to display, 'pName' from the 'Player' table.", "Join the 'Player' table with the 'Tryout' table using the unique player identifier 'pID'.", "Sort the results in alphabetical order based on the 'pName' column."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName", "source_tables": ["player", "tryout"], "description": "The virtual table contains the names of players who participated in tryouts, sourced from the 'Player' table. The data is organized in alphabetical order based on the players' names.", "virtual_table": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName"}
{"sample_id": "train.4960", "db_id": "soccer_2", "question": "What are the unique types of player positions in the tryout?", "rationale": ["Identify the relevant table, which is 'Tryout'.", "Select the distinct values from the 'pPos' column to count the unique player positions.", "Use the COUNT function to aggregate the distinct player positions."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "description": "The virtual table provides a count of unique player positions from the 'Tryout' table. This count reflects the distinct values present in the 'pPos' column, which indicates the various positions players are trying out for.", "virtual_table": "SELECT count(DISTINCT pPos) FROM tryout"}
{"sample_id": "train.3370", "db_id": "sports_competition", "question": "What are the types of competition that have most 5 competitions for that type?", "rationale": ["Identify the relevant table, which is 'competition'.", "Select the column to display, 'Competition_type'.", "Group the results by 'Competition_type' to aggregate the data.", "Add a condition to filter the groups based on the count of competitions using a placeholder for numeric values."], "gold_sql": "SELECT Competition_type FROM competition GROUP BY Competition_type HAVING COUNT(*)  <=  5", "source_tables": ["competition"], "description": "The virtual table summarizes the types of competitions from the 'competition' table, grouping them by their type and filtering to show only those competition types that have a specified maximum number of competitions. The placeholder in the HAVING clause represents the upper limit for the count of competitions for each type.", "virtual_table": "SELECT Competition_type FROM competition GROUP BY Competition_type HAVING COUNT(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["Identify the relevant table, which is 'player'.", "Select the column to display, 'Position'.", "Use the INTERSECT operator to find positions of players who meet both conditions regarding their points, utilizing placeholders for the numeric values."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "description": "The virtual table presents the playing positions of players from the 'player' table who have scored more than a specified number of points and less than another specified number of points. The placeholders in the query represent the numeric values for the point thresholds.", "virtual_table": "SELECT POSITION FROM player WHERE Points  >  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT POSITION FROM player WHERE Points  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["Identify the relevant table, which is 'competition'.", "Select the 'country' column to display.", "Add a condition to filter the 'competition_type' column for tournament competitions using a placeholder for string values.", "Group the results by 'country' to aggregate the data.", "Order the results by the count of occurrences in descending order to find the country with the most participations.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "description": "The virtual table summarizes the countries that participated in various competitions, specifically focusing on tournament types. It groups the results by country and orders them by the count of tournament participations in descending order, allowing for the identification of the country with the highest participation. The placeholders represent the type of competition and the limit on the number of results to return.", "virtual_table": "SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3387", "db_id": "sports_competition", "question": "Find the countries that have never participated in any competition with Friendly type.", "rationale": ["Identify the relevant table, which is 'competition'.", "Select the 'country' column to display.", "Use the EXCEPT clause to exclude countries that have participated in competitions of the specified type, utilizing a placeholder for the competition type."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "description": "The virtual table lists countries that have not participated in any competition of a specific type. It uses a placeholder to filter out countries based on the competition type, allowing users to specify the type of competition they are interested in.", "virtual_table": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["Identify the relevant table, which is 'player'.", "Select the column to display, 'Position'.", "Group the results by 'Position' to calculate the average points for each position.", "Add a condition to filter the groups using the HAVING clause to include only those with an average points score above a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "description": "The virtual table summarizes the positions of players from the 'player' table, grouped by their playing position. It filters the results to include only those positions where the average points scored by players in that position exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average points required for inclusion.", "virtual_table": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3367", "db_id": "sports_competition", "question": "List the most common type of competition.", "rationale": ["Identify the relevant table, which is 'competition'.", "Select the column 'Competition_type' to display the types of competitions.", "Group the results by 'Competition_type' to aggregate them.", "Order the results by the count of each type in descending order to find the most common types.", "Add a limit to specify how many of the most common types to return using a placeholder for numeric values."], "gold_sql": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["competition"], "description": "The virtual table summarizes the types of competitions from the 'competition' table, grouping them to identify the most common type. The placeholder in the LIMIT clause allows for specifying the number of results to return, indicating how many of the most common competition types should be listed.", "virtual_table": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["Identify the relevant table, which is 'competition'.", "Select the columns to display, 'Competition_type' and 'Country'."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "description": "The virtual table provides information about the types and countries of competitions from the 'competition' table. It includes the competition type and the country where each competition is held.", "virtual_table": "SELECT Competition_type ,  Country FROM competition"}
{"sample_id": "train.3356", "db_id": "sports_competition", "question": "What are the names and players of all the clubs?", "rationale": ["Identify the relevant tables, which are 'club' and 'player'.", "Select the columns to display, 'name' from the 'club' table and 'Player_ID' from the 'player' table.", "Join the two tables on the 'Club_ID' to associate players with their respective clubs."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "description": "The virtual table provides the names of clubs along with the unique identifiers of players associated with each club. It combines data from the 'club' and 'player' tables based on the club's unique identifier, allowing users to see which players belong to which clubs.", "virtual_table": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID"}
{"sample_id": "train.594", "db_id": "store_1", "question": "What is the full name of the employee who has the most customers?", "rationale": ["Identify the relevant tables, which are 'employees' and 'customers'.", "Select the columns to display, 'first_name' and 'last_name' from the 'employees' table.", "Join the 'employees' table with the 'customers' table on the support representative's identifier.", "Group the results by employee ID to aggregate the customer counts.", "Order the results by the count of customers in descending order to find the employee with the most customers.", "Add a limit to specify how many top employees to return using a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "description": "The virtual table provides the first and last names of employees from the 'employees' table who are support representatives for customers. It joins the 'employees' table with the 'customers' table based on the support representative's identifier, groups the results by employee ID, and orders them by the count of customers they support in descending order. The placeholder in the LIMIT clause indicates the number of top employees to retrieve based on the highest customer count.", "virtual_table": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.606", "db_id": "store_1", "question": "What are the first and last names of all the employees and how many people report to them?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display, 'first_name' and 'last_name' from the second instance of the 'employees' table (T2).", "Count the number of reports for each manager by counting the occurrences of 'reports_to' in the first instance of the 'employees' table (T1).", "Join the 'employees' table with itself to relate employees to their managers using the 'reports_to' field.", "Group the results by the manager's identifier to aggregate the count of reports.", "Order the results by the count of reports in descending order to show the most reported managers first.", "Add a limit to the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T2.first_name , T2.last_name ,  count(T1.reports_to) FROM employees AS T1 JOIN employees AS T2 ON T1.reports_to = T2.id GROUP BY T1.reports_to ORDER BY count(T1.reports_to) DESC LIMIT 1;", "source_tables": ["employees"], "description": "The virtual table presents the first and last names of employees along with the count of how many employees report to each of them. It utilizes a self-join on the 'employees' table to correlate employees with their respective managers, grouping the results by the manager's identifier. The count of reports is aggregated and sorted in descending order, with a limit applied to the number of results returned.", "virtual_table": "SELECT T2.first_name , T2.last_name ,  count(T1.reports_to) FROM employees AS T1 JOIN employees AS T2 ON T1.reports_to = T2.id GROUP BY T1.reports_to ORDER BY count(T1.reports_to) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables, which are 'employees' and 'customers'.", "Select the columns to display, 'first_name' and 'last_name' from the 'employees' table.", "Join the 'employees' table with the 'customers' table on the support representative's identifier.", "Group the results by employee ID to count the number of customers each employee supports.", "Order the results by the count of customers in descending order to find the employee who supports the most customers.", "Add a limit to specify how many top employees to return using a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "description": "The virtual table provides the first and last names of employees from the 'employees' table who are support representatives for customers. It joins the 'employees' table with the 'customers' table based on the support representative's identifier, groups the results by employee ID, and orders them by the count of customers they support in descending order. The placeholder in the LIMIT clause indicates the maximum number of employees to return.", "virtual_table": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["Identify the relevant table, which is 'invoices'.", "Select the 'billing_state' column and count the number of invoices for each state.", "Add a condition to filter the results by 'billing_country' using a placeholder for string values.", "Group the results by 'billing_state' to aggregate the counts.", "Order the results by the count of invoices in descending order.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "description": "The virtual table summarizes the billing states from the 'invoices' table, counting the number of invoices issued in each state. The results are filtered by a specific country, and the states are ordered by the count of invoices in descending order, with a limit on the number of results returned.", "virtual_table": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["Identify the relevant table, which is 'invoices'.", "Select the 'billing_country' column and calculate the average of the 'total' column.", "Group the results by 'billing_country' to get the average invoice size for each country.", "Order the results by the average invoice size in descending order to find the top countries.", "Add a limit to restrict the number of countries returned, using a placeholder for numeric values."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "description": "The virtual table summarizes the billing countries and their corresponding average invoice sizes from the 'invoices' table. It groups the results by country and orders them in descending order based on the average invoice size, with a limit on the number of countries returned as specified by a placeholder.", "virtual_table": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.587", "db_id": "store_1", "question": "What is the title, phone and hire date of Nancy Edwards?", "rationale": ["Identify the relevant table, which is 'employees'.", "Select the columns to display: 'title', 'phone', and 'hire_date'.", "Add conditions to filter the 'first_name' and 'last_name' columns for the specified employee using placeholders for string values."], "gold_sql": "SELECT title ,  phone ,  hire_date FROM employees WHERE first_name = 'Nancy' AND last_name = 'Edwards';", "source_tables": ["employees"], "description": "The virtual table provides the title, phone number, and hire date of employees from the 'employees' table based on their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the employee being queried.", "virtual_table": "SELECT title ,  phone ,  hire_date FROM employees WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["Identify the relevant tables: 'tracks', 'invoice_lines', 'invoices', and 'customers'.", "Select the column to display, which is the 'name' of the track from the 'tracks' table.", "Join the 'tracks' table with 'invoice_lines' on the track ID to link tracks to their respective invoices.", "Join the 'invoice_lines' table with 'invoices' on the invoice ID to connect invoices to customers.", "Join the 'invoices' table with 'customers' on the customer ID to filter by customer name.", "Add conditions to filter the results based on the specified customer's first and last name using placeholders."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "description": "The virtual table describes the names of tracks from the 'tracks' table that were purchased by a specific customer. It joins the 'tracks' table with 'invoice_lines' to link tracks to invoices, then connects to the 'invoices' table to associate invoices with customers, and finally filters the results based on the customer's first and last name using placeholders.", "virtual_table": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = [PLACEHOLDER-TYPE:STRING] AND T4.last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.589", "db_id": "store_1", "question": "find the full name of employees who report to Nancy Edwards?", "rationale": ["Identify the relevant table, which is 'employees'.", "Join the 'employees' table with itself to relate employees to their managers.", "Select the columns to display, 'first_name' and 'last_name' of the employees reporting to the specified manager.", "Add conditions to filter the manager's name using placeholders for string values."], "gold_sql": "SELECT T2.first_name , T2.last_name FROM employees AS T1 JOIN employees AS T2 ON T1.id = T2.reports_to WHERE T1.first_name = 'Nancy' AND T1.last_name = 'Edwards';", "source_tables": ["employees"], "description": "The virtual table provides the first and last names of employees from the 'employees' table who report to a specific manager. The placeholders in the WHERE clause represent the first and last names of the manager.", "virtual_table": "SELECT T2.first_name , T2.last_name FROM employees AS T1 JOIN employees AS T2 ON T1.id = T2.reports_to WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the relevant tables: 'genres', 'tracks', and 'media_types'.", "Select the column to display, which is 'name' from the 'tracks' table.", "Join the 'genres' table to the 'tracks' table on the genre identifier to filter by genre.", "Join the 'media_types' table to the 'tracks' table on the media type identifier to filter by media type.", "Add conditions to filter the results based on the specified genre and media type using placeholders for string values."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "description": "The virtual table provides the names of tracks from the 'tracks' table that are associated with a specific genre and media type. It joins the 'genres' table to filter tracks by genre and the 'media_types' table to filter by media type, using placeholders for the genre and media type names.", "virtual_table": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = [PLACEHOLDER-TYPE:STRING] OR T3.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["Identify the relevant tables, which are 'customers' and 'invoices'.", "Use a JOIN to connect the 'customers' table with the 'invoices' table based on the customer ID.", "Select the count of invoices to determine the number of orders.", "Add conditions to filter the customer based on their first and last names using placeholders."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "description": "The virtual table counts the number of invoices associated with a specific customer from the 'customers' and 'invoices' tables. The placeholders in the WHERE clause represent the first and last names of the customer whose orders are being counted.", "virtual_table": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.553", "db_id": "store_1", "question": "List every album ordered by album title in ascending order.", "rationale": ["Identify the relevant table, which is 'albums'.", "Select the column to display, 'title'.", "Add an order clause to sort the results by the 'title' column in ascending order."], "gold_sql": "SELECT title FROM albums ORDER BY title;", "source_tables": ["albums"], "description": "The virtual table lists the titles of albums from the 'albums' table, ordered in ascending order by their title. This allows users to view all album titles in a sorted manner without specifying any particular album.", "virtual_table": "SELECT title FROM albums ORDER BY title;"}
{"sample_id": "train.625", "db_id": "store_1", "question": "List name of all tracks in Balls to the Wall.", "rationale": ["Identify the relevant tables, which are 'albums' and 'tracks'.", "Select the column to display, which is 'name' from the 'tracks' table.", "Join the 'albums' table with the 'tracks' table using the album identifier.", "Add a condition to filter the 'title' column of the 'albums' table for the specified album using a placeholder for string values."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "description": "The virtual table lists the names of tracks from the 'tracks' table that belong to a specific album titled 'Balls to the Wall'. The query joins the 'albums' and 'tracks' tables based on the album's identifier, and filters the results using a placeholder for the album title.", "virtual_table": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["Identify the relevant table, which is 'customers'.", "Use the count function to determine the total number of customers.", "Add a condition to filter the 'state' column for the specified state using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "description": "The virtual table provides a count of customers from the 'customers' table who reside in a specific state. The placeholder in the WHERE clause represents the state name.", "virtual_table": "SELECT count(*) FROM customers WHERE state = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["Identify the relevant tables, which are 'albums' and 'tracks'.", "Select the column to display, which is 'title' from the 'albums' table.", "Join the 'albums' table with the 'tracks' table on the album identifier to associate tracks with their respective albums.", "Add a condition to filter the 'tracks' table for the specified track name using a placeholder for string values."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "description": "The virtual table provides the title of an album from the 'albums' table that contains a specific track from the 'tracks' table. The join condition links the album's identifier with the track's album identifier, while the placeholder in the WHERE clause represents the name of the track being queried.", "virtual_table": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.4939", "db_id": "store_product", "question": "What are the names of all products that are not the most frequently-used maximum page size?", "rationale": ["Identify the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add a condition to filter out products that match the most frequently used maximum page size using a subquery.", "The subquery groups the products by 'max_page_size', counts them, and orders them to find the most common size, with a placeholder for the limit."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "description": "The virtual table lists the names of products from the 'product' table that do not match the most frequently used maximum page size. The subquery identifies the maximum page size by counting occurrences and ordering them, with a placeholder representing the limit for the count of maximum page sizes.", "virtual_table": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4943", "db_id": "store_product", "question": "What are the names of the districts that have both mall and village store style shops?", "rationale": ["Identify the relevant tables: 'store', 'store_district', and 'district'.", "Join the 'store' table with 'store_district' to link stores to their respective districts.", "Join the resulting table with the 'district' table to access district names.", "Filter the results based on the store type for both mall and village using placeholders for string values.", "Use INTERSECT to ensure that only districts with both types of stores are returned."], "gold_sql": "SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  'City Mall' INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  'Village Store'", "source_tables": ["store_district", "store", "district"], "description": "The virtual table provides the names of districts that contain both mall and village store types. It combines data from the 'store', 'store_district', and 'district' tables, filtering for the specified store types using placeholders for string values. The use of INTERSECT ensures that only districts with both store types are included in the results.", "virtual_table": "SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["Identify the relevant table, which is 'product'.", "Select the column to display, 'max_page_size'.", "Group the results by 'max_page_size' to aggregate the data.", "Add a condition to filter the results using the HAVING clause to include only those page sizes that have more than a specified count of products, using a placeholder for numeric values."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "description": "The virtual table provides a list of maximum page sizes from the 'product' table, grouped by each unique page size. It includes only those page sizes that have more than a specified number of products associated with them, as indicated by the placeholder in the HAVING clause.", "virtual_table": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4925", "db_id": "store_product", "question": "What is the city with the most number of flagship stores?", "rationale": ["Identify the relevant tables: 'store', 'store_district', and 'district'.", "Join the tables on their respective identifiers to link stores with their districts.", "Group the results by the 'headquartered_city' to aggregate the count of stores per city.", "Order the results by the count of stores in descending order to find the city with the most flagship stores.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "description": "The virtual table provides a list of cities where flagship stores are headquartered, derived from the 'store', 'store_district', and 'district' tables. It groups the results by city and orders them by the count of flagship stores in descending order, allowing the user to identify the city with the highest number of such stores. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4931", "db_id": "store_product", "question": "What are the products with the maximum page size A4 that also have a pages per minute color smaller than 5?", "rationale": ["Identify the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add conditions to filter the 'max_page_size' column for a specific value and the 'pages_per_minute_color' column for a numeric threshold using placeholders."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "description": "The virtual table lists the names of products from the 'product' table that meet specific criteria regarding their maximum page size and print speed. The placeholders in the WHERE clause represent the maximum page size and the threshold for pages per minute color output.", "virtual_table": "SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4933", "db_id": "store_product", "question": "What are the products with the maximum page size eqal to A4 or a pages per minute color less than 5?", "rationale": ["Identify the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add conditions to filter the 'max_page_size' for a specific size and 'pages_per_minute_color' for a specific numeric value using placeholders."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "description": "The virtual table lists products from the 'product' table that either have a maximum page size equal to a specified size or have a print speed in pages per minute for color output that is less than a specified number. The placeholders in the WHERE clause allow for dynamic input of the maximum page size and pages per minute color values.", "virtual_table": "SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["Identify the relevant tables: 'store', 'store_district', and 'district'.", "Join the 'store' table with 'store_district' to link stores to their respective districts.", "Join the resulting table with the 'district' table to access city information.", "Group the results by the 'headquartered_city' to count the number of stores in each city.", "Order the results by the count of stores in descending order to find the city with the most stores.", "Use a placeholder in the LIMIT clause to allow for dynamic specification of how many top cities to return."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "description": "The virtual table summarizes the cities where stores are located, specifically focusing on the city with the highest number of stores. It aggregates the data from the 'store', 'store_district', and 'district' tables, grouping by the city names and ordering them by the count of stores in descending order. The placeholder in the LIMIT clause allows for specifying the number of top cities to retrieve.", "virtual_table": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4934", "db_id": "store_product", "question": "Find all the product whose name contains the word \"Scanner\".", "rationale": ["Identify the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add a condition to filter the 'product' column for names that contain the specified keyword using a placeholder for string values."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "description": "The virtual table contains the names of products from the 'product' table that include a specific keyword in their name. The placeholder in the WHERE clause is used to represent the keyword for filtering the product names.", "virtual_table": "SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4928", "db_id": "store_product", "question": "What products are available at store named \"Miramichi\"?", "rationale": ["Identify the relevant tables: 'product', 'store_product', and 'store'.", "Select the column to display, which is 'product' from the 'product' table.", "Join the 'store_product' table to link products with stores using 'product_id'.", "Join the 'store' table to filter by the store's name using a placeholder for string values."], "gold_sql": "SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  'Miramichi'", "source_tables": ["store", "store_product", "product"], "description": "The virtual table describes the products available in a specific store by joining the 'product', 'store_product', and 'store' tables. The placeholder in the WHERE clause represents the name of the store, allowing users to filter the results based on the store they are interested in.", "virtual_table": "SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["Identify the relevant tables: 'store', 'store_district', and 'district'.", "Select the column to display, which is 'store_name' from the 'store' table.", "Join the 'store' table with the 'store_district' table on 'store_id' to link stores with their districts.", "Join the 'store_district' table with the 'district' table on 'district_id' to access district information.", "Add a condition to filter the 'district_name' column for the specified district using a placeholder for string values."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "description": "The virtual table describes the names of stores from the 'store' table that are located in a specific district. It joins the 'store' table with the 'store_district' table to associate stores with their respective districts, and further joins with the 'district' table to filter by the district's name. The placeholder in the WHERE clause represents the name of the district being queried.", "virtual_table": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.81", "db_id": "student_assessment", "question": "How many registed students do each course have? List course name and the number of their registered students?", "rationale": ["Identify the relevant tables: 'Students', 'Student_Course_Registrations', and 'Courses'.", "Join the 'Students' table with 'Student_Course_Registrations' to associate students with their course registrations.", "Join the resulting table with the 'Courses' table to access course names.", "Group the results by course ID to count the number of registered students for each course, ensuring the course name is displayed alongside the count."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "description": "The virtual table summarizes the course names along with the count of registered students for each course. It combines data from the 'Students', 'Student_Course_Registrations', and 'Courses' tables, linking students to their respective course registrations and retrieving the course names. The count of students is aggregated for each course, providing a clear overview of student enrollment per course.", "virtual_table": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id"}
{"sample_id": "train.78", "db_id": "student_assessment", "question": "What are the details of the student who registered for the most number of courses?", "rationale": ["Identify the relevant tables, which are 'Students' and 'Student_Course_Registrations'.", "Select the 'student_details' column from the 'Students' table.", "Join the 'Students' table with the 'Student_Course_Registrations' table on the student ID.", "Group the results by student ID to count the number of course registrations for each student.", "Order the results in descending order based on the count of registrations to find the student with the most registrations.", "Limit the results using a placeholder for numeric values to specify how many top students to retrieve."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "The virtual table provides details of students from the 'Students' table who have registered for courses. It joins the 'Students' table with the 'Student_Course_Registrations' table to count the number of courses each student has registered for. The results are grouped by student ID and ordered in descending order based on the count of registrations, with a limit set by a placeholder for numeric values to specify how many top students to retrieve.", "virtual_table": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.59", "db_id": "student_assessment", "question": "What are the ids of the students who registered for some courses but had the least number of courses for all students?", "rationale": ["Identify the relevant table, which is 'Student_Course_Registrations'.", "Select the 'student_id' column to display the identifiers of students.", "Group the results by 'student_id' to aggregate course registrations for each student.", "Order the results by the count of courses registered to find those with the least registrations.", "Use a placeholder in the LIMIT clause to specify how many student IDs to return."], "gold_sql": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT 1", "source_tables": ["student_course_registrations"], "description": "The virtual table provides the identifiers of students from the 'Student_Course_Registrations' table who have registered for courses. It groups the results by student ID and orders them by the count of courses they have registered for, allowing for the identification of those with the least number of registrations. The placeholder in the LIMIT clause indicates the maximum number of student IDs to return.", "virtual_table": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.58", "db_id": "student_assessment", "question": "what is id of students who registered some courses but the least number of courses in these students?", "rationale": ["Identify the relevant table, which is 'Student_Course_Registrations'.", "Select the 'student_id' column to display the identifiers of students.", "Group the results by 'student_id' to aggregate course registrations for each student.", "Order the results by the count of courses registered to find those with the least registrations.", "Use a placeholder in the LIMIT clause to specify how many student IDs to return."], "gold_sql": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT 1", "source_tables": ["student_course_registrations"], "description": "The virtual table provides a list of student identifiers from the 'Student_Course_Registrations' table, grouped by each student. It orders the results based on the count of courses each student has registered for, allowing for the identification of students with the least number of course registrations. The placeholder in the LIMIT clause indicates the number of results to return, which can be adjusted as needed.", "virtual_table": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["Identify the relevant tables, which are 'Courses' and 'Student_Course_Registrations'.", "Select the 'course_name' from the 'Courses' table.", "Join the 'Courses' table with the 'Student_Course_Registrations' table on the course ID to link courses with their registrations.", "Group the results by course ID to count the number of registrations for each course.", "Order the results by the count of registrations in descending order to find the course with the most registrations.", "Add a limit to specify how many courses to return, using a placeholder for numeric values."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "description": "The virtual table provides the names of courses from the 'Courses' table that have the highest number of registered students. It aggregates the data by counting the registrations for each course and orders the results in descending order, allowing the user to specify a limit on the number of courses returned.", "virtual_table": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["Identify the relevant table, which is 'Student_Course_Registrations'.", "Select all columns to display the details of the students.", "Add a condition to filter out students whose IDs are present in the 'Student_Course_Attendance' table using a subquery with a NOT IN clause."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "description": "The virtual table contains all details of students from the 'Student_Course_Registrations' table who have registered for courses but have not attended any of them. The query uses a subquery to filter out students based on their attendance records, ensuring that only those who have no corresponding entries in the 'Student_Course_Attendance' table are included.", "virtual_table": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)"}
{"sample_id": "train.67", "db_id": "student_assessment", "question": "What is detail of the student who most recently registered course?", "rationale": ["Identify the relevant tables, which are 'Students' and 'Student_Course_Registrations'.", "Join the 'Student_Course_Registrations' table with the 'Students' table to access student details based on their registration.", "Order the results by the 'registration_date' in descending order to get the most recent registration at the top.", "Use a placeholder in the LIMIT clause to specify how many records to return."], "gold_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "The virtual table provides details of students from the 'Students' table who have registered for courses, specifically focusing on the most recent registration. The placeholder in the LIMIT clause indicates the number of records to return, allowing for flexibility in the query.", "virtual_table": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["Identify the relevant table, which is 'Student_Course_Attendance'.", "Select the column to display, 'student_id'.", "The query aims to retrieve all student IDs that have at least one attendance record, implying that the selection is based on existing entries in the attendance table."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "description": "The virtual table contains the identifiers of students from the 'Student_Course_Attendance' table who have participated in at least one course. This table focuses on the unique student IDs associated with course attendance records.", "virtual_table": "SELECT student_id FROM student_course_attendance"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["Identify the relevant tables: 'Addresses', 'People_Addresses', and 'Students'.", "Select the 'city' column from the 'Addresses' table and ensure distinct values are returned.", "Join the 'People_Addresses' table to link addresses to people, and then join the 'Students' table to filter for student-related addresses."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "description": "The virtual table provides a list of distinct cities from the addresses associated with students. It combines data from the 'Addresses', 'People_Addresses', and 'Students' tables to ensure that only unique city entries are retrieved for students' addresses.", "virtual_table": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id"}
{"sample_id": "dev.542", "db_id": "student_transcripts_tracking", "question": "What is the first, middle, and last name, along with the id and number of enrollments, for the student who enrolled the most in any program?", "rationale": ["Identify the relevant tables, which are 'Students' and 'Student_Enrolment'.", "Select the columns to display: 'student_id', 'first_name', 'middle_name', 'last_name', and a count of enrollments.", "Join the 'Students' table with the 'Student_Enrolment' table on the student ID to link students with their enrollments.", "Group the results by student ID to aggregate the count of enrollments for each student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Limit the results to a specific number using a placeholder for numeric values."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "description": "The virtual table provides information about students, including their unique identifier, first name, middle name, and last name, along with a count of their enrollments in various degree programs. The query aggregates the enrollment data by student and orders the results to identify the student with the highest number of enrollments, using a placeholder to limit the results to a specific number.", "virtual_table": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["Identify the relevant tables, which are 'Addresses' and 'Students'.", "Select the columns to display: 'address_id', 'line_1', and 'line_2' from the 'Addresses' table.", "Join the 'Addresses' table with the 'Students' table on the current address ID.", "Group the results by 'address_id' to aggregate student counts per address.", "Order the results in descending order based on the count of students to find the address with the most students.", "Use a placeholder in the LIMIT clause to specify the number of results to return."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "description": "The virtual table provides a summary of addresses from the 'Addresses' table that are currently associated with students. It includes the unique identifier for each address and the primary and secondary address lines. The results are grouped by address ID and ordered by the number of students linked to each address, allowing for the identification of the address with the highest student count. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables, which are 'Students' and 'Student_Enrolment'.", "Select the columns to display: student_id, first_name, middle_name, last_name, and the count of enrollments.", "Join the 'Students' table with the 'Student_Enrolment' table on the student_id to link students with their enrollments.", "Group the results by student_id to aggregate the enrollment counts for each student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Use a placeholder in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "description": "The virtual table provides information about students, including their unique identifiers, first names, middle names, and last names, along with a count of their enrollments in degree programs. The query aggregates the enrollment data by student, allowing for the identification of the student with the highest number of enrollments. The placeholder in the LIMIT clause specifies the maximum number of results to return.", "virtual_table": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant tables, which are 'Students' and 'Addresses'.", "Select the 'last_name' column from the 'Students' table.", "Join the 'Students' table with the 'Addresses' table to filter based on the current address.", "Add a condition to filter the 'state_province_county' column for the specified state using a placeholder for string values.", "Use the EXCEPT clause to exclude students who have registered in any degree programs by checking against the 'Student_Enrolment' table."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "description": "The virtual table provides the last names of students from the 'Students' table who currently reside in a specific state, while excluding those who are enrolled in any degree programs. The placeholder in the WHERE clause represents the state name, and the EXCEPT clause ensures that only students without any enrolment records are included.", "virtual_table": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id"}
{"sample_id": "dev.534", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?", "rationale": ["Identify the relevant table, which is 'Students', to retrieve student names and IDs.", "Join the 'Student_Enrolment' table to link students with their enrolment records.", "Group the results by student ID to aggregate enrolment counts.", "Use the HAVING clause to filter for students enrolled in exactly two degree programs, represented by a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "description": "The virtual table provides the first, middle, and last names, along with the unique identifiers of students from the 'Students' table who are enrolled in exactly two degree programs during a single semester. The placeholder in the HAVING clause indicates the number of degree programs the students must be enrolled in.", "virtual_table": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.533", "db_id": "student_transcripts_tracking", "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.", "rationale": ["Identify the relevant table, which is 'Students', to retrieve student names and IDs.", "Join the 'Student_Enrolment' table to associate students with their enrolment records.", "Group the results by student ID to aggregate enrolment counts.", "Use a HAVING clause to filter students based on the specified number of degree programs they are enrolled in, using a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "description": "The virtual table provides the first name, middle name, last name, and unique identifier of students from the 'Students' table who are enrolled in a specific number of degree programs during a single semester. The placeholder in the HAVING clause indicates the required count of degree programs for filtering the results.", "virtual_table": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.572", "db_id": "student_transcripts_tracking", "question": "What is the maximum number of times that a course shows up in different transcripts and what is that course's enrollment id?", "rationale": ["Identify the relevant table, which is 'Transcript_Contents'.", "Count the occurrences of each 'student_course_id' to determine how many times each course shows up in transcripts.", "Group the results by 'student_course_id' to aggregate the counts for each course.", "Order the results by the count in descending order to prioritize the most frequently appearing courses.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["transcript_contents"], "description": "The virtual table provides a count of how many times each course appears in different transcripts, along with the corresponding student course enrollment ID. The results are grouped by the student course ID and ordered by the count in descending order, allowing for the identification of the most frequently appearing course based on the specified limit.", "virtual_table": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table, which is 'Students'.", "Select the column to display, 'cell_mobile_number'.", "Add conditions to filter the 'first_name' and 'last_name' columns for the specified student using placeholders for string values."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "description": "The virtual table provides the mobile phone number of students from the 'Students' table based on their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the student being queried.", "virtual_table": "select cell_mobile_number from students where first_name  =  [PLACEHOLDER-TYPE:STRING] and last_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.584", "db_id": "student_transcripts_tracking", "question": "What are the first names of the students who live in Haiti permanently or have the cell phone number 09700166582 ?", "rationale": ["Identify the relevant tables, which are 'Students' and 'Addresses'.", "Select the column to display, which is 'first_name' from the 'Students' table.", "Join the 'Students' table with the 'Addresses' table on the permanent address identifier.", "Add conditions to filter the results based on the country of the address and the student's mobile phone number using placeholders for string values."], "gold_sql": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'", "source_tables": ["addresses", "students"], "description": "The virtual table provides the first names of students from the 'Students' table who either have a permanent address in a specific country or possess a specific mobile phone number. The placeholders in the WHERE clause allow for filtering based on the country and mobile number criteria.", "virtual_table": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.583", "db_id": "student_transcripts_tracking", "question": "Find the first name of the students who permanently live in the country Haiti or have the cell phone number 09700166582 .", "rationale": ["Identify the relevant tables, which are 'Students' and 'Addresses'.", "Select the column to display, 'first_name' from the 'Students' table.", "Join the 'Students' table with the 'Addresses' table on the permanent address identifier.", "Add conditions to filter the results based on the country of the address or the student's cell phone number using placeholders for string values."], "gold_sql": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'", "source_tables": ["addresses", "students"], "description": "The virtual table provides the first names of students from the 'Students' table who either have a permanent address in a specific country or possess a particular cell phone number. The placeholders in the WHERE clause allow for filtering based on the country and cell phone number criteria.", "virtual_table": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.578", "db_id": "student_transcripts_tracking", "question": "What are the different addresses that have students living there?", "rationale": ["Identify the relevant table, which is 'Students'.", "Count the distinct values of 'current_address_id' to determine the number of unique addresses.", "The query focuses on the current addresses of students, ensuring that only those addresses are counted."], "gold_sql": "SELECT count(DISTINCT current_address_id) FROM Students", "source_tables": ["students"], "description": "The virtual table provides a count of distinct addresses associated with students currently residing at those addresses. The placeholder in the query represents the unique identifier for the current address of each student, allowing for the identification of different addresses where students live.", "virtual_table": "SELECT count(DISTINCT current_address_id) FROM Students"}
{"sample_id": "dev.579", "db_id": "student_transcripts_tracking", "question": "List all the student details in reversed lexicographical order.", "rationale": ["Identify the relevant table, which is 'Students'.", "Select the column 'other_student_details' to display additional information about the students.", "Add an ORDER BY clause to sort the results in descending order, which represents reversed lexicographical order."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "description": "The virtual table contains the details of students from the 'Students' table, specifically focusing on any additional information related to each student. The results are sorted in reversed lexicographical order based on the additional details provided.", "virtual_table": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC"}
{"sample_id": "train.4328", "db_id": "tracking_grants_for_research", "question": "Find the organisation ids and details of the organisations which are involved in", "rationale": ["Identify the relevant tables, which are 'Grants' and 'Organisations'.", "Select the columns to display, 'organisation_id' and 'organisation_details' from the 'Organisations' table.", "Join the 'Grants' table with the 'Organisations' table on the 'organisation_id' to link grants to their respective organisations.", "Group the results by 'organisation_id' to aggregate the grant amounts for each organisation.", "Add a condition in the HAVING clause to filter organisations based on the total grant amount using a placeholder for numeric values."], "gold_sql": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  6000", "source_tables": ["grants", "organisations"], "description": "The virtual table provides the organisation IDs and details of organisations that are involved in grants, specifically those that have received a total grant amount exceeding a specified threshold. The query joins the 'Grants' and 'Organisations' tables based on the organisation ID, ensuring that only relevant organisations are included in the results. The placeholder in the HAVING clause allows for filtering based on the total grant amount received by each organisation.", "virtual_table": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4323", "db_id": "tracking_grants_for_research", "question": "What are the details of the project that is producing both patents and papers as outcomes?", "rationale": ["Identify the relevant table, which is 'Projects'.", "Select the column to display, 'project_details'.", "Join the 'Projects' table with 'Project_Outcomes' to link projects with their outcomes.", "Use an INTERSECT to filter projects that produce both specified outcomes, ensuring both conditions are met.", "Placeholders are used in the WHERE clauses to represent the outcome codes for patents and papers."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'", "source_tables": ["project_outcomes", "projects"], "description": "The virtual table provides details of projects from the 'Projects' table that are associated with specific outcomes, namely patents and papers. It utilizes an intersection of two queries to ensure that only projects producing both types of outcomes are included. The placeholders in the WHERE clauses represent the unique codes for the respective outcomes.", "virtual_table": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the relevant table, which is 'Project_Staff'.", "Select the columns to display, 'date_from' and 'date_to'.", "Use a subquery to find the project IDs with the most staff members by grouping and counting them, ordering by count in descending order, and limiting the results to a specified number.", "Add a condition to filter for staff members with a specific role code, ensuring that the role is a leadership position."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "description": "The virtual table provides the start and end dates of staff involvement in projects. It specifically focuses on projects that have the highest number of staff members, while also ensuring that at least one of those staff members holds a leadership role. The placeholders in the query allow for the specification of the number of top projects to consider and the role code for the leadership position.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4361", "db_id": "tracking_grants_for_research", "question": "What are the ids, types, and details of the organization with the most research staff?", "rationale": ["Identify the relevant tables, which are 'Organisations' and 'Research_Staff'.", "Select the columns to display: 'organisation_id', 'organisation_type', and 'organisation_details'.", "Join the 'Organisations' table with the 'Research_Staff' table on the organization ID to link research staff to their respective organizations.", "Group the results by 'organisation_id' to aggregate the count of research staff for each organization.", "Order the results by the count of research staff in descending order to find the organization with the most research staff.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "The virtual table provides the identifiers, types, and details of organizations that employ research staff. It aggregates the data from the 'Organisations' table and joins it with the 'Research_Staff' table to count the number of research staff associated with each organization. The results are sorted in descending order based on the count of research staff, allowing the user to identify the organization with the highest number of research staff, limited by a specified number of results.", "virtual_table": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables, which are 'Organisations' and 'Research_Staff'.", "Select the columns to display: 'organisation_id', 'organisation_type', and 'organisation_details'.", "Join the 'Organisations' table with the 'Research_Staff' table on the organisation ID to link the data.", "Group the results by 'organisation_id' to count the number of research staff per organisation.", "Order the results in descending order based on the count of research staff to identify the organisation with the most hires.", "Limit the results using a placeholder for numeric values to specify how many organisations to return."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "The virtual table provides a list of organisations along with their unique identifiers, types, and details, specifically focusing on those that have employed research staff. The data is aggregated to show the organisations with the highest number of research staff, with a limit set by a placeholder for numeric values to specify how many organisations to return.", "virtual_table": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4338", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects which did not hire any staff for a researcher role.", "rationale": ["Identify the relevant table, which is 'Projects'.", "Select the column to display, 'project_details'.", "Add a condition to filter projects that do not have any associated staff members for a specific role by using a subquery on the 'Project_Staff' table.", "Use a placeholder for the role code in the subquery to allow for dynamic input."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "description": "The virtual table provides the project details of projects from the 'Projects' table that have not hired any staff members for a specific researcher role. The placeholder in the subquery represents the role code for the researcher role, allowing users to specify which role they are interested in filtering out.", "virtual_table": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4332", "db_id": "tracking_grants_for_research", "question": "Which organisation type hires most research staff?", "rationale": ["Identify the relevant tables, which are 'Organisations' and 'Research_Staff'.", "Join the two tables on the organisation ID to link research staff to their respective organisations.", "Group the results by organisation type to count the number of research staff for each type.", "Order the results in descending order based on the count of research staff to identify which organisation type hires the most.", "Use a placeholder in the LIMIT clause to allow the user to specify how many organisation types to return."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "The virtual table provides a list of organisation types that employ research staff, sorted by the number of staff members associated with each type. The placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.", "virtual_table": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4377", "db_id": "tracking_grants_for_research", "question": "How many project members were leaders or started working before '1989-04-24 23:51:54'?", "rationale": ["Identify the relevant table, which is 'Project_Staff'.", "Select the count of records to display the total number of project members.", "Add conditions to filter the records based on the 'role_code' for leadership and 'date_from' for the start date using placeholders for string values."], "gold_sql": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'", "source_tables": ["project_staff"], "description": "The virtual table counts the number of project staff members from the 'Project_Staff' table who either hold a specific leadership role or began their involvement in a project before a certain date. The placeholders in the WHERE clause represent the role code and the date for filtering the results.", "virtual_table": "SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["Identify the relevant table, which is 'Project_Staff'.", "Select the column to display, 'role_code'.", "Add conditions to filter the 'date_from' and 'date_to' columns for the specified date range using placeholders for string values."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "description": "The virtual table provides a list of role codes for staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.", "virtual_table": "SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4372", "db_id": "tracking_grants_for_research", "question": "What are all the details of the organisations described as 'Sponsor'? Sort the result in an ascending order.", "rationale": ["Identify the relevant tables, which are 'Organisations' and 'Organisation_Types'.", "Select the column to display, 'organisation_details'.", "Join the two tables on the organisation type to filter the results based on the specified organisation type description using a placeholder for string values.", "Add an ORDER BY clause to sort the results in ascending order based on 'organisation_details'."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "description": "The virtual table provides details of organisations from the 'Organisations' table that are classified under a specific type, which is indicated by a description in the 'Organisation_Types' table. The results are sorted in ascending order based on the organisation details, with a placeholder for the organisation type description used in the filtering condition.", "virtual_table": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING] ORDER BY organisation_details"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["Identify the relevant table, which is 'Project_Staff'.", "Select the 'role_code' column to display the roles of staff members.", "Group the results by 'role_code' to aggregate the data based on roles.", "Order the results by the count of each role in descending order to find the most common role.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "description": "The virtual table summarizes the role codes of staff members from the 'Project_Staff' table, grouped by their roles. It orders the results by the frequency of each role, allowing users to identify the most common role among the staff. The placeholder in the LIMIT clause indicates the number of top roles to return.", "virtual_table": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["Identify the relevant table, which is 'Documents'.", "Select the 'grant_id' and count the number of documents for each grant using the COUNT function.", "Group the results by 'grant_id' to aggregate the document counts.", "Order the results in descending order based on the document count to find the grant with the most documents.", "Use a placeholder in the LIMIT clause to allow the user to specify how many top results they want."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "description": "The virtual table summarizes the number of documents associated with each grant ID from the 'Documents' table. It also identifies the grant ID that has the highest number of documents. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: 'Staff_Roles' for role descriptions and 'Project_Staff' for staff identifiers.", "Join 'Staff_Roles' with 'Project_Staff' on the role code to associate staff with their roles.", "Group the results by staff ID to aggregate the data for each staff member.", "Count the number of projects associated with each staff member's role and order the results in descending order to find the most involved roles.", "Limit the results based on a placeholder for numeric values to control the output size."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "description": "The virtual table provides the role descriptions of staff members along with their unique identifiers, specifically focusing on the roles that are associated with the highest number of projects. The results are grouped by staff ID and ordered by the count of projects in descending order, with a limit set by a placeholder for numeric values.", "virtual_table": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4350", "db_id": "tracking_grants_for_research", "question": "How many staff does each project has? List the project id and the number in an ascending order.", "rationale": ["Identify the relevant tables, which are 'Project_Staff' and 'Projects'.", "Select the 'project_id' from 'Project_Staff' and count the number of staff members associated with each project.", "Join 'Project_Staff' with 'Projects' on the 'project_id' to ensure the correct association between staff and projects.", "Group the results by 'project_id' to aggregate the staff count for each project.", "Order the results by the count of staff in ascending order."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "description": "The virtual table provides a count of staff members associated with each project from the 'Project_Staff' table. It includes the project ID and the total number of staff for each project, sorted in ascending order based on the staff count.", "virtual_table": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC"}
{"sample_id": "train.4393", "db_id": "tracking_grants_for_research", "question": "What roles did staff members play between '2003-04-19 15:06:20' and '2016-03-15 00:33:18'?", "rationale": ["Identify the relevant table, which is 'Project_Staff'.", "Select the column to display, 'role_code'.", "Add conditions to filter the 'date_from' and 'date_to' columns for the specified date range using placeholders for string values."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "description": "The virtual table describes the role codes of staff members from the 'Project_Staff' table who were involved in projects during a specified date range. The placeholders in the WHERE clause represent the start and end dates for filtering the records.", "virtual_table": "SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4396", "db_id": "tracking_grants_for_research", "question": "Which role is most common for the staff?", "rationale": ["Identify the relevant table, which is 'Project_Staff'.", "Select the 'role_code' column to display the roles of staff members.", "Group the results by 'role_code' to aggregate the counts of each role.", "Order the results by the count of each role in descending order to find the most common role.", "Use a placeholder in the LIMIT clause to specify how many top roles to return."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "description": "The virtual table summarizes the role codes of staff members from the 'Project_Staff' table, grouped by their role. It orders the results by the count of occurrences in descending order, allowing the user to identify the most common role among the staff. The placeholder in the LIMIT clause indicates the number of top roles to return.", "virtual_table": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4385", "db_id": "tracking_grants_for_research", "question": "What are the details for the projects which were launched by the organization with the most projects?", "rationale": ["Identify the relevant table, which is 'Projects'.", "Select the column to display, 'project_details'.", "Use a subquery to find the 'organisation_id' of the organization with the most projects by grouping and counting the projects, ordering them in descending order, and limiting the results to one organization."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "description": "The virtual table provides details of projects from the 'Projects' table that were launched by the organization with the highest number of projects. The placeholder in the subquery limits the results to the top organization based on project count.", "virtual_table": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables, which are 'Organisations' and 'Research_Staff'.", "Select the columns to display, 'organisation_type' and 'organisation_id'.", "Join the two tables on the organisation ID to link research staff to their respective organisations.", "Group the results by 'organisation_id' to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most staff.", "Add a limit to the results using a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "The virtual table provides the organisation type and identifier for organisations that employ research staff. It aggregates the data from the 'Organisations' and 'Research_Staff' tables, grouping by organisation ID to count the number of research staff associated with each organisation. The results are ordered by the count in descending order, allowing the user to identify the organisation with the highest number of research staff, with a placeholder to limit the number of results returned.", "virtual_table": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4342", "db_id": "tracking_grants_for_research", "question": "When do all the researcher role staff start to work, and when do they stop working?", "rationale": ["Identify the relevant table, which is 'Project_Staff'.", "Select the columns to display, 'date_from' and 'date_to', which represent the start and end dates of employment.", "Add a condition to filter the 'role_code' column for the specified researcher role using a placeholder for string values."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "description": "The virtual table provides the start and end dates of employment for staff members associated with projects, specifically filtering for those in a researcher role. The placeholder in the WHERE clause allows for the specification of the role code to identify the relevant staff members.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4337", "db_id": "tracking_grants_for_research", "question": "What is the response received date for the document described as Regular that was granted more than 100 dollars?", "rationale": ["Identify the relevant tables: 'Documents', 'Document_Types', and 'Grants'.", "Select the column 'response_received_date' from the 'Documents' table.", "Join 'Documents' with 'Document_Types' on 'document_type_code' to filter by document description.", "Join 'Documents' with 'Grants' on 'grant_id' to filter by grant amount.", "Add conditions in the WHERE clause to filter based on the specified document description and grant amount using placeholders."], "gold_sql": "SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  'Regular' OR T3.grant_amount  >  100", "source_tables": ["grants", "document_types", "documents"], "description": "The virtual table provides the response received date for documents from the 'Documents' table that are associated with a specific document type and grants exceeding a certain amount. The placeholders in the WHERE clause allow for filtering based on the document description and the grant amount.", "virtual_table": "SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4349", "db_id": "tracking_grants_for_research", "question": "What are the details for the project whose research has been published?", "rationale": ["Identify the relevant tables: 'Projects', 'Project_Outcomes', and 'Research_Outcomes'.", "Select the column to display, which is 'project_details' from the 'Projects' table.", "Join 'Projects' with 'Project_Outcomes' on 'project_id' to connect projects with their outcomes.", "Join 'Project_Outcomes' with 'Research_Outcomes' on 'outcome_code' to filter based on research outcomes.", "Add a condition to filter the results based on the 'outcome_description' using a placeholder for string values."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE '%Published%'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "description": "The virtual table provides details of projects from the 'Projects' table that have associated research outcomes published. It joins the 'Projects' table with the 'Project_Outcomes' table to link projects with their outcomes, and further joins with the 'Research_Outcomes' table to filter based on the description of the research outcome. The placeholder in the WHERE clause allows for specifying the desired outcome description.", "virtual_table": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4394", "db_id": "tracking_grants_for_research", "question": "What are the descriptions of all the project outcomes?", "rationale": ["Identify the relevant tables, which are 'Research_Outcomes' and 'Project_Outcomes'.", "Select the column to display, 'outcome_description' from 'Research_Outcomes'.", "Join the two tables on the 'outcome_code' to ensure that only matching outcomes are retrieved."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code", "source_tables": ["project_outcomes", "research_outcomes"], "description": "The virtual table provides the descriptions of project outcomes by joining the 'Research_Outcomes' and 'Project_Outcomes' tables. It retrieves the 'outcome_description' from 'Research_Outcomes' where the 'outcome_code' matches in both tables, allowing for a comprehensive view of the outcomes associated with various projects.", "virtual_table": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: 'Grants', 'Organisations', and 'Organisation_Types'.", "Select the sum of the 'grant_amount' from the 'Grants' table.", "Join the 'Grants' table with the 'Organisations' table using the organisation ID.", "Join the 'Organisations' table with the 'Organisation_Types' table to access the organisation type description.", "Add a condition to filter the organisation type description using a placeholder for string values."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "description": "The virtual table summarizes the total grant amount from the 'Grants' table for organisations classified under a specific type, which is defined in the 'Organisation_Types' table. The query joins the 'Grants' and 'Organisations' tables based on the organisation ID, and further joins with the 'Organisation_Types' table to filter organisations by their type description. The placeholder in the WHERE clause represents the description of the organisation type being queried.", "virtual_table": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4364", "db_id": "tracking_grants_for_research", "question": "Which document type is described with the prefix 'Initial'?", "rationale": ["Identify the relevant table, which is 'Document_Types'.", "Select the column to display, 'document_type_code'.", "Add a condition to filter the 'document_description' column using a placeholder for string values that represent the prefix."], "gold_sql": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'", "source_tables": ["document_types"], "description": "The virtual table provides the unique code for document types from the 'Document_Types' table that match a specific description pattern. The placeholder in the WHERE clause allows for filtering based on a description that includes a specified prefix.", "virtual_table": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4353", "db_id": "tracking_grants_for_research", "question": "What is the complete description of the job of a researcher?", "rationale": ["Identify the relevant table, which is 'Staff_Roles'.", "Select the column to display, 'role_description'.", "Add a condition to filter the 'role_code' column for the specified role using a placeholder for string values."], "gold_sql": "SELECT role_description FROM Staff_Roles WHERE role_code  =  'researcher'", "source_tables": ["staff_roles"], "description": "The virtual table provides the descriptions of roles from the 'Staff_Roles' table based on a specific role code. The placeholder in the WHERE clause represents the unique code for the role of a researcher.", "virtual_table": "SELECT role_description FROM Staff_Roles WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant tables: 'Research_Outcomes', 'Project_Outcomes', and 'Projects'.", "Select the column to display, which is 'outcome_description' from 'Research_Outcomes'.", "Join 'Research_Outcomes' with 'Project_Outcomes' on the outcome code to link outcomes to projects.", "Join 'Project_Outcomes' with 'Projects' on the project ID to filter by project details.", "Add a condition to filter the 'project_details' column for the specified project detail using a placeholder for string values."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "description": "The virtual table describes the outcome descriptions of projects from the 'Research_Outcomes' table that are linked to specific projects in the 'Projects' table. The placeholder in the WHERE clause represents the detailed description of the project being queried.", "virtual_table": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["Identify the relevant table, which is 'Transactions'.", "Select the columns to display, including 'transaction_type_code', maximum share count, and minimum share count.", "Use the GROUP BY clause to aggregate the results based on 'transaction_type_code', allowing for the calculation of maximum and minimum share counts for each transaction type."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "description": "The virtual table summarizes the maximum and minimum share counts associated with various transaction types from the 'Transactions' table. The placeholder in the GROUP BY clause represents the unique transaction type codes, allowing for aggregation of share counts for each type.", "virtual_table": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["Identify the relevant tables, which are 'Sales' and 'Purchases'.", "Select the column 'sales_details' from the 'Sales' table and 'purchase_details' from the 'Purchases' table.", "Use the UNION operator to combine the results from both tables into a single virtual table."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "description": "The virtual table combines details of sales transactions from the 'Sales' table and purchase transactions from the 'Purchases' table. It provides a unified view of the sales and purchase details, allowing for easy comparison and analysis of both types of transactions.", "virtual_table": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases"}
{"sample_id": "train.5865", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions whose share count is bigger than 100 and whose type code is \"PUR\"?", "rationale": ["Identify the relevant tables: 'Lots', 'Transactions_Lots', and 'Transactions'.", "Select the column to display, which is 'lot_details' from the 'Lots' table.", "Join the 'Lots' table with 'Transactions_Lots' to link lots to transactions.", "Join the 'Transactions_Lots' table with 'Transactions' to access transaction details.", "Add conditions to filter transactions based on share count and transaction type code, using placeholders for the respective values."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  100 AND T3.transaction_type_code  =  'PUR'", "source_tables": ["lots", "transactions_lots", "transactions"], "description": "The virtual table provides the lot details from the 'Lots' table for lots that are linked to transactions meeting specific criteria. It filters transactions based on a minimum share count and a specific transaction type code, using placeholders for the numeric share count and the string transaction type code.", "virtual_table": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["Identify the relevant table, which is 'Investors'.", "Select the column to display, 'Investor_details'.", "No filtering conditions are needed since the request is to show all investor details."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "description": "The virtual table contains detailed information about investors from the 'Investors' table. The query retrieves all entries in the 'Investor_details' column, providing a comprehensive view of each investor's information.", "virtual_table": "SELECT Investor_details FROM INVESTORS"}
{"sample_id": "train.5851", "db_id": "tracking_share_transactions", "question": "Show all dates of transactions whose type code is \"SALE\".", "rationale": ["Identify the relevant table, which is 'Transactions'.", "Select the column to display, 'date_of_transaction'.", "Add a condition to filter the 'transaction_type_code' column for the specified transaction type using a placeholder for string values."], "gold_sql": "SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  'SALE'", "source_tables": ["transactions"], "description": "The virtual table displays the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code, allowing users to filter the results based on their input.", "virtual_table": "SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the distinct 'Fname' column from the 'Student' table.", "Join the 'Student' table with the 'Voting_record' table on the condition that the 'StuID' matches the 'Vice_President_Vote'.", "Use the EXCEPT clause to exclude students whose 'city_code' matches the specified value, utilizing a placeholder for the city code."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "description": "The virtual table presents the distinct first names of students who have cast votes for the vice president, while excluding those who reside in a specific city. The query utilizes a join between the 'Student' and 'Voting_record' tables based on the student identifier, and it incorporates a condition to filter out students based on their city code using a placeholder for string values.", "virtual_table": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5497", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes but do not have 2192 as the advisor?", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the distinct last names from the 'Student' table.", "Join the 'Student' table with the 'Voting_record' table based on the student ID and the presidential vote.", "Use an EXCEPT clause to filter out students who have a specific advisor, using a placeholder for the advisor's name."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "description": "The virtual table describes the distinct last names of students from the 'Student' table who have cast votes for the presidential candidate in the 'Voting_record' table, while excluding those students whose advisor is a specific individual. The placeholders in the query represent the advisor's name.", "virtual_table": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the column to display, 'Major'.", "Add a condition to filter the 'Sex' column for female students using a placeholder for string values.", "Group the results by the 'Major' column to aggregate the data.", "Order the results by the count of each major in descending order to find the most common one.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "The virtual table summarizes the majors of female students from the 'Student' table. It groups the results by major and orders them by their frequency in descending order, allowing for the identification of the most common major among this demographic. The placeholders in the WHERE clause and the LIMIT clause represent the gender and the number of results to return, respectively.", "virtual_table": "SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5483", "db_id": "voter_2", "question": "What are the first and last names of all the female students who have president votes?", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the columns to display, 'Fname' and 'LName' from the 'Student' table.", "Join the 'Student' table with the 'Voting_record' table on the 'StuID' to link students with their voting records.", "Add a condition to filter the 'Sex' column for female students using a placeholder for string values.", "Ensure that the voting record includes a vote for the president by checking the 'President_Vote' column."], "gold_sql": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  'F'", "source_tables": ["student", "voting_record"], "description": "The virtual table describes the first and last names of female students from the 'Student' table who have cast votes for the presidential candidate. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5485", "db_id": "voter_2", "question": "What are the first names and last names of the students who are 18 years old and have vice president votes.", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the columns to display, 'Fname' and 'LName' from the 'Student' table.", "Join the 'Student' table with the 'Voting_record' table on the condition that the student's ID matches the vice president vote.", "Add a condition to filter the 'Age' column for students who are 18 years old using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  18", "source_tables": ["student", "voting_record"], "description": "The virtual table describes the distinct first and last names of students from the 'Student' table who are 18 years old and have cast votes for the vice president. The placeholder in the WHERE clause represents the age of the students.", "virtual_table": "SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the column to display, 'Major'.", "Add a condition to filter the 'Sex' column for female students using a placeholder for string values.", "Group the results by 'Major' to aggregate the counts of female students in each major.", "Order the results by the count of students in descending order to find the most popular major.", "Limit the results to return only the top entry using a placeholder for numeric values."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "The virtual table summarizes the majors studied by students from the 'Student' table, specifically filtering for female students. It groups the results by major and orders them by the count of female students in descending order, allowing for the identification of the major with the highest enrollment of female students. The placeholders represent the gender and the limit for the number of results returned.", "virtual_table": "SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5508", "db_id": "voter_2", "question": "Which major has the most students?", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the 'Major' column to group by.", "Use the COUNT function to count the number of students in each major.", "Order the results in descending order based on the count of students.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "The virtual table summarizes the majors of students from the 'Student' table, grouping them to count the number of students in each major. The result is ordered in descending order based on the count, allowing the identification of the major with the highest number of students. The placeholder in the LIMIT clause indicates the maximum number of results to return.", "virtual_table": "SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["Identify the relevant table, which is 'Voting_record'.", "Select the column to display, 'President_Vote', ensuring that only distinct values are retrieved.", "Add a condition to filter the 'Registration_Date' column for the specified date using a placeholder for string values."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "description": "The virtual table presents the distinct presidential votes recorded in the 'Voting_record' table for a specific registration date. The placeholder in the WHERE clause represents the date of registration for filtering the votes.", "virtual_table": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5478", "db_id": "voter_2", "question": "Find the distinct Advisor of students who have treasurer votes in the spring election cycle.", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the distinct column 'Advisor' from the 'Student' table.", "Join the 'Student' table with the 'Voting_record' table on the 'StuID' and 'Treasurer_Vote' columns to link students with their voting records.", "Add a condition to filter the 'Election_Cycle' column for the specified cycle using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "The virtual table describes the distinct advisors of students from the 'Student' table who have cast votes for the treasurer in the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the column to calculate the average, which is 'Age' from the 'Student' table.", "Join the 'Student' table with the 'Voting_record' table on the 'StuID' to link students with their voting records.", "Add conditions to filter students based on the specified city code and the election cycle using placeholders for string values."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "The virtual table calculates the average age of students from the 'Student' table who reside in a specific city and have cast votes for the secretary position in a particular election cycle. The placeholders in the WHERE clause represent the city code and the election cycle identifier.", "virtual_table": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5477", "db_id": "voter_2", "question": "What are the distinct ages of students who have secretary votes in the fall election cycle?", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the 'Age' column from the 'Student' table and ensure distinct values are returned.", "Join the 'Student' table with the 'Voting_record' table on the 'StuID' to link students with their voting records.", "Add a condition to filter the results based on the 'Election_Cycle' column using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "description": "The virtual table presents the distinct ages of students from the 'Student' table who have cast votes for the secretary position in the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5465", "db_id": "voter_2", "question": "Return all the distinct secretary votes made in the fall election cycle.", "rationale": ["Identify the relevant table, which is 'Voting_record'.", "Select the column to display, 'Secretary_Vote', ensuring that only distinct values are returned.", "Add a condition to filter the 'Election_Cycle' column for the specified election cycle using a placeholder for string values."], "gold_sql": "SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  'Fall'", "source_tables": ["voting_record"], "description": "The virtual table contains distinct votes cast for the secretary position from the voting records associated with students. The placeholder in the WHERE clause represents the specific election cycle during which these votes were recorded.", "virtual_table": "SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the 'Advisor' column from the 'Student' table, ensuring distinct values are returned.", "Join the 'Student' table with the 'Voting_record' table on the 'StuID' to link students with their voting records.", "Add a condition to filter the results based on the 'Election_Cycle' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "The virtual table provides a list of unique advisors for students who participated in the treasurer voting during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5487", "db_id": "voter_2", "question": "Count the number of male students who had class senator votes in the fall election cycle.", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Join the 'Student' table with the 'Voting_record' table on the 'StuID' and 'Class_Senator_Vote' columns to link students with their voting records.", "Count the total number of records that meet the criteria of being male and having participated in the specified election cycle, using placeholders for the gender and election cycle."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "description": "The virtual table counts the number of male students from the 'Student' table who participated in the voting for class senator during a specific election cycle. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.", "virtual_table": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5475", "db_id": "voter_2", "question": "What are the distinct first names of the students who have class president votes?", "rationale": ["Identify the relevant tables, which are 'Student' and 'Voting_record'.", "Select the distinct 'Fname' column from the 'Student' table.", "Join the 'Student' table with the 'Voting_record' table using the 'StuID' to filter for students who have class president votes."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE", "source_tables": ["student", "voting_record"], "description": "The virtual table presents the distinct first names of students from the 'Student' table who have participated in voting for class president. The join condition links the 'Student' table with the 'Voting_record' table based on the unique student identifier, ensuring that only those students who have cast a vote for class president are included in the results.", "virtual_table": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE"}
{"sample_id": "train.5457", "db_id": "voter_2", "question": "List the major of each male student.", "rationale": ["Identify the relevant table, which is 'Student'.", "Select the column to display, 'Major'.", "Add a condition to filter the 'Sex' column for male students using a placeholder for string values."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'M'", "source_tables": ["student"], "description": "The virtual table provides a list of majors for male students from the 'Student' table. The placeholder in the WHERE clause is used to specify the gender of the students being queried.", "virtual_table": "SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6582", "db_id": "wine_1", "question": "What are the countries for appelations with at most 3 wines?", "rationale": ["Identify the relevant tables, which are 'appellations' and 'wine'.", "Select the 'County' column from the 'appellations' table.", "Join the 'appellations' table with the 'wine' table on the 'Appelation' column to correlate wines with their respective appellations.", "Group the results by the 'Appelation' to aggregate the wine counts for each appellation.", "Add a condition in the HAVING clause to filter for appellations that have a count of wines less than or equal to the specified placeholder."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation GROUP BY T2.Appelation HAVING count(*)  <=  3", "source_tables": ["wine", "appellations"], "description": "The virtual table provides a list of counties associated with appellations that have a limited number of wines, specifically those with three or fewer entries. The placeholder in the HAVING clause allows for the specification of the maximum number of wines per appellation.", "virtual_table": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation GROUP BY T2.Appelation HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6547", "db_id": "wine_1", "question": "Find the the grape whose white color grapes are used to produce wines with scores higher than 90.", "rationale": ["Identify the relevant tables, which are 'grapes' and 'wine'.", "Select the distinct column 'Grape' from the 'grapes' table.", "Join the 'grapes' table with the 'wine' table on the 'Grape' column to correlate grape varieties with their respective wines.", "Add a condition to filter the 'Color' column for white grapes using a placeholder for string values.", "Add another condition to filter the 'Score' column for wines with scores higher than a specified number using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White' AND T2.score  >  90", "source_tables": ["wine", "grapes"], "description": "The virtual table describes the distinct grape varieties from the 'grapes' table that are white in color and are used to produce wines with a score greater than a specified threshold. The placeholders in the WHERE clause represent the color of the grapes and the minimum score for the wines.", "virtual_table": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.score  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6597", "db_id": "wine_1", "question": "Find the county where produces the most number of wines with score higher than 90.", "rationale": ["Identify the relevant tables, which are 'appellations' and 'wine'.", "Join the two tables on the appellation column to combine their data.", "Select the 'County' column from the 'appellations' table.", "Add a condition to filter the wines based on their score using a placeholder for numeric values.", "Group the results by county to count the number of wines per county.", "Order the results in descending order based on the count of wines and limit the output to a specified number using placeholders."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1", "source_tables": ["wine", "appellations"], "description": "The virtual table provides information about the counties associated with appellations that produce wines scoring above a certain threshold. It aggregates the data to identify which county has the highest number of such wines, using placeholders to specify the score limit and the number of results to return.", "virtual_table": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.County ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6588", "db_id": "wine_1", "question": "Which 3 wineries produce the most wines made from white grapes?", "rationale": ["Identify the relevant tables, which are 'grapes' and 'wine'.", "Join the two tables on the grape variety to connect the wine entries with their corresponding grape types.", "Filter the results to include only those wines made from grapes of a specific color, using a placeholder for string values.", "Group the results by winery to aggregate the count of wines produced by each winery.", "Order the results in descending order based on the count of wines to identify the top producers.", "Limit the output to a specified number of wineries using a placeholder for numeric values."], "gold_sql": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  'White' GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3", "source_tables": ["wine", "grapes"], "description": "The virtual table provides a list of wineries that produce wines made from a specific color of grapes, in this case, white grapes. It joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the color of the grapes, groups the results by winery, and orders them by the count of wines produced, limiting the output to a specified number of wineries.", "virtual_table": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6566", "db_id": "wine_1", "question": "Give the color of the grape whose wine products have the highest average price?", "rationale": ["Identify the relevant tables, which are 'grapes' and 'wine'.", "Select the 'Color' column from the 'grapes' table.", "Join the 'grapes' table with the 'wine' table on the grape variety.", "Group the results by grape variety to calculate the average price of wines for each grape.", "Order the results by the average price in descending order to find the highest priced wines.", "Add a limit placeholder to specify how many results to return."], "gold_sql": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT 1", "source_tables": ["wine", "grapes"], "description": "The virtual table describes the color of grape varieties from the 'grapes' table that are associated with wines from the 'wine' table. The results are grouped by grape variety, and the ordering is based on the average price of the wines, with a placeholder indicating the limit for the number of results returned.", "virtual_table": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6544", "db_id": "wine_1", "question": "Give the names and scores of wines made from white grapes.", "rationale": ["Identify the relevant tables, which are 'grapes' and 'wine'.", "Join the 'grapes' table with the 'wine' table on the 'Grape' column to associate each wine with its corresponding grape variety.", "Select the columns to display, which are 'Name' and 'Score' from the 'wine' table.", "Add a condition to filter the 'Color' column in the 'grapes' table for white grapes using a placeholder for string values."], "gold_sql": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White'", "source_tables": ["wine", "grapes"], "description": "The virtual table presents the names and scores of wines derived from specific grape varieties categorized as white grapes. The placeholder in the WHERE clause is used to filter the grape color, allowing users to specify the desired color of grapes.", "virtual_table": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6543", "db_id": "wine_1", "question": "What are the names and scores of wines that are made of white color grapes?", "rationale": ["Identify the relevant tables, which are 'grapes' and 'wine'.", "Join the 'grapes' table with the 'wine' table on the 'Grape' column to link grape varieties with their corresponding wines.", "Select the columns to display, 'Name' and 'Score' from the 'wine' table.", "Add a condition to filter the 'Color' column in the 'grapes' table for the specified color using a placeholder for string values."], "gold_sql": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White'", "source_tables": ["wine", "grapes"], "description": "The virtual table describes the names and scores of wines from the 'wine' table that are produced using grape varieties from the 'grapes' table, specifically those that are classified as white grapes. The placeholder in the WHERE clause represents the color of the grapes.", "virtual_table": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6533", "db_id": "wine_1", "question": "List the names of all distinct wines that are made of red color grape.", "rationale": ["Identify the relevant tables, which are 'grapes' and 'wine'.", "Select the distinct 'Name' column from the 'wine' table.", "Join the 'grapes' table with the 'wine' table on the 'Grape' column.", "Add a condition to filter the 'Color' column in the 'grapes' table for red grapes using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red'", "source_tables": ["wine", "grapes"], "description": "The virtual table lists the distinct names of wines produced from grape varieties that are classified as red. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes with a specified color, represented by a placeholder.", "virtual_table": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6531", "db_id": "wine_1", "question": "List the names of all distinct wines that have scores higher than 90.", "rationale": ["Identify the relevant table, which is 'wine'.", "Select the column to display, 'Name'.", "Add a condition to filter the 'Score' column for values greater than a specified number using a placeholder for numeric values."], "gold_sql": "SELECT Name FROM WINE WHERE score  >  90", "source_tables": ["wine"], "description": "The virtual table lists the names of wines from the 'wine' table that have a score exceeding a specified threshold. The placeholder in the WHERE clause represents the minimum score required to filter the wines.", "virtual_table": "SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6517", "db_id": "wine_1", "question": "What is the name of the highest rated wine?", "rationale": ["Identify the relevant table, which is 'wine'.", "Select the column to display, 'Name'.", "Order the results by the 'Score' column to find the highest rated wine.", "Use a placeholder in the LIMIT clause to specify how many top results to return."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "description": "The virtual table provides the names of wines from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause indicates the number of top-rated wines to retrieve.", "virtual_table": "SELECT Name FROM WINE ORDER BY Score LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6560", "db_id": "wine_1", "question": "What are the names of wines, sorted in alphabetical order?", "rationale": ["Identify the relevant table, which is 'wine'.", "Select the column to display, 'Name', ensuring that only distinct entries are shown.", "Add an ORDER BY clause to sort the results alphabetically by the 'Name' column."], "gold_sql": "SELECT DISTINCT Name FROM WINE ORDER BY Name", "source_tables": ["wine"], "description": "The virtual table lists the distinct names of wines from the 'wine' table, sorted in alphabetical order. This allows users to view all unique wine names without duplicates, organized for easy reference.", "virtual_table": "SELECT DISTINCT Name FROM WINE ORDER BY Name"}
{"sample_id": "train.6520", "db_id": "wine_1", "question": "What is the winery at which the wine with the highest score was made?", "rationale": ["Identify the relevant table, which is 'wine'.", "Select the column to display, 'Winery'.", "Order the results by the 'Score' column in descending order to find the highest score.", "Limit the results to one entry using a placeholder for numeric values."], "gold_sql": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1", "source_tables": ["wine"], "description": "The virtual table provides information about the winery associated with the highest-rated wine from the 'wine' table. The query orders the wines by their score and limits the result to the top entry, represented by a placeholder for numeric values.", "virtual_table": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.783", "db_id": "world_1", "question": "Return the codes of countries that do not speak English and do not have Republics for governments.", "rationale": ["Identify the relevant tables, which are 'country' and 'countrylanguage'.", "Select the 'Code' column from the 'country' table.", "Add a condition to filter out countries with a specific government form using a placeholder for string values.", "Use the EXCEPT clause to exclude countries that have English as a spoken language, represented by a placeholder for the language."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "description": "The virtual table provides a list of country codes from the 'country' table that do not have a government form classified as a Republic and are not associated with the English language in the 'countrylanguage' table. The placeholders in the query represent the specific government form and language to filter the results accordingly.", "virtual_table": "SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.777", "db_id": "world_1", "question": "What are the Asian countries which have a population larger than that of any country in Africa?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the column to display, 'Name'.", "Add a condition to filter the 'Continent' column for the specified continent using a placeholder for string values.", "Include a subquery to find the minimum population of countries in another specified continent, ensuring the population condition is met."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Asia'  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  'Africa')", "source_tables": ["country"], "description": "The virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of any country in another specified continent. The placeholders in the query represent the continent names for filtering the results accordingly.", "virtual_table": "SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.820", "db_id": "world_1", "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?", "rationale": ["Identify the relevant table, which is 'countrylanguage'.", "Select the column 'CountryCode' and the maximum value of 'Percentage' to find the highest percentage of speakers.", "Add a condition to filter the 'Language' column for the specified language using a placeholder for string values.", "Group the results by 'CountryCode' to ensure we get the maximum percentage for each country."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "description": "The virtual table provides the country codes of countries where a specific language is spoken, specifically focusing on the maximum percentage of speakers for that language. The placeholder in the WHERE clause allows for the specification of the language in question, while the GROUP BY clause organizes the results by country code to identify the highest percentage of speakers.", "virtual_table": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode"}
{"sample_id": "dev.767", "db_id": "world_1", "question": "How many people live in countries that do not speak English?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the column to display, which is the sum of the 'Population'.", "Add a condition to filter countries based on the absence of English as an official language using a subquery that joins 'country' and 'countrylanguage' tables.", "The placeholder in the subquery represents the language to be excluded."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "description": "The virtual table summarizes the total population of countries from the 'country' table that do not have English as an official language. It uses a subquery to filter out countries where English is spoken, represented by a placeholder for the language name.", "virtual_table": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.796", "db_id": "world_1", "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.", "rationale": ["Identify the relevant table, which is 'country'.", "Select the columns to display, which are the sum of the 'Population' and 'GovernmentForm'.", "Group the results by 'GovernmentForm' to aggregate the population for each type of government.", "Add a condition in the HAVING clause to filter the groups based on the average life expectancy using a placeholder for numeric values."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "description": "The virtual table summarizes the total population and the government form for each type of government in the 'country' table, specifically for those governments where the average life expectancy exceeds a certain threshold. The placeholder in the HAVING clause represents the minimum average life expectancy required for inclusion in the results.", "virtual_table": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the column 'GovernmentForm' to group the results by different forms of government.", "Use the 'Population' column to calculate the total population for each government form.", "Add a condition to filter the results based on the average life expectancy using a placeholder for numeric values."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "description": "The virtual table summarizes the total population of countries grouped by their government forms, specifically for those government forms that have an average life expectancy exceeding a certain threshold. The placeholder in the HAVING clause represents the minimum average life expectancy required for inclusion in the results.", "virtual_table": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.799", "db_id": "world_1", "question": "What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy less than 72?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the columns to display: total population (using sum) and average life expectancy (using avg), along with the continent name.", "Group the results by continent to aggregate the population and life expectancy data.", "Add a condition to filter the results based on the average life expectancy being less than a specified numeric value using a placeholder."], "gold_sql": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  72", "source_tables": ["country"], "description": "The virtual table summarizes the total population and average life expectancy for each continent from the 'country' table. It groups the data by continent and filters the results to include only those continents where the average life expectancy is below a specified threshold, represented by a placeholder for numeric values.", "virtual_table": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.782", "db_id": "world_1", "question": "What are the codes of the countries that do not speak English and whose government forms are not Republic?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the 'Code' column to display the country codes.", "Add a condition to filter the 'GovernmentForm' column for values that are not equal to the specified government form using a placeholder for string values.", "Use the EXCEPT clause to exclude country codes that are associated with the English language in the 'countrylanguage' table, using a placeholder for the language."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "description": "The virtual table provides a list of country codes from the 'country' table that do not have a government form classified as a Republic and are not associated with the English language in the 'countrylanguage' table. The placeholders in the query allow for the specification of the government form and language to filter the results accordingly.", "virtual_table": "SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.754", "db_id": "world_1", "question": "What are the countries where either English or Dutch is the official language ?", "rationale": ["Identify the relevant tables, which are 'country' and 'countrylanguage'.", "Select the column to display, which is 'name' from the 'country' table.", "Join the 'country' table with the 'countrylanguage' table on the country code.", "Add conditions to filter for the specified languages (English and Dutch) and check if they are official languages using placeholders for string values."], "gold_sql": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'english' and isofficial  =  't' union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'dutch' and isofficial  =  't'", "source_tables": ["country", "countrylanguage"], "description": "The virtual table lists the names of countries from the 'country' table that have either English or Dutch as an official language. The query combines results from two separate conditions using a union, where each condition checks for a specific language and its official status using placeholders for the language names and their official status.", "virtual_table": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING] union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.758", "db_id": "world_1", "question": "Which languages are spoken by only one country in republic governments?", "rationale": ["Identify the relevant tables, which are 'country' and 'countrylanguage'.", "Join the 'country' table with the 'countrylanguage' table on the country code to associate languages with their respective countries.", "Filter the results to include only those countries with a republican form of government using a placeholder for string values.", "Group the results by language to count how many countries speak each language.", "Use a HAVING clause to filter the grouped results to include only those languages that are spoken by exactly one country, using a placeholder for numeric values."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "description": "The virtual table describes the languages spoken in countries that have a republican form of government, specifically focusing on those languages that are unique to only one country. The placeholders in the WHERE clause represent the type of government and the count of countries speaking each language.", "virtual_table": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.821", "db_id": "world_1", "question": "Return the codes of countries for which Spanish is the predominantly spoken language.", "rationale": ["Identify the relevant table, which is 'countrylanguage'.", "Select the column 'CountryCode' and the maximum 'Percentage' to find the predominant language spoken in each country.", "Add a condition to filter the 'Language' column for the specified language using a placeholder for string values.", "Group the results by 'CountryCode' to ensure each country is represented only once."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "description": "The virtual table provides the country codes of countries where a specific language, in this case, Spanish, is predominantly spoken. It aggregates the data by country code and uses a placeholder to specify the language of interest, allowing users to filter for any language they choose.", "virtual_table": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the 'Population' column to calculate the total number of people.", "Add a condition to exclude countries that use English by using a subquery that joins 'country' and 'countrylanguage' tables, filtering for the specified language using a placeholder for string values."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "description": "The virtual table summarizes the total population of countries that do not have English as an official language. It utilizes a subquery to filter out countries where English is spoken, ensuring that only the populations of non-English speaking nations are included in the sum.", "virtual_table": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.723", "db_id": "world_1", "question": "How many people live in Asia, and what is the largest GNP among them?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the columns to display, which are the sum of the 'Population' and the maximum 'GNP'.", "Add a condition to filter the 'Continent' column for the specified continent using a placeholder for string values."], "gold_sql": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  'Asia'", "source_tables": ["country"], "description": "The virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name, allowing users to specify which continent they are interested in.", "virtual_table": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.778", "db_id": "world_1", "question": "What are the country codes for countries that do not speak English?", "rationale": ["Identify the relevant table, which is 'countrylanguage'.", "Select the column to display, 'CountryCode'.", "Use the EXCEPT clause to filter out country codes where the specified language is spoken, utilizing a placeholder for string values."], "gold_sql": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["countrylanguage"], "description": "The virtual table provides a list of country codes from the 'countrylanguage' table, excluding those countries where English is spoken. The placeholder in the query represents the language to be filtered out, allowing users to specify any language they wish to exclude from the results.", "virtual_table": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.742", "db_id": "world_1", "question": "Which continent has the most diverse languages?", "rationale": ["Identify the relevant tables, which are 'country' and 'countrylanguage'.", "Join the two tables on the country code to relate countries to their languages.", "Group the results by continent to count the number of languages for each continent.", "Order the results in descending order based on the count of languages to find the most diverse continent.", "Use a placeholder in the LIMIT clause to allow the user to specify how many top continents to return."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "description": "The virtual table summarizes the continents along with the count of diverse languages spoken in each continent. It joins the 'country' table with the 'countrylanguage' table to aggregate the number of languages per continent. The placeholder in the LIMIT clause allows for specifying the number of top continents to retrieve based on language diversity.", "virtual_table": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the distinct values of the 'GovernmentForm' column to count the different forms of government.", "Add a condition to filter the 'Continent' column for the specified continent using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "description": "The virtual table provides a count of the distinct forms of government found in countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name, allowing users to specify 'Africa' or any other continent as needed.", "virtual_table": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.734", "db_id": "world_1", "question": "How many type of governments are in Africa?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the distinct values of the 'GovernmentForm' column to count the different types of governments.", "Add a condition to filter the 'Continent' column for the specified continent using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "description": "The virtual table provides a count of distinct types of government forms present in countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name, allowing users to specify which continent they are interested in.", "virtual_table": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.779", "db_id": "world_1", "question": "Return the country codes for countries that do not speak English.", "rationale": ["Identify the relevant table, which is 'countrylanguage'.", "Select the column to display, 'CountryCode'.", "Use the EXCEPT clause to filter out country codes where the specified language is spoken, using a placeholder for string values."], "gold_sql": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["countrylanguage"], "description": "The virtual table provides a list of country codes from the 'countrylanguage' table, excluding those countries where English is spoken. The placeholder in the query represents the language to be excluded, which in this case is English.", "virtual_table": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.730", "db_id": "world_1", "question": "What is the average GNP and total population in all nations whose government is US territory?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the columns to display, which are the average GNP and the sum of the population.", "Add a condition to filter the 'GovernmentForm' column for the specified government type using a placeholder for string values."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "description": "The virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific type of government. The placeholder in the WHERE clause represents the government form being queried.", "virtual_table": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the relevant table, which is 'country'.", "Select the columns to display: 'Name', 'SurfaceArea', and 'IndepYear'.", "Order the results by the 'Population' column to find the country with the lowest population.", "Use a placeholder in the LIMIT clause to restrict the output to only one country."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "description": "The virtual table provides the name, year of independence, and surface area of countries from the 'country' table, ordered by their population. The placeholder in the LIMIT clause indicates that only the country with the lowest population will be selected.", "virtual_table": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the relevant table, which is 'city'.", "Select the column to display, 'name'.", "Add a condition to filter the 'Population' column using the BETWEEN clause with placeholders for numeric values."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "description": "The virtual table lists the names of cities from the 'city' table that have a population within a specified range. The placeholders in the WHERE clause represent the lower and upper limits of the population range.", "virtual_table": "SELECT name FROM city WHERE Population BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.725", "db_id": "world_1", "question": "Give the average life expectancy for countries in Africa which are republics?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the column to calculate the average, 'LifeExpectancy'.", "Add conditions to filter the 'Continent' and 'GovernmentForm' columns for the specified values using placeholders for string values."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "description": "The virtual table provides the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the type of government.", "virtual_table": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the relevant table, which is 'country'.", "Select the count of records to display using count(*).", "Add a condition to filter the 'GovernmentForm' column for the specified type of government using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "description": "The virtual table provides a count of countries from the 'country' table that have a specific type of government, specifically those classified as republics. The placeholder in the WHERE clause represents the type of government being queried.", "virtual_table": "SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.745", "db_id": "world_1", "question": "What is the number of nations that use English and Dutch?", "rationale": ["Identify the relevant tables, which are 'country' and 'countrylanguage'.", "Use a subquery to select the names of countries that speak English and another for those that speak Dutch.", "Utilize the INTERSECT operator to find countries that appear in both subqueries.", "Count the total number of unique countries that meet the criteria."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch')", "source_tables": ["country", "countrylanguage"], "description": "The virtual table provides a count of nations that have both English and Dutch as spoken languages. It combines data from the 'country' and 'countrylanguage' tables, filtering for countries where the specified languages are spoken. The placeholders represent the languages being queried.", "virtual_table": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.486", "db_id": "wta_1", "question": "Find the number of left handed winners who participated in the WTA Championships.", "rationale": ["Identify the relevant table, which is 'matches'.", "Select the count of distinct 'winner_name' to get the number of unique left-handed winners.", "Add conditions to filter the 'tourney_name' for the specified tournament and 'winner_hand' for left-handed players using placeholders for string values."], "gold_sql": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L'", "source_tables": ["matches"], "description": "The virtual table summarizes the count of distinct winners from the 'matches' table who are left-handed and participated in a specific tournament. The placeholders in the WHERE clause represent the tournament name and the winner's hand preference.", "virtual_table": "SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  [PLACEHOLDER-TYPE:STRING] AND winner_hand  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.464", "db_id": "wta_1", "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?", "rationale": ["Identify the relevant table, which is 'matches'.", "Select the columns to display, 'winner_name' and 'winner_rank_points'.", "Group the results by 'winner_name' to count the number of matches won by each player.", "Order the results by the count of matches won in descending order to find the top winner.", "Limit the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["matches"], "description": "The virtual table provides the names of winners from the 'matches' table along with their corresponding ranking points. The results are grouped by the winner's name and ordered by the count of matches won in descending order, allowing for the identification of the player with the most victories. The placeholder in the LIMIT clause specifies the number of top winners to retrieve.", "virtual_table": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.476", "db_id": "wta_1", "question": "What is the code of the country with the most players?", "rationale": ["Identify the relevant table, which is 'players'.", "Select the 'country_code' column to display.", "Group the results by 'country_code' to aggregate the player counts.", "Order the results by the count of players in descending order to find the country with the most players.", "Use a placeholder in the LIMIT clause to specify how many top results to return."], "gold_sql": "SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["players"], "description": "The virtual table provides a list of country codes from the 'players' table, grouped by each unique country code. It orders the results by the count of players associated with each country in descending order, allowing the identification of the country with the most players. The placeholder in the LIMIT clause indicates the number of top results to return.", "virtual_table": "SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.471", "db_id": "wta_1", "question": "Find the total ranking points for each player and their first name.", "rationale": ["Identify the relevant tables, which are 'players' and 'rankings'.", "Select the columns to display, which are the sum of 'ranking_points' and 'first_name' from the 'players' table.", "Join the 'players' table with the 'rankings' table on the 'player_id' to associate players with their ranking points.", "Group the results by 'first_name' to aggregate the total ranking points for each player."], "gold_sql": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name", "source_tables": ["rankings", "players"], "description": "The virtual table summarizes the total ranking points for each player along with their first names. It combines data from the 'players' table, which contains player identifiers and names, with the 'rankings' table, which holds the ranking points associated with each player. The results are grouped by the player's first name to provide a total ranking points count for each individual.", "virtual_table": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name"}
{"sample_id": "dev.469", "db_id": "wta_1", "question": "Find the average ranking for each player and their first name.", "rationale": ["Identify the relevant tables, which are 'players' and 'rankings'.", "Select the average of the 'ranking' column and the 'first_name' column from the 'players' table.", "Join the two tables on the 'player_id' to associate players with their rankings.", "Group the results by 'first_name' to compute the average ranking for each player."], "gold_sql": "SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name", "source_tables": ["rankings", "players"], "description": "The virtual table provides the average ranking of players along with their first names. It combines data from the 'players' table and the 'rankings' table, linking them through the unique player identifier. The results are grouped by the players' first names to calculate the average ranking for each player.", "virtual_table": "SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name"}
{"sample_id": "dev.439", "db_id": "wta_1", "question": "Find the highest rank of losers in all matches.", "rationale": ["Identify the relevant table, which is 'matches'.", "Select the 'loser_rank' column to find the minimum value.", "Use the MIN function to aggregate the ranks and determine the highest rank of losers across all matches."], "gold_sql": "SELECT min(loser_rank) FROM matches", "source_tables": ["matches"], "description": "The virtual table provides the minimum rank of losing players from the 'matches' table, which reflects the highest rank among all losers in the matches. This is determined by aggregating the 'loser_rank' column to find the lowest value, indicating the best performance of the losing players.", "virtual_table": "SELECT min(loser_rank) FROM matches"}
