{"sample_id": "train.2612", "db_id": "inn_1", "question": "Find the name of the room with the maximum occupancy.", "rationale": ["Identify the relevant table: Rooms, which contains the room details including maxOccupancy.", "To find the room with the maximum occupancy, we need to select the roomName from the Rooms table.", "We need to determine the maximum occupancy value, which can be done using a subquery that selects the maximum value from the maxOccupancy column in the Rooms table.", "The final query selects the roomName where the maxOccupancy matches the maximum occupancy found in the subquery."], "gold_sql": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE maxOccupancy = (SELECT MAX(maxOccupancy) FROM Rooms);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n        \"virtual_table\": \"SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;\"\n    }\n}\n"}
{"sample_id": "train.2621", "db_id": "inn_1", "question": "What is the average minimum and price of the rooms for each different decor.", "rationale": ["Identify the relevant table: The Rooms table contains the necessary information about room decor and prices.", "Determine the required calculations: We need to calculate the average price of rooms, which involves using the AVG() function.", "Group the results: Since we want the average price for each different decor, we will use the GROUP BY clause on the 'decor' column.", "Select the necessary columns: We will select the 'decor' column and the calculated average price, which we will alias as 'average_price'."], "gold_sql": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;", "source_tables": ["rooms"], "pred_sql": "SELECT decor, AVG(basePrice) AS average_price FROM Rooms GROUP BY decor;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2628", "db_id": "inn_1", "question": "List the name of rooms with king or queen bed.", "rationale": ["The user wants to list the names of rooms that have either a king or queen bed.", "To achieve this, we need to select the 'roomName' column from the 'Rooms' table.", "We will filter the results using a WHERE clause to check if the 'bedType' is either 'king' or 'queen'.", "The SQL query will use the IN operator to specify multiple values for the 'bedType' condition."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE bedType IN ('king', 'queen');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["We need to find the name of each room and the number of times reservations were made for it.", "To achieve this, we will select the 'roomName' from the 'Rooms' table.", "We will also count the number of reservations for each room, which can be done using COUNT(*) on the 'Reservations' table.", "We will join the 'Reservations' table with the 'Rooms' table on the 'Room' identifier to link reservations to their respective rooms.", "Finally, we will group the results by 'roomName' to get the count of reservations for each room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T2.roomName, COUNT(*) AS reservation_count \nFROM Reservations AS T1 \nJOIN Rooms AS T2 ON T1.Room = T2.RoomId \nGROUP BY T2.roomName;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n        \"virtual_table\": \"SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;\"\n    }\n}\n"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["Identify the table needed: The question asks for details of trucks, so we will use the 'Trucks' table.", "Select all columns: We need all details of the trucks, so we will use SELECT *.", "Order by license number: The question specifies to order the results by the truck's license number, so we will add ORDER BY truck_licence_number."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "pred_sql": "SELECT * FROM Trucks ORDER BY truck_licence_number;", "hint": "\n"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to find customer names, so we will select 'customer_name' from the Customers table.", "To filter customers based on their address, we need to join the Customers table with the Customer_Addresses table using 'customer_id'.", "Next, we join the Customer_Addresses table with the Addresses table using 'address_id' to access the state information.", "Finally, we apply a WHERE clause to filter out customers whose state is 'California'."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT customer_name \nFROM Customers c \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nJOIN Addresses a ON ca.address_id = a.address_id \nWHERE a.state_province_county != 'California';", "hint": "\n"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["Identify the relevant tables: Delivery_Routes, Delivery_Route_Locations, and Order_Deliveries are needed to find the route with the highest number of deliveries.", "Join Delivery_Routes with Delivery_Route_Locations on route_id to link routes with their locations.", "Join the result with Order_Deliveries on location_code to associate deliveries with their respective routes.", "Group the results by route_name to count the number of deliveries for each route.", "Order the results in descending order based on the count of deliveries to find the route with the highest number.", "Limit the results to 1 to get only the top route."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "pred_sql": "SELECT route_name\nFROM Delivery_Routes\nJOIN Delivery_Route_Locations ON Delivery_Routes.route_id = Delivery_Route_Locations.route_id\nJOIN Order_Deliveries ON Delivery_Route_Locations.location_code = Order_Deliveries.location_code\nGROUP BY route_name\nORDER BY COUNT(Order_Deliveries.actual_order_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3175", "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["Identify the tables involved: CLASS and EMPLOYEE.", "We need to count the number of distinct professors teaching a specific class, so we will use COUNT(DISTINCT) to avoid counting the same professor multiple times.", "Join the CLASS table with the EMPLOYEE table on the professor's identifier (PROF_NUM) to get the professor's details.", "Filter the results to only include the class with the code 'ACCT-211'.", "Select the count of distinct professors from the joined tables."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT T2.emp_fname) AS professor_count \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM \nWHERE T1.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and EMPLOYEE.", "We need to count the number of distinct professors teaching a specific class, which is identified by the CLASS_CODE 'ACCT-211'.", "Join the CLASS table with the EMPLOYEE table on the professor's identifier (PROF_NUM) to get the professor's details.", "Use the COUNT function to count the distinct professors from the joined result where the CLASS_CODE matches 'ACCT-211'.", "The final SQL query selects the count of distinct first names of professors who teach the specified class."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT T2.emp_fname) AS professor_count \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM \nWHERE T1.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["Identify the tables needed: CLASS, EMPLOYEE, and COURSE.", "We need to get the first names and date of birth of professors, so we will select EMP_FNAME and EMP_DOB from the EMPLOYEE table.", "To find which professors teach the course ACCT-211, we need to join the CLASS table with the EMPLOYEE table on the professor's identifier (PROF_NUM).", "We also need to join the CLASS table with the COURSE table to filter by the course code (CRS_CODE).", "The final SQL query will select the first names and date of birth of professors who teach the specified course."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT T2.EMP_FNAME, T2.EMP_DOB \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM \nJOIN COURSE AS T3 ON T1.CRS_CODE = T3.CRS_CODE \nWHERE T3.CRS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3188", "db_id": "college_1", "question": "Where is the history department?", "rationale": ["The user is asking for the location of the history department, which implies we need to find the department with the name 'History'.", "To find the department, we will query the DEPARTMENT table, specifically looking for the DEPT_NAME column that matches 'History'.", "The SQL query will select the DEPT_NAME from the DEPARTMENT table where the DEPT_NAME is 'History'."], "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"], "pred_sql": "SELECT dept_name FROM department WHERE dept_name = 'History'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the table that contains the school locations, which is the DEPARTMENT table.", "Determine the relevant column for the location, which is DEPT_ADDRESS.", "Filter the results based on the SCHOOL_CODE, specifically for the code 'BUS'.", "Use DISTINCT to ensure that only unique locations are returned."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "\n"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE are needed to get department names and their associated courses.", "Join the DEPARTMENT table with the COURSE table on the DEPT_CODE to link departments with their courses.", "Use the SUM function to calculate the total credit hours offered by each department based on the CRS_CREDIT from the COURSE table.", "Group the results by DEPT_NAME to get the total credit hours for each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT D.DEPT_NAME, SUM(C.CRS_CREDIT) AS TOTAL_CREDIT\nFROM DEPARTMENT D\nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE\nGROUP BY D.DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3202", "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["Identify the tables involved: DEPARTMENT and COURSE.", "Determine the relationship between the tables: DEPARTMENT has a DEPT_CODE that links to COURSE's DEPT_CODE.", "We need to count the number of courses offered by each department, so we will use the COUNT function.", "Join the DEPARTMENT and COURSE tables on DEPT_CODE to get the relevant data.", "The final query will count the number of courses for each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT count(*) FROM DEPARTMENT AS T1 JOIN COURSE AS T2 ON T1.DEPT_CODE = T2.DEPT_CODE", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors and their associated school codes.", "Count the number of professors per school: Use COUNT(PROF_NUM) to count the number of professors for each SCHOOL_CODE.", "Group the results by school: Use GROUP BY SCHOOL_CODE to aggregate the counts by school.", "Order the results to find the smallest count: Use ORDER BY professor_count ASC to sort the counts in ascending order.", "Limit the results to the top entry: Use LIMIT 1 to get only the school with the smallest number of professors."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "pred_sql": "SELECT SCHOOL_CODE, COUNT(PROF_NUM) AS professor_count\nFROM PROFESSOR\nGROUP BY SCHOOL_CODE\nORDER BY professor_count ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3215", "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["Identify the tables needed: We need the PROFESSOR table to get the professors' information and the DEPARTMENT table to get the department names.", "We need to count the number of professors with a Ph.D. degree, so we will use the COUNT() function.", "To get the department names along with the count of professors, we will join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE.", "We will filter the professors to only include those with a Ph.D. degree using a WHERE clause.", "Finally, we will group the results by department name to get the count of professors in each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(PROFESSOR.EMP_NUM) AS NumberOfProfessors\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nWHERE PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D.'\nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["We need to find the number of students for each department, which requires counting students grouped by their respective departments.", "The relevant tables for this query are DEPARTMENT and STUDENT, as we need to link students to their departments.", "We will join the DEPARTMENT table with the STUDENT table on the DEPT_CODE column, which is common to both tables.", "After joining, we will group the results by DEPT_NAME to get the count of students in each department.", "Finally, we will use the COUNT function to count the number of students (STU_NUM) for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPT_NAME, COUNT(STU_NUM) AS student_count \nFROM DEPARTMENT \nJOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE \nGROUP BY DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["Identify the tables needed: STUDENT for student hours and DEPARTMENT for department names.", "Join the STUDENT table with the DEPARTMENT table on the DEPT_CODE to associate students with their respective departments.", "Use the SUM function to calculate the total hours (STU_HRS) for each department.", "Group the results by department name (DEPT_NAME) to get the total hours per department."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT D.DEPT_NAME, SUM(S.STU_HRS) AS TOTAL_HOURS\nFROM STUDENT S\nJOIN DEPARTMENT D ON S.DEPT_CODE = D.DEPT_CODE\nGROUP BY D.DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE are needed to find the total credits offered by each department.", "Join the DEPARTMENT table with the COURSE table on the DEPT_CODE to associate courses with their respective departments.", "Use the SUM function to calculate the total credits for each department by summing the CRS_CREDIT from the COURSE table.", "Group the results by department name to aggregate the total credits for each department.", "Order the results in descending order based on the total credits to find the department with the most credits.", "Limit the results to 1 to get only the department that offers the most credits."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "pred_sql": "SELECT D.DEPT_NAME, SUM(C.CRS_CREDIT) AS TOTAL_CREDITS\nFROM DEPARTMENT D\nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE\nGROUP BY D.DEPT_NAME\nORDER BY TOTAL_CREDITS DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the tables involved: STUDENT, ENROLL, and CLASS.", "Determine the relationship between the tables: STUDENT is linked to ENROLL through STU_NUM, and ENROLL is linked to CLASS through CLASS_CODE.", "Select the first name of the students, which is in the STUDENT table (STU_FNAME).", "Filter the results to only include students enrolled in the class with CLASS_CODE 'ACCT-211'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211';", "hint": "\n"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["Identify the tables needed: STUDENT for student names, ENROLL for enrollment details, and CLASS for class information.", "Join the ENROLL table with the STUDENT table on the student number (STU_NUM) to get student details for enrolled classes.", "Join the CLASS table with the ENROLL table on the class code (CLASS_CODE) to filter for the specific class 'ACCT-211'.", "Add a WHERE clause to filter for students who received a grade of 'C'.", "Select the first name of the students (STU_FNAME) from the resulting joined tables."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT S.STU_FNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nJOIN CLASS C ON E.CLASS_CODE = C.CLASS_CODE \nWHERE C.CLASS_CODE = 'ACCT-211' AND E.ENROLL_GRADE = 'C';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["We need to find the department with the most students enrolled.", "To do this, we will join the STUDENT table with the DEPARTMENT table using the DEPT_CODE.", "We will group the results by department name to count the number of students in each department.", "We will order the results in descending order based on the count of students to get the department with the most students at the top.", "Finally, we will limit the results to 1 to get only the top department."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT T2.DEPT_NAME\nFROM STUDENT AS T1\nJOIN DEPARTMENT AS T2 ON T1.DEPT_CODE = T2.DEPT_CODE\nGROUP BY T2.DEPT_NAME\nORDER BY COUNT(T1.STU_NUM) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3257", "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["Identify the relevant table: The CLASS table contains information about classes, including the room where they are held.", "Determine the required columns: We need the CRS_CODE of the courses, which is also present in the CLASS table.", "Specify the condition: We want to filter the results to only include classes that take place in room 'KLR209'.", "Construct the SQL query: Use SELECT to get the distinct CRS_CODE from the CLASS table where CLASS_ROOM is 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CRS_CODE FROM CLASS WHERE CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students enrolled in classes associated with a specific course code from the 'CLASS' and 'ENROLL' tables. The placeholder in the WHERE clause represents the course code for which the enrollment count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about classes, including the room where they are held.", "Determine the required columns: We need the CRS_CODE of the courses, which is present in the CLASS table.", "Specify the condition: We are interested in classes located in room 'KLR209'.", "Construct the SQL query: Use a SELECT statement to retrieve distinct CRS_CODE values from the CLASS table where CLASS_ROOM equals 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CRS_CODE FROM CLASS WHERE CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students enrolled in classes associated with a specific course code from the 'CLASS' and 'ENROLL' tables. The placeholder in the WHERE clause represents the course code for which the enrollment count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed since we want student names and their grades.", "We need to join the STUDENT table with the ENROLL table on the student number (STU_NUM) to access the grades associated with each student.", "We are interested in students who received a grade of 'C', so we will filter the results using a WHERE clause on the ENROLL_GRADE column.", "To avoid duplicate names, we will use DISTINCT to ensure each student's first name appears only once in the result."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["Identify the relevant tables: We need to find professors from the EMPLOYEE table who do not teach any classes listed in the CLASS table.", "Use a subquery to find professors who teach classes: The subquery selects the PROF_NUM from the CLASS table, which represents professors who are teaching classes.", "Use the NOT IN clause to filter out professors who are teaching classes: We will select professors from the EMPLOYEE table whose EMP_NUM is not in the list of PROF_NUM from the CLASS table."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME FROM EMPLOYEE WHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the relevant tables: PROFESSOR and CLASS.", "We need to find professors who are not teaching any classes, which means we need to look for professors whose EMP_NUM is not present in the CLASS table's PROF_NUM column.", "The hint provides a virtual table that shows how to join CLASS and EMPLOYEE to get the first names of professors who are teaching classes.", "To find professors not teaching any classes, we can use a subquery that selects PROF_NUM from CLASS and use it in a NOT IN clause to filter out those professors from the PROFESSOR table.", "Finally, we select the first names (emp_fname) of the remaining professors."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT emp_fname FROM PROFESSOR WHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the table that contains information about professors, which is the PROFESSOR table.", "Determine the relevant column that indicates the highest degree obtained by the professors, which is PROF_HIGH_DEGREE.", "We need to count the number of professors who have either a Ph.D. or a Masters degree.", "Use the COUNT() function to count the number of rows that meet the criteria.", "Construct the SQL query to select the count from the PROFESSOR table where the PROF_HIGH_DEGREE is either 'Ph.D.' or 'Masters'."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) AS NumberOfProfessors\nFROM PROFESSOR\nWHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "hint": "\n"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["Identify the tables needed: CLASS and EMPLOYEE.", "We need to find the first names of professors, which are in the EMPLOYEE table, and the courses they teach, which are in the CLASS table.", "Join the CLASS table with the EMPLOYEE table on the professor's identifier (PROF_NUM).", "Filter the results to include only the courses CIS-220 and QM-261 using a WHERE clause with the IN operator."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "pred_sql": "SELECT T2.EMP_FNAME FROM CLASS AS T1 JOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM WHERE T1.CRS_CODE IN ('CIS-220', 'QM-261')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the tables needed: STUDENT, ENROLL, CLASS, COURSE, and DEPARTMENT.", "Join the STUDENT table with ENROLL to get the classes each student is enrolled in.", "Join the ENROLL table with CLASS to get the class details.", "Join the CLASS table with COURSE to get the course details.", "Join the COURSE table with DEPARTMENT to filter by department names.", "Use a WHERE clause to filter for departments 'Accounting' and 'Computer Info. Systems'.", "Select the distinct first names of students who meet the criteria."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME \nFROM STUDENT AS S \nJOIN ENROLL AS E ON S.STU_NUM = E.STU_NUM \nJOIN CLASS AS C ON E.CLASS_CODE = C.CLASS_CODE \nJOIN COURSE AS CRS ON C.CRS_CODE = CRS.CRS_CODE \nJOIN DEPARTMENT AS D ON CRS.DEPT_CODE = D.DEPT_CODE \nWHERE D.DEPT_NAME IN ('Accounting', 'Computer Info. Systems')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of employees, the office locations of professors, and descriptions of courses from the respective tables. The data is retrieved by joining the 'CLASS' table with the 'EMPLOYEE', 'COURSE', and 'PROFESSOR' tables based on their relationships, specifically linking professors to their classes and courses.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3308", "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["Identify the relevant tables: PROFESSOR and DEPARTMENT.", "We need to select the first names and office locations of professors, so we will select 'emp_fname' and 'prof_office' from the PROFESSOR table.", "To filter professors by department, we will join the PROFESSOR table with the DEPARTMENT table on the 'dept_code'.", "We need to filter for professors in the 'History' department and those who have a Ph.D., so we will add a WHERE clause to check for 'dept_name' = 'History' and 'prof_high_degree' = 'Ph.D.'"], "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"], "pred_sql": "SELECT T2.emp_fname, T2.prof_office \nFROM PROFESSOR AS T2 \nJOIN DEPARTMENT AS T3 ON T2.dept_code = T3.dept_code \nWHERE T3.dept_name = 'History' AND T2.prof_high_degree = 'Ph.D.';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3319", "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["Identify the tables needed: STUDENT for student names and ENROLL for enrollment details including grades.", "We need to find students who received either an 'A' or 'C' grade, so we will filter the ENROLL table based on the ENROLL_GRADE column.", "To get the names of the students, we will select the first and last names from the STUDENT table.", "We will join the STUDENT table with the ENROLL table on the student number (STU_NUM) to link students with their grades.", "Finally, we will use DISTINCT to ensure that we do not have duplicate names in the result set."], "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME, S.STU_LNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nWHERE E.ENROLL_GRADE IN ('A', 'C');", "hint": "\n"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, COURSE, PROFESSOR, and DEPARTMENT.", "We need to retrieve the first names of professors and their highest degree, so we will select T2.EMP_FNAME and T4.PROF_HIGH_DEGREE.", "Join the CLASS table with the EMPLOYEE table to get the professor's first name using the PROF_NUM foreign key.", "Join the CLASS table with the COURSE table to link classes to their respective courses using the CRS_CODE foreign key.", "Join the EMPLOYEE table with the PROFESSOR table to get the highest degree of the professors using the EMP_NUM foreign key.", "Join the PROFESSOR table with the DEPARTMENT table to filter professors by the department they belong to using the DEPT_CODE foreign key.", "Add a WHERE clause to filter results to only include professors from the 'Computer Information Systems' department."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "pred_sql": "SELECT T2.EMP_FNAME, T4.PROF_HIGH_DEGREE \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM \nJOIN COURSE AS T3 ON T1.CRS_CODE = T3.CRS_CODE \nJOIN PROFESSOR AS T4 ON T2.EMP_NUM = T4.EMP_NUM \nJOIN DEPARTMENT AS T5 ON T4.DEPT_CODE = T5.DEPT_CODE \nWHERE T5.DEPT_NAME = 'Computer Information Systems'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of employees, the office locations of professors, and descriptions of courses from the respective tables. The data is retrieved by joining the 'CLASS' table with the 'EMPLOYEE', 'COURSE', and 'PROFESSOR' tables based on their relationships, specifically linking professors to their classes and courses.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE are needed to find the department offering a specific class.", "The relationship between DEPARTMENT and COURSE is established through the DEPT_CODE foreign key.", "We need to filter the courses based on their description containing the word 'Statistics'.", "Use the LIKE operator to search for 'Statistics' in the CRS_DESCRIPTION column of the COURSE table.", "Select the DEPT_NAME from the DEPARTMENT table after joining it with the COURSE table based on DEPT_CODE."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT DEPT_NAME \nFROM DEPARTMENT \nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE \nWHERE CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["Identify the relevant table: The question asks about competition types and countries, which are found in the 'competition' table.", "Select the required columns: We need to select 'Competition_type' and 'Country' from the 'competition' table.", "Construct the SQL query: Using the identified table and selected columns, the SQL query is formed as 'SELECT Competition_type, Country FROM competition'."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "pred_sql": "SELECT Competition_type, Country FROM competition;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides information about the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.\",\n        \"virtual_table\": \"SELECT Competition_type ,  Country FROM competition\"\n    }\n}\n"}
{"sample_id": "train.3355", "db_id": "sports_competition", "question": "Please show the names and the players of clubs.", "rationale": ["Identify the tables needed: 'club' for club names and 'player' for player names.", "Determine the relationship between the tables: 'club' and 'player' are linked by 'Club_ID'.", "Use a JOIN operation to combine the data from both tables based on 'Club_ID'.", "Select the desired columns: the name of the club and the name of the player."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "pred_sql": "SELECT T1.name, T2.name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID = T2.Club_ID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of clubs along with the unique identifiers of players associated with those clubs. The join operation links the 'club' table and the 'player' table based on the common 'Club_ID' field, allowing for the retrieval of player information for each club.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID\"\n    }\n}\n"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["We need to find the positions of players whose average points scored is greater than 20.", "To do this, we will select the 'Position' column from the 'player' table.", "We will group the results by 'Position' to calculate the average points for each position.", "We will use the HAVING clause to filter the groups where the average points is greater than 20."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "pred_sql": "SELECT Position\nFROM player\nGROUP BY Position\nHAVING AVG(Points) > 20;", "hint": "\n"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant column for player positions, which is 'Position'.", "Identify the column that contains the points scored by players, which is 'Points'.", "Formulate the condition to filter players based on their points: greater than 20 or less than 10.", "Construct the SQL query to select the 'Position' from the 'player' table where the points meet the specified conditions."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player WHERE Points > 20 OR Points < 10;", "hint": "\n"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competition types and countries.", "Filter for tournament competitions: We need to focus on rows where the Competition_type is 'tournament'.", "Count the number of tournaments per country: Use COUNT(*) to count the occurrences of each country in the filtered results.", "Group the results by country: Use GROUP BY Country to aggregate the counts for each country.", "Order the results: Use ORDER BY Tournament_Count DESC to sort the countries by the number of tournaments in descending order.", "Limit the results to the top country: Use LIMIT 1 to get only the country with the most tournaments."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country, COUNT(*) AS Tournament_Count \nFROM competition \nWHERE Competition_type = 'tournament' \nGROUP BY Country \nORDER BY Tournament_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides information about the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.\",\n        \"virtual_table\": \"SELECT Competition_type ,  Country FROM competition\"\n    }\n}\n"}
{"sample_id": "train.3384", "db_id": "sports_competition", "question": "what is the name of the country that participated in the most tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competition types and countries.", "Filter for tournament competitions: We need to focus on rows where the Competition_type is 'tournament'.", "Count the number of tournaments per country: Use COUNT(*) to count the number of tournaments for each country.", "Group the results by country: Use GROUP BY Country to aggregate the counts for each country.", "Order the results: Use ORDER BY Tournament_Count DESC to sort the countries by the number of tournaments in descending order.", "Limit the results to the top country: Use LIMIT 1 to get only the country with the most tournaments."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country, COUNT(*) AS Tournament_Count \nFROM competition \nWHERE Competition_type = 'tournament' \nGROUP BY Country \nORDER BY Tournament_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides information about the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.\",\n        \"virtual_table\": \"SELECT Competition_type ,  Country FROM competition\"\n    }\n}\n"}
{"sample_id": "train.3388", "db_id": "sports_competition", "question": "What are the countries that have never participated in any friendly-type competitions?", "rationale": ["We need to find countries that have never participated in friendly-type competitions.", "First, we can create a subquery that selects distinct countries from the competition table where the competition type is 'friendly'.", "Next, we will select distinct countries from the competition table and use the NOT IN clause to exclude those countries that were found in the subquery.", "This will give us the list of countries that have not participated in any friendly-type competitions."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT Country \nFROM competition \nWHERE Country NOT IN (\n    SELECT DISTINCT Country \n    FROM competition \n    WHERE Competition_type = 'friendly'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides information about the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.\",\n        \"virtual_table\": \"SELECT Competition_type ,  Country FROM competition\"\n    }\n}\n"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["Identify the relevant table: The 'employees' table contains the necessary information about employees, including their first name, last name, and salary.", "Determine the required fields: We need to select the 'FIRST_NAME', 'LAST_NAME', and 'SALARY' columns from the 'employees' table.", "Apply the filter condition: We need to filter the results to include only those employees whose salary is below 6000, which can be done using a WHERE clause.", "Construct the SQL query: Combine the selected fields and the filter condition into a complete SQL query."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME, LAST_NAME, SALARY FROM employees WHERE SALARY < 6000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department id.", "To create the full name, concatenate the first and last names using '||'.", "Filter employees whose first name does not contain the letter 'M' using the NOT LIKE operator.", "Select the relevant fields from the 'employees' table."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID FROM employees WHERE FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by DEPARTMENT_ID.", "Construct the SQL query using the SELECT statement with the identified fields and conditions."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs to filter out departments managed by those IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department id.", "To create the full name, concatenate the first and last names using '||'.", "Filter employees whose first name does not contain the letter 'M' using the NOT LIKE operator.", "Order the results by department id in ascending order.", "Construct the SQL query using the SELECT statement with the identified fields and conditions."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant tables: jobs and employees.", "Determine the relationship between jobs and employees: employees have a JOB_ID that links to jobs.", "Select the JOB_TITLE from the jobs table.", "Filter the results to include only those employees whose salary is greater than 9000.", "Use DISTINCT to ensure unique job titles are returned."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT DISTINCT jobs.JOB_TITLE FROM jobs JOIN employees ON jobs.JOB_ID = employees.JOB_ID WHERE employees.SALARY > 9000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The question asks for job titles and salary ranges, which are found in the 'jobs' table.", "Select the required columns: We need to select 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY' from the 'jobs' table.", "Apply the filter: The question specifies that we need jobs with a maximum salary between 12000 and 18000, so we will use a WHERE clause to filter 'MAX_SALARY' accordingly.", "Construct the SQL query: Combine the selected columns and the filter into a complete SQL query."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY \nFROM jobs \nWHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["We need to find the employee IDs and the final dates of employment at their last job.", "The relevant tables are 'employees' and 'job_history'.", "We will join the 'employees' table with the 'job_history' table on the EMPLOYEE_ID.", "To get the final date of employment, we need to find the maximum END_DATE for each employee in the job_history table.", "We can use a subquery to get the maximum END_DATE for each employee and filter the results accordingly."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT e.EMPLOYEE_ID, j.END_DATE\nFROM employees e\nJOIN job_history j ON e.EMPLOYEE_ID = j.EMPLOYEE_ID\nWHERE j.END_DATE = (SELECT MAX(END_DATE) FROM job_history WHERE EMPLOYEE_ID = e.EMPLOYEE_ID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["Identify the tables needed: We need data from the 'employees' table for salary and commission percentage, and from the 'departments' table for department names.", "Join the 'employees' table with the 'departments' table on the DEPARTMENT_ID to associate employees with their respective departments.", "Filter the results to include only those employees who have a non-null commission percentage, indicating they receive a commission.", "Use the AVG() function to calculate the average salary of employees for each department.", "Group the results by department name to get the average salary for each department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_NAME, AVG(e.SALARY) AS average_salary\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nWHERE e.COMMISSION_PCT IS NOT NULL\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["Identify the table needed: The 'employees' table contains the salary and commission percentage information.", "Determine the condition: We need to filter employees whose commission percentage is not null.", "Use the AVG() function: To calculate the average salary of the filtered employees, we will use the AVG() function on the SALARY column.", "Construct the SQL query: Combine the SELECT statement with the AVG() function and the WHERE clause to filter the results."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT AVG(SALARY) AS average_salary FROM employees WHERE COMMISSION_PCT IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["Identify the required columns: COUNTRY_ID from countries and the count of cities from locations.", "To get the number of cities for each country, we need to join the countries table with the locations table on the COUNTRY_ID.", "Use the COUNT() function to count the number of cities for each country.", "Group the results by COUNTRY_ID to ensure we get a count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT countries.COUNTRY_ID, COUNT(locations.CITY) AS number_of_cities\nFROM countries\nJOIN locations ON countries.COUNTRY_ID = locations.COUNTRY_ID\nGROUP BY countries.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["Identify the tables needed: 'countries' for country information and 'locations' for city information.", "Determine the relationship between the tables: 'locations' has a foreign key 'COUNTRY_ID' that links to 'countries'.", "Use a JOIN to combine 'countries' and 'locations' on 'COUNTRY_ID'.", "Count the number of cities (from 'locations') for each country (from 'countries').", "Group the results by 'COUNTRY_ID' to get the count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT c.COUNTRY_ID, COUNT(l.CITY) AS CITY_COUNT\nFROM countries c\nJOIN locations l ON c.COUNTRY_ID = l.COUNTRY_ID\nGROUP BY c.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["The user wants detailed information about jobs done by employees earning a salary of 12000 or more.", "We need to filter employees based on their salary, so we will use the employees table to get those who meet the salary criteria.", "We will join the job_history table to get the jobs associated with those employees.", "Finally, we will join the jobs table to get the detailed information about each job.", "The final query will select all columns from the jobs table and the filtered job history and employee data."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "pred_sql": "SELECT * FROM jobs AS J JOIN (SELECT * FROM job_history AS T1 JOIN employees AS T2 ON T1.EMPLOYEE_ID = T2.EMPLOYEE_ID WHERE T2.SALARY >= 12000) AS JobDetails ON J.JOB_ID = JobDetails.JOB_ID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the requirement: We need information about employees who are managers.", "Understand the relationship: An employee is a manager if their 'EMPLOYEE_ID' matches the 'MANAGER_ID' in the 'departments' table.", "Join the 'employees' table with the 'departments' table on 'DEPARTMENT_ID' to get the relevant information.", "Use a DISTINCT clause to ensure that we do not have duplicate records of employees who are managers."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id WHERE T1.employee_id = T2.manager_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that duplicate records are eliminated, providing a unique list of such employees.\",\n        \"virtual_table\": \"SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id\"\n    }\n}\n"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["Identify the departments where managers are managing employees.", "To find managers managing 4 or more employees, we need to group employees by their MANAGER_ID and count the number of employees for each manager.", "Use the HAVING clause to filter those managers who have 4 or more employees.", "Select the DEPARTMENT_ID from the departments table where the MANAGER_ID is in the list of managers identified in the previous step."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DEPARTMENT_ID FROM departments WHERE MANAGER_ID IN (SELECT MANAGER_ID FROM employees GROUP BY MANAGER_ID HAVING COUNT(EMPLOYEE_ID) >= 4)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that duplicate records are eliminated, providing a unique list of such employees.\",\n        \"virtual_table\": \"SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id\"\n    }\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find distinct department IDs where a manager oversees 4 or more employees.", "To do this, we first need to identify managers who have 4 or more employees reporting to them. We can achieve this by grouping the employees by their manager ID and counting the number of employees for each manager.", "Using a subquery, we can select the manager IDs that have 4 or more employees using the HAVING clause.", "Next, we join the departments table with the employees table to get the department IDs for those managers identified in the subquery.", "Finally, we select distinct department IDs from this joined result to ensure we do not have duplicates."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DISTINCT d.DEPARTMENT_ID \nFROM departments d \nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nWHERE d.MANAGER_ID IN (\n    SELECT e1.MANAGER_ID \n    FROM employees e1 \n    GROUP BY e1.MANAGER_ID \n    HAVING COUNT(e1.EMPLOYEE_ID) >= 4\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that duplicate records are eliminated, providing a unique list of such employees.\",\n        \"virtual_table\": \"SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id\"\n    }\n}\n"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["Identify the relevant tables: 'employees' for employee details and 'job_history' for job history.", "Join the 'job_history' table with the 'employees' table on the employee ID to get comprehensive information.", "Filter the results to include only those employees whose salary is greater than the minimum salary from the 'jobs' table and less than 2500.", "Use a subquery to get the minimum salary from the 'jobs' table for comparison."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "pred_sql": "SELECT * FROM job_history AS T1 JOIN employees AS T2 ON T1.EMPLOYEE_ID = T2.EMPLOYEE_ID WHERE T2.SALARY > (SELECT MIN(MIN_SALARY) FROM jobs) AND T2.SALARY < 2500", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["Identify the requirement: We need the full names and hire dates of employees who work in the same department as an employee named Clara.", "To find Clara's department, we will first query the employees table to get Clara's department ID.", "We will use a subquery to find the department ID of Clara by joining the employees table with the departments table.", "Once we have Clara's department ID, we can then select the first name, last name, and hire date of all employees in that department.", "The final query will join the employees table with the departments table to filter employees based on the department ID obtained from the subquery."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, e.HIRE_DATE \nFROM employees AS e \nJOIN departments AS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nWHERE d.DEPARTMENT_ID = (SELECT d2.DEPARTMENT_ID \n                         FROM employees AS e2 \n                         JOIN departments AS d2 ON e2.DEPARTMENT_ID = d2.DEPARTMENT_ID \n                         WHERE e2.FIRST_NAME = 'Clara')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the relevant tables: We need to retrieve employee names and hire dates, which are in the 'employees' table, and we need to filter by department, which is in the 'departments' table.", "We need to find the department of the employee named Clara. This requires a subquery that selects the department ID for Clara from the 'employees' and 'departments' tables.", "The main query will select the first name, last name, and hire date of employees from the 'employees' table who belong to the same department as Clara, excluding Clara herself.", "The final SQL query combines these elements, using a JOIN to link employees to their departments and a WHERE clause to filter based on Clara's department and exclude Clara."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, e.HIRE_DATE \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nWHERE d.DEPARTMENT_ID = (SELECT d2.DEPARTMENT_ID \n                         FROM employees e2 \n                         JOIN departments d2 ON e2.DEPARTMENT_ID = d2.DEPARTMENT_ID \n                         WHERE e2.FIRST_NAME = 'Clara') \nAND e.FIRST_NAME != 'Clara';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["We need to find employees who work in the same department as any employee whose name contains 'T'.", "First, we will create a subquery to find the department IDs of employees whose first or last name contains 'T'.", "The subquery will select distinct department IDs from the employees table where the first name or last name matches the condition using the LIKE operator.", "Next, we will use this subquery in the main query to select the employee ID, first name, and last name of employees who belong to those departments.", "We will join the employees table with the departments table to ensure we can filter by department ID.", "Finally, we will use DISTINCT to avoid duplicate entries in the result set."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "pred_sql": "SELECT DISTINCT T1.employee_id, T1.first_name, T1.last_name \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nWHERE T2.department_id IN (\n    SELECT DISTINCT T3.department_id \n    FROM employees AS T3 \n    WHERE T3.first_name LIKE '%T%' OR T3.last_name LIKE '%T%'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the main requirement: to display employee number (EMPLOYEE_ID) and job id (JOB_ID) for employees with a salary smaller than any salary of those with job title 'MK_MAN'.", "To achieve this, we need to use a subquery that finds the minimum salary of employees with the job title 'MK_MAN'.", "The subquery will join the 'employees' table with the 'jobs' table to filter by job title.", "The main query will select EMPLOYEE_ID and JOB_ID from the 'employees' table where the salary is less than the result of the subquery."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID FROM employees WHERE SALARY < (SELECT MIN(SALARY) FROM employees JOIN jobs ON employees.JOB_ID = jobs.JOB_ID WHERE JOB_TITLE = 'MK_MAN')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To do this, we will join the 'employees' table with the 'departments' table using the DEPARTMENT_ID.", "We will group the results by DEPARTMENT_ID to aggregate the salaries.", "We will use the SUM function to calculate the total salaries for each department.", "To filter the departments that have more than 2 employees, we will use the HAVING clause with COUNT to count the number of employees in each department."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, SUM(e.SALARY) AS total_salaries \nFROM employees AS e \nJOIN departments AS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_ID \nHAVING COUNT(e.EMPLOYEE_ID) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To get the full name, we can concatenate the first name and last name of the employee using '||'.", "We will select the DEPARTMENT_ID, the concatenated full name, and the SALARY from the employees table.", "To find the highest salary in each department, we can use a subquery that selects the maximum salary from the employees table, grouped by DEPARTMENT_ID.", "The main query will filter employees whose salary matches the maximum salary for their respective department."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                  FROM employees \n                  WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the tables needed: employees for names, departments for linking to locations, and locations for city information.", "Use a JOIN to connect employees to departments and then to locations based on their identifiers.", "Select the full name by concatenating first and last names, and also select the city from the locations table.", "Filter the results to include only those employees whose first names contain the letter 'Z' using the LIKE operator."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name || ' ' || T1.last_name AS full_name, T3.city \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nWHERE T1.first_name LIKE '%Z%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "Join the employees table with the departments table on department_id to get department information for each employee.", "Join the departments table with the locations table on location_id to get location information for each department.", "Join the locations table with the countries table on country_id to get the country information for each location.", "Select the first name and last name from the employees table and the country name from the countries table.", "Add a WHERE clause to filter the results for a specific employee ID."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name, T1.last_name, T4.country_name \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nJOIN countries AS T4 ON T3.country_id = T4.country_id \nWHERE T1.employee_id = ?", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "To get the department name, we will select it from the 'departments' table.", "To count the number of employees in each department, we will use the COUNT function on the 'EMPLOYEE_ID' from the 'employees' table.", "We will join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' to link employees to their respective departments.", "Since some departments may not have any employees, we will use a LEFT JOIN to ensure all departments are included in the result.", "Finally, we will group the results by the department name to get the count of employees per department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES \nFROM departments AS d \nLEFT JOIN employees AS e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["We need to retrieve the department names and the count of employees in each department.", "The relevant tables for this query are 'departments' and 'employees'.", "We will perform a LEFT JOIN between 'departments' and 'employees' on the 'DEPARTMENT_ID' to ensure we get all departments even if they have no employees.", "We will select the 'DEPARTMENT_NAME' from the 'departments' table and count the 'EMPLOYEE_ID' from the 'employees' table to get the number of employees in each department.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS EMPLOYEE_COUNT \nFROM departments AS d \nLEFT JOIN employees AS e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["We need to display the full name (first and last name) and salary of employees.", "The relevant tables are 'employees', 'departments', and 'locations'.", "We will join 'employees' with 'departments' on 'department_id' to get department information.", "Next, we will join 'departments' with 'locations' on 'location_id' to filter by city.", "Finally, we will filter the results to include only those employees whose departments are located in London."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name, T1.last_name, T1.salary \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nWHERE T3.city = 'London'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "We need to retrieve the first name, last name, and salary of employees.", "Join the employees table with the departments table on department_id to get department information.", "Join the departments table with the locations table on location_id to get location information.", "Join the locations table with the countries table on country_id to get country information.", "Filter the results to only include employees working in the city of London."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name, T1.last_name, T1.salary \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nJOIN countries AS T4 ON T3.country_id = T4.country_id \nWHERE T3.city = 'London';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3532", "db_id": "music_1", "question": "Find the id of the song that lasts the longest.", "rationale": ["Identify the tables involved: 'song' and 'files'.", "We need to find the song with the longest duration, which is stored in the 'files' table.", "Join the 'song' table with the 'files' table on the 'f_id' column to access the duration of each song.", "Order the results by the duration in descending order to get the longest duration first.", "Limit the results to 1 to get only the longest song's id."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT T1.f_id FROM song AS T1 JOIN files AS T2 ON T1.f_id = T2.f_id ORDER BY T2.duration DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["Identify the relevant tables: 'song' for artist names and 'files' for song durations.", "Join the 'song' table with the 'files' table on the foreign key 'f_id' to access the duration of each song.", "Select the 'artist_name' from the joined tables.", "Order the results by the 'duration' column in ascending order to get the shortest song first.", "Limit the results to 1 to get only the artist who sang the shortest song."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "pred_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id = T2.f_id ORDER BY T2.duration LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["Identify the relevant tables: 'song' and 'files' are needed to access song details and their durations.", "Join the 'song' table with the 'files' table on the foreign key 'f_id' to link songs with their respective file details.", "Use the COUNT() function to count the number of songs that meet the specified duration criteria.", "Filter the results using a WHERE clause to specify that the duration must be '4:00'."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "pred_sql": "SELECT COUNT(*) FROM song AS T1 JOIN files AS T2 ON T1.f_id = T2.f_id WHERE T2.duration = '4:00'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3549", "db_id": "music_1", "question": "What is the average rating of songs produced by female artists?", "rationale": ["Identify the tables involved: We need to use the 'artist' table to filter by gender and the 'song' table to get the ratings of the songs.", "Determine the relationship between the tables: The 'artist' table is linked to the 'song' table through the 'artist_name' column.", "Use the average function: We need to calculate the average rating of songs, which can be done using the AVG() function in SQL.", "Construct the SQL query: Based on the hint provided, we will replace the placeholder in the virtual table with 'female' to filter for female artists."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "pred_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name WHERE T1.gender = 'female'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average rating of songs performed by artists of a specific gender. The placeholder in the WHERE clause represents the gender of the artists being queried.\",\n        \"virtual_table\": \"SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["Identify the table to query: The 'files' table contains the 'formats' column which we need to analyze.", "Group the results by the 'formats' column to count how many files exist for each format.", "Order the results in descending order based on the count of files to find the most common format.", "Limit the results to 1 to get only the top format used by the most files."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of audio file formats from the 'files' table, grouped by format type. The results are ordered by the count of files in each format, allowing users to see the most common formats used. The placeholder in the LIMIT clause represents the maximum number of formats to return.\",\n        \"virtual_table\": \"SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3556", "db_id": "music_1", "question": "What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?", "rationale": ["Identify the relevant table: The 'files' table contains the information about file formats and resolutions.", "Determine the conditions: We need to filter files that are in the 'mp4' format and have a resolution smaller than 1000.", "Construct the SQL query: Use a SELECT statement to retrieve the 'f_id' from the 'files' table where the conditions are met. Use the LIKE operator to check for 'mp4' in the 'formats' column and CAST the 'resolution' to an integer for comparison."], "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"], "pred_sql": "SELECT f_id FROM files WHERE formats LIKE '%mp4%' AND CAST(resolution AS INTEGER) < 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of file identifiers from the 'files' table, sorted by the duration of the audio files in descending order. The placeholder in the LIMIT clause indicates the maximum number of file identifiers to return.\",\n        \"virtual_table\": \"SELECT f_id FROM files ORDER BY duration DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["Identify the relevant tables: 'artist' and 'song'.", "We need to find artists who are female, so we will filter the 'artist' table by gender = 'female'.", "We also need to find songs that are in Bangla, so we will filter the 'song' table by checking if the 'languages' column contains 'Bangla'.", "Join the 'artist' table with the 'song' table on the 'artist_name' column to combine the relevant information.", "Select the 'country' column from the 'artist' table to get the country of origin of the female artists who produced songs in Bangla."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE artist.gender = 'female' AND song.languages LIKE '%Bangla%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["Identify the relevant tables: 'artist' and 'song'.", "We need to filter artists based on gender, specifically female artists, so we will use the 'gender' column from the 'artist' table.", "We also need to filter songs based on the language, specifically those sung in Bangla, so we will use the 'languages' column from the 'song' table.", "We will join the 'artist' table with the 'song' table on the 'artist_name' column to get the relevant information about the artists and their songs.", "Finally, we will select the artist's name and country from the joined tables, applying the necessary filters for gender and language."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE artist.gender = 'female' AND song.languages LIKE '%Bangla%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["Identify the relevant tables: 'artist' for artist details and 'song' for song details.", "Join the 'artist' table with the 'song' table on the artist's name to get the necessary information about the artist who performed the song.", "Order the results by the 'resolution' column in the 'song' table to find the song with the smallest resolution.", "Limit the results to 1 to get only the artist associated with the song that has the smallest resolution."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "pred_sql": "SELECT T1.gender, T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name ORDER BY T2.resolution LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3567", "db_id": "music_1", "question": "For each file format, return the number of artists who released songs in that format.", "rationale": ["We need to count the number of distinct artists who released songs in each file format.", "To do this, we will join the 'files' table with the 'song' table on the file ID (f_id) to associate songs with their respective files.", "Next, we will join the 'song' table with the 'artist' table on the artist name to get the artist information for each song.", "We will then group the results by the 'formats' column from the 'files' table to count the number of distinct artists for each format.", "Finally, we will select the format and the count of distinct artists, giving us the desired result."], "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"], "pred_sql": "SELECT f.formats, COUNT(DISTINCT a.artist_name) AS artist_count \nFROM files f \nJOIN song s ON f.f_id = s.f_id \nJOIN artist a ON s.artist_name = a.artist_name \nGROUP BY f.formats;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of audio file formats from the 'files' table, grouped by format type. The results are ordered by the count of files in each format, allowing users to see the most common formats used. The placeholder in the LIMIT clause represents the maximum number of formats to return.\",\n        \"virtual_table\": \"SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3576", "db_id": "music_1", "question": "What are the names and genders of all artists who released songs in the month of March?", "rationale": ["Identify the tables involved: 'artist' and 'song'.", "We need to retrieve the names and genders of artists, so we will select 'artist_name' and 'gender' from the 'artist' table.", "To find artists who released songs in March, we need to filter the 'song' table based on the 'releasedate' column.", "Use the strftime function to extract the month from the 'releasedate' and check if it equals '03' for March.", "Join the 'artist' table with the 'song' table on the 'artist_name' to correlate artists with their songs."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "pred_sql": "SELECT T1.artist_name, T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name WHERE strftime('%m', T2.releasedate) = '03'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["Identify the relevant table: The 'song' table contains the 'languages' column that we need to analyze.", "Group the results by 'languages': This allows us to count how many songs are available in each language.", "Order the results: We want to order the languages by the number of songs, so we use 'ORDER BY count(*) DESC' to get the most common languages first.", "Select the languages: We only need the 'languages' column in our final output."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "pred_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of languages in which songs are available, grouped by language and ordered by the number of songs in each language. The placeholder in the LIMIT clause allows the user to specify the maximum number of languages to retrieve.\",\n        \"virtual_table\": \"SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3590", "db_id": "music_1", "question": "What are the names of all male British artists?", "rationale": ["Identify the relevant table: The 'artist' table contains information about artists, including their gender and country.", "Determine the conditions: We need to filter for male artists from Britain.", "Construct the SQL query: Use a SELECT statement to retrieve the artist names from the 'artist' table where the gender is 'male' and the country is 'British'."], "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"], "pred_sql": "SELECT artist_name FROM artist WHERE gender = 'male' AND country = 'British';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3598", "db_id": "music_1", "question": "What is the average rating and resolution of all bangla songs?", "rationale": ["Identify the tables needed: We need the 'song' table for song details and the 'artist' table for artist details.", "Determine the columns to select: We need the average rating of the songs and the resolution of the songs.", "Join the tables: We will join the 'artist' table and the 'song' table on the artist's name.", "Filter the results: We need to filter the songs to only include those that are of the 'bangla' genre.", "Calculate the average rating: We will use the AVG function to calculate the average rating of the songs that match the criteria."], "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"], "pred_sql": "SELECT avg(T2.rating) AS average_rating, T2.resolution FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name WHERE T2.genre_is = 'bangla'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average rating of songs performed by artists of a specific gender. The placeholder in the WHERE clause represents the gender of the artists being queried.\",\n        \"virtual_table\": \"SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3599", "db_id": "music_1", "question": "What are the maximum and minimum resolution of songs whose duration is 3 minutes?", "rationale": ["Identify the tables involved: 'files' and 'song'.", "Determine the relationship between the tables: 'files' is joined with 'song' on the 'f_id' column.", "Focus on the requirement: finding maximum and minimum resolutions of songs with a specific duration.", "Use the provided hint to construct the SQL query, replacing the placeholder with the actual duration '3 minutes'.", "The final SQL query selects the maximum and minimum resolutions from the joined tables based on the specified duration."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "pred_sql": "SELECT max(T2.resolution), min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id WHERE T1.duration LIKE '3 minutes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum and minimum audio resolutions of songs from the 'song' table, filtered by the duration of the associated files in the 'files' table. The placeholder in the WHERE clause represents the specific duration pattern to match.\",\n        \"virtual_table\": \"SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["Identify the columns needed: maximum duration and resolution of songs, and the languages they are available in.", "Use the MAX() function to get the maximum values for duration and resolution.", "Group the results by languages to aggregate the maximum values for each language.", "Order the results by the count of songs in each language to prioritize the most popular languages."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "pred_sql": "SELECT MAX(duration) AS max_duration, MAX(resolution) AS max_resolution, languages FROM song GROUP BY languages ORDER BY COUNT(*) DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of languages in which songs are available, grouped by language and ordered by the number of songs in each language. The placeholder in the LIMIT clause allows the user to specify the maximum number of languages to retrieve.\",\n        \"virtual_table\": \"SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["Identify the relevant columns needed for the query: genre, duration, and rating from the song table.", "Use the MIN() function to find the shortest duration and lowest rating for each genre.", "Group the results by genre using GROUP BY clause to aggregate the data accordingly.", "Order the results by genre using ORDER BY clause to sort the output."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "pred_sql": "SELECT genre_is, MIN(duration) AS shortest_duration, MIN(rating) AS lowest_rating \nFROM song \nGROUP BY genre_is \nORDER BY genre_is;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of songs from the 'song' table that belong to a specific genre or are available in a specific language. The placeholders in the WHERE clause represent the genre and language criteria.\",\n        \"virtual_table\": \"SELECT song_name FROM song WHERE genre_is  =  [PLACEHOLDER-TYPE:STRING] OR languages  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3607", "db_id": "music_1", "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "rationale": ["Identify the tables involved: 'artist' and 'song'.", "We need to select the artist's name and country, which are in the 'artist' table.", "We need to filter the results based on the resolution of the songs, which is a column in the 'song' table.", "Join the 'artist' table with the 'song' table on the artist's name to ensure we only get artists who have released songs.", "Apply the condition to filter songs with resolution greater than 900."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE song.resolution > 900;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3619", "db_id": "music_1", "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their languages and the artists who performed them.", "Filter songs by language: We need to filter the songs to only include those that have 'Bangla' in their languages column.", "Group by artist: To find the top artists, we will group the results by 'artist_name' and count the number of songs for each artist.", "Order the results: We will order the grouped results by the count of songs in descending order to get the artists with the most songs in Bangla at the top.", "Limit the results: Finally, we will limit the results to the top 3 artists."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist_name, COUNT(song_name) AS song_count \nFROM song \nWHERE languages LIKE '%Bangla%' \nGROUP BY artist_name \nORDER BY song_count DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of languages in which songs are available, grouped by language and ordered by the number of songs in each language. The placeholder in the LIMIT clause allows the user to specify the maximum number of languages to retrieve.\",\n        \"virtual_table\": \"SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3623", "db_id": "music_1", "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "Determine the columns needed: duration from 'song', file_size and formats from 'files'.", "Establish the relationship between the tables using the foreign key: 'song.f_id' relates to 'files.f_id'.", "Filter the results to include only songs where the genre is 'pop'.", "Order the results by the song title (song_name).", "Construct the SQL query using the SELECT statement with the appropriate JOIN and WHERE clauses."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT T1.duration, T2.file_size, T2.formats \nFROM song AS T1 \nJOIN files AS T2 ON T1.f_id = T2.f_id \nWHERE T1.genre_is = 'pop' \nORDER BY T1.song_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "We need to select the duration, file size, and formats, which are in the 'song' and 'files' tables.", "Join the 'song' table with the 'files' table on the foreign key 'f_id' to access both song and file details.", "Filter the results to include only those songs that belong to the 'pop' genre using a WHERE clause.", "Order the results alphabetically by the song title using ORDER BY clause."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT T1.duration, T2.file_size, T2.formats \nFROM song AS T1 \nJOIN files AS T2 ON T1.f_id = T2.f_id \nWHERE T1.genre_is = 'pop' \nORDER BY T1.song_name ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["Identify the relevant tables: 'salary' for player salaries and 'team' for team names.", "Join the 'salary' table with the 'team' table on the team identifier to link salaries to the respective teams.", "Use the 'avg' function to calculate the average salary from the 'salary' table.", "Filter the results to include only those players from the team named 'Boston Red Stockings' using a WHERE clause."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "pred_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average salary of players from a specific team in the 'salary' table. The placeholder in the WHERE clause represents the name of the team for which the average salary is being calculated.\",\n        \"virtual_table\": \"SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their birth countries.", "Select the 'birth_country' column and count the number of players from each country using COUNT(player_id).", "Group the results by 'birth_country' to aggregate the player counts for each country.", "Order the results in ascending order based on the player count to find the countries with the least players.", "Limit the results to the top 3 countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["We need to find the highest salary for each team, which requires aggregating salary data by team.", "To do this, we will use the MAX function to get the maximum salary.", "We will join the salary table with the team table to get the team names and IDs.", "The join condition will be on the team_id column from both tables.", "Finally, we will group the results by team_id and team name to ensure we get the maximum salary for each team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T2.name, T2.team_id, MAX(T1.salary) AS max_salary \nFROM salary AS T1 \nJOIN team AS T2 ON T1.team_id = T2.team_id \nGROUP BY T2.team_id, T2.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3658", "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["We need to retrieve the team name, team id, and the maximum salary for each team.", "To do this, we will select the team name and team id from the 'team' table.", "We will also need to calculate the maximum salary from the 'salary' table.", "We will join the 'salary' table with the 'team' table on the team_id to associate salaries with the correct teams.", "We will use the MAX() function to find the maximum salary for each team.", "Finally, we will group the results by team name and team id to ensure we get one result per team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T2.name, T2.team_id, MAX(T1.salary) AS max_salary\nFROM salary AS T1\nJOIN team AS T2 ON T1.team_id = T2.team_id\nGROUP BY T2.name, T2.team_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["Identify the tables needed: 'team' for team names and IDs, and 'salary' for salary information.", "Join the 'team' table with the 'salary' table on 'team_id' to associate teams with their salaries.", "Group the results by 'team_id' to calculate the average salary for each team.", "Order the results by the average salary in ascending order to find the team with the lowest average salary.", "Limit the results to 1 to get only the team with the lowest average salary."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T2.name, T2.team_id FROM team AS T2 JOIN salary AS T1 ON T2.team_id = T1.team_id GROUP BY T2.team_id ORDER BY AVG(T1.salary) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average salary of players from a specific team in the 'salary' table. The placeholder in the WHERE clause represents the name of the team for which the average salary is being calculated.\",\n        \"virtual_table\": \"SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["Identify the tables needed: We need the 'player' table for player names and the 'player_award' table to check for awards won by players.", "Join the 'player' table with the 'player_award' table twice: one for the year 1960 and another for the year 1961. This allows us to find players who won awards in both years.", "Use the condition in the WHERE clause to filter the results for the specific years (1960 and 1961).", "Select the first and last names of the players who meet the criteria."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.name_first, p.name_last\nFROM player p\nJOIN player_award pa1 ON p.player_id = pa1.player_id\nJOIN player_award pa2 ON p.player_id = pa2.player_id\nWHERE pa1.year = 1960 AND pa2.year = 1961;", "hint": "\n"}
{"sample_id": "train.3663", "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["Identify the columns needed: 'name_given' for the first name and 'name_last' for the last name from the 'player' table.", "Determine the conditions for filtering: weight greater than 220 or height shorter than 75.", "Construct the SQL SELECT statement to retrieve the specified columns from the 'player' table with the appropriate WHERE clause for the conditions."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_given, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "\n"}
{"sample_id": "train.3664", "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["Identify the relevant table: The 'player' table contains the information about players including their first name, last name, weight, and height.", "Determine the columns needed: We need 'name_first' and 'name_last' for the player's names.", "Establish the conditions: We want players with a weight greater than 220 or a height less than 75.", "Construct the SQL query: Use a SELECT statement to retrieve the names from the 'player' table where the specified conditions are met."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) of the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include the Boston Red Stockings.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(wins) FROM postseason AS P JOIN team AS T ON P.team_id_winner = T.team_id WHERE T.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) for the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(wins) FROM postseason AS P JOIN team AS T ON P.team_id_winner = T.team_id WHERE T.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
