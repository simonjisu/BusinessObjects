{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["Identify the table that contains course registrations, which is 'Student_Course_Registrations'.", "Count the number of students registered for each course by using COUNT(student_id) and group the results by course_id.", "Order the results in descending order to find the course with the most registrations.", "Limit the results to 1 to get only the course with the highest number of registered students."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT course_id, COUNT(student_id) AS number_of_students \nFROM Student_Course_Registrations \nGROUP BY course_id \nORDER BY number_of_students DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n    \"1\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n    \"2\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["The question asks for the IDs of students who attended some courses.", "To find this information, we need to look at the 'Student_Course_Attendance' table, which records attendance of students for courses.", "We want to select unique student IDs, so we will use the DISTINCT keyword to avoid duplicates.", "The final SQL query will select the distinct student_id from the Student_Course_Attendance table."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n    \"2\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\"\n}\n"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["The question asks for the IDs of all students who have attended at least one course.", "To find this information, we need to look at the 'Student_Course_Attendance' table, which records attendance for students in courses.", "We will select the 'student_id' from the 'Student_Course_Attendance' table.", "Using DISTINCT ensures that we only get unique student IDs, as a student may have attended multiple courses."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n    \"2\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\"\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["Identify the relevant tables: Candidates, People, and Student_Course_Attendance.", "Join the Candidates table with the People table to link candidates to their personal information.", "Join the resulting table with the Student_Course_Attendance table to find attendance records for candidates.", "Order the results by the date of attendance in descending order to get the most recent attendance first.", "Limit the results to 1 to get only the most recent candidate who accessed the course."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT DISTINCT c.candidate_id \nFROM Candidates c \nJOIN People p ON c.candidate_id = p.person_id \nJOIN Student_Course_Attendance a ON p.person_id = a.student_id \nORDER BY a.date_of_attendance DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n    \"2\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\"\n}\n"}
{"sample_id": "train.77", "db_id": "student_assessment", "question": "What is detail of the student who registered the most number of courses?", "rationale": ["Identify the table that contains student details, which is the 'Students' table.", "Determine the relationship between students and their course registrations, which is found in the 'Student_Course_Registrations' table.", "To find the student who registered for the most courses, we need to count the number of course registrations for each student.", "Group the results by student_id and order them by the count of course registrations in descending order.", "Limit the results to only the top entry to get the student with the most registrations.", "Join this result back to the 'Students' table to retrieve the details of that student."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT s.student_id, s.student_details \nFROM Students s \nJOIN ( \n    SELECT student_id, COUNT(course_id) AS course_count \n    FROM Student_Course_Registrations \n    GROUP BY student_id \n    ORDER BY course_count DESC \n    LIMIT 1 \n) AS most_courses ON s.student_id = most_courses.student_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n    \"2\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\"\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["We need to retrieve the course ID and course names along with the count of registered students for each course.", "To achieve this, we will use a SELECT statement to get the course_id and course_name from the Courses table.", "We will also need to count the number of students registered for each course, which can be done using the COUNT() function on the student_id from the Student_Course_Registrations table.", "To link the Courses and Student_Course_Registrations tables, we will use a LEFT JOIN on the course_id.", "We will group the results by course_id and course_name to ensure we get the count of students for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT Courses.course_id, COUNT(Student_Course_Registrations.student_id) AS student_count, Courses.course_name \nFROM Courses \nLEFT JOIN Student_Course_Registrations ON Courses.course_id = Student_Course_Registrations.course_id \nGROUP BY Courses.course_id, Courses.course_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n    \"2\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\"\n}\n"}
{"sample_id": "train.90", "db_id": "student_assessment", "question": "What are the ids of the students who registered for course 301 most recently?", "rationale": ["Identify the relevant table: 'Student_Course_Registrations' contains the registration information for students and courses.", "Filter the records to only include those where the course_id is '301'.", "Order the results by 'registration_date' in descending order to get the most recent registration first.", "Limit the results to 1 to get only the most recent student registration for course 301."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n    \"2\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["We need to find distinct cities of addresses associated with students.", "To do this, we will join the Addresses table with the People_Addresses table to link addresses to people.", "Next, we will join the resulting table with the Students table to filter for only those people who are students.", "Finally, we will select the distinct cities from the Addresses table."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "pred_sql": "SELECT DISTINCT a.city\nFROM Addresses a\nJOIN People_Addresses pa ON a.address_id = pa.address_id\nJOIN Students s ON pa.person_id = s.student_id;", "hint": "\n"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["We need to find students who registered for courses but did not attend any.", "First, we will select the details from the 'Students' table.", "We will join the 'Student_Course_Registrations' table to get the registered courses for each student.", "Next, we will perform a LEFT JOIN with the 'Student_Course_Attendance' table to check for attendance records.", "In the WHERE clause, we will filter for students where the attendance record is NULL, indicating they did not attend any course."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "pred_sql": "SELECT s.student_id, s.student_details \nFROM Students s \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nLEFT JOIN Student_Course_Attendance sca ON scr.student_id = sca.student_id AND scr.course_id = sca.course_id \nWHERE sca.student_id IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n    \"2\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant tables: We need to look at the 'Student_Course_Registrations' table to find students who registered for courses, and the 'Courses' table to filter for the course named 'Statistics'.", "Join the tables: We will join 'Student_Course_Registrations' with 'Courses' on the course_id to access course names.", "Filter for the specific course: We will add a WHERE clause to filter the results to only include registrations for the course 'Statistics'.", "Select the student_id: We will select the student_id from the 'Student_Course_Registrations' table.", "Order by registration date: Finally, we will order the results by the registration_date to get the students in the order they registered."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT sr.student_id\nFROM Student_Course_Registrations sr\nJOIN Courses c ON sr.course_id = c.course_id\nWHERE c.course_name = 'Statistics'\nORDER BY sr.registration_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n    \"2\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\"\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Determine the specific course of interest, which is 'Statistics'.", "Use a subquery to find the course_id associated with the course name 'Statistics'.", "Select the student_id from 'Student_Course_Registrations' where the course_id matches the one found in the subquery.", "Order the results by the registration_date to get the ids in the order of registration."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n    \"2\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.123", "db_id": "bike_1", "question": "For each zip code, return the average mean temperature of August there.", "rationale": ["Identify the relevant table: The 'weather' table contains the temperature data and zip codes.", "Determine the columns needed: We need 'zip_code' and the average of 'mean_temperature_f'.", "Filter the data for August: Use a WHERE clause to filter the dates to include only those in August.", "Group the results: Use GROUP BY to aggregate the results by 'zip_code' to get the average temperature for each zip code."], "gold_sql": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE '8/%' GROUP BY zip_code", "source_tables": ["weather"], "pred_sql": "SELECT zip_code, AVG(mean_temperature_f) AS average_mean_temperature\nFROM weather\nWHERE date BETWEEN '2023-08-01' AND '2023-08-31'\nGROUP BY zip_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n    \"1\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n    \"2\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\"\n}\n"}
{"sample_id": "train.135", "db_id": "bike_1", "question": "Which bike traveled the most often in zip code 94002?", "rationale": ["Identify the relevant table: The 'trip' table contains information about bike trips, including the bike identifier and the zip code of the user.", "Filter trips by zip code: We need to filter the trips to only include those that started in zip code 94002.", "Count trips per bike: We will group the results by bike_id and count the number of trips for each bike.", "Order by trip count: To find the bike that traveled the most often, we will order the results in descending order based on the trip count.", "Limit the results: Since we only want the bike that traveled the most often, we will limit the results to 1."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id, COUNT(*) AS trip_count\nFROM trip\nWHERE zip_code = '94002'\nGROUP BY bike_id\nORDER BY trip_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n    \"1\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n    \"2\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\"\n}\n"}
{"sample_id": "train.136", "db_id": "bike_1", "question": "What is the id of the bike that traveled the most in 94002?", "rationale": ["Identify the relevant table: The 'trip' table contains the information about bike trips, including the bike_id and duration.", "Filter trips by zip code: We need to focus on trips that started in the zip code '94002'.", "Order the results: To find the bike that traveled the most, we will order the trips by duration in descending order.", "Limit the results: Since we only need the bike that traveled the most, we will limit the results to 1."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id\nFROM trip\nWHERE zip_code = '94002'\nORDER BY duration DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n    \"1\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n    \"2\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\"\n}\n"}
{"sample_id": "train.143", "db_id": "bike_1", "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?", "rationale": ["We need to select the names and ids of stations.", "The relevant tables are 'station' and 'status'.", "We will join the 'station' table with the 'status' table on the station id.", "We need to group the results by station id to calculate the average number of bikes available.", "We will use the HAVING clause to filter for stations with an average of more than 14 bikes available.", "Additionally, we will check if the installation date of the station falls in December using the strftime function to extract the month from the installation_date."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT s.name, s.id \nFROM station s \nJOIN status st ON s.id = st.station_id \nGROUP BY s.id \nHAVING AVG(st.bikes_available) > 14 OR strftime('%m', s.installation_date) = '12';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n    \"1\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.144", "db_id": "bike_1", "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "rationale": ["Identify the relevant tables: 'station' for station details and 'status' for bike availability.", "Join the 'station' table with the 'status' table on the station ID to access bike availability data.", "Group the results by station ID to calculate the average number of bikes available for each station.", "Use the HAVING clause to filter stations that have an average of more than 14 bikes available.", "Additionally, check if the installation date of the station falls in December using a LIKE clause to match the month in the date format."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT s.name, s.id \nFROM station s \nJOIN status st ON s.id = st.station_id \nGROUP BY s.id \nHAVING AVG(st.bikes_available) > 14 \n   OR s.installation_date LIKE '%-12-%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n    \"1\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.145", "db_id": "bike_1", "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?", "rationale": ["Identify the relevant table: The question pertains to cloud cover rates, which are found in the 'weather' table.", "Filter by zip code: We need to focus on records where the zip code is 94107, so we will include a WHERE clause for this.", "Group by cloud cover: To find the most common cloud cover rates, we will group the results by the 'cloud_cover' column.", "Count occurrences: We will count how many times each cloud cover rate appears using COUNT(cloud_cover).", "Order results: To find the most common rates, we will order the results in descending order based on the count of occurrences.", "Limit results: Finally, we will limit the results to the top 3 most common cloud cover rates using LIMIT 3."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "pred_sql": "SELECT cloud_cover, COUNT(cloud_cover) AS cover_count\nFROM weather\nWHERE zip_code = 94107\nGROUP BY cloud_cover\nORDER BY cover_count DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n    \"1\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n    \"2\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\"\n}\n"}
{"sample_id": "train.161", "db_id": "bike_1", "question": "For each trip, return its ending station's installation date.", "rationale": ["We need to return the installation date of the ending station for each trip.", "The relevant tables are 'trip' and 'station'.", "We will join the 'trip' table with the 'station' table on the condition that the 'end_station_id' from the 'trip' table matches the 'id' from the 'station' table.", "We will select the 'installation_date' from the 'station' table as it corresponds to the ending station of each trip."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.installation_date \nFROM trip t \nJOIN station s ON t.end_station_id = s.id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n    \"1\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n    \"2\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\"\n}\n"}
{"sample_id": "train.162", "db_id": "bike_1", "question": "What is the installation date for each ending station on all the trips?", "rationale": ["Identify the relevant tables: 'trip' for trips and 'station' for station details.", "We need the installation date of each ending station, which is found in the 'station' table.", "The 'trip' table contains the 'end_station_id' which links to the 'id' in the 'station' table.", "Use a JOIN operation to combine 'trip' and 'station' on the condition that 'trip.end_station_id' matches 'station.id'.", "Select the 'installation_date' from the 'station' table after the join."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.installation_date \nFROM trip t \nJOIN station s ON t.end_station_id = s.id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n    \"1\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\"\n}\n"}
{"sample_id": "train.163", "db_id": "bike_1", "question": "Which trip started from the station with the largest dock count? Give me the trip id.", "rationale": ["Identify the relevant tables: We need to look at the 'trip' table for trip details and the 'station' table for dock counts.", "Determine the relationship: The 'trip' table has a foreign key 'start_station_id' that relates to the 'id' in the 'station' table.", "Find the station with the largest dock count: We can use a subquery to find the maximum dock count from the 'station' table.", "Join the tables: We will join the 'trip' table with the 'station' table on the station ID to filter trips that started from the station with the maximum dock count.", "Select the trip ID: Finally, we will select the trip ID from the resulting dataset."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "pred_sql": "SELECT trip.id \nFROM trip \nJOIN station ON trip.start_station_id = station.id \nWHERE station.dock_count = (SELECT MAX(dock_count) FROM station);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n    \"1\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n    \"2\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\"\n}\n"}
{"sample_id": "train.165", "db_id": "bike_1", "question": "Count the number of trips that did not end in San Francisco city.", "rationale": ["Identify the requirement to count trips that did not end in San Francisco.", "To achieve this, we need to filter trips based on their end station.", "We will use a subquery to find all station IDs that are located in San Francisco.", "The subquery will select the 'id' from the 'station' table where the 'city' is 'San Francisco'.", "The main query will count all trips where the 'end_station_id' is not in the list of IDs returned by the subquery."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) AS trip_count \nFROM trip \nWHERE end_station_id NOT IN (\n    SELECT id \n    FROM station \n    WHERE city = 'San Francisco'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.166", "db_id": "bike_1", "question": "How many trips did not end in San Francisco?", "rationale": ["Identify the relevant table: The 'trip' table contains information about trips, including the end station name.", "Determine the condition: We need to count trips that did not end in San Francisco, which means we will filter the results where the 'end_station_name' is not equal to 'San Francisco'.", "Use the COUNT function: To get the total number of trips that meet the condition, we will use the COUNT(*) function.", "Construct the SQL query: Combine the SELECT statement with the FROM clause and the WHERE condition to form the complete SQL query."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != 'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) AS trip_count \nFROM trip \nWHERE end_station_name != 'San Francisco';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.167", "db_id": "bike_1", "question": "In zip code 94107, on which day neither Fog nor Rain was not observed?", "rationale": ["Identify the relevant table: The 'weather' table contains the weather reports including events like Fog and Rain.", "Filter by zip code: We need to focus on the records where the zip code is 94107.", "Exclude specific weather events: We want to find days where neither Fog nor Rain was observed, which can be done by checking the 'events' column for the absence of these terms.", "Select distinct dates: We want to retrieve unique dates that meet the criteria, so we will use SELECT DISTINCT."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT date \nFROM weather \nWHERE zip_code = 94107 \nAND events NOT LIKE '%Fog%' \nAND events NOT LIKE '%Rain%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n    \"1\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n    \"2\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\"\n}\n"}
{"sample_id": "train.168", "db_id": "bike_1", "question": "On which day has it neither been foggy nor rained in the zip code of 94107?", "rationale": ["Identify the relevant table: The 'weather' table contains the necessary information about weather conditions.", "Determine the conditions for the query: We need to find days with no fog (events IS NULL) and no rain (precipitation_inches = 0).", "Specify the zip code: We are interested in the weather reports for the zip code 94107.", "Construct the SQL query: Select the date from the weather table where the conditions are met."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT date \nFROM weather \nWHERE zip_code = 94107 \nAND events IS NULL \nAND precipitation_inches = 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n    \"1\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n    \"2\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\"\n}\n"}
{"sample_id": "train.183", "db_id": "bike_1", "question": "List all the cities in a decreasing order of each city's stations' highest latitude.", "rationale": ["We need to list all the cities from the 'station' table.", "To find the highest latitude for each city, we will use the MAX function on the 'lat' column.", "We will group the results by 'city' to ensure we get the highest latitude for each city.", "Finally, we will order the results in decreasing order of the highest latitude using ORDER BY clause."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, MAX(lat) AS highest_latitude\nFROM station\nGROUP BY city\nORDER BY highest_latitude DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.184", "db_id": "bike_1", "question": "For each city, list their names in decreasing order by their highest station latitude.", "rationale": ["We need to select the city and name of the stations from the 'station' table.", "The requirement is to list the names of the stations for each city.", "To fulfill the requirement of ordering by the highest latitude, we will use the 'lat' column from the 'station' table.", "We will order the results in descending order to get the highest latitude first."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, name FROM station ORDER BY lat DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\"\n}\n"}
{"sample_id": "train.189", "db_id": "bike_1", "question": "For each station, return its longitude and the average duration of trips that started from the station.", "rationale": ["We need to select the longitude of each station and the average duration of trips that started from that station.", "The 'station' table contains the longitude information, while the 'trip' table contains the duration of trips and the starting station ID.", "To get the average duration of trips for each station, we will join the 'station' table with the 'trip' table on the station ID.", "We will group the results by the station ID to calculate the average duration for each station.", "Finally, we will select the longitude and the calculated average duration in the SQL query."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.long, AVG(t.duration) AS average_duration\nFROM station s\nJOIN trip t ON s.id = t.start_station_id\nGROUP BY s.id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n    \"1\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n    \"2\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\"\n}\n"}
{"sample_id": "train.190", "db_id": "bike_1", "question": "For each start station id, what is its name, longitude and average duration of trips started there?", "rationale": ["We need to retrieve the start station id, name, longitude, and average duration of trips that started at each station.", "The relevant table for station information is the 'station' table, which contains the station id, name, and longitude.", "The 'trip' table contains the duration of trips and the start station id.", "To get the average duration of trips for each start station, we will join the 'station' table with the 'trip' table on the station id and the start station id.", "We will use the AVG() function to calculate the average duration of trips for each station.", "Finally, we will group the results by the station id, name, and longitude to get the average duration for each unique station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.id, s.name, s.long, AVG(t.duration) AS average_duration\nFROM station s\nJOIN trip t ON s.id = t.start_station_id\nGROUP BY s.id, s.name, s.long;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n    \"1\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n    \"2\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\"\n}\n"}
{"sample_id": "train.192", "db_id": "bike_1", "question": "For each end station id, what is its name, latitude, and minimum duration for trips ended there?", "rationale": ["We need to retrieve the end station id, name, latitude, and minimum duration for trips that ended at each station.", "The relevant tables are 'station' for station details and 'trip' for trip details.", "We will join the 'station' table with the 'trip' table on the end station id, which is represented by 'end_station_id' in the 'trip' table.", "We will select the station id, name, and latitude from the 'station' table, and the minimum duration of trips from the 'trip' table.", "To get the minimum duration, we will use the MIN() function and group the results by station id, name, and latitude."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.id, s.name, s.lat, MIN(t.duration) AS min_duration\nFROM station s\nJOIN trip t ON s.id = t.end_station_id\nGROUP BY s.id, s.name, s.lat;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n    \"1\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n    \"2\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\"\n}\n"}
{"sample_id": "train.196", "db_id": "bike_1", "question": "What are all the different zip codes that have a maximum dew point that was always below 70?", "rationale": ["We need to find all unique zip codes where the maximum dew point is always below 70.", "To achieve this, we will select distinct zip codes from the weather table.", "We will group the results by zip_code to aggregate the data for each zip code.", "We will use the HAVING clause to filter the groups where the maximum dew point (max_dew_point_f) is less than 70."], "gold_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT zip_code \nFROM weather \nGROUP BY zip_code \nHAVING MAX(max_dew_point_f) < 70;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n    \"1\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n    \"2\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\"\n}\n"}
{"sample_id": "train.205", "db_id": "bike_1", "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.", "rationale": ["We need to find zip codes where the average mean humidity is below 70 and at least 100 trips took place.", "First, we will group the 'trip' table by 'zip_code' and count the number of trips for each zip code using COUNT(id).", "We will filter these groups using HAVING to ensure that only those with at least 100 trips are included.", "Next, we need to check the average mean humidity for each zip code in the 'weather' table.", "We will create a subquery that groups the 'weather' table by 'zip_code' and calculates the average mean humidity using AVG(mean_humidity).", "We will filter this subquery using HAVING to include only those zip codes where the average mean humidity is below 70.", "Finally, we will use the results of the subquery to filter the main query, ensuring that we only select zip codes that meet both criteria."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code \nFROM trip \nGROUP BY zip_code \nHAVING COUNT(id) >= 100 AND zip_code IN (\n    SELECT zip_code \n    FROM weather \n    GROUP BY zip_code \n    HAVING AVG(mean_humidity) < 70\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n    \"1\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n    \"2\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\"\n}\n"}
{"sample_id": "train.206", "db_id": "bike_1", "question": "What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?", "rationale": ["We need to find zip codes with an average mean humidity below 70 and at least 100 trips.", "First, we will group the 'trip' table by 'zip_code' and count the number of trips for each zip code using COUNT(id).", "Next, we will filter these groups to only include those with at least 100 trips using HAVING COUNT(id) >= 100.", "Simultaneously, we need to check the average mean humidity for each zip code in the 'weather' table.", "We will create a subquery that groups the 'weather' table by 'zip_code' and calculates the average mean humidity using AVG(mean_humidity).", "We will filter this subquery to only include zip codes where the average mean humidity is below 70 using HAVING AVG(mean_humidity) < 70.", "Finally, we will use the results of the subquery to filter the main query, ensuring that we only select zip codes that meet both criteria."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code \nFROM trip \nGROUP BY zip_code \nHAVING COUNT(id) >= 100 AND zip_code IN (\n    SELECT zip_code \n    FROM weather \n    GROUP BY zip_code \n    HAVING AVG(mean_humidity) < 70\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n    \"1\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n    \"2\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\"\n}\n"}
{"sample_id": "train.304", "db_id": "product_catalog", "question": "What are the attribute data types with more than 3 attribute definitions?", "rationale": ["Identify the table that contains the attribute definitions, which is 'Attribute_Definitions'.", "We need to find the attribute data types, so we will select the 'attribute_data_type' column.", "To find the data types with more than 3 definitions, we will group the results by 'attribute_data_type'.", "We will use the HAVING clause to filter groups that have a count of 'attribute_id' greater than 3."], "gold_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  3", "source_tables": ["attribute_definitions"], "pred_sql": "SELECT attribute_data_type\nFROM Attribute_Definitions\nGROUP BY attribute_data_type\nHAVING COUNT(attribute_id) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\"\n}\n"}
{"sample_id": "train.316", "db_id": "product_catalog", "question": "Find the entry names of the catalog with the attribute that have the most entries.", "rationale": ["Identify the relevant tables: Catalog_Contents for entry names and Catalog_Contents_Additional_Attributes for attributes.", "Join Catalog_Contents with Catalog_Contents_Additional_Attributes on catalog_entry_id to link entries with their attributes.", "Group the results by catalog_entry_name to count the number of attributes associated with each entry.", "Order the results by the count of attributes in descending order to find the entry with the most attributes.", "Limit the results to 1 to get only the entry name with the most attributes."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT cc.catalog_entry_name\nFROM Catalog_Contents cc\nJOIN Catalog_Contents_Additional_Attributes cca ON cc.catalog_entry_id = cca.catalog_entry_id\nGROUP BY cc.catalog_entry_name\nORDER BY COUNT(cca.attribute_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n    \"1\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n    \"2\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\"\n}\n"}
{"sample_id": "train.317", "db_id": "product_catalog", "question": "What is the entry name of the most expensive catalog (in USD)?", "rationale": ["Identify the relevant table: Catalog_Contents contains the catalog entries and their prices.", "We need to find the entry name of the most expensive catalog, which means we need to order the entries by price in descending order.", "Use the ORDER BY clause to sort the entries by price_in_dollars in descending order.", "Limit the results to 1 to get only the most expensive entry.", "Select the catalog_entry_name to get the name of the most expensive catalog entry."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents ORDER BY price_in_dollars DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n    \"1\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n    \"2\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\"\n}\n"}
{"sample_id": "train.330", "db_id": "product_catalog", "question": "What are the names of catalog entries with level number 8?", "rationale": ["Identify the relevant table: The question asks for catalog entries, which are found in the 'Catalog_Contents' table.", "Determine the specific column needed: The question specifically asks for the names of the catalog entries, which corresponds to the 'catalog_entry_name' column.", "Apply the filter: The question specifies a level number of 8, so we need to filter the results where 'catalog_level_number' equals '8'.", "Construct the SQL query: Combine the selected column and the filter condition into a complete SQL query."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  '8'", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE catalog_level_number = '8';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n    \"1\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n    \"2\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\"\n}\n"}
{"sample_id": "train.331", "db_id": "product_catalog", "question": "Find the names of the products with length smaller than 3 or height greater than 5.", "rationale": ["Identify the table that contains product information, which is the Catalog_Contents table.", "Determine the relevant columns needed for the query: catalog_entry_name for product names, length for the length condition, and height for the height condition.", "Construct the SQL SELECT statement to retrieve the catalog_entry_name from the Catalog_Contents table.", "Add the WHERE clause to filter products based on the conditions: length smaller than 3 or height greater than 5."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name \nFROM Catalog_Contents \nWHERE length < 3 OR height > 5;", "hint": "\n"}
{"sample_id": "train.332", "db_id": "product_catalog", "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.", "rationale": ["Identify the relevant table: The question asks about catalog contents, which are stored in the 'Catalog_Contents' table.", "Determine the columns needed: We need the 'catalog_entry_name' column from the 'Catalog_Contents' table.", "Apply the conditions: The question specifies that we need entries with a length below 3 or above 5. This translates to a WHERE clause in SQL that filters based on the 'length' column.", "Construct the SQL query: Combine the SELECT statement with the FROM clause and the WHERE conditions to form the complete SQL query."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE length < 3 OR length > 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n    \"1\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n    \"2\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\"\n}\n"}
{"sample_id": "train.338", "db_id": "product_catalog", "question": "On which days more than one revisions were made on catalogs.", "rationale": ["Identify the relevant table: The 'Catalogs' table contains information about catalog revisions, specifically the 'date_of_latest_revision' column.", "Group the results by the 'date_of_latest_revision' to count how many revisions were made on each date.", "Use the COUNT function to count the number of revisions for each date.", "Filter the results using the HAVING clause to only include dates where the count of revisions is greater than one."], "gold_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1", "source_tables": ["catalogs"], "pred_sql": "SELECT date_of_latest_revision, COUNT(*) as revision_count \nFROM Catalogs \nGROUP BY date_of_latest_revision \nHAVING COUNT(*) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n    \"1\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n    \"2\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\"\n}\n"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flight origins and destinations.", "Determine the required information: We need to find the origins of flights that are headed to Honolulu.", "Construct the SQL query: Use SELECT to get distinct origins from the flight table where the destination is 'Honolulu'."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT DISTINCT origin FROM flight WHERE destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n    \"1\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the required columns: We need the 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We are interested in flights that depart from 'LA' and arrive at 'Honolulu'.", "Construct the SQL query: Use a SELECT statement to retrieve the specified columns from the 'flight' table, applying the necessary WHERE clause to filter the results."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n    \"1\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their prices.", "Determine the columns needed: We need the 'price' column to calculate the average price.", "Filter the results: We need to filter the flights to only include those from 'LA' to 'Honolulu'.", "Use the AVG() function: To calculate the average price of the filtered flights, we will use the AVG() function in SQL.", "Construct the SQL query: Combine all the elements into a complete SQL query that selects the average price from the flight table with the specified conditions."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT AVG(price) AS average_price \nFROM flight \nWHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n    \"1\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["Identify the tables needed: We need data from the 'aircraft' table for aircraft names and from the 'flight' table to count the number of flights.", "We will use a LEFT JOIN to combine the 'aircraft' table with the 'flight' table on the aircraft ID (aid) to ensure we get all aircraft even if they have no flights.", "We will use COUNT(f.flno) to count the number of flights associated with each aircraft.", "We need to group the results by aircraft ID and name to get the count for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT a.name, COUNT(f.flno) AS number_of_flights\nFROM aircraft a\nLEFT JOIN flight f ON a.aid = f.aid\nGROUP BY a.aid, a.name;", "hint": "\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables needed: We need information from the 'aircraft' table for aircraft names and the 'flight' table to count the number of flights.", "We will use a LEFT JOIN to connect the 'aircraft' table with the 'flight' table on the aircraft ID (aid) to ensure we include all aircraft, even those with no flights.", "We will use COUNT(f.flno) to count the number of flights for each aircraft.", "We will group the results by the aircraft ID (a.aid) to get the count of flights for each aircraft.", "Finally, we will select the aircraft name and the count of flights in the output."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT a.name, COUNT(f.flno) AS flight_count\nFROM aircraft a\nLEFT JOIN flight f ON a.aid = f.aid\nGROUP BY a.aid;", "hint": "\n"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["Identify the tables involved: employee, certificate, and aircraft.", "We need to find employees who are not certified to fly a specific aircraft (Boeing 737-800).", "Use a LEFT JOIN to connect employee with certificate to find all employees and their certifications.", "Use another LEFT JOIN to connect certificate with aircraft to get the aircraft details.", "Filter the results to include only those employees who do not have a certification for Boeing 737-800.", "The condition for filtering is that the aircraft name should not be 'Boeing 737-800' or the aircraft name should be NULL (indicating no certification)."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.name \nFROM employee e \nLEFT JOIN certificate c ON e.eid = c.eid \nLEFT JOIN aircraft a ON c.aid = a.aid \nWHERE a.name != 'Boeing 737-800' OR a.name IS NULL;", "hint": "\n"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["Identify the relevant tables: We need to get the aircraft names from the 'aircraft' table and the count of certificates from the 'certificate' table.", "Join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid) to associate each aircraft with its certificates.", "Group the results by aircraft ID to count how many certificates each aircraft has.", "Order the results by the count of certificates in ascending order to find the aircraft with the fewest certificates.", "Limit the results to 1 to get only the aircraft with the fewest certificates."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nORDER BY COUNT(c.eid) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.432", "db_id": "flight_1", "question": "What are the names of the aircraft that the least people are certified to fly?", "rationale": ["Identify the relevant tables: We need to find aircraft names and the number of employees certified to fly each aircraft, so we will use the 'aircraft' and 'certificate' tables.", "Join the tables: We will join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid) to link aircraft with their certified employees.", "Group by aircraft: We will group the results by the aircraft ID to count the number of certifications for each aircraft.", "Count certifications: Use COUNT(c.eid) to count the number of employees certified for each aircraft.", "Order by count: We will order the results in ascending order based on the count of certifications to find the aircraft with the least certifications.", "Limit the results: Finally, we will limit the results to 1 to get the aircraft with the least number of certified employees."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nORDER BY COUNT(c.eid) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["Identify the relevant tables: employee, certificate, and aircraft.", "We need to find employees who have certificates to fly aircraft with a distance greater than 5000.", "Join the employee table with the certificate table on employee ID (eid) and then join with the aircraft table on aircraft ID (aid).", "Filter the results to include only those aircraft where the distance is greater than 5000.", "Group the results by employee ID to count the number of certificates each employee has.", "Order the results by the count of certificates in descending order to find the employee with the most certificates.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.salary, e.name \nFROM employee e \nJOIN certificate c ON e.eid = c.eid \nJOIN aircraft a ON c.aid = a.aid \nWHERE a.distance > 5000 \nGROUP BY e.eid \nORDER BY COUNT(c.aid) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The question asks for all the different food allergies, which implies we need to retrieve unique allergy names.", "We will use the 'Allergy_Type' table, which contains the 'Allergy' column that lists the names of the allergies.", "To get all unique allergies, we will use the SELECT DISTINCT statement to avoid duplicates."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Allergy_Type;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.452", "db_id": "allergy_1", "question": "How many animal type allergies exist?", "rationale": ["Identify the relevant table: The Allergy_Type table contains the allergy types.", "Determine the specific allergy type: We are interested in counting the distinct allergy types that fall under 'Animal'.", "Use the COUNT function to count the distinct AllergyType entries that match 'Animal'.", "Construct the SQL query to select the count of distinct AllergyType from the Allergy_Type table where the AllergyType is 'Animal'."], "gold_sql": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  'animal'", "source_tables": ["allergy_type"], "pred_sql": "SELECT COUNT(DISTINCT AllergyType) AS Animal_Allergy_Count\nFROM Allergy_Type\nWHERE AllergyType = 'Animal';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["Identify the tables involved: We need to look at the 'Allergy_Type' and 'Has_Allergy' tables to find the allergy types and their counts.", "Join the tables: We will join 'Has_Allergy' with 'Allergy_Type' on the common column 'Allergy' to get the allergy types associated with each student.", "Group by allergy type: We will group the results by 'AllergyType' to count how many allergies fall under each type.", "Count the allergies: Use COUNT() to count the number of occurrences of each allergy type.", "Order the results: We will order the results in descending order based on the count of allergies to find the most common allergy type.", "Limit the results: Finally, we will limit the results to 1 to get only the allergy type with the highest count."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(Has_Allergy.Allergy) AS AllergyCount\nFROM Has_Allergy\nJOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy\nGROUP BY AllergyType\nORDER BY AllergyCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["We need to find the least common allergy type, which means we need to count how many students have each type of allergy.", "To do this, we will join the 'Has_Allergy' table with the 'Allergy_Type' table on the Allergy column.", "We will group the results by AllergyType to get the count of students for each allergy type.", "Next, we will order the results by the count of students in ascending order to find the least common allergy type.", "Finally, we will limit the results to 1 to get only the least common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(StuID) AS AllergyCount\nFROM Has_Allergy\nJOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy\nGROUP BY AllergyType\nORDER BY AllergyCount ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student names, which is the 'Student' table.", "To get the full names, we need to concatenate the 'Fname' and 'LName' columns.", "Use the SQL SELECT statement to retrieve the concatenated names as 'FullName'."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName FROM Student;", "hint": "\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the table needed: The 'Student' table contains the information about students, including their IDs and gender.", "Determine the condition: We need to filter the students based on their gender, specifically for male students.", "Construct the SQL query: Use a SELECT statement to retrieve the 'StuID' from the 'Student' table where the 'Sex' column equals 'Male'."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\"\n}\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the majors, which is the 'Student' table.", "We need to group the results by the 'Major' column to count how many students are in each major.", "Use the COUNT function to count the number of students (StuID) for each major.", "Order the results in descending order based on the count of students to find the largest major.", "Limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(StuID) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major and ordered by the number of students in each major in descending order. The placeholder in the LIMIT clause represents the maximum number of majors to return.\"\n}\n"}
{"sample_id": "train.502", "db_id": "allergy_1", "question": "Give the advisor with the most students.", "rationale": ["Identify the table that contains advisor information, which is the 'Student' table.", "We need to count the number of students for each advisor, so we will use the COUNT() function on the 'StuID' column.", "Group the results by the 'Advisor' column to aggregate the student counts for each advisor.", "Order the results in descending order based on the count of students to find the advisor with the most students.", "Limit the results to 1 to get only the advisor with the highest count."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(StuID) AS StudentCount\nFROM Student\nGROUP BY Advisor\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of academic advisors from the 'Student' table, grouped by the advisor's name. The results are ordered by the number of students assigned to each advisor in descending order, with a limit on the number of advisors returned, specified by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["Identify the relevant tables: We need to count students with specific allergies, so we will use the 'Has_Allergy' table which links students to their allergies.", "Determine the condition: We are interested in students who have 'cat' allergies, so we will filter the results based on this condition.", "Count distinct students: We need to count the unique student IDs (StuID) from the 'Has_Allergy' table where the allergy matches 'cat'.", "Construct the SQL query: Using the COUNT function to get the number of distinct students with the specified allergy."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(DISTINCT Has_Allergy.StuID) AS StudentCount \nFROM Has_Allergy \nWHERE Has_Allergy.Allergy = 'cat';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the relevant tables: We need to look at the 'Has_Allergy' table to find students with specific allergies.", "Determine the specific allergy: The question asks about 'cat allergies', so we will filter for that allergy.", "Count the unique students: We need to count the distinct 'StuID' from the 'Has_Allergy' table where the allergy is 'cat'.", "Construct the SQL query: We will use the COUNT function to get the number of unique students affected by cat allergies."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(DISTINCT Has_Allergy.StuID) AS StudentCount \nFROM Has_Allergy \nWHERE Allergy = 'cat';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["We need to count the number of female students who have specific allergies (milk or eggs).", "To do this, we will join the 'Student' table with the 'Has_Allergy' table on the 'StuID' column, which is the unique identifier for students.", "We will filter the results to include only female students by adding a condition in the WHERE clause: 'Student.Sex = 'Female'.", "Next, we will specify the allergies we are interested in (milk and eggs) using the IN clause: 'Has_Allergy.Allergy IN ('milk', 'eggs')'.", "Finally, we will use COUNT(DISTINCT Student.StuID) to count the unique students that meet these criteria."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Student.Sex = 'Female' \nAND Has_Allergy.Allergy IN ('milk', 'eggs');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.514", "db_id": "allergy_1", "question": "Which allergy is the most common?", "rationale": ["Identify the relevant tables: 'Has_Allergy' contains the allergies associated with students.", "To find the most common allergy, we need to count occurrences of each allergy in the 'Has_Allergy' table.", "Use the COUNT function to count how many students have each allergy.", "Group the results by the 'Allergy' column to aggregate the counts for each allergy.", "Order the results in descending order based on the count to get the most common allergy at the top.", "Limit the results to 1 to retrieve only the most common allergy."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT Allergy, COUNT(*) as AllergyCount \nFROM Has_Allergy \nGROUP BY Allergy \nORDER BY AllergyCount DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["We need to find students who have allergies to both milk and cat.", "To do this, we will join the 'Student' table with the 'Has_Allergy' table twice: once for each allergy.", "The first join (HA1) will filter for students with a milk allergy, and the second join (HA2) will filter for students with a cat allergy.", "We will select the last name (LName) and age (Age) of the students who meet both conditions.", "The final SQL query will include the necessary SELECT, FROM, and JOIN clauses, along with the appropriate WHERE conditions."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.LName, S.Age \nFROM Student S \nJOIN Has_Allergy HA1 ON S.StuID = HA1.StuID \nJOIN Has_Allergy HA2 ON S.StuID = HA2.StuID \nWHERE HA1.Allergy = 'milk' AND HA2.Allergy = 'cat';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the tables needed: We need to retrieve student information (last names and ages) and their allergies, so we will use the 'Student' and 'Has_Allergy' tables.", "Determine the relationship: The 'Has_Allergy' table links students to their allergies via the 'StuID' column, which is a foreign key in 'Has_Allergy'.", "Select the required columns: We need 'LName' and 'Age' from the 'Student' table.", "Filter the results: We need to filter students who have allergies to 'milk' and 'cat'. This can be done using the WHERE clause with the IN operator to specify multiple allergies.", "Group the results: Since we are joining tables and filtering, we should group by 'StuID' to ensure we get unique student records."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Student.LName, Student.Age \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat') \nGROUP BY Student.StuID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.523", "db_id": "allergy_1", "question": "Find the first name and gender of the student who has allergy to milk but not cat.", "rationale": ["Identify the tables needed: We need data from the 'Student' table for first names and gender, and the 'Has_Allergy' table to filter students based on their allergies.", "We need to find students who have an allergy to 'milk'. This requires a subquery that selects 'StuID' from 'Has_Allergy' where 'Allergy' is 'milk'.", "We also need to exclude students who have an allergy to 'cat'. This requires another subquery that selects 'StuID' from 'Has_Allergy' where 'Allergy' is 'cat'.", "Combine the results: Use the 'StuID' from the first subquery to filter the 'Student' table, and use the 'StuID' from the second subquery to exclude those students from the results.", "Select the desired columns: Finally, select 'Fname' and 'Sex' from the 'Student' table for the filtered results."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex \nFROM Student \nWHERE StuID IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'milk'\n) \nAND StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'cat'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.524", "db_id": "allergy_1", "question": "What are the first name and gender of the students who have allergy to milk but can put up with cats?", "rationale": ["Identify the required fields: first name (Fname) and gender (Sex) of students.", "Filter students who have an allergy to milk. This requires a subquery to the Has_Allergy table where Allergy = 'milk'.", "Also, filter out students who have an allergy to cats. This requires another subquery to the Has_Allergy table where Allergy = 'cats'.", "Combine these conditions using the IN and NOT IN clauses to get the desired results."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex \nFROM Student \nWHERE StuID IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'milk'\n) \nAND StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'cats'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the tables needed: We need to get student ages from the 'Student' table and filter based on allergies from the 'Has_Allergy' and 'Allergy_Type' tables.", "Join the tables: We will join 'Student' with 'Has_Allergy' on 'StuID' and then join 'Has_Allergy' with 'Allergy_Type' on 'Allergy' to access the allergy types associated with each student.", "Filter by allergy types: We need to filter the results to include only those students who have allergies categorized as 'food' or 'animal'.", "Calculate the average age: We will use the AVG() function to calculate the average age of the filtered students, ensuring to cast the age to an integer for accurate calculation."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT AVG(CAST(Student.Age AS INTEGER)) AS Average_Age\nFROM Student\nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID\nJOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy\nWHERE Allergy_Type.AllergyType IN ('food', 'animal');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["We need to find students who are not allergic to any type of food.", "To do this, we will select the first name and last name of each student from the Student table.", "We will use a LEFT JOIN between the Student table and the Has_Allergy table to include all students, even those without allergies.", "Next, we will also LEFT JOIN the Allergy_Type table to get the allergy types associated with each allergy.", "In the WHERE clause, we will filter for cases where the AllergyType is NULL, which indicates that the student has no allergies."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT S.Fname || ' ' || S.LName AS FullName \nFROM Student S \nLEFT JOIN Has_Allergy HA ON S.StuID = HA.StuID \nLEFT JOIN Allergy_Type AT ON HA.Allergy = AT.Allergy \nWHERE AT.AllergyType IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["Identify the tables needed: Student, Has_Allergy, and Allergy_Type.", "We need to count the number of male students, so we will filter the Student table by Sex = 'M'.", "We need to find students with allergies, so we will join the Has_Allergy table on StuID.", "We also need to filter for allergies that are of type 'Food', so we will join the Allergy_Type table and filter by AllergyType = 'Food'.", "Finally, we will use COUNT(DISTINCT s.StuID) to get the number of unique male students with food allergies."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT COUNT(DISTINCT s.StuID) \nFROM Student s \nJOIN Has_Allergy ha ON s.StuID = ha.StuID \nJOIN Allergy_Type at ON ha.Allergy = at.Allergy \nWHERE s.Sex = 'M' AND at.AllergyType = 'Food';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\"\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables needed: We need data from the 'Student' table for first names and city codes, and from the 'Has_Allergy' table to filter students with specific allergies.", "Determine the relationship: The 'Has_Allergy' table links students to their allergies via the 'StuID' column, which is a foreign key in 'Has_Allergy' referencing 'Student'.", "Select the required columns: We need to select distinct first names (Fname) and city codes (city_code) from the 'Student' table.", "Filter the results: We need to filter the results to include only those students who have allergies to either 'milk' or 'cat'. This is done using the WHERE clause with the IN operator to specify the allergies.", "Construct the SQL query: Combine the SELECT statement, JOIN clause, and WHERE clause to form the complete SQL query."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT Student.Fname, Student.city_code \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["Identify the tables needed: We need data from the 'Student' table for first names and city codes, and the 'Has_Allergy' table to filter students based on their allergies.", "Determine the relationship: The 'Has_Allergy' table links students to their allergies via the 'StuID' column, which is a foreign key in 'Has_Allergy' referencing 'Student'.", "Select the required fields: We need to select distinct first names (Fname) and city codes (city_code) from the 'Student' table.", "Filter the results: We need to filter students who have allergies to either 'milk' or 'cat'. This is done using a WHERE clause that checks if the allergy is in the specified list.", "Join the tables: Use an INNER JOIN to combine 'Student' and 'Has_Allergy' on the 'StuID' column to get the relevant data."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT Student.Fname, Student.city_code \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n    \"1\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n    \"2\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\"\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["We need to find the names of the countries and the average invoice size.", "The relevant table for this information is the 'invoices' table, which contains the 'billing_country' and 'total' columns.", "To calculate the average invoice size for each country, we will use the AVG() function on the 'total' column.", "We will group the results by 'billing_country' to get the average for each country.", "To get the top countries by average invoice size, we will order the results in descending order based on the average invoice size.", "Finally, we will limit the results to the top 10 countries."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size\nFROM invoices\nGROUP BY billing_country\nORDER BY AVG(total) DESC\nLIMIT 10;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["Identify the relevant table: invoices, which contains billing information.", "We need to count the number of invoices for each state, so we will use the COUNT() function.", "We will group the results by billing_state to get the count for each state.", "The final SQL query will select the billing_state and the count of invoices, grouping by billing_state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["We need to find the states with the most invoices, which means we will be counting the number of invoices per state.", "The relevant table for this information is the 'invoices' table, which contains a 'billing_state' column.", "To get the count of invoices per state, we will use the COUNT() function and group the results by 'billing_state'.", "Finally, we will order the results in descending order to show the states with the most invoices at the top."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state\nORDER BY invoice_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.568", "db_id": "store_1", "question": "What is the number of invoices and total money billed in them from CA?", "rationale": ["Identify the relevant table: invoices, which contains information about invoices including total amounts and billing details.", "Determine the required information: the number of invoices and the total amount billed.", "Use COUNT(*) to count the number of invoices and SUM(total) to calculate the total amount billed.", "Filter the results to only include invoices from California (CA) by adding a WHERE clause that specifies billing_state = 'CA'."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS number_of_invoices, SUM(total) AS total_billed FROM invoices WHERE billing_state = 'CA';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the table that contains the required information: The 'employees' table has the email and phone number of employees.", "Determine the specific employee: The question asks for Astrid Gruber, so we need to filter the results based on the first name 'Astrid' and last name 'Gruber'.", "Construct the SQL query: We will select the 'email' and 'phone' columns from the 'employees' table where the first name is 'Astrid' and the last name is 'Gruber'."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the street address of employees from the 'employees' table based on their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the employee being queried.\"\n}\n"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["Identify the relevant table: The 'customers' table contains information about customers, including their state.", "Determine the condition: We need to count customers specifically from California, so we will filter the results where the 'state' column equals 'California'.", "Construct the SQL query: Use the COUNT() function to count the number of customers that meet the condition, and select this count as 'customer_count'."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) AS customer_count FROM customers WHERE state = 'California';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: We need to find employees and customers, so we will use the 'employees' and 'customers' tables.", "Join the tables: We will join the 'employees' table with the 'customers' table on the 'support_rep_id' to link customers to their respective support representatives.", "Group by employee: We will group the results by employee ID to count the number of customers each employee supports.", "Count customers: We will use COUNT(c.id) to count the number of customers for each employee.", "Order the results: We will order the results in descending order based on the count of customers supported.", "Limit the results: We will limit the results to 1 to get the employee who supports the most customers."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees who report to a specific manager from the 'employees' table. The placeholders in the WHERE clause represent the first and last names of the manager.\"\n}\n"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["Identify the relevant tables: invoices and customers.", "Determine the relationship between invoices and customers: invoices have a customer_id that links to the customers table.", "Filter the customers table to find the specific customer 'Luca Mancini' using first_name and last_name.", "Count the number of invoices associated with this customer using COUNT(*) function."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "pred_sql": "SELECT COUNT(*) AS order_count \nFROM invoices \nJOIN customers ON invoices.customer_id = customers.id \nWHERE customers.first_name = 'Luca' AND customers.last_name = 'Mancini';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\"\n}\n"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["Identify the track 'Balls to the Wall' in the tracks table.", "Join the tracks table with the albums table using the album_id foreign key.", "Select the title of the album from the albums table where the track name matches 'Balls to the Wall'."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT albums.title FROM albums JOIN tracks ON albums.id = tracks.album_id WHERE tracks.name = 'Balls to the Wall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\"\n}\n"}
{"sample_id": "train.626", "db_id": "store_1", "question": "What is the name of all tracks in the album named Balls to the Wall?", "rationale": ["Identify the relevant tables: We need to retrieve track names from the 'tracks' table and filter them based on the album title from the 'albums' table.", "Determine the relationship: The 'tracks' table has a foreign key 'album_id' that references the 'id' in the 'albums' table, allowing us to join these two tables.", "Construct the SQL query: We will select the 'name' column from the 'tracks' table and join it with the 'albums' table on the condition that the album title matches 'Balls to the Wall'."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN albums ON tracks.album_id = albums.id \nWHERE albums.title = 'Balls to the Wall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\"\n}\n"}
{"sample_id": "train.630", "db_id": "store_1", "question": "What are the names of all Rock tracks that are stored on MPEG audio files?", "rationale": ["Identify the relevant tables: tracks, media_types, and genres are needed to get track names, media type, and genre respectively.", "Join the tracks table with media_types on media_type_id to filter tracks based on their media type.", "Join the tracks table with genres on genre_id to filter tracks based on their genre.", "Use a WHERE clause to specify that we want tracks that are of the genre 'Rock' and are stored in 'MPEG audio' files."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN media_types ON tracks.media_type_id = media_types.id \nJOIN genres ON tracks.genre_id = genres.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG audio';", "hint": "\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the tables involved: tracks, genres, and media_types.", "We need to select the track names, so we will select 'tracks.name'.", "To filter tracks by genre, we will join the 'tracks' table with the 'genres' table on 'tracks.genre_id = genres.id'.", "To filter tracks by media type, we will join the 'tracks' table with the 'media_types' table on 'tracks.media_type_id = media_types.id'.", "We will add a WHERE clause to filter for the genre 'Rock' and the media type 'MPEG'.", "Combine all these elements to form the final SQL query."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN genres ON tracks.genre_id = genres.id \nJOIN media_types ON tracks.media_type_id = media_types.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG';", "hint": "\n"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["Identify the relevant tables: tracks, invoice_lines, invoices, and customers are needed to find the tracks bought by a specific customer.", "Join the tables: We need to join tracks with invoice_lines to get the track purchases, then join invoice_lines with invoices to link to the customer, and finally join invoices with customers to filter by the customer's name.", "Filter by customer name: Use a WHERE clause to specify that we are looking for purchases made by Dean Peeters, using both first and last name."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN invoice_lines ON tracks.id = invoice_lines.track_id \nJOIN invoices ON invoice_lines.invoice_id = invoices.id \nJOIN customers ON invoices.customer_id = customers.id \nWHERE customers.first_name = 'Dean' AND customers.last_name = 'Peeters';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\"\n}\n"}
{"sample_id": "train.686", "db_id": "customers_card_transactions", "question": "What are the full names of customers who do not have any accounts?", "rationale": ["We need to find customers who do not have any accounts, which means we need to check the relationship between the Customers and Accounts tables.", "To do this, we can use a LEFT JOIN to combine the Customers table with a subquery that counts the number of accounts for each customer.", "The subquery selects the customer_id from the Accounts table and counts the number of account_id entries, grouping by customer_id.", "In the main query, we select the first and last names of customers from the Customers table.", "We then join this with the subquery on customer_id, and filter the results where the account count is NULL, indicating that those customers have no accounts."], "gold_sql": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_first_name, c.customer_last_name \nFROM Customers c \nLEFT JOIN (SELECT customer_id, COUNT(account_id) AS account_count \n            FROM Accounts \n            GROUP BY customer_id) a \nON c.customer_id = a.customer_id \nWHERE a.account_count IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\",\n    \"1\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\"\n}\n"}
{"sample_id": "train.688", "db_id": "customers_card_transactions", "question": "What are the full names of customers who have accounts?", "rationale": ["We need to find the full names of customers who have accounts, which means we need to join the Customers table with the Accounts table.", "The Customers table contains the first and last names of customers, which we can concatenate to form the full name.", "The Accounts table contains the customer_id that links to the Customers table, allowing us to find which customers have accounts.", "We will use a JOIN operation to combine the two tables based on the customer_id, and then select the concatenated full name from the result."], "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\",\n    \"1\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\"\n}\n"}
{"sample_id": "train.704", "db_id": "customers_card_transactions", "question": "Return the full name and phone of the customer who has card number 4560596484842.", "rationale": ["Identify the tables needed: We need information from the 'Customers' table for customer details and the 'Customers_Cards' table for card details.", "Determine the fields to select: We need the full name (first and last name) and the phone number of the customer.", "Join the tables: We will join 'Customers' and 'Customers_Cards' on 'customer_id' to link customers with their cards.", "Filter the results: We will filter the results to only include the customer with the specified card number '4560596484842'.", "Construct the SQL query: Combine all the elements into a valid SQL SELECT statement."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.card_number  =  '4560596484842'", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name, customer_phone \nFROM Customers \nJOIN Customers_Cards ON Customers.customer_id = Customers_Cards.customer_id \nWHERE Customers_Cards.card_number = '4560596484842';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\"\n}\n"}
{"sample_id": "train.717", "db_id": "customers_card_transactions", "question": "What is the customer id, first and last name with least number of accounts.", "rationale": ["We need to find the customer with the least number of accounts.", "To do this, we will join the 'Customers' table with the 'Accounts' table on the 'customer_id'.", "We will use a LEFT JOIN to ensure we include customers even if they have no accounts.", "Next, we will group the results by customer ID, first name, and last name to count the number of accounts for each customer.", "We will use the COUNT function to count the number of accounts associated with each customer.", "Finally, we will order the results by the count of accounts in ascending order and limit the results to 1 to get the customer with the least number of accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name \nFROM Customers c \nLEFT JOIN Accounts a ON c.customer_id = a.customer_id \nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name \nORDER BY COUNT(a.account_id) ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\",\n    \"1\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\"\n}\n"}
{"sample_id": "train.718", "db_id": "customers_card_transactions", "question": "Return the id and full name of the customer who has the fewest accounts.", "rationale": ["We need to find the customer with the fewest accounts.", "To do this, we will first summarize the number of accounts associated with each customer using a subquery that counts the accounts grouped by customer_id.", "Next, we will join this subquery with the Customers table to get the customer details.", "We will select the customer_id and concatenate the first and last name to get the full name of the customer.", "Finally, we will order the results by the account count in ascending order and limit the result to 1 to get the customer with the fewest accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nJOIN (SELECT customer_id, COUNT(*) AS account_count\n      FROM Accounts\n      GROUP BY customer_id) ac ON c.customer_id = ac.customer_id\nORDER BY ac.account_count ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\"\n}\n"}
{"sample_id": "train.721", "db_id": "customers_card_transactions", "question": "What is the card type code with most number of cards?", "rationale": ["Identify the relevant table: Customers_Cards contains the card type codes and card IDs.", "Count the number of cards for each card type code using COUNT(card_id).", "Group the results by card type code to aggregate the counts.", "Order the results in descending order based on the count of cards to find the most frequent card type.", "Limit the results to 1 to get only the card type code with the most number of cards."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "pred_sql": "SELECT card_type_code, COUNT(card_id) AS card_count \nFROM Customers_Cards \nGROUP BY card_type_code \nORDER BY card_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table summarizes the different types of cards issued to customers, displaying the card type codes from the 'Customers_Cards' table. The results are grouped by card type code and ordered by the frequency of each type, allowing the user to specify a limit on the number of types returned.\"\n}\n"}
{"sample_id": "train.735", "db_id": "customers_card_transactions", "question": "Show the number of transaction types.", "rationale": ["The user wants to know the number of transaction types.", "To achieve this, we need to select the 'transaction_type' from the 'Financial_Transactions' table.", "We will use the COUNT function to count the occurrences of each transaction type.", "We will group the results by 'transaction_type' to get the count for each type."], "gold_sql": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, COUNT(*) AS transaction_count \nFROM Financial_Transactions \nGROUP BY transaction_type;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions associated with each account from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account identifier, while the count function aggregates the total number of transactions for each account.\",\n    \"1\": \"The virtual table summarizes the different types of cards issued to customers, displaying the card type codes from the 'Customers_Cards' table. The results are grouped by card type code and ordered by the frequency of each type, allowing the user to specify a limit on the number of types returned.\"\n}\n"}
{"sample_id": "train.743", "db_id": "customers_card_transactions", "question": "What is the transaction type that has processed the greatest total amount in transactions?", "rationale": ["Identify the relevant table: Financial_Transactions contains the transaction details including type and amount.", "We need to group the transactions by their type to calculate the total amount for each type.", "Use the SUM function to calculate the total amount for each transaction type.", "Order the results in descending order to find the transaction type with the greatest total amount.", "Limit the results to 1 to get only the top transaction type."], "gold_sql": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, SUM(transaction_amount) AS total_amount\nFROM Financial_Transactions\nGROUP BY transaction_type\nORDER BY total_amount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions associated with each account from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account identifier, while the count function aggregates the total number of transactions for each account.\"\n}\n"}
{"sample_id": "train.893", "db_id": "insurance_fnol", "question": "What are the customer phone numbers under the policy \"Life Insurance\"?", "rationale": ["Identify the relevant tables: Available_Policies for customer phone numbers and Services for policy names.", "Join the Available_Policies table with Customers_Policies to link customers with their policies.", "Join the Services table to filter for the specific policy type, 'Life Insurance'.", "Select the Customer_Phone from the resulting joined tables where the policy name matches 'Life Insurance'."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "pred_sql": "SELECT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nJOIN Services s ON s.Service_ID = cp.Policy_ID \nWHERE s.Service_name = 'Life Insurance';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\"\n}\n"}
{"sample_id": "train.895", "db_id": "insurance_fnol", "question": "Which policy type has the most records in the database?", "rationale": ["We need to find out which policy type has the most records in the database.", "To do this, we will query the 'Available_Policies' table, focusing on the 'policy_type_code' column.", "We will use the COUNT function to count the occurrences of each policy type.", "We will group the results by 'policy_type_code' to aggregate the counts for each type.", "To find the most common policy type, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one record to get the top policy type."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "pred_sql": "SELECT policy_type_code, COUNT(*) as policy_count \nFROM Available_Policies \nGROUP BY policy_type_code \nORDER BY policy_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\"\n}\n"}
{"sample_id": "train.897", "db_id": "insurance_fnol", "question": "What are all the customer phone numbers under the most popular policy type?", "rationale": ["We need to find all customer phone numbers associated with the most popular policy type.", "To determine the most popular policy type, we can create a subquery that counts the occurrences of each policy type in the Available_Policies table, grouping by the policy_type_code and ordering by the count in descending order, limiting the result to the top one.", "Next, we join this subquery with the Customers_Policies table to link the most popular policy type to the customers who have that policy.", "We also need to join the Available_Policies table to get the Customer_Phone associated with the policy.", "Finally, we select distinct customer phone numbers to avoid duplicates."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nJOIN (\n    SELECT policy_type_code, COUNT(*) as policy_count \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    ORDER BY policy_count DESC \n    LIMIT 1\n) AS most_popular_policy ON ap.policy_type_code = most_popular_policy.policy_type_code \nJOIN Customers c ON cp.Customer_ID = c.Customer_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\"\n}\n"}
{"sample_id": "train.898", "db_id": "insurance_fnol", "question": "Find the phone numbers of customers using the most common policy type among the available policies.", "rationale": ["Identify the tables involved: Customers, Customers_Policies, and Available_Policies.", "We need to find the phone numbers of customers, so we will select 'Customer_Phone' from the Customers table.", "To link customers with their policies, we will join the Customers table with the Customers_Policies table on 'Customer_ID'.", "Next, we will join the Customers_Policies table with the Available_Policies table on 'Policy_ID' to access the policy types.", "To find the most common policy type, we will create a subquery that groups the policies by 'policy_type_code', counts them, and orders them in descending order, limiting the result to the top one.", "Finally, we will filter the main query to only include customers whose policies match the most common policy type found in the subquery."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT c.Customer_Phone \nFROM Customers c \nJOIN Customers_Policies cp ON c.Customer_ID = cp.Customer_ID \nJOIN Available_Policies ap ON cp.Policy_ID = ap.Policy_ID \nWHERE ap.policy_type_code = (\n    SELECT policy_type_code \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\"\n}\n"}
{"sample_id": "train.1060", "db_id": "match_season", "question": "Show the players from college UCLA.", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their college.", "Determine the condition: We need to filter players based on their college, specifically those who attended UCLA.", "Use a subquery: To find the teams associated with UCLA, we can use a subquery on the 'match_season' table to get the 'Team_id' where the 'College' is 'UCLA'.", "Combine the results: The main query will select the 'Player' names from the 'player' table where the 'Team' matches the 'Team_id' from the subquery."], "gold_sql": "SELECT Player FROM match_season WHERE College  =  'UCLA'", "source_tables": ["match_season"], "pred_sql": "SELECT Player FROM player WHERE Team IN (SELECT Team_id FROM match_season WHERE College = 'UCLA');", "hint": "\n"}
{"sample_id": "train.1082", "db_id": "match_season", "question": "Show the season, the player, and the name of the team that players belong to.", "rationale": ["Identify the required columns: Season, Player, and Team Name.", "The Season and Player are from the match_season table.", "The Team Name is from the team table.", "To get the Team Name associated with each player, a JOIN operation is needed between match_season and team tables on the Team identifier.", "Construct the SQL SELECT statement to retrieve the desired columns from the joined tables."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "pred_sql": "SELECT match_season.Season, match_season.Player, team.Name \nFROM match_season \nJOIN team ON match_season.Team = team.Team_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of match seasons, including the season name, player name, and the corresponding team name. The data is retrieved from the 'match_season' table, which is joined with the 'team' table to associate each player with their respective team using the team identifier.\",\n    \"1\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\"\n}\n"}
{"sample_id": "train.1092", "db_id": "match_season", "question": "Show the country names and the corresponding number of players.", "rationale": ["We need to show the country names and the corresponding number of players.", "To get the country names, we will select from the 'country' table.", "We need to count the number of players associated with each country, which requires joining the 'country' table with the 'match_season' table to link players to their countries.", "We also need to join the 'player' table to ensure we are counting the players correctly.", "The join condition will be based on the country identifier in the 'match_season' table and the 'country' table, and the player names in the 'match_season' and 'player' tables.", "Finally, we will group the results by country name to get the count of players for each country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "pred_sql": "SELECT country.Country_name, COUNT(player.Player_ID) AS Number_of_Players\nFROM country\nJOIN match_season ON country.Country_id = match_season.Country\nJOIN player ON match_season.Player = player.Player\nGROUP BY country.Country_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct official native languages of countries represented by players in a specific position during matches. The placeholder in the WHERE clause represents the player's position.\",\n    \"1\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\"\n}\n"}
{"sample_id": "train.1098", "db_id": "match_season", "question": "Show the top 3 most common colleges of players in match seasons.", "rationale": ["We need to find the top 3 most common colleges of players in match seasons.", "To do this, we will query the 'match_season' table, which contains the 'College' column.", "We will use the COUNT function to count the occurrences of each college.", "We will group the results by the 'College' column to aggregate the counts for each college.", "Next, we will order the results in descending order based on the count of players from each college.", "Finally, we will limit the results to the top 3 colleges."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as College_Count \nFROM match_season \nGROUP BY College \nORDER BY College_Count DESC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\",\n    \"1\": \"This virtual table provides a summary of match seasons, including the season name, player name, and the corresponding team name. The data is retrieved from the 'match_season' table, which is joined with the 'team' table to associate each player with their respective team using the team identifier.\"\n}\n"}
{"sample_id": "train.1099", "db_id": "match_season", "question": "What are the three colleges from which the most players are from?", "rationale": ["Identify the relevant table: The 'match_season' table contains the 'College' column and player information.", "Count the number of players from each college: Use COUNT(*) to count the number of players grouped by 'College'.", "Group the results by college: Use GROUP BY College to aggregate the counts for each college.", "Order the results: Use ORDER BY Player_Count DESC to sort the colleges by the number of players in descending order.", "Limit the results to the top three: Use LIMIT 3 to get only the top three colleges with the most players."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as Player_Count\nFROM match_season\nGROUP BY College\nORDER BY Player_Count DESC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.1107", "db_id": "match_season", "question": "Return the names of countries that have players that play the Forward position, as well as players who play the Defender position.", "rationale": ["We need to return the names of countries that have players in specific positions (Forward and Defender).", "To achieve this, we will join the 'country' table with the 'match_season' table using the country identifier (Country_id).", "The join will allow us to associate each player with their respective country during a specific season.", "We will filter the results using a WHERE clause to include only those players whose position is either 'Forward' or 'Defender'.", "Finally, we will select distinct country names to avoid duplicates in the result."], "gold_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "pred_sql": "SELECT DISTINCT c.Country_name\nFROM country c\nJOIN match_season ms ON c.Country_id = ms.Country\nWHERE ms.Position IN ('Forward', 'Defender');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct official native languages of countries represented by players in a specific position during matches. The placeholder in the WHERE clause represents the player's position.\",\n    \"1\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\"\n}\n"}
