{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["Identify the relevant tables: We need to find staff members and their assignment durations, so we will use the Staff and Staff_Department_Assignments tables.", "Join the Staff table with the Staff_Department_Assignments table on staff_id to get the staff names along with their assignment details.", "Calculate the duration of each assignment by subtracting date_assigned_from from date_assigned_to.", "Order the results by the calculated duration in ascending order to find the staff member with the least amount of time assigned.", "Limit the results to 1 to get only the staff member with the least assignment duration."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name FROM Staff_Department_Assignments AS sda\nJOIN Staff AS st ON sda.staff_id = st.staff_id\nORDER BY (date_assigned_to - date_assigned_from) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n    \"1\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n    \"2\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\"\n}\n"}
{"sample_id": "train.4753", "db_id": "department_store", "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.", "rationale": ["Identify the main table to query: Customer_Orders, which contains customer orders and their statuses.", "We need to find distinct customer IDs, so we will use SELECT DISTINCT on the customer_id column.", "We need to filter orders that were placed after some orders that were cancelled. This requires a subquery to find the earliest order date of cancelled orders.", "The subquery selects the minimum order date from Customer_Orders where the order_status_code is 'Cancelled'.", "The main query selects customer IDs from Customer_Orders where the order_date is greater than the result of the subquery."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "pred_sql": "SELECT DISTINCT co.customer_id\nFROM Customer_Orders co\nWHERE co.order_date > (\n    SELECT MIN(co2.order_date)\n    FROM Customer_Orders co2\n    WHERE co2.order_status_code = 'Cancelled'\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The date is determined by finding the earliest order date associated with a particular order status, represented by a placeholder.\"\n}\n"}
{"sample_id": "train.4755", "db_id": "department_store", "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?", "rationale": ["Identify the staff members who have a department assignment.", "Use the Staff_Department_Assignments table to find the staff_id and the date_assigned_to.", "We need to find the maximum date_assigned_to for staff members with the job title of 'Clerical'.", "Join the Staff_Department_Assignments table with the Staff table to filter by job title code 'Clerical'.", "Select staff_id from Staff_Department_Assignments where their date_assigned_to is earlier than the maximum date_assigned_to of Clerical staff."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "pred_sql": "SELECT staff_id FROM Staff_Department_Assignments AS sda\nWHERE date_assigned_to < (\n    SELECT MAX(date_assigned_to)\n    FROM Staff_Department_Assignments AS sda2\n    JOIN Staff AS st ON sda2.staff_id = st.staff_id\n    WHERE st.job_title_code = 'Clerical'\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n    \"1\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n    \"2\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\"\n}\n"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to retrieve customer names and IDs, which are in the Customers table.", "To find customers with 'TN' in their address, we need to join the Customers table with the Customer_Addresses table to link customers to their addresses.", "Next, we join the Customer_Addresses table with the Addresses table to access the address details.", "We will use a WHERE clause to filter addresses that contain 'TN' in the address_details column.", "Finally, we select the customer_name and customer_id from the Customers table."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "pred_sql": "SELECT Customers.customer_name, Customers.customer_id \nFROM Customers \nJOIN Customer_Addresses ON Customers.customer_id = Customer_Addresses.customer_id \nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id \nWHERE Addresses.address_details LIKE '%TN%';", "hint": "\n"}
{"sample_id": "train.4760", "db_id": "department_store", "question": "What are the names and genders of staff who were assigned in 2016?", "rationale": ["Identify the relevant tables: 'Staff' for staff details and 'Staff_Department_Assignments' for assignment dates.", "We need to select the staff names and genders, which are in the 'Staff' table.", "To find staff assigned in 2016, we need to filter the 'Staff_Department_Assignments' table based on the 'date_assigned_from' column.", "The date range for 2016 is from '2016-01-01' to '2017-01-01'.", "Join the 'Staff' table with 'Staff_Department_Assignments' on 'staff_id' to get the necessary details.", "Construct the SQL query to select the required fields and apply the date filter."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT Staff.staff_name, Staff.staff_gender \nFROM Staff \nJOIN Staff_Department_Assignments ON Staff.staff_id = Staff_Department_Assignments.staff_id \nWHERE Staff_Department_Assignments.date_assigned_from >= '2016-01-01' \nAND Staff_Department_Assignments.date_assigned_from < '2017-01-01';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n    \"1\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\",\n    \"2\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\"\n}\n"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["Identify the relevant table: The 'Staff' table contains the names of staff members, and the 'Staff_Department_Assignments' table contains the assignments of staff members to departments along with their job titles.", "Determine the criteria for multiple job assignments: We need to find staff members who have been assigned to more than one distinct job title. This can be achieved by grouping the assignments by 'staff_id' and counting the distinct 'job_title_code'.", "Use a subquery to filter staff members: The subquery will select 'staff_id' from 'Staff_Department_Assignments' where the count of distinct 'job_title_code' is greater than 1, indicating multiple job assignments.", "Join the results with the 'Staff' table: Finally, we will select the 'staff_name' from the 'Staff' table where the 'staff_id' is in the list of staff IDs returned by the subquery."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Staff_Department_Assignments GROUP BY staff_id HAVING COUNT(DISTINCT job_title_code) > 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n    \"1\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n    \"2\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\"\n}\n"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["Identify the relevant table: Customers, which contains customer_id, customer_name, customer_address, and payment_method_code.", "Filter customers based on their address containing 'WY'. This can be done using the LIKE operator with a wildcard: '%WY%'.", "Exclude customers who use a credit card for payment. This is done by checking that payment_method_code is not equal to 'CREDIT_CARD'.", "Combine these conditions in the WHERE clause of the SQL query to retrieve the desired customer ids and names."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name \nFROM Customers \nWHERE customer_address LIKE '%WY%' \nAND payment_method_code != 'CREDIT_CARD';", "hint": "\n"}
{"sample_id": "train.4793", "db_id": "department_store", "question": "Find the average price of all product clothes.", "rationale": ["Identify the table that contains product information, which is the 'Products' table.", "Determine the relevant column for price, which is 'product_price'.", "To find the average price, use the AVG() function.", "Filter the products to only include those that are classified as 'clothes' using the 'product_type_code' column."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "pred_sql": "SELECT AVG(product_price) AS average_price\nFROM Products\nWHERE product_type_code = 'clothes';", "hint": "\n"}
{"sample_id": "train.4795", "db_id": "department_store", "question": "Find the name of the most expensive hardware product.", "rationale": ["Identify the relevant table: Products.", "Determine the column needed: product_name for the name of the product and product_price for the price.", "Filter the products to only include those of type 'hardware' using product_type_code.", "Sort the results by product_price in descending order to get the most expensive product first.", "Limit the results to 1 to get only the most expensive hardware product."], "gold_sql": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1", "source_tables": ["products"], "pred_sql": "SELECT product_name FROM Products WHERE product_type_code = 'hardware' ORDER BY product_price DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["Identify the relevant tables: We need to look at the 'product' and 'store_product' tables to find products and their maximum page sizes.", "Join the 'store_product' table with the 'product' table on the product ID to access the maximum page size for each product.", "Group the results by 'max_page_size' to aggregate the products that share the same page size.", "Use the HAVING clause to filter the groups, ensuring we only include those with more than 3 products listed."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size\nFROM store_product sp\nJOIN product p ON sp.Product_ID = p.product_id\nGROUP BY max_page_size\nHAVING COUNT(sp.Product_ID) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n    \"1\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\"\n}\n"}
{"sample_id": "train.4903", "db_id": "store_product", "question": "What is the maximum page size for everything that has more than 3 products listed?", "rationale": ["Identify the requirement: We need to find the maximum page size for products that are listed in stores with more than 3 products.", "To achieve this, we will first need to identify the stores that have more than 3 products. This can be done using a subquery that groups the 'store_product' table by 'Store_ID' and counts the number of products for each store, filtering with HAVING COUNT(Product_ID) > 3.", "Next, we will use the result of this subquery to filter the 'product' table to get the maximum page size for the products that belong to those stores.", "Finally, we will use the MAX function to get the maximum page size from the filtered products."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT MAX(max_page_size) FROM product WHERE product_id IN (SELECT Product_ID FROM store_product GROUP BY Store_ID HAVING COUNT(Product_ID) > 3);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n    \"1\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\"\n}\n"}
{"sample_id": "train.4913", "db_id": "store_product", "question": "What is the total number of residents for the districts with the 3 largest areas?", "rationale": ["Identify the relevant table: The 'district' table contains the population and area information needed for the query.", "Determine the requirement: We need to find the total number of residents in the districts with the 3 largest areas.", "Use a subquery to find the District_IDs of the top 3 districts by area: This is done by ordering the districts by 'City_Area' in descending order and limiting the results to 3.", "Sum the 'City_Population' for the districts identified in the subquery: This will give us the total number of residents for those districts."], "gold_sql": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3", "source_tables": ["district"], "pred_sql": "SELECT SUM(City_Population) AS Total_Residents\nFROM district\nWHERE District_ID IN (\n    SELECT District_ID\n    FROM district\n    ORDER BY City_Area DESC\n    LIMIT 3\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of stores grouped by the city where their respective districts are headquartered. The placeholders in the query represent the relationships between stores and districts, allowing for aggregation of store counts based on the city names.\",\n    \"1\": \"This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in each city, with a limit on the number of cities returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["Identify the relevant tables: store, store_district, and district are needed to find stores in a specific district.", "Join the store table with the store_district table on Store_ID to link stores to their respective districts.", "Join the resulting table with the district table on District_ID to access district names.", "Filter the results to only include stores located in 'Khanewal District' by using a WHERE clause."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT store.Store_Name \nFROM store \nJOIN store_district ON store.Store_ID = store_district.Store_ID \nJOIN district ON store_district.District_ID = district.District_ID \nWHERE district.District_name = 'Khanewal';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in each city, with a limit on the number of cities returned as specified by the placeholder.\",\n    \"1\": \"This virtual table provides a count of stores grouped by the city where their respective districts are headquartered. The placeholders in the query represent the relationships between stores and districts, allowing for aggregation of store counts based on the city names.\"\n}\n"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["Identify the relevant tables: store, store_district, and district are needed to find the number of stores in each city.", "Join the store table with store_district to associate stores with their respective districts.", "Join the resulting table with the district table to access the Headquartered_City for each district.", "Group the results by Headquartered_City to count the number of stores in each city.", "Order the results by the count of stores in descending order to find the city with the most stores.", "Limit the results to 1 to get only the city with the highest number of stores."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT d.Headquartered_City, COUNT(s.Store_ID) AS Number_of_Stores\nFROM store s\nJOIN store_district sd ON s.Store_ID = sd.Store_ID\nJOIN district d ON sd.District_ID = d.District_ID\nGROUP BY d.Headquartered_City\nORDER BY Number_of_Stores DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in each city, with a limit on the number of cities returned as specified by the placeholder.\",\n    \"1\": \"This virtual table provides a count of stores grouped by the city where their respective districts are headquartered. The placeholders in the query represent the relationships between stores and districts, allowing for aggregation of store counts based on the city names.\"\n}\n"}
{"sample_id": "train.4930", "db_id": "store_product", "question": "Find products with max page size as \"A4\" and pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for max page size and pages per minute color.", "Determine the conditions: We need to filter products where max_page_size is 'A4' and pages_per_minute_color is less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table, applying the WHERE clause to filter based on the identified conditions."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' AND pages_per_minute_color < 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n    \"1\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\"\n}\n"}
{"sample_id": "train.4932", "db_id": "store_product", "question": "Find products with max page size as \"A4\" or pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to find products with a maximum page size of 'A4' or a pages per minute color speed less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table where either condition is met, using the OR operator to combine the conditions."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n    \"1\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\"\n}\n"}
{"sample_id": "train.4935", "db_id": "store_product", "question": "What are all of the products whose name includes the substring \"Scanner\"?", "rationale": ["Identify the table that contains product information, which is the 'product' table.", "Determine the column that contains the product names or descriptions, which is the 'product' column.", "Use the SQL LIKE operator to search for products that include the substring 'Scanner'.", "The '%' wildcard is used before and after 'Scanner' to match any characters before or after the substring.", "Construct the SQL query to select all columns from the 'product' table where the product name contains 'Scanner'."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE product LIKE '%Scanner%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n    \"1\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\"\n}\n"}
{"sample_id": "train.4937", "db_id": "store_product", "question": "What is the most common maximum page size?", "rationale": ["The question asks for the most common maximum page size, which implies we need to count occurrences of each maximum page size in the product table.", "To find the most common maximum page size, we will use the COUNT function to count how many times each max_page_size appears.", "We will group the results by max_page_size to aggregate the counts for each unique size.", "To get the most common size, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one entry to get the most common maximum page size."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1", "source_tables": ["product"], "pred_sql": "SELECT max_page_size, COUNT(*) as count\nFROM product\nGROUP BY max_page_size\nORDER BY count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n    \"1\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\"\n}\n"}
{"sample_id": "train.4938", "db_id": "store_product", "question": "Find the name of the products that are not using the most frequently-used max page size.", "rationale": ["Identify the products from the 'product' table.", "Determine the most frequently-used max page size by grouping the products based on 'max_page_size' and counting the occurrences.", "Order the results by the count in descending order to find the most common max page size.", "Use a subquery to get the most frequently-used max page size.", "Select the product names where the max_page_size is not equal to the most frequently-used max page size."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "pred_sql": "SELECT product.product \nFROM product \nWHERE product.max_page_size != (SELECT max_page_size \n                                  FROM product \n                                  GROUP BY max_page_size \n                                  ORDER BY COUNT(*) DESC \n                                  LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n    \"1\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\"\n}\n"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["We need to calculate the average enrollment of students for each college.", "To do this, we will use the AVG() function on the 'enr' column from the 'College' table.", "We will also select the 'cName' column to group the results by college name.", "The GROUP BY clause will be used to ensure that we get the average enrollment for each college individually."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "pred_sql": "SELECT AVG(enr) AS average_enrollment, cName FROM College GROUP BY cName;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\"\n}\n"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["Identify the relevant tables: The question pertains to players and their training hours, which suggests we need to look at the Player table.", "Determine the required calculation: The question asks for the average training hours, so we will use the AVG() function.", "Assume a column for training hours exists: Since the schema provided does not explicitly mention training hours, we will assume there is a column named 'training_hours' in the Player table for the sake of this query.", "Construct the SQL query: We will select the average of the training_hours column from the Player table."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_training_hours FROM Player", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n    \"1\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4956", "db_id": "soccer_2", "question": "Find the name and training hours of players whose hours are below 1500.", "rationale": ["Identify the relevant table: The 'Player' table contains the names of players and their training hours.", "Determine the condition: We need to find players whose training hours are below 1500.", "Construct the SQL query: Select the 'pName' and 'hours' columns from the 'Player' table where the 'hours' are less than 1500."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "pred_sql": "SELECT pName, hours FROM Player WHERE hours < 1500;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who attended high schools with an enrollment number less than a specified value. The placeholder in the WHERE clause represents the enrollment number of students.\",\n    \"2\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4961", "db_id": "soccer_2", "question": "What are the different types of player positions?", "rationale": ["The question asks for the different types of player positions.", "To find the different types of player positions, we need to look at the 'Tryout' table where player positions are recorded.", "Using the SELECT DISTINCT statement allows us to retrieve unique values from the 'pPos' column in the 'Tryout' table, ensuring that we only get each position listed once."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT pPos FROM Tryout;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n    \"2\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\"\n}\n"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["Identify the relevant table: The 'Tryout' table contains the decision made regarding each player's tryout.", "Determine the specific decision to count: We are interested in counting the number of players who were accepted after the tryout.", "Construct the SQL query: Use the COUNT function to count the number of rows in the 'Tryout' table where the decision is 'accepted'."], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) AS accepted_students\nFROM Tryout\nWHERE decision = 'accepted';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"2\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["Identify the relevant table: The 'Player' table contains information about players, but it does not have a column for training hours. Therefore, we need to assume that training hours are either part of the 'Player' table or need to be calculated based on the tryouts.", "Determine the aggregation functions needed: We need to find the maximum, average, and minimum training hours, which requires the use of the MAX(), AVG(), and MIN() functions in SQL.", "Construct the SQL query: Since the 'Player' table does not have a 'training_hours' column, we cannot directly query it. However, if we assume that training hours are associated with the players in some way, we would typically join the 'Player' table with another table that contains training hours. In this case, we will just select from the 'Player' table as a placeholder."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT MAX(training_hours) AS max_training_hours, AVG(training_hours) AS avg_training_hours, MIN(training_hours) AS min_training_hours FROM Player;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n    \"1\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4967", "db_id": "soccer_2", "question": "What is the average, maximum, and minimum for the number of hours spent training?", "rationale": ["Identify the relevant tables: The question pertains to training hours, which suggests a table related to training or tryouts.", "Determine the necessary calculations: The question asks for average, maximum, and minimum values, which can be calculated using SQL aggregate functions AVG(), MAX(), and MIN().", "Assume there is a 'Training' table that records training hours for players, as the original schema does not include this information.", "Use a WHERE clause to filter the results based on the decision made regarding the player's tryout, assuming we are interested in players who were accepted."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_hours, MAX(training_hours) AS max_hours, MIN(training_hours) AS min_hours \nFROM Training \nWHERE decision = 'accepted';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n    \"1\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4970", "db_id": "soccer_2", "question": "What are the names of players whose training hours is between 500 and 1500?", "rationale": ["Identify the relevant table: The 'Player' table contains player names and their training hours.", "Determine the condition: We need to filter players based on their training hours being between 500 and 1500.", "Construct the SQL query: Use a SELECT statement to retrieve player names from the 'Player' table where the training hours fall within the specified range."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE training_hours BETWEEN 500 AND 1500;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n    \"2\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\"\n}\n"}
{"sample_id": "train.4971", "db_id": "soccer_2", "question": "What are the names of players who train between 500 and 1500 hours?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find players based on their training hours, which is not directly available in the schema. However, we can infer that the decision made in the Tryout table might relate to their training hours.", "The hint suggests that we can filter players based on their decisions in the Tryout table.", "We will select player names from the Player table where their IDs are in the Tryout table with a specific decision (e.g., 'accepted').", "Since the question specifies a range of training hours (500 to 1500), we will assume that this is represented by the position (pPos) in the Tryout table, and we will filter based on that range.", "Combine the conditions to form the final SQL query."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE decision = 'accepted') AND pID IN (SELECT pID FROM Tryout WHERE pPos BETWEEN 500 AND 1500);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n    \"2\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4975", "db_id": "soccer_2", "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?", "rationale": ["Identify the relevant table: The 'College' table contains the necessary information about college names and enrollment numbers.", "Determine the conditions: We need colleges with an enrollment number greater than 10000 and located in Louisiana.", "Construct the SQL query: Use a SELECT statement to retrieve 'cName' and 'enr' from the 'College' table, applying the specified conditions in the WHERE clause."], "gold_sql": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = 'LA'", "source_tables": ["college"], "pred_sql": "SELECT cName, enr FROM College WHERE enr > 10000 AND state = 'Louisiana';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who attended high schools with an enrollment number less than a specified value. The placeholder in the WHERE clause represents the enrollment number of students.\",\n    \"2\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4981", "db_id": "soccer_2", "question": "What are the name of the players who received a card in descending order of the hours of training?", "rationale": ["Identify the relevant table: The 'Player' table contains the names of the players and their eligibility year.", "Determine the required output: We need the names of players who received a card, which corresponds to the 'yCard' column in the 'Player' table.", "Sort the results: The names should be ordered in descending order based on the 'yCard' column, which indicates the year of the player's card or eligibility."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player ORDER BY yCard DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\"\n}\n"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["To find the most popular position among players in the tryout, we need to count how many players are trying out for each position.", "We will use the 'Tryout' table, which contains the 'pPos' column representing the position players are trying out for.", "We will group the results by 'pPos' to aggregate the counts for each position.", "We will count the number of players for each position using COUNT(*).", "To determine the most popular position, we will order the results in descending order based on the count of players for each position.", "Finally, we will limit the results to 1 to get only the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"2\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\"\n}\n"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["To determine the most popular position at tryouts, we need to count how many players tried out for each position.", "We will use the 'Tryout' table, which contains the 'pPos' column representing the position players are trying out for.", "We will group the results by 'pPos' to aggregate the counts for each position.", "We will count the occurrences of each position using COUNT(pPos) and alias it as 'position_count'.", "To find the most popular position, we will order the results in descending order based on 'position_count'.", "Finally, we will limit the results to 1 to get the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(pPos) AS position_count\nFROM Tryout\nGROUP BY pPos\nORDER BY position_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n    \"2\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["Identify the relevant table: The 'Tryout' table contains information about players, their positions, and decisions made regarding their tryouts.", "Determine the required information: We need to find the minimum hours of students playing in different positions.", "Use the MIN() function to calculate the minimum hours for each position.", "Group the results by position using GROUP BY clause to get the minimum hours for each unique position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(hours) AS min_hours\nFROM Tryout\nGROUP BY pPos;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\"\n}\n"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["Identify the relevant tables: We need to find information about players and their practice times, which suggests a table related to practice.", "Determine the required fields: We need the position (pPos) and the minimum practice time for each position.", "Group the results: Since we want the minimum practice time for each position, we will use the GROUP BY clause on pPos.", "Use the MIN function: To find the minimum practice time for each position, we will use the MIN aggregate function."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(practice_time) AS min_practice_time\nFROM Practice\nGROUP BY pPos;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\"\n}\n"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["Identify the tables involved: Player and Tryout.", "We need to select the names of players, which corresponds to the 'pName' column in the Player table.", "We also need to include the position they practiced for, which corresponds to the 'pPos' column in the Tryout table.", "To find players who received a 'yes' decision at tryouts, we will filter the results using the 'decision' column in the Tryout table.", "We will join the Player and Tryout tables on the 'pID' column, which is the unique identifier for players."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT Player.pName, Tryout.pPos \nFROM Player \nJOIN Tryout ON Player.pID = Tryout.pID \nWHERE Tryout.decision = 'yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n    \"2\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find the names of students (players) who successfully tried out for the position of striker.", "This requires a JOIN between the Player table and the Tryout table on the pID column.", "We filter the results where the position (pPos) is 'striker' and the decision is 'successful'.", "Select the pName from the Player table as the final output."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT Player.pName \nFROM Player \nJOIN Tryout ON Player.pID = Tryout.pID \nWHERE Tryout.pPos = 'striker' AND Tryout.decision = 'successful';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n    \"2\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["Identify the relevant tables: Player and Tryout.", "Determine the condition: we are interested in players who got rejected in their tryouts.", "Join the Player and Tryout tables on the pID to get the necessary information about players and their tryout decisions.", "Filter the results to include only those players whose decision was 'rejected'.", "Select the average of the hours spent practicing from the filtered results."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT AVG(hours) AS average_hours\nFROM (SELECT pID, HS, hours\n      FROM Player\n      JOIN Tryout ON Player.pID = Tryout.pID\n      WHERE Tryout.decision = 'rejected') AS rejected_players;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n    \"1\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.5018", "db_id": "soccer_2", "question": "Which college has any student who is a goalie and succeeded in the tryout.", "rationale": ["Identify the relevant tables: College, Player, and Tryout.", "We need to find colleges that have students who are goalies and succeeded in their tryouts.", "This requires joining the College table with the Tryout table on the college name, and the Tryout table with the Player table on the player ID.", "Filter the results where the position (pPos) is 'goalie' and the decision is 'succeeded'.", "Select distinct college names to avoid duplicates."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT c.cName \nFROM College c \nJOIN Tryout t ON c.cName = t.cName \nJOIN Player p ON t.pID = p.pID \nWHERE t.pPos = 'goalie' AND t.decision = 'succeeded';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"2\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\"\n}\n"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["Identify the relevant tables: College and Tryout are needed to get the state and enrollment of colleges where players have been accepted in tryouts.", "We need to join the College table with the Tryout table on the common column cName to link colleges with their respective tryouts.", "The condition for filtering is that we only want colleges where the decision in the Tryout table is 'accepted'.", "Select the state and enrollment number (enr) from the College table for the filtered results."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT College.state, College.enr \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.decision = 'accepted';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"1\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"2\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\"\n}\n"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["Identify the tables involved: College and Tryout.", "We need to find the total enrollment of colleges where students were accepted during tryouts, so we will join the College table with the Tryout table on the college name (cName).", "We will filter the results to only include rows where the decision in the Tryout table is 'accepted'.", "We need to sum the enrollment numbers from the College table, which requires converting the enrollment number from text to integer.", "Finally, we will group the results by the state of the colleges to get the total enrollment per state."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT SUM(CAST(College.enr AS INTEGER)) AS total_enrollment, College.state \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.decision = 'accepted' \nGROUP BY College.state;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"1\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"2\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\"\n}\n"}
{"sample_id": "train.5026", "db_id": "soccer_2", "question": "Find the names of schools that have some students playing in goalie and mid positions.", "rationale": ["We need to find the names of schools (colleges) that have students playing in specific positions: goalie and mid.", "To achieve this, we will use the College table to get the names of colleges.", "We will join the College table with the Tryout table on the college name (cName) to filter the colleges based on the positions of the players.", "In the WHERE clause, we will specify that we are interested in players whose positions (pPos) are either 'goalie' or 'mid'.", "Using DISTINCT will ensure that we only get unique college names in the result."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT c.cName \nFROM College c \nJOIN Tryout t ON c.cName = t.cName \nWHERE t.pPos IN ('goalie', 'mid')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n    \"2\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\"\n}\n"}
{"sample_id": "train.5028", "db_id": "soccer_2", "question": "Find the names of states that have some college students playing in goalie and mid positions.", "rationale": ["We need to find distinct states where colleges have students playing in specific positions (goalie and mid).", "To do this, we will join the College, Tryout, and Player tables based on their relationships: College.cName with Tryout.cName and Tryout.pID with Player.pID.", "We will select the distinct states from the College table.", "The condition for the join will be that the position (pPos) in the Tryout table must be either 'goalie' or 'mid'."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT College.state\nFROM College\nJOIN Tryout ON College.cName = Tryout.cName\nJOIN Player ON Tryout.pID = Player.pID\nWHERE Tryout.pPos IN ('goalie', 'mid')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"1\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"2\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\"\n}\n"}
{"sample_id": "train.5029", "db_id": "soccer_2", "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?", "rationale": ["We need to find distinct states where colleges have students playing in specific positions (goalie and mid-field).", "To do this, we will join the College, Tryout, and Player tables based on their relationships.", "The College table provides the state information, while the Tryout table gives us the positions players are trying out for.", "We will filter the results using a WHERE clause to include only those players who are trying out for either 'goalie' or 'mid-field'.", "Finally, we will select distinct states to avoid duplicates in our results."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT College.state\nFROM College\nJOIN Tryout ON College.cName = Tryout.cName\nJOIN Player ON Tryout.pID = Player.pID\nWHERE Tryout.pPos IN ('goalie', 'mid-field')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"1\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"2\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\"\n}\n"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant tables: We need to look at the 'Tryout' table to find players in specific positions.", "Determine the positions of interest: The positions we are interested in are 'goalie' and 'mid'.", "Count distinct colleges: We want to count how many unique colleges (cName) have players trying out for either of these positions.", "Construct the SQL query: We will use a SELECT statement to count distinct college names from the Tryout table where the position is either 'goalie' or 'mid'."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(DISTINCT cName) AS school_count\nFROM Tryout\nWHERE pPos IN ('goalie', 'mid')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n    \"1\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"2\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\"\n}\n"}
{"sample_id": "train.5037", "db_id": "soccer_2", "question": "What is the count of states with college students playing in the mid position but not as goalies?", "rationale": ["Identify the tables involved: College, Player, and Tryout.", "We need to count distinct states, so we will use COUNT(DISTINCT College.state).", "We need to join the College table with the Tryout table on the college name (cName) and the Tryout table with the Player table on the player ID (pID).", "The WHERE clause needs to filter for players trying out for the 'mid' position and exclude those with a decision of 'goalie'.", "Construct the SQL query using the identified elements."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')", "source_tables": ["tryout", "college"], "pred_sql": "SELECT COUNT(DISTINCT College.state) \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nJOIN Player ON Tryout.pID = Player.pID \nWHERE Tryout.pPos = 'mid' AND Tryout.decision IS NOT 'goalie';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"1\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\"\n}\n"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["Identify the requirement to find states with colleges that have enrollments less than some other college.", "To achieve this, we need to compare the enrollment numbers of colleges in different states.", "We can use a subquery to find the maximum enrollment number from the College table.", "The main query will select distinct states from the College table where the enrollment number is less than the maximum enrollment number found in the subquery."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE enr < (SELECT MAX(enr) FROM College)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\",\n    \"1\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n    \"2\": \"This virtual table describes the names and high schools of players from the 'Player' table who attended high schools with an enrollment number less than a specified value. The placeholder in the WHERE clause represents the enrollment number of students.\"\n}\n"}
{"sample_id": "train.5102", "db_id": "cre_Drama_Workshop_Groups", "question": "Show the minimum, average, maximum order quantity of all invoices.", "rationale": ["Identify the relevant table: The 'Invoice_Items' table contains the 'Order_Quantity' column which we need to analyze.", "Determine the required calculations: We need to calculate the minimum, average, and maximum of the 'Order_Quantity'.", "Construct the SQL query: Use the aggregate functions MIN(), AVG(), and MAX() on the 'Order_Quantity' column from the 'Invoice_Items' table."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "pred_sql": "SELECT MIN(Order_Quantity) AS Min_Quantity, AVG(Order_Quantity) AS Avg_Quantity, MAX(Order_Quantity) AS Max_Quantity \nFROM Invoice_Items;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n    \"1\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\"\n}\n"}
{"sample_id": "train.5118", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the payment method code used by the most orders?", "rationale": ["Identify the relevant table: Invoices contains the payment_method_code and Order_ID.", "Group the results by payment_method_code to count how many orders are associated with each payment method.", "Order the results in descending order based on the count of Order_ID to find the most used payment method.", "Limit the results to 1 to get only the top payment method code."], "gold_sql": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices"], "pred_sql": "SELECT payment_method_code\nFROM Invoices\nGROUP BY payment_method_code\nORDER BY COUNT(Order_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5127", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the descriptions of the service types that cost more than 100.", "rationale": ["Identify the relevant table: The question asks for service types, which are found in the Services table.", "Determine the required column: We need the descriptions of the service types, so we will select the 'Service_Type_Description' column.", "Filter the results: The question specifies that we only want service types that cost more than 100, which implies we need to filter based on the 'Product_Price' column.", "Construct the SQL query: Combine the SELECT statement with the FROM clause and the WHERE condition to form the complete SQL query."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT Service_Type_Description \nFROM Services \nWHERE Product_Price > 100;", "hint": "\n"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["Identify the relevant tables: We need to find workshop groups and services, so we will use the Drama_Workshop_Groups and Services tables.", "Determine the relationship: The Services table has a foreign key Workshop_Group_ID that links to the Drama_Workshop_Groups table.", "Filter the services: We need to filter the services to only those with the product name 'film'.", "Select the distinct workshop group names: We want the names of the workshop groups, so we will select Store_Name from the Drama_Workshop_Groups table and ensure we get distinct values."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "pred_sql": "SELECT DISTINCT d.Store_Name\nFROM Drama_Workshop_Groups d\nJOIN Services s ON d.Workshop_Group_ID = s.Workshop_Group_ID\nWHERE s.Product_Name = 'film';", "hint": "\n"}
{"sample_id": "train.5142", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the order details of the products with price higher than 2000?", "rationale": ["We need to retrieve order details of products with a price higher than 2000.", "The relevant tables for this query are Invoice_Items, Invoices, Order_Items, and Products.", "We will join these tables to get the necessary details:", "1. Start with Invoice_Items to get the invoice details.", "2. Join Invoices to link the invoice items to their respective invoices.", "3. Join Order_Items to connect the invoice items to the orders they belong to.", "4. Finally, join Products to filter products based on their price.", "The WHERE clause will filter products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_ID, Product_ID, Order_Quantity, Other_Item_Details \nFROM Invoice_Items \nJOIN Invoices ON Invoice_Items.Invoice_ID = Invoices.Invoice_ID \nJOIN Order_Items ON Invoice_Items.Order_Item_ID = Order_Items.Order_Item_ID \nJOIN Products ON Order_Items.Product_ID = Products.Product_ID \nWHERE Products.Product_Price > 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n    \"1\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\"\n}\n"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["Identify the relevant tables: We need to retrieve order details, which are stored in the 'Order_Items' table, and we also need product information, which is in the 'Products' table.", "Determine the columns to select: We want to select order item details such as Order_Item_ID, Order_ID, Product_ID, Order_Quantity, and the Product_Price.", "Establish the relationship between tables: We will join 'Order_Items' with 'Products' on the Product_ID to get the product price for each order item.", "Apply the filter condition: We need to filter the results to include only those products with a price greater than 2000. This will be done in the WHERE clause."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT oi.Order_Item_ID, oi.Order_ID, oi.Product_ID, oi.Order_Quantity, p.Product_Price \nFROM Order_Items oi \nJOIN Products p ON oi.Product_ID = p.Product_ID \nWHERE p.Product_Price > 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n    \"1\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\"\n}\n"}
{"sample_id": "train.5160", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the most frequent status of bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most frequent status of bookings, which means we need to count occurrences of each status code.", "Use the COUNT function: We will count the number of bookings for each status code using COUNT(*) and group the results by 'Status_Code'.", "Order the results: To find the most frequent status, we will order the results in descending order based on the count of bookings.", "Limit the results: Since we only want the most frequent status, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Frequency\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most common status code, which implies counting occurrences of each status code.", "Use the COUNT function: We will count the number of bookings for each status code.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each unique status code.", "Order the results: To find the most common status code, we will order the results in descending order based on the count.", "Limit the results: Since we only need the most common status code, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Count\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["Identify the relevant tables: We need information from the Drama_Workshop_Groups and Bookings tables.", "Determine the relationship: The Drama_Workshop_Groups table is linked to the Bookings table through the Workshop_Group_ID.", "Select the required fields: We need the Store_Name from the Drama_Workshop_Groups table.", "Apply the filter: We need to filter the bookings to only those with a status code of 'stop'.", "Use DISTINCT to ensure we only get unique workshop group names."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "pred_sql": "SELECT DISTINCT dg.Store_Name\nFROM Drama_Workshop_Groups dg\nJOIN Bookings b ON dg.Workshop_Group_ID = b.Workshop_Group_ID\nWHERE b.Status_Code = 'stop';", "hint": "\n"}
{"sample_id": "train.5171", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the description of the service type that offers not only the photo product but also the film product.", "rationale": ["Identify the relevant tables: Ref_Service_Types for service descriptions, Services for linking services to products, and Order_Items for product details.", "Join Ref_Service_Types with Services on Service_Type_Code to get the service descriptions associated with each service.", "Join Services with Order_Items to link services to the products they offer.", "Use a subquery to filter products to only those that are 'photo' and 'film'.", "Group the results by Service_Type_Description to aggregate services that offer both products.", "Use HAVING to ensure that only service types offering both products are included, which means counting distinct Product_IDs should equal 2."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT DISTINCT rst.Service_Type_Description\nFROM Ref_Service_Types rst\nJOIN Services s ON rst.Service_Type_Code = s.Service_Type_Code\nJOIN Order_Items oi ON s.Product_ID = oi.Product_ID\nWHERE oi.Product_ID IN (\n    SELECT Product_ID\n    FROM Products\n    WHERE Product_Name IN ('photo', 'film')\n)\nGROUP BY rst.Service_Type_Description\nHAVING COUNT(DISTINCT oi.Product_ID) = 2;", "hint": "\n"}
{"sample_id": "train.5459", "db_id": "voter_2", "question": "Find the average age of female students.", "rationale": ["Identify the table needed: The 'Student' table contains the age and gender information.", "Determine the condition: We need to filter for female students, which is done using the condition 'Sex = 'Female'.", "Calculate the average: Use the AVG() function to calculate the average age of the filtered students.", "Construct the SQL query: Combine the SELECT statement with the AVG function and the WHERE clause to filter for female students."], "gold_sql": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  'F'", "source_tables": ["student"], "pred_sql": "SELECT AVG(Age) AS Average_Age FROM Student WHERE Sex = 'Female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\",\n    \"1\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n    \"2\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5466", "db_id": "voter_2", "question": "What are the distinct president votes on 08/30/2015?", "rationale": ["Identify the relevant table: The question pertains to votes, specifically for the president, which is recorded in the 'Voting_record' table.", "Determine the specific column needed: We need the distinct values from the 'President_Vote' column.", "Filter the records based on the date: The question specifies a date (08/30/2015), which corresponds to the 'Registration_Date' column in the 'Voting_record' table.", "Construct the SQL query: Use SELECT DISTINCT to get unique president votes from the 'Voting_record' table where the 'Registration_Date' matches the specified date."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote \nFROM Voting_record \nWHERE Registration_Date = '2015-08-30';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"1\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"2\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["Identify the relevant table: The 'Voting_record' table contains the voting information, including the presidential votes.", "Determine the required data: We need to retrieve distinct presidential votes.", "Specify the condition: We need to filter the records based on the registration date, which is '08/30/2015'.", "Format the date correctly for SQLite: Convert '08/30/2015' to '2015-08-30'.", "Construct the SQL query: Use SELECT DISTINCT to get unique presidential votes from the Voting_record table where the registration date matches."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote \nFROM Voting_record \nWHERE Registration_Date = '2015-08-30';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"1\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"2\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5476", "db_id": "voter_2", "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "We need to find distinct ages of students, so we will select the 'Age' column from the 'Student' table.", "We need to join the 'Student' table with the 'Voting_record' table on the 'StuID' column to access voting records for students.", "We are specifically interested in students who have voted for the secretary candidate, so we will check if 'Secretary_Vote' is not null.", "We also need to filter the results based on the election cycle, which is specified as 'fall'.", "Construct the SQL query using SELECT DISTINCT to get unique ages, joining the two tables, and applying the necessary filters."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Age \nFROM Student S \nJOIN Voting_record V ON S.StuID = V.StuID \nWHERE V.Secretary_Vote IS NOT NULL \nAND V.Election_Cycle = 'fall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"1\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n    \"2\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["Identify the relevant tables: We need to get information from the 'Student' table for advisors and the 'Voting_record' table for voting details.", "Determine the relationship: The 'StuID' in both tables will be used to join them together.", "Specify the condition: We are interested in students who have voted for a treasurer, which means we need to check if 'Treasurer_Vote' is not null.", "Filter by election cycle: We need to specify that we are looking for votes in the spring election cycle.", "Select distinct advisors: Since multiple students may have the same advisor, we will use DISTINCT to get a unique list of advisors."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Advisor FROM Student INNER JOIN Voting_record ON Student.StuID = Voting_record.StuID WHERE Voting_record.Treasurer_Vote IS NOT NULL AND Voting_record.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"1\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"2\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5486", "db_id": "voter_2", "question": "How many male (sex is M) students have class senator votes in the fall election cycle?", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "Determine the relevant columns: 'Sex' from 'Student' and 'Election_Cycle' from 'Voting_record'.", "Filter for male students (Sex = 'M') and the specific election cycle (fall).", "Count the number of records that meet these criteria using COUNT(*) function."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT COUNT(*) \nFROM Student s \nJOIN Voting_record v ON s.StuID = v.StuID \nWHERE s.Sex = 'M' \nAND v.Election_Cycle = 'fall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of students from the 'Student' table who are registered to vote in a specific election cycle and belong to a particular gender. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.\",\n    \"1\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"2\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "Determine the columns needed: average age from 'Student' and the secretary vote from 'Voting_record'.", "Establish the relationship between the tables using the foreign key: 'Voting_record.Secretary_Vote' corresponds to 'Student.StuID'.", "Apply the filters: city code must be 'NYC' and the election cycle must be 'spring'.", "Construct the SQL query to calculate the average age of students who meet the criteria."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(Age) AS Average_Age\nFROM Student\nJOIN Voting_record ON Student.StuID = Voting_record.Secretary_Vote\nWHERE Student.city_code = 'NYC' AND Voting_record.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n    \"1\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"2\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\"\n}\n"}
{"sample_id": "train.5492", "db_id": "voter_2", "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "Determine the condition for female students: 'Sex' = 'F'.", "Identify the voting record for the secretary candidate: 'Secretary_Vote'.", "Specify the election cycle as 'spring'.", "Join the 'Student' table with the 'Voting_record' table on the 'StuID' and 'Secretary_Vote' columns.", "Calculate the average age of the filtered results using AVG(Age)."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(Age) AS Average_Age\nFROM Student\nJOIN Voting_record ON Student.StuID = Voting_record.Secretary_Vote\nWHERE Student.Sex = 'F' AND Voting_record.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n    \"1\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"2\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\"\n}\n"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["Identify the relevant tables: We need to retrieve data from the Student table and the Voting_record table.", "Determine the columns needed: We need the distinct first names (Fname) of students, so we will select S.Fname.", "Establish the relationship between tables: We will join the Student table (S) with the Voting_record table (V) on the StuID column, which is common to both tables.", "Set the conditions for the query: We want students who have voted for the vice president, which means we need to check that the Vice_President_Vote column in the Voting_record table is not null.", "Additionally, we need to filter out students whose city code is 'PIT', so we will add a condition to exclude those records.", "Finally, we will use DISTINCT to ensure that we only get unique first names."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Fname \nFROM Student S \nJOIN Voting_record V ON S.StuID = V.StuID \nWHERE V.Vice_President_Vote IS NOT NULL \nAND S.city_code != 'PIT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5495", "db_id": "voter_2", "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?", "rationale": ["We need to find distinct first names of students who voted for the vice president.", "To do this, we will join the Student table with the Voting_record table on the StuID column, which is the unique identifier for students in both tables.", "We will filter the results to include only those records where the Vice_President_Vote is not null, indicating that the student has cast a vote for the vice president.", "Additionally, we will filter out students who reside in a city with the city code 'PIT' by adding a condition that city_code should not equal 'PIT'.", "Finally, we will select the distinct first names (Fname) from the resulting dataset."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Fname FROM Student JOIN Voting_record ON Student.StuID = Voting_record.StuID WHERE Vice_President_Vote IS NOT NULL AND city_code != 'PIT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"1\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5496", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is not 2192.", "rationale": ["Identify the relevant tables: Student and Voting_record.", "We need to find distinct last names (LName) of students, so we will select LName from the Student table.", "We need to join the Student table with the Voting_record table on the StuID column to access voting information.", "We need to filter the results to include only those students who have cast a vote for president (President_Vote IS NOT NULL).", "Additionally, we need to ensure that the advisor of the student is not '2192' (Advisor != '2192').", "Finally, we will use DISTINCT to ensure that we only get unique last names."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student JOIN Voting_record ON Student.StuID = Voting_record.StuID WHERE President_Vote IS NOT NULL AND Advisor != '2192';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"1\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5499", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes and have 8741 as the advisor?", "rationale": ["Identify the requirement to find distinct last names of students who voted for president and have a specific advisor.", "The relevant table for student information is 'Student', which contains the last names and advisor information.", "The 'Voting_record' table contains the voting information, specifically the 'President_Vote' column to check if a student voted for president.", "To find students who voted for president, we can use a subquery to select 'StuID' from 'Voting_record' where 'President_Vote' is not null.", "We then need to filter the 'Student' table to get distinct last names where the 'StuID' is in the result of the subquery and the 'Advisor' is '8741'.", "Combine these conditions into a single SQL query using SELECT DISTINCT to get the unique last names."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student WHERE StuID IN (SELECT StuID FROM Voting_record WHERE President_Vote IS NOT NULL) AND Advisor = '8741';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n    \"1\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and sex.", "Filter the data: We need to focus on female students, so we will add a WHERE clause to filter by Sex = 'F'.", "Group the results: To find the most common major, we will group the results by the Major column.", "Count the occurrences: We will use COUNT(*) to count the number of students in each major.", "Order the results: We will order the results in descending order based on the count of students in each major.", "Limit the results: Since we only want the most common major, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as MajorCount \nFROM Student \nWHERE Sex = 'F' \nGROUP BY Major \nORDER BY MajorCount DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major field of study. The results are ordered by the number of students in each major in descending order, with a limit on the number of majors returned as specified by the placeholder.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are registered to vote in a specific election cycle and belong to a particular gender. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.\"\n}\n"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and gender.", "Filter for female students: We need to focus on female students, so we will add a WHERE clause to filter by 'Sex = 'Female' '.", "Group by major: To find out how many female students are in each major, we will use GROUP BY on the 'Major' column.", "Count the number of students in each major: We will use COUNT(*) to count the number of female students in each major.", "Order the results: We want the major with the most female students, so we will order the results in descending order by the count of students.", "Limit the results: Since we only want the major with the most female students, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major\nFROM Student\nWHERE Sex = 'Female'\nGROUP BY Major\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major field of study. The results are ordered by the number of students in each major in descending order, with a limit on the number of majors returned as specified by the placeholder.\",\n    \"1\": \"This virtual table counts the number of students from the 'Student' table who are registered to vote in a specific election cycle and belong to a particular gender. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.\",\n    \"2\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\"\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories are needed to filter by product category and selling price.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to access the category descriptions.", "Filter the results to include only those products that belong to the 'Spices' category and have a typical selling price greater than 1000.", "Count the number of products that meet these criteria."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT COUNT(*) \nFROM Products \nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code \nWHERE Ref_Product_Categories.product_category_description = 'Spices' \nAND Products.typical_selling_price > 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"1\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\"\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the relevant tables: We need to get product category descriptions, so we will use the 'Ref_Product_Categories' table.", "Join the 'Products' table to link products with their categories using the 'product_category_code'.", "Filter the products based on their descriptions containing the letter 't' using the LIKE operator.", "Select distinct product category descriptions to avoid duplicates."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description \nFROM Ref_Product_Categories rpc \nJOIN Products p ON rpc.product_category_code = p.product_category_code \nWHERE p.product_description LIKE '%t%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"1\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\",\n    \"2\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\"\n}\n"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["Identify the tables involved: Products, Product_Characteristics, and Characteristics.", "We need to count distinct characteristic names, so we will use COUNT(DISTINCT ...) in the SELECT clause.", "Join the Products table with Product_Characteristics on product_id to link products with their characteristics.", "Join the Product_Characteristics table with Characteristics on characteristic_id to access characteristic names.", "Filter the results to only include the product with the name 'cumin' using a WHERE clause."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT c.characteristic_name) AS distinct_characteristic_count\nFROM Products p\nJOIN Product_Characteristics pc ON p.product_id = pc.product_id\nJOIN Characteristics c ON pc.characteristic_id = c.characteristic_id\nWHERE p.product_name = 'cumin';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"1\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n    \"2\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\"\n}\n"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["Identify the tables involved: Products, Ref_Colors, Product_Characteristics, and Characteristics.", "Determine the relationships between these tables using foreign keys: Products to Ref_Colors via color_code, Products to Product_Characteristics via product_id, and Product_Characteristics to Characteristics via characteristic_id.", "Use a LEFT JOIN to include all products, even if they do not have a matching color or characteristic.", "Filter the results in the WHERE clause to include products that are either described as 'white' in the Ref_Colors table or have a characteristic named 'hot' in the Characteristics table.", "Count the distinct product IDs to avoid counting the same product multiple times if it meets both criteria."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT p.product_id) \nFROM Products p \nLEFT JOIN Ref_Colors c ON p.color_code = c.color_code \nLEFT JOIN Product_Characteristics pc ON p.product_id = pc.product_id \nLEFT JOIN Characteristics ch ON pc.characteristic_id = ch.characteristic_id \nWHERE c.color_description = 'white' OR ch.characteristic_name = 'hot';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n    \"1\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"2\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\"\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: We need to find the unit of measure for 'Herb' products, which involves the 'Ref_Product_Categories' and 'Products' tables.", "Determine the relationship: The 'Products' table has a foreign key relationship with the 'Ref_Product_Categories' table through 'product_category_code'.", "Filter the products: We need to filter the products to only those that have 'Herb' in their name. This can be done using a LIKE clause in the WHERE condition.", "Select the unit of measure: Finally, we select the 'unit_of_measure' from the 'Ref_Product_Categories' table based on the filtered products."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT pc.unit_of_measure \nFROM Ref_Product_Categories pc \nJOIN Products p ON pc.product_category_code = p.product_category_code \nWHERE p.product_name LIKE '%Herb%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"1\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\"\n}\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the tables needed: We need the 'Products' table for product details and 'Ref_Product_Categories' for the unit of measurement and product category code.", "Determine the columns to select: We need 'product_category_code' from 'Ref_Product_Categories' and 'unit_of_measure' from 'Ref_Product_Categories'.", "Establish the join condition: The 'product_category_code' in 'Products' should match with 'product_category_code' in 'Ref_Product_Categories'.", "Add the filter condition: We need to filter the results where the product name is 'chervil'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT pc.product_category_code, p.unit_of_measure \nFROM Products p \nJOIN Ref_Product_Categories pc ON p.product_category_code = pc.product_category_code \nWHERE p.product_name = 'chervil';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"1\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\",\n    \"2\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\"\n}\n"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["Identify the relevant tables: Products and Ref_Colors are needed to get the color descriptions for products.", "Join the Products table with the Ref_Colors table on the color_code to access color descriptions.", "Group the results by color_description to count how many products correspond to each color.", "Order the results by the count of products in descending order to find the most common color.", "Limit the results to 1 to get the description of the color for the most products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT Ref_Colors.color_description\nFROM Products\nJOIN Ref_Colors ON Products.color_code = Ref_Colors.color_code\nGROUP BY Ref_Colors.color_description\nORDER BY COUNT(Products.product_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\",\n    \"1\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n    \"2\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["We need to find the description of the color used by the least number of products.", "To do this, we will join the 'Ref_Colors' table with the 'Products' table on the 'color_code' column.", "Next, we will group the results by 'color_code' to count how many products are associated with each color.", "We will then order the results in ascending order based on the count of products, so that the color with the least products comes first.", "Finally, we will limit the results to 1 to get only the color description used by the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT color_description FROM Ref_Colors\nJOIN Products ON Ref_Colors.color_code = Products.color_code\nGROUP BY Ref_Colors.color_code\nORDER BY COUNT(Products.product_id) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\",\n    \"1\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n    \"2\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To achieve this, we will join the 'Characteristics' table with the 'Product_Characteristics' table to link characteristics to products.", "Next, we will join the 'Products' table to get the product information associated with each characteristic.", "We will group the results by the characteristic name to count how many distinct products each characteristic is associated with.", "Finally, we will use the HAVING clause to filter the results to only include characteristics that are linked to two or more distinct products."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT c.characteristic_name\nFROM Characteristics c\nJOIN Product_Characteristics pc ON c.characteristic_id = pc.characteristic_id\nJOIN Products p ON pc.product_id = p.product_id\nGROUP BY c.characteristic_name\nHAVING COUNT(DISTINCT p.product_id) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\",\n    \"1\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"2\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\"\n}\n"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to query.", "Select the 'Builder' column: We want to list the builders, so we will select this column.", "Use DISTINCT to avoid duplicate entries: Since multiple railways can have the same builder, we will use DISTINCT to ensure each builder is listed only once.", "Order the results: We need the results in ascending alphabetical order, so we will use ORDER BY Builder ASC.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "pred_sql": "SELECT DISTINCT Builder FROM railway ORDER BY Builder ASC;", "hint": "\n"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["Identify the relevant tables: railway and train.", "We need to find the railway associated with the most trains, so we will join the railway table with the train table on the Railway_ID.", "We will group the results by Railway_ID and Builder to count the number of trains associated with each railway.", "Use COUNT(train.Train_ID) to count the number of trains for each railway.", "Order the results in descending order based on the count of trains to get the railway with the most trains at the top.", "Limit the results to 1 to get only the railway associated with the most trains."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "pred_sql": "SELECT railway.Railway_ID, railway.Builder\nFROM railway\nJOIN train ON railway.Railway_ID = train.Railway_ID\nGROUP BY railway.Railway_ID, railway.Builder\nORDER BY COUNT(train.Train_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["We need to find the most common builder of railways, which means we need to count how many railways each builder has constructed.", "To do this, we will select the 'Builder' column from the 'railway' table and count the occurrences of each builder using COUNT(*).", "We will group the results by 'Builder' to aggregate the counts for each builder.", "Next, we will order the results in descending order based on the count of railways built (BuilderCount).", "Finally, we will limit the results to just one entry to get the most common builder."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "pred_sql": "SELECT Builder, COUNT(*) as BuilderCount \nFROM railway \nGROUP BY Builder \nORDER BY BuilderCount DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["Identify the table to query: The relevant table is 'Student' as we need the last names of students.", "Determine the conditions for selection: We need students who are either female, live in a city with the code 'BAL', or are male and under 20 years old.", "Construct the WHERE clause: The conditions can be combined using OR operators. The first condition checks for females, the second checks for the city code, and the third checks for males under 20.", "Select the required column: We only need the last names, so we will select 'LName'.", "Combine all parts into a full SQL query: The final query selects 'LName' from 'Student' where the specified conditions are met."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "pred_sql": "SELECT LName FROM Student WHERE (Sex = 'Female') OR (city_code = 'BAL') OR (Sex = 'Male' AND Age < '20');", "hint": "\n"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["Identify the tables involved: Dorm and Has_amenity.", "We need to count the number of amenities for each dormitory, so we will use COUNT() on the amenid from the Has_amenity table.", "We need to filter dorms that can accommodate more than 100 students, which is done using a WHERE clause on the student_capacity column in the Dorm table.", "To get the names of the dorms along with the count of amenities, we will select Dorm.dorm_name and the count of amenities.", "We will group the results by Dorm.dormid and Dorm.dorm_name to ensure we get the count of amenities for each dormitory."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "pred_sql": "SELECT Dorm.dorm_name, COUNT(Has_amenity.amenid) AS amenity_count\nFROM Dorm\nJOIN Has_amenity ON Dorm.dormid = Has_amenity.dormid\nWHERE Dorm.student_capacity > 100\nGROUP BY Dorm.dormid, Dorm.dorm_name;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\",\n    \"1\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\"\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables needed: Student, Lives_in, and Dorm.", "We need to count the total number of students, so we will use the COUNT() function.", "Join the Student table with the Lives_in table on the student ID (StuID) to find out where each student lives.", "Join the resulting table with the Dorm table on the dorm ID to access the gender of the dorm.", "Filter the results to include only those dorms that are designated for males (gender = 'male').", "Select the count of students from the filtered results."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(*) AS total_students\nFROM Student s\nJOIN Lives_in l ON s.StuID = l.stuid\nJOIN Dorm d ON l.dormid = d.dormid\nWHERE d.gender = 'male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\",\n    \"1\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\"\n}\n"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["Identify the tables involved: Student, Lives_in, Dorm, and Has_amenity.", "We need to find students' first names who live in the dorm with the most amenities.", "Join the Student table with the Lives_in table to link students to their dorms.", "Create a subquery that counts the number of amenities for each dorm by joining the Dorm and Has_amenity tables.", "Group the results of the subquery by dormid and order them by the count of amenities in descending order.", "Limit the subquery to return only the dorm with the highest count of amenities.", "Join the result of the subquery back to the Lives_in table to filter for students living in that dorm.", "Select the first names of those students."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT S.Fname \nFROM Student S \nJOIN Lives_in L ON S.StuID = L.stuid \nJOIN (\n    SELECT D.dormid \n    FROM Dorm D \n    JOIN Has_amenity HA ON D.dormid = HA.dormid \n    GROUP BY D.dormid \n    ORDER BY COUNT(HA.amenid) DESC \n    LIMIT 1\n) AS MostAmenities ON L.dormid = MostAmenities.dormid;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\",\n    \"1\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\"\n}\n"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["Identify the required fields: first name and age of students.", "Determine the relevant tables: Student, Lives_in, Dorm, Has_amenity, and Dorm_amenity.", "Establish relationships between tables: Students live in dorms, dorms have amenities.", "Join the Student table with Lives_in to find which students live in which dorms.", "Join the Dorm table to access dorm details and amenities.", "Join the Has_amenity and Dorm_amenity tables to filter for dorms that have a specific amenity, in this case, 'TV Lounge'.", "Use a WHERE clause to filter the results to only include dorms with a 'TV Lounge'."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "pred_sql": "SELECT Student.Fname, Student.Age \nFROM Student \nJOIN Lives_in ON Student.StuID = Lives_in.stuid \nJOIN Dorm ON Lives_in.dormid = Dorm.dormid \nJOIN Has_amenity ON Dorm.dormid = Has_amenity.dormid \nJOIN Dorm_amenity ON Has_amenity.amenid = Dorm_amenity.amenid \nWHERE Dorm_amenity.amenity_name = 'TV Lounge';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\",\n    \"1\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\"\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the main goal: Retrieve the email addresses of customers who have filed complaints about the product with the greatest number of complaints.", "To find the product with the greatest number of complaints, a subquery is needed that counts complaints grouped by product_id and orders them in descending order, limiting the result to the top product.", "Join the Customers table with the Complaints table on customer_id to access customer email addresses related to the complaints.", "Use the result of the subquery to filter the complaints to only those related to the product with the highest complaint count."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address\nFROM Customers c\nJOIN Complaints comp ON c.customer_id = comp.customer_id\nWHERE comp.product_id = (\n    SELECT product_id\n    FROM Complaints\n    GROUP BY product_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["Identify the products that have been complained about by customers.", "We need to find the customer who has filed the least amount of complaints.", "To do this, we can use a subquery that groups complaints by customer_id and counts them, ordering by the count in ascending order.", "The subquery will return the customer_id of the customer with the least complaints.", "We then join the Products table with the Complaints table on product_id to get the relevant product details for the identified customer."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT p.product_id, p.product_name \nFROM Products p \nJOIN Complaints c ON p.product_id = c.product_id \nWHERE c.customer_id = (\n    SELECT customer_id \n    FROM Complaints \n    GROUP BY customer_id \n    ORDER BY COUNT(complaint_id) ASC \n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the relevant tables: Complaints, Products, and Staff.", "We need to find the product with the lowest price, so we will use a subquery to get the minimum product price from the Products table.", "Next, we need to join the Complaints table with the Products table to link complaints to their respective products.", "We also need to join the Complaints table with the Staff table to find out which staff member is handling the complaint.", "Finally, we will select the last name of the staff member where the product price matches the lowest price found in the subquery."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT Staff.last_name \nFROM Complaints \nJOIN Products ON Complaints.product_id = Products.product_id \nJOIN Staff ON Complaints.staff_id = Staff.staff_id \nWHERE Products.product_price = (SELECT MIN(product_price) FROM Products);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["Identify the relevant table: The Complaints table contains the complaint status information.", "Determine the required fields: We need the complaint status code and the count of records for each status.", "Group the results: Use GROUP BY to aggregate the records by complaint status code.", "Filter the results: Use HAVING to filter out complaint statuses that have 3 or fewer records."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "pred_sql": "SELECT complaint_status_code, COUNT(*) as complaint_count \nFROM Complaints \nGROUP BY complaint_status_code \nHAVING COUNT(*) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["Identify the need to count customers based on their type.", "Use the Customers table to access customer_type_code and customer_id.", "Group the results by customer_type_code to get the count of customers for each type.", "Order the results in descending order based on the count of customers to find the most common type.", "Limit the results to 1 to get only the most common customer type."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT customer_type_code, COUNT(customer_id) AS customer_count \nFROM Customers \nGROUP BY customer_type_code \nORDER BY customer_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.\",\n    \"1\": \"This virtual table summarizes the states where customers reside, grouping the results by state and ordering them by the number of customers in each state. The placeholder in the LIMIT clause allows for specifying the maximum number of states to return.\",\n    \"2\": \"This virtual table summarizes the states where customers reside, grouping the results by state and ordering them by the number of customers in each state. The placeholder in the LIMIT clause allows for specifying the maximum number of states to return.\"\n}\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the goal: We need the first names of the top 5 staff members who have handled the greatest number of complaints.", "To achieve this, we will need to count the number of complaints handled by each staff member.", "We will use the Complaints table to group by staff_id and count the number of complaints for each staff member.", "Next, we will order the results in descending order based on the count of complaints to get the top staff members.", "Finally, we will limit the results to the top 5 staff members and select their first names from the Staff table."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Complaints GROUP BY staff_id ORDER BY COUNT(complaint_id) DESC LIMIT 5);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["We need to return the first names of staff members who have handled the most complaints.", "To find out which staff members handled the most complaints, we will need to count the number of complaints associated with each staff member.", "We can achieve this by using a subquery that selects the staff_id from the Complaints table, grouping by staff_id and ordering by the count of complaint_id in descending order.", "We will limit the results of this subquery to the top 5 staff members with the most complaints.", "Finally, we will select the first names of these staff members from the Staff table using the staff_ids obtained from the subquery."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Complaints GROUP BY staff_id ORDER BY COUNT(complaint_id) DESC LIMIT 5);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The user wants to see all investor details, which means we need to select all columns from the Investors table.", "The SQL command to retrieve all columns from a table is 'SELECT *'.", "The table we are interested in is 'Investors'.", "Therefore, the full SQL query is 'SELECT * FROM Investors'."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "pred_sql": "SELECT * FROM Investors;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\"\n}\n"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["We need to show details of all investors who have made transactions with a share count greater than 100.", "To do this, we will select the investor_id and Investor_details from the Investors table.", "We will join the Investors table with the Transactions table on the investor_id to link investors with their transactions.", "We will apply a WHERE clause to filter transactions where the share_count is greater than 100.", "Using DISTINCT ensures that we do not have duplicate investor entries in the result."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "pred_sql": "SELECT DISTINCT Investors.investor_id, Investors.Investor_details \nFROM Investors \nJOIN Transactions ON Investors.investor_id = Transactions.investor_id \nWHERE Transactions.share_count > 100;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\"\n}\n"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["Identify the relevant tables: Lots, Transactions, and Transactions_Lots are needed to get lot details associated with transactions.", "Use JOIN to connect Lots with Transactions through Transactions_Lots, as it links transactions to lots.", "Filter the results using a WHERE clause to only include transactions where the share count is less than 50.", "Select the lot details from the Lots table based on the filtered transactions."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT Lots.lot_details \nFROM Lots \nJOIN Transactions_Lots ON Lots.lot_id = Transactions_Lots.lot_id \nJOIN Transactions ON Transactions_Lots.transaction_id = Transactions.transaction_id \nWHERE Transactions.share_count < 50;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n    \"1\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\"\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["Identify the relevant tables: Transactions and Ref_Transaction_Types.", "We need to calculate the average transaction amount, so we will use the AVG() function on the amount_of_transaction column from the Transactions table.", "To categorize the average amounts by transaction types, we will join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code.", "We will group the results by transaction_type_description to get the average for each type.", "Finally, we will select the transaction type description and the calculated average transaction amount."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\"\n}\n"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["Identify the relevant tables: Transactions and Ref_Transaction_Types are needed to get transaction types and their share counts.", "Join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to get descriptions of each transaction type.", "Use aggregate functions MAX() and MIN() to find the maximum and minimum share counts for each transaction type.", "Group the results by transaction_type_description to get the max and min share counts for each type."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, MAX(t.share_count) AS max_share_count, MIN(t.share_count) AS min_share_count\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\",\n    \"1\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\"\n}\n"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["Identify the tables involved: Sales and Purchases.", "Determine the columns needed: sales_transaction_id and sales_details from Sales, purchase_transaction_id and purchase_details from Purchases.", "Since we want details of all sales and purchases, a FULL OUTER JOIN is appropriate to include all records from both tables, even if there are no matches.", "Construct the SQL query to select the required columns from both tables using the FULL OUTER JOIN."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "pred_sql": "SELECT Sales.sales_transaction_id, Sales.sales_details, Purchases.purchase_transaction_id, Purchases.purchase_details\nFROM Sales\nFULL OUTER JOIN Purchases ON Sales.sales_transaction_id = Purchases.purchase_transaction_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n    \"1\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\"\n}\n"}
