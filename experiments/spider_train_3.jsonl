{"sample_id": 1500, "db_id": "debate", "question": "Show the distinct venues of debates", "rationale": ["Identify the table that contains venue information, which is the 'debate' table.", "Determine the specific column that holds the venue data, which is 'Venue'.", "Use the DISTINCT keyword to ensure that only unique venues are returned in the result set.", "Construct the SQL query to select distinct venues from the debate table."], "pred_sql": "SELECT DISTINCT Venue FROM debate;", "gold_sql": "SELECT DISTINCT Venue FROM debate", "source_tables": ["debate"]}
{"sample_id": 1501, "db_id": "debate", "question": "Show the names of people, and dates and venues of debates they are on the affirmative side.", "rationale": ["Identify the required information: names of people, dates, and venues of debates where they are on the affirmative side.", "Determine the relevant tables: 'people' for names, 'debate' for dates and venues, and 'debate_people' to link people to debates.", "Establish the relationships: 'debate_people' links 'people' and 'debate' through the 'Affirmative' and 'Debate_ID' columns.", "Construct the SQL query using JOINs to combine the necessary tables based on the relationships identified."], "pred_sql": "SELECT people.Name, debate.Date, debate.Venue \nFROM debate_people \nJOIN people ON debate_people.Affirmative = people.People_ID \nJOIN debate ON debate_people.Debate_ID = debate.Debate_ID;", "gold_sql": "SELECT T3.Name ,  T2.Date ,  T2.Venue FROM debate_people AS T1 JOIN debate AS T2 ON T1.Debate_ID  =  T2.Debate_ID JOIN people AS T3 ON T1.Affirmative  =  T3.People_ID", "source_tables": ["debate", "debate_people", "people"]}
{"sample_id": 1502, "db_id": "debate", "question": "Show the names of people, and dates and venues of debates they are on the negative side, ordered in ascending alphabetical order of name.", "rationale": ["Identify the required information: names of people, dates, and venues of debates where they are on the negative side.", "Determine the tables involved: 'people', 'debate', and 'debate_people' are needed to get the required information.", "Establish the relationships: 'debate_people.Negative' links to 'people.People_ID' and 'debate_people.Debate_ID' links to 'debate.Debate_ID'.", "Select the relevant columns: 'people.Name', 'debate.Date', and 'debate.Venue'.", "Use JOIN clauses to combine the tables based on the identified relationships.", "Order the results by 'people.Name' in ascending order."], "pred_sql": "SELECT people.Name, debate.Date, debate.Venue \nFROM debate_people \nJOIN people ON debate_people.Negative = people.People_ID \nJOIN debate ON debate_people.Debate_ID = debate.Debate_ID \nORDER BY people.Name ASC;", "gold_sql": "SELECT T3.Name ,  T2.Date ,  T2.Venue FROM debate_people AS T1 JOIN debate AS T2 ON T1.Debate_ID  =  T2.Debate_ID JOIN people AS T3 ON T1.Negative  =  T3.People_ID ORDER BY T3.Name ASC", "source_tables": ["debate", "debate_people", "people"]}
{"sample_id": 1503, "db_id": "debate", "question": "Show the names of people that are on affirmative side of debates with number of audience bigger than 200.", "rationale": ["Identify the relevant tables: 'people', 'debate_people', and 'debate'.", "We need to select the 'Name' from the 'people' table.", "To find the affirmative side, we will join 'people' with 'debate_people' on 'People_ID' and 'Affirmative'.", "Next, we need to filter the debates based on the number of audience members, which is found in the 'debate' table.", "Join 'debate_people' with 'debate' on 'Debate_ID' to access the 'Num_of_Audience'.", "Apply the condition to filter debates where 'Num_of_Audience' is greater than 200.", "Construct the SQL query to select the names of people on the affirmative side of those debates."], "pred_sql": "SELECT p.Name FROM people p JOIN debate_people dp ON p.People_ID = dp.Affirmative JOIN debate d ON dp.Debate_ID = d.Debate_ID WHERE d.Num_of_Audience > 200;", "gold_sql": "SELECT T3.Name FROM debate_people AS T1 JOIN debate AS T2 ON T1.Debate_ID  =  T2.Debate_ID JOIN people AS T3 ON T1.Affirmative  =  T3.People_ID WHERE T2.Num_of_Audience  >  200", "source_tables": ["debate", "debate_people", "people"]}
{"sample_id": 1504, "db_id": "debate", "question": "Show the names of people and the number of times they have been on the affirmative side of debates.", "rationale": ["We need to retrieve the names of people and count how many times they have been on the affirmative side of debates.", "The relevant tables are 'people' for names and 'debate_people' for affirmative participation.", "We will join the 'people' table with the 'debate_people' table on the 'People_ID' and 'Affirmative' columns.", "We will use the COUNT function to count the occurrences of each person's name in the affirmative role.", "Finally, we will group the results by the person's name to get the count for each individual."], "pred_sql": "SELECT p.Name, COUNT(dp.Affirmative) AS Affirmative_Count\nFROM people p\nJOIN debate_people dp ON p.People_ID = dp.Affirmative\nGROUP BY p.Name;", "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM debate_people AS T1 JOIN people AS T2 ON T1.Affirmative  =  T2.People_ID GROUP BY T2.Name", "source_tables": ["debate_people", "people"]}
{"sample_id": 1505, "db_id": "debate", "question": "Show the names of people who have been on the negative side of debates at least twice.", "rationale": ["We need to find people who have participated on the negative side of debates.", "This requires joining the 'people' table with the 'debate_people' table on the 'People_ID' and 'Negative' columns.", "We will group the results by 'People_ID' to count how many times each person has been on the negative side.", "Using the HAVING clause, we will filter the groups to include only those with a count of debates greater than or equal to 2.", "Finally, we will select the 'Name' of these people from the 'people' table."], "pred_sql": "SELECT p.Name\nFROM people p\nJOIN debate_people dp ON p.People_ID = dp.Negative\nGROUP BY p.People_ID\nHAVING COUNT(dp.Debate_ID) >= 2;", "gold_sql": "SELECT T2.Name FROM debate_people AS T1 JOIN people AS T2 ON T1.Negative  =  T2.People_ID GROUP BY T2.Name HAVING COUNT(*)  >=  2", "source_tables": ["debate_people", "people"]}
{"sample_id": 1506, "db_id": "debate", "question": "List the names of people that have not been on the affirmative side of debates.", "rationale": ["Identify the main requirement: List names of people who have not been on the affirmative side of debates.", "To find this, we need to select names from the 'people' table.", "We need to exclude those who are listed as 'Affirmative' in the 'debate_people' table.", "We can achieve this by using a subquery that selects all 'Affirmative' names from 'debate_people'.", "The main query will select names from 'people' where their 'People_ID' is not in the list of affirmative participants."], "pred_sql": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT Affirmative FROM debate_people);", "gold_sql": "SELECT Name FROM people WHERE People_id NOT IN (SELECT Affirmative FROM debate_people)", "source_tables": ["debate_people", "people"]}
{"sample_id": 1507, "db_id": "insurance_and_eClaims", "question": "List the names of all the customers in alphabetical order.", "rationale": ["Identify the table that contains customer information, which is the 'Customers' table.", "Determine the column that holds the names of the customers, which is 'Customer_Details'.", "Specify that we want to select the 'Customer_Details' column from the 'Customers' table.", "To list the names in alphabetical order, use the ORDER BY clause with 'Customer_Details' in ascending order."], "pred_sql": "SELECT Customer_Details FROM Customers ORDER BY Customer_Details ASC;", "gold_sql": "SELECT customer_details FROM customers ORDER BY customer_details", "source_tables": ["customers"]}
{"sample_id": 1508, "db_id": "insurance_and_eClaims", "question": "Sort the customer names in alphabetical order.", "rationale": ["Identify the table that contains customer names, which is the 'Customers' table.", "Determine the column that holds the customer names, which is 'Customer_Details'.", "Use the SELECT statement to retrieve the 'Customer_Details' from the 'Customers' table.", "Apply the ORDER BY clause to sort the results in alphabetical order (ASC) based on 'Customer_Details'."], "pred_sql": "SELECT Customer_Details FROM Customers ORDER BY Customer_Details ASC;", "gold_sql": "SELECT customer_details FROM customers ORDER BY customer_details", "source_tables": ["customers"]}
{"sample_id": 1509, "db_id": "insurance_and_eClaims", "question": "Find all the policy type codes associated with the customer \"Dayana Robel\"", "rationale": ["Identify the relevant tables: We need to retrieve policy type codes, which are in the Policies table, and we need to filter by customer details, which are in the Customers table.", "Determine the relationship: The Policies table has a foreign key 'Customer_ID' that links to the 'Customer_ID' in the Customers table. This means we need to join these two tables on this key.", "Select the required columns: We need to select 'Policy_Type_Code' from the Policies table.", "Add the condition: We need to filter the results to only include records where the 'Customer_Details' in the Customers table matches 'Dayana Robel'.", "Construct the SQL query: Combine all the above steps into a single SQL query."], "pred_sql": "SELECT Policies.Policy_Type_Code \nFROM Policies \nJOIN Customers ON Policies.Customer_ID = Customers.Customer_ID \nWHERE Customers.Customer_Details = 'Dayana Robel';", "gold_sql": "SELECT policy_type_code FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.customer_details  =  'Dayana Robel'", "source_tables": ["policies", "customers"]}
{"sample_id": 1510, "db_id": "insurance_and_eClaims", "question": "What are the type codes of the policies used by the customer \"Dayana Robel\"?", "rationale": ["Identify the relevant tables: We need to retrieve policy type codes, which are stored in the Policies table, and we need to filter by customer details, which are in the Customers table.", "Determine the relationship: The Policies table has a foreign key 'Customer_ID' that links to the 'Customer_ID' in the Customers table. This means we can join these two tables on this key.", "Formulate the SELECT statement: We want to select the 'Policy_Type_Code' from the Policies table.", "Add the JOIN clause: We will join the Policies table with the Customers table on the 'Customer_ID' field to access customer details.", "Add the WHERE clause: We need to filter the results to only include policies for the customer with the details 'Dayana Robel'."], "pred_sql": "SELECT Policies.Policy_Type_Code \nFROM Policies \nJOIN Customers ON Policies.Customer_ID = Customers.Customer_ID \nWHERE Customers.Customer_Details = 'Dayana Robel';", "gold_sql": "SELECT policy_type_code FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.customer_details  =  'Dayana Robel'", "source_tables": ["policies", "customers"]}
{"sample_id": 1511, "db_id": "insurance_and_eClaims", "question": "Which type of policy is most frequently used? Give me the policy type code.", "rationale": ["Identify the relevant table: The query is asking about policy types, so we will focus on the Policies table.", "Determine the required information: We need to find the most frequently used policy type, which means we need to count occurrences of each Policy_Type_Code.", "Use the COUNT function: We will use COUNT(*) to count how many times each Policy_Type_Code appears in the Policies table.", "Group the results: We will use GROUP BY Policy_Type_Code to aggregate the counts by each policy type.", "Order the results: To find the most frequently used policy type, we will order the results in descending order of frequency.", "Limit the results: Since we only want the most frequently used policy type, we will limit the results to 1."], "pred_sql": "SELECT Policy_Type_Code, COUNT(*) as Frequency\nFROM Policies\nGROUP BY Policy_Type_Code\nORDER BY Frequency DESC\nLIMIT 1;", "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"]}
{"sample_id": 1512, "db_id": "insurance_and_eClaims", "question": "Find the type code of the most frequently used policy.", "rationale": ["Identify the table that contains the policy type codes, which is the Policies table.", "To find the most frequently used policy type code, we need to group the results by Policy_Type_Code.", "We will count the occurrences of each Policy_Type_Code using COUNT(*) and order the results in descending order to get the most frequent one at the top.", "Finally, we will limit the results to 1 to get only the most frequently used policy type code."], "pred_sql": "SELECT Policy_Type_Code FROM Policies GROUP BY Policy_Type_Code ORDER BY COUNT(*) DESC LIMIT 1;", "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"]}
{"sample_id": 1513, "db_id": "insurance_and_eClaims", "question": "Find all the policy types that are used by more than 2 customers.", "rationale": ["Identify the relevant table: Policies, which contains the Policy_Type_Code and Customer_ID.", "We need to find policy types used by more than 2 customers, so we will group by Customer_ID in the Customers table and count the occurrences.", "Use a subquery to select Customer_IDs that are associated with more than 2 customers.", "Then, in the main query, select the Policy_Type_Code from the Policies table where the Customer_ID is in the list obtained from the subquery.", "Finally, group the results by Policy_Type_Code to get distinct policy types used by more than 2 customers."], "pred_sql": "SELECT Policy_Type_Code FROM Policies WHERE Customer_ID IN (SELECT Customer_ID FROM Customers GROUP BY Customer_ID HAVING COUNT(Customer_ID) > 2) GROUP BY Policy_Type_Code;", "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"]}
{"sample_id": 1514, "db_id": "insurance_and_eClaims", "question": "Which types of policy are chosen by more than 2 customers? Give me the policy type codes.", "rationale": ["Identify the relevant table: The query is about policies and customers, so we will focus on the Policies table.", "Determine the condition: We need to find policy types chosen by more than 2 customers. This means we need to group by Customer_ID and count the number of customers for each policy type.", "Use a subquery: We will create a subquery to find Customer_IDs that have more than 2 policies.", "Select the Policy_Type_Code: Finally, we will select the Policy_Type_Code from the Policies table where the Customer_IDs meet the criteria from the subquery."], "pred_sql": "SELECT Policy_Type_Code FROM Policies WHERE Customer_ID IN (SELECT Customer_ID FROM Policies GROUP BY Customer_ID HAVING COUNT(Customer_ID) > 2) GROUP BY Policy_Type_Code;", "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"]}
{"sample_id": 1515, "db_id": "insurance_and_eClaims", "question": "Find the total and average amount paid in claim headers.", "rationale": ["Identify the required data: total and average amount paid in claim headers.", "Determine the relevant table: Claim_Headers contains the Amount_Paid column.", "Use aggregate functions: SUM() to calculate the total and AVG() to calculate the average.", "Construct the SQL query to select the total and average from the Amount_Paid column in the Claim_Headers table."], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid FROM Claim_Headers;", "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"]}
{"sample_id": 1516, "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["Identify the relevant table: The 'Claim_Headers' table contains the 'Amount_Paid' column which is needed for the calculations.", "Determine the required calculations: We need to calculate the total amount paid and the average amount paid.", "Use SQL aggregate functions: Use SUM() to calculate the total and AVG() to calculate the average.", "Construct the SQL query: Select the total and average amount paid from the Claim_Headers table."], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid FROM Claim_Headers;", "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"]}
{"sample_id": 1517, "db_id": "insurance_and_eClaims", "question": "Find the total amount claimed in the most recently created document.", "rationale": ["Identify the relevant tables: Claim_Headers for the amount claimed and Claims_Documents for the document creation date.", "We need to sum the 'Amount_Claimed' from the Claim_Headers table.", "To find the most recently created document, we will use a subquery to get the maximum 'Created_Date' from the Claims_Documents table.", "Join the Claim_Headers table with the Claims_Documents table on the Claim_ID to link claims with their documents.", "Filter the results to only include claims that correspond to the most recently created document."], "pred_sql": "SELECT SUM(ch.Amount_Claimed) AS Total_Amount_Claimed\nFROM Claim_Headers ch\nJOIN Claims_Documents cd ON ch.Claim_Header_ID = cd.Claim_ID\nWHERE cd.Created_Date = (SELECT MAX(Created_Date) FROM Claims_Documents);", "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"]}
{"sample_id": 1518, "db_id": "insurance_and_eClaims", "question": "How much amount in total were claimed in the most recently created document?", "rationale": ["Identify the relevant tables: Claim_Headers for the amount claimed and Claims_Documents for the document creation date.", "We need to sum the 'Amount_Claimed' from the Claim_Headers table.", "Join the Claim_Headers table with the Claims_Documents table on the Claim_ID to link claims with their documents.", "Filter the results to only include claims associated with the most recently created document by using a subquery to find the maximum 'Created_Date' in the Claims_Documents table."], "pred_sql": "SELECT SUM(ch.Amount_Claimed) AS Total_Claimed_Amount\nFROM Claim_Headers ch\nJOIN Claims_Documents cd ON ch.Claim_Header_ID = cd.Claim_ID\nWHERE cd.Created_Date = (SELECT MAX(Created_Date) FROM Claims_Documents);", "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"]}
{"sample_id": 1519, "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers.", "We need to find the customer who made the largest claim, so we will focus on the Amount_Claimed column in the Claim_Headers table.", "To link the claims to customers, we will join the Claim_Headers table with the Policies table using the Policy_ID.", "Next, we will join the Policies table with the Customers table using the Customer_ID.", "We will order the claims by Amount_Claimed in descending order to find the largest claim.", "Finally, we will select the Customer_Details of the customer associated with the largest claim."], "pred_sql": "SELECT c.Customer_Details \nFROM Customers c \nJOIN Claim_Headers ch ON c.Customer_ID = (SELECT p.Customer_ID \n                                          FROM Policies p \n                                          JOIN Claim_Headers ch2 ON p.Policy_ID = ch2.Policy_ID \n                                          ORDER BY ch2.Amount_Claimed DESC \n                                          LIMIT 1)", "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"]}
{"sample_id": 1520, "db_id": "insurance_and_eClaims", "question": "Which customer made the largest amount of claim in a single claim? Return the customer details.", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers.", "We need to find the customer who made the largest claim, so we will join the Customers table with the Policies table on Customer_ID, and then join the Claim_Headers table on Policy_ID.", "Select the Customer_Details from the Customers table.", "Order the results by Amount_Claimed in descending order to get the largest claim at the top.", "Limit the results to 1 to get only the customer with the largest claim."], "pred_sql": "SELECT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID \nORDER BY ch.Amount_Claimed DESC \nLIMIT 1;", "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"]}
{"sample_id": 1521, "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the minimum amount of payment in one claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers are needed to find the customer details and their claims.", "Join the Customers table with the Policies table on Customer_ID to link customers to their policies.", "Join the resulting table with the Claim_Headers table on Policy_ID to access the claims made by each customer.", "Order the results by the Amount_Claimed in ascending order to find the minimum amount claimed.", "Limit the results to 1 to get only the customer with the minimum claim amount."], "pred_sql": "SELECT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID \nORDER BY ch.Amount_Claimed ASC \nLIMIT 1;", "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"]}
{"sample_id": 1522, "db_id": "insurance_and_eClaims", "question": "Which customer made the smallest amount of claim in one claim? Return the customer details.", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers.", "We need to find the customer who made the smallest claim, so we will focus on the Amount_Claimed column in the Claim_Headers table.", "Join the Customers table with the Policies table on Customer_ID to link customers to their policies.", "Then, join the Claim_Headers table on Policy_ID to link policies to their claims.", "Order the results by Amount_Claimed in ascending order to get the smallest claim first.", "Limit the results to 1 to get only the customer with the smallest claim."], "pred_sql": "SELECT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID \nORDER BY ch.Amount_Claimed ASC \nLIMIT 1;", "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"]}
{"sample_id": 1523, "db_id": "insurance_and_eClaims", "question": "Find the names of customers who have no policies associated.", "rationale": ["Identify the table that contains customer information, which is the 'Customers' table.", "Identify the table that contains policy information, which is the 'Policies' table.", "To find customers with no associated policies, we need to perform a LEFT JOIN between 'Customers' and 'Policies' on the 'Customer_ID'.", "In the WHERE clause, we check for NULL values in 'Policies.Customer_ID' to filter out customers who do not have any policies associated with them."], "pred_sql": "SELECT Customers.Customer_Details FROM Customers LEFT JOIN Policies ON Customers.Customer_ID = Policies.Customer_ID WHERE Policies.Customer_ID IS NULL;", "gold_sql": "SELECT customer_details FROM customers EXCEPT SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id", "source_tables": ["policies", "customers"]}
{"sample_id": 1524, "db_id": "insurance_and_eClaims", "question": "What are the names of customers who do not have any policies?", "rationale": ["Identify the Customers table which contains customer information.", "We need to find customers who do not have any policies, which means we need to check the Policies table for any associated Customer_IDs.", "Use a subquery to select all Customer_IDs from the Policies table.", "Use the NOT IN clause to filter out those Customer_IDs from the Customers table.", "Select the Customer_Details from the Customers table where the Customer_ID is not in the list of Customer_IDs from the Policies table."], "pred_sql": "SELECT Customer_Details FROM Customers WHERE Customer_ID NOT IN (SELECT Customer_ID FROM Policies)", "gold_sql": "SELECT customer_details FROM customers EXCEPT SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id", "source_tables": ["policies", "customers"]}
{"sample_id": 1525, "db_id": "insurance_and_eClaims", "question": "How many claim processing stages are there in total?", "rationale": ["Identify the table that contains the claim processing stages, which is 'Claims_Processing_Stages'.", "To find the total number of claim processing stages, we need to count the entries in this table.", "Use the COUNT() function to count all records in the 'Claims_Processing_Stages' table.", "Construct the SQL query to select the count from the 'Claims_Processing_Stages' table."], "pred_sql": "SELECT COUNT(*) AS Total_Claim_Processing_Stages FROM Claims_Processing_Stages;", "gold_sql": "SELECT count(*) FROM claims_processing_stages", "source_tables": ["claims_processing_stages"]}
{"sample_id": 1526, "db_id": "insurance_and_eClaims", "question": "Find the number of distinct stages in claim processing.", "rationale": ["Identify the requirement: We need to find the number of distinct stages in claim processing.", "Determine the relevant table: The 'Claims_Processing_Stages' table contains the stages of claim processing.", "Use the COUNT function to count distinct values: We will use COUNT(DISTINCT Claim_Stage_ID) to get the number of unique stages.", "Construct the SQL query: The final SQL query will select the count of distinct Claim_Stage_ID from the Claims_Processing_Stages table."], "pred_sql": "SELECT COUNT(DISTINCT Claim_Stage_ID) AS Distinct_Stages FROM Claims_Processing_Stages;", "gold_sql": "SELECT count(*) FROM claims_processing_stages", "source_tables": ["claims_processing_stages"]}
{"sample_id": 1527, "db_id": "insurance_and_eClaims", "question": "What is the name of the claim processing stage that most of the claims are on?", "rationale": ["Identify the relevant tables: Claims_Processing and Claims_Processing_Stages are needed to get the claim processing stages and their counts.", "Join the Claims_Processing table with Claims_Processing_Stages on Claim_Stage_ID to get the names of the stages along with the claims.", "Group the results by Claim_Status_Name to count how many claims are in each processing stage.", "Order the results by the count of claims in descending order to find the stage with the most claims.", "Limit the results to 1 to get only the top stage with the highest count."], "pred_sql": "SELECT cps.Claim_Status_Name, COUNT(*) as Claim_Count\nFROM Claims_Processing cp\nJOIN Claims_Processing_Stages cps ON cp.Claim_Stage_ID = cps.Claim_Stage_ID\nGROUP BY cps.Claim_Status_Name\nORDER BY Claim_Count DESC\nLIMIT 1;", "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"]}
{"sample_id": 1528, "db_id": "insurance_and_eClaims", "question": "Which claim processing stage has the most claims? Show the claim status name.", "rationale": ["Identify the relevant tables: Claims_Processing and Claims_Processing_Stages are needed to get the claim processing stages and their associated claims.", "Join the Claims_Processing table with the Claims_Processing_Stages table on Claim_Stage_ID to get the claim status names along with the claims.", "Use COUNT() to count the number of claims for each claim processing stage.", "Group the results by Claim_Status_Name to aggregate the counts for each stage.", "Order the results in descending order based on the count of claims to find the stage with the most claims.", "Limit the results to 1 to get only the stage with the highest count."], "pred_sql": "SELECT cps.Claim_Status_Name, COUNT(cp.Claim_ID) AS Claim_Count\nFROM Claims_Processing cp\nJOIN Claims_Processing_Stages cps ON cp.Claim_Stage_ID = cps.Claim_Stage_ID\nGROUP BY cps.Claim_Status_Name\nORDER BY Claim_Count DESC\nLIMIT 1;", "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"]}
{"sample_id": 1529, "db_id": "insurance_and_eClaims", "question": "Find the names of customers whose name contains \"Diana\".", "rationale": ["Identify the table that contains customer information, which is the 'Customers' table.", "Determine the relevant column that contains the names of the customers, which is 'Customer_Details'.", "Formulate a SQL query to select 'Customer_Details' from the 'Customers' table.", "Use the WHERE clause to filter results where 'Customer_Details' contains the substring 'Diana', using the LIKE operator with wildcards."], "pred_sql": "SELECT Customer_Details FROM Customers WHERE Customer_Details LIKE '%Diana%';", "gold_sql": "SELECT customer_details FROM customers WHERE customer_details LIKE '%Diana%'", "source_tables": ["customers"]}
{"sample_id": 1530, "db_id": "insurance_and_eClaims", "question": "Which customers have the substring \"Diana\" in their names? Return the customer details.", "rationale": ["Identify the table that contains customer information, which is the 'Customers' table.", "Determine the column that contains the names of the customers, which is 'Customer_Details'.", "Use the SQL 'SELECT' statement to specify that we want to retrieve 'Customer_Details'.", "Apply a 'WHERE' clause to filter the results to only those customers whose 'Customer_Details' contain the substring 'Diana'.", "Use the 'LIKE' operator with wildcards '%' to match any characters before and after 'Diana'."], "pred_sql": "SELECT Customer_Details FROM Customers WHERE Customer_Details LIKE '%Diana%';", "gold_sql": "SELECT customer_details FROM customers WHERE customer_details LIKE '%Diana%'", "source_tables": ["customers"]}
{"sample_id": 1531, "db_id": "insurance_and_eClaims", "question": "Find the names of the customers who have an deputy policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Select the Customer_Details from the Customers table.", "Filter the results to include only those policies with a Policy_Type_Code of 'deputy'.", "Use DISTINCT to ensure that each customer's name appears only once in the results."], "pred_sql": "SELECT DISTINCT Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Policy_Type_Code = 'deputy';", "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy'", "source_tables": ["policies", "customers"]}
{"sample_id": 1532, "db_id": "insurance_and_eClaims", "question": "Which customers have an insurance policy with the type code \"Deputy\"? Give me the customer details.", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Select the required fields: We need Customer_Details from the Customers table.", "Filter the results based on the condition: We want policies with Policy_Type_Code 'Deputy'.", "Construct the SQL query using JOIN to combine the tables and apply the WHERE clause for filtering."], "pred_sql": "SELECT Customers.Customer_Details FROM Customers JOIN Policies ON Customers.Customer_ID = Policies.Customer_ID WHERE Policies.Policy_Type_Code = 'Deputy';", "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy'", "source_tables": ["policies", "customers"]}
{"sample_id": 1533, "db_id": "insurance_and_eClaims", "question": "Find the names of customers who either have an deputy policy or uniformed policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between Customers and Policies using the Customer_ID.", "Select the Customer_Details from the Customers table.", "Filter the results to include only those policies that are either 'deputy' or 'uniformed' by using the Policy_Type_Code column."], "pred_sql": "SELECT DISTINCT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nWHERE p.Policy_Type_Code IN ('deputy', 'uniformed');", "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy' OR t1.policy_type_code  =  'Uniform'", "source_tables": ["policies", "customers"]}
{"sample_id": 1534, "db_id": "insurance_and_eClaims", "question": "Which customers have an insurance policy with the type code \"Deputy\" or \"Uniform\"? Return the customer details.", "rationale": ["Identify the tables involved: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Select the required fields: We need Customer_Details from the Customers table.", "Filter the results based on the Policy_Type_Code: We want policies with type codes 'Deputy' or 'Uniform'.", "Construct the SQL query using JOIN to combine the tables and apply the filter condition."], "pred_sql": "SELECT Customers.Customer_Details FROM Customers JOIN Policies ON Customers.Customer_ID = Policies.Customer_ID WHERE Policies.Policy_Type_Code IN ('Deputy', 'Uniform');", "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy' OR t1.policy_type_code  =  'Uniform'", "source_tables": ["policies", "customers"]}
{"sample_id": 1535, "db_id": "insurance_and_eClaims", "question": "Find the names of all the customers and staff members.", "rationale": ["Identify the tables needed: Customers and Staff.", "Determine the columns to select: Customer_Details from Customers and Staff_Details from Staff.", "Use a SELECT statement to retrieve the desired columns.", "Since we want to list all customers and staff members, we can use a cross join (implicit join) between Customers and Staff to get all combinations of customers and staff."], "pred_sql": "SELECT Customers.Customer_Details AS Customer_Name, Staff.Staff_Details AS Staff_Name FROM Customers, Staff;", "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"]}
{"sample_id": 1536, "db_id": "insurance_and_eClaims", "question": "What are the names of the customers and staff members?", "rationale": ["Identify the tables needed: Customers and Staff.", "Determine the columns to select: Customer_Details from Customers and Staff_Details from Staff.", "Use a SELECT statement to retrieve the desired columns.", "Since we want names from both tables, we can use a cross join (implicit join) to combine them, resulting in all combinations of customers and staff."], "pred_sql": "SELECT Customers.Customer_Details AS Customer_Name, Staff.Staff_Details AS Staff_Name FROM Customers, Staff;", "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"]}
{"sample_id": 1537, "db_id": "insurance_and_eClaims", "question": "Find the number of records of each policy type and its type code.", "rationale": ["Identify the table that contains the relevant data: The 'Policies' table contains the 'Policy_Type_Code' and is where we can count the number of records.", "We need to count the number of records for each policy type, which can be done using the COUNT() function in SQL.", "To group the results by policy type, we will use the GROUP BY clause on 'Policy_Type_Code'.", "The final SQL query will select the 'Policy_Type_Code' and the count of records for each type, formatted as 'Number_of_Records'."], "pred_sql": "SELECT Policy_Type_Code, COUNT(*) AS Number_of_Records FROM Policies GROUP BY Policy_Type_Code;", "gold_sql": "SELECT policy_type_code ,  count(*) FROM policies GROUP BY policy_type_code", "source_tables": ["policies"]}
{"sample_id": 1538, "db_id": "insurance_and_eClaims", "question": "For each policy type, return its type code and its count in the record.", "rationale": ["Identify the relevant table: The query requires information about policy types, which are stored in the Policies table.", "Select the necessary columns: We need the Policy_Type_Code and a count of how many records exist for each type, so we will select Policy_Type_Code and use COUNT(*) to get the number of records.", "Group the results: To get the count for each policy type, we need to group the results by Policy_Type_Code using GROUP BY.", "Construct the SQL query: Combine the selected columns, the count function, and the grouping into a complete SQL query."], "pred_sql": "SELECT Policy_Type_Code, COUNT(*) AS Policy_Count FROM Policies GROUP BY Policy_Type_Code;", "gold_sql": "SELECT policy_type_code ,  count(*) FROM policies GROUP BY policy_type_code", "source_tables": ["policies"]}
{"sample_id": 1539, "db_id": "insurance_and_eClaims", "question": "Find the name of the customer that has been involved in the most policies.", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find the customer details, so we will select from the Customers table.", "To find out how many policies each customer has, we will join the Policies table on the Customer_ID.", "We will group the results by Customer_ID to count the number of policies for each customer.", "We will order the results by the count of policies in descending order to get the customer with the most policies at the top.", "Finally, we will limit the results to 1 to get only the top customer."], "pred_sql": "SELECT Customers.Customer_Details\nFROM Customers\nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID\nGROUP BY Customers.Customer_ID\nORDER BY COUNT(Policies.Policy_ID) DESC\nLIMIT 1;", "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t2.customer_details ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies", "customers"]}
{"sample_id": 1540, "db_id": "insurance_and_eClaims", "question": "Which customer have the most policies? Give me the customer details.", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find the customer with the most policies, so we will join the Customers table with the Policies table on the Customer_ID.", "We will group the results by Customer_ID to count the number of policies each customer has.", "To find the customer with the most policies, we will order the results by the count of policies in descending order.", "Finally, we will limit the results to 1 to get only the customer with the most policies."], "pred_sql": "SELECT Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nGROUP BY Customers.Customer_ID \nORDER BY COUNT(Policies.Policy_ID) DESC \nLIMIT 1;", "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t2.customer_details ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies", "customers"]}
{"sample_id": 1541, "db_id": "insurance_and_eClaims", "question": "What is the description of the claim status \"Open\"?", "rationale": ["Identify the table that contains claim status descriptions, which is 'Claims_Processing_Stages'.", "Determine the relevant column that holds the description of the claim status, which is 'Claim_Status_Description'.", "Identify the condition needed to filter the results, which is the claim status name being 'Open'.", "Construct the SQL query to select the 'Claim_Status_Description' from 'Claims_Processing_Stages' where 'Claim_Status_Name' equals 'Open'."], "pred_sql": "SELECT Claim_Status_Description FROM Claims_Processing_Stages WHERE Claim_Status_Name = 'Open';", "gold_sql": "SELECT claim_status_description FROM claims_processing_stages WHERE claim_status_name  =  'Open'", "source_tables": ["claims_processing_stages"]}
{"sample_id": 1542, "db_id": "insurance_and_eClaims", "question": "Find the description of the claim status \"Open\".", "rationale": ["Identify the table that contains claim status descriptions, which is 'Claims_Processing_Stages'.", "Determine the relevant column that holds the description of the claim status, which is 'Claim_Status_Description'.", "Identify the condition needed to filter the results, which is the claim status name being 'Open'.", "Construct the SQL query to select the 'Claim_Status_Description' from 'Claims_Processing_Stages' where 'Claim_Status_Name' equals 'Open'."], "pred_sql": "SELECT Claim_Status_Description FROM Claims_Processing_Stages WHERE Claim_Status_Name = 'Open';", "gold_sql": "SELECT claim_status_description FROM claims_processing_stages WHERE claim_status_name  =  'Open'", "source_tables": ["claims_processing_stages"]}
{"sample_id": 1543, "db_id": "insurance_and_eClaims", "question": "How many distinct claim outcome codes are there?", "rationale": ["Identify the table that contains the claim outcome codes, which is the Claims_Processing table.", "To find the number of distinct claim outcome codes, we need to use the COUNT function along with DISTINCT.", "The SQL query will select the count of distinct values from the Claim_Outcome_Code column in the Claims_Processing table."], "pred_sql": "SELECT COUNT(DISTINCT Claim_Outcome_Code) AS Distinct_Claim_Outcome_Codes FROM Claims_Processing;", "gold_sql": "SELECT count(DISTINCT claim_outcome_code) FROM claims_processing", "source_tables": ["claims_processing"]}
{"sample_id": 1544, "db_id": "insurance_and_eClaims", "question": "Count the number of distinct claim outcome codes.", "rationale": ["Identify the requirement to count distinct values, specifically the claim outcome codes.", "Determine the relevant table that contains the claim outcome codes, which is the Claims_Processing table.", "Construct the SQL query using the COUNT function along with DISTINCT to ensure unique values are counted.", "Select the Claim_Outcome_Code from the Claims_Processing table and alias the count result for clarity."], "pred_sql": "SELECT COUNT(DISTINCT Claim_Outcome_Code) AS Distinct_Claim_Outcome_Count FROM Claims_Processing;", "gold_sql": "SELECT count(DISTINCT claim_outcome_code) FROM claims_processing", "source_tables": ["claims_processing"]}
{"sample_id": 1545, "db_id": "insurance_and_eClaims", "question": "Which customer is associated with the latest policy?", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between Customers and Policies using the Customer_ID.", "We need to find the latest policy, which can be determined by the maximum Start_Date in the Policies table.", "Use a subquery to find the maximum Start_Date from the Policies table.", "Join the Customers table with the Policies table on Customer_ID to get the associated customer details for the latest policy."], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Start_Date = (SELECT MAX(Start_Date) FROM Policies);", "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"]}
{"sample_id": 1546, "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: Customers and Policies, since we need customer information and policy start dates.", "We need to join the Customers table with the Policies table on the Customer_ID to link customers with their policies.", "We want to find the most recent policy, so we will order the results by the Start_Date in descending order.", "To get only the most recent policy, we will limit the results to 1."], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details, Policies.Start_Date \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nORDER BY Policies.Start_Date DESC \nLIMIT 1;", "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"]}
{"sample_id": 1547, "db_id": "customers_and_invoices", "question": "Show the number of accounts.", "rationale": ["Identify the table that contains account information, which is the 'Accounts' table.", "To find the number of accounts, we need to use the COUNT() function, which counts the number of rows in a table.", "The SQL query will select the count of all records from the 'Accounts' table and label it as 'number_of_accounts'."], "pred_sql": "SELECT COUNT(*) AS number_of_accounts FROM Accounts;", "gold_sql": "SELECT count(*) FROM Accounts", "source_tables": ["accounts"]}
{"sample_id": 1548, "db_id": "customers_and_invoices", "question": "How many accounts are there?", "rationale": ["Identify the table that contains account information, which is the 'Accounts' table.", "To find out how many accounts there are, we need to count the number of entries in the 'Accounts' table.", "Use the COUNT() function to count all rows in the 'Accounts' table.", "Select the count with an alias 'total_accounts' for clarity."], "pred_sql": "SELECT COUNT(*) AS total_accounts FROM Accounts;", "gold_sql": "SELECT count(*) FROM Accounts", "source_tables": ["accounts"]}
{"sample_id": 1549, "db_id": "customers_and_invoices", "question": "How many customers have opened an account?", "rationale": ["Identify the relevant table: Accounts, as it contains information about customer accounts.", "Use the COUNT() function to count the number of entries in the Accounts table, which corresponds to the number of customers who have opened an account."], "pred_sql": "SELECT COUNT(*) AS number_of_customers FROM Accounts;", "gold_sql": "SELECT count(DISTINCT customer_id) FROM Accounts", "source_tables": ["accounts"]}
{"sample_id": 1550, "db_id": "customers_and_invoices", "question": "Count the number of customers who have an account.", "rationale": ["Identify the tables involved: Customers and Accounts.", "Determine the relationship: Customers have accounts in the Accounts table, linked by customer_id.", "Use a JOIN to combine Customers and Accounts based on customer_id.", "Count the distinct customer_id from the Customers table to avoid duplicates, as a customer can have multiple accounts."], "pred_sql": "SELECT COUNT(DISTINCT Customers.customer_id) AS customer_count FROM Customers JOIN Accounts ON Customers.customer_id = Accounts.customer_id;", "gold_sql": "SELECT count(DISTINCT customer_id) FROM Accounts", "source_tables": ["accounts"]}
{"sample_id": 1551, "db_id": "customers_and_invoices", "question": "Show the id, the date of account opened, the account name, and other account detail for all accounts.", "rationale": ["Identify the table that contains the required information: Accounts.", "Determine the specific columns needed: account_id, date_account_opened, account_name, and other_account_details.", "Construct the SQL SELECT statement to retrieve these columns from the Accounts table."], "pred_sql": "SELECT account_id, date_account_opened, account_name, other_account_details FROM Accounts;", "gold_sql": "SELECT account_id ,  date_account_opened ,  account_name ,  other_account_details FROM Accounts", "source_tables": ["accounts"]}
{"sample_id": 1552, "db_id": "customers_and_invoices", "question": "What are the ids, date opened, name, and other details for all accounts?", "rationale": ["Identify the table that contains account information, which is the Accounts table.", "Determine the specific columns needed: account_id, date_account_opened, account_name, and other_account_details.", "Construct the SQL SELECT statement to retrieve these columns from the Accounts table."], "pred_sql": "SELECT account_id, date_account_opened, account_name, other_account_details FROM Accounts;", "gold_sql": "SELECT account_id ,  date_account_opened ,  account_name ,  other_account_details FROM Accounts", "source_tables": ["accounts"]}
{"sample_id": 1553, "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "Determine the columns needed: account_id, account_name, and other_account_details from Accounts.", "Establish the relationship between Accounts and Customers using the customer_id foreign key.", "Filter the results to include only those accounts associated with the customer whose first name is 'Meaghan'.", "Construct the SQL SELECT statement to retrieve the specified columns from the joined tables."], "pred_sql": "SELECT Accounts.account_id, Accounts.account_name, Accounts.other_account_details \nFROM Accounts \nJOIN Customers ON Accounts.customer_id = Customers.customer_id \nWHERE Customers.customer_first_name = 'Meaghan';", "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"]}
{"sample_id": 1554, "db_id": "customers_and_invoices", "question": "What are the ids, names, dates of opening, and other details for accounts corresponding to the customer with the first name \"Meaghan\"?", "rationale": ["Identify the relevant tables: Accounts and Customers are needed to get account details and customer information.", "Determine the columns to select: We need account_id, account_name, date_account_opened, and other_account_details from the Accounts table.", "Establish the relationship between tables: Use a JOIN to connect Accounts and Customers on customer_id.", "Filter the results: Use a WHERE clause to specify that we only want accounts for the customer with the first name 'Meaghan'."], "pred_sql": "SELECT Accounts.account_id, Accounts.account_name, Accounts.date_account_opened, Accounts.other_account_details \nFROM Accounts \nJOIN Customers ON Accounts.customer_id = Customers.customer_id \nWHERE Customers.customer_first_name = 'Meaghan';", "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"]}
{"sample_id": 1555, "db_id": "customers_and_invoices", "question": "Show the account name and other account detail for all accounts by the customer with first name Meaghan and last name Keeling.", "rationale": ["Identify the relevant table: Accounts, which contains account_name and other_account_details.", "Determine the condition: We need to filter accounts by a specific customer, identified by their first name (Meaghan) and last name (Keeling).", "To find the customer_id for the specified customer, we will use a subquery on the Customers table, filtering by customer_first_name and customer_last_name.", "The main query will select account_name and other_account_details from the Accounts table where the customer_id matches the result of the subquery."], "pred_sql": "SELECT account_name, other_account_details FROM Accounts WHERE customer_id IN (SELECT customer_id FROM Customers WHERE customer_first_name = 'Meaghan' AND customer_last_name = 'Keeling');", "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"]}
{"sample_id": 1556, "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Accounts and Customers are needed to get account details for a specific customer.", "Determine the columns to select: We need account details such as account_id, date_account_opened, account_name, and other_account_details from the Accounts table.", "Establish the relationship between tables: Use a JOIN to connect Accounts and Customers on customer_id.", "Filter the results: Use a WHERE clause to specify the customer's first and last name as 'Meaghan' and 'Keeling' respectively."], "pred_sql": "SELECT a.account_id, a.date_account_opened, a.account_name, a.other_account_details \nFROM Accounts a \nJOIN Customers c ON a.customer_id = c.customer_id \nWHERE c.customer_first_name = 'Meaghan' AND c.customer_last_name = 'Keeling';", "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"]}
{"sample_id": 1557, "db_id": "customers_and_invoices", "question": "Show the first name and last name for the customer with account name 900.", "rationale": ["Identify the relevant tables: Customers and Accounts.", "Determine the columns needed: customer_first_name and customer_last_name from Customers.", "Establish the relationship between the tables using the foreign key: Accounts.customer_id = Customers.customer_id.", "Add a condition to filter the results based on the account name: WHERE Accounts.account_name = '900'.", "Construct the SQL query using SELECT to retrieve the specified columns, INNER JOIN to combine the tables, and the WHERE clause for filtering."], "pred_sql": "SELECT customer_first_name, customer_last_name FROM Customers INNER JOIN Accounts ON Customers.customer_id = Accounts.customer_id WHERE Accounts.account_name = '900';", "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"]}
{"sample_id": 1558, "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "Determine the columns needed: customer_first_name and customer_last_name from Customers, and account_name from Accounts.", "Join the Customers table with the Accounts table on the customer_id column to link customers with their accounts.", "Filter the results to include only those accounts where the account_name is '900'.", "Select the full names of the customers by concatenating customer_first_name and customer_last_name."], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name FROM Customers INNER JOIN Accounts ON Customers.customer_id = Accounts.customer_id WHERE Accounts.account_name = '900';", "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"]}
{"sample_id": 1559, "db_id": "customers_and_invoices", "question": "How many customers don't have an account?", "rationale": ["Identify the Customers table as it contains customer information.", "Determine that we need to count customers who do not have an account.", "Use a subquery to find all customer_ids from the Accounts table.", "Use the NOT IN clause to filter out customers who have an account from the total customer list.", "Count the remaining customers who do not have an account."], "pred_sql": "SELECT COUNT(*) AS customer_count FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts);", "gold_sql": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)", "source_tables": ["accounts", "customers"]}
{"sample_id": 1560, "db_id": "customers_and_invoices", "question": "Count the number of customers who do not have an account.", "rationale": ["Identify the main goal: Count the number of customers without an account.", "To find customers without an account, we need to compare the 'Customers' table with the 'Accounts' table.", "We can use a subquery to select all customer_ids from the 'Accounts' table.", "Then, we can use the NOT IN clause to filter out those customer_ids from the 'Customers' table.", "Finally, we use COUNT(*) to count the remaining customers who do not have an account."], "pred_sql": "SELECT COUNT(*) AS customer_count FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts);", "gold_sql": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)", "source_tables": ["accounts", "customers"]}
{"sample_id": 1561, "db_id": "customers_and_invoices", "question": "Show the unique first names, last names, and phone numbers for all customers with any account.", "rationale": ["Identify the columns needed: customer_first_name, customer_last_name, and phone_number from the Customers table.", "We need to filter customers who have any account, which means we need to check the Accounts table for existing customer_ids.", "Use a subquery to select customer_ids from the Accounts table.", "Use the DISTINCT keyword to ensure that we only get unique combinations of first names, last names, and phone numbers."], "pred_sql": "SELECT DISTINCT customer_first_name, customer_last_name, phone_number FROM Customers WHERE customer_id IN (SELECT customer_id FROM Accounts)", "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name ,  T1.phone_number FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"]}
{"sample_id": 1562, "db_id": "customers_and_invoices", "question": "What are the distinct first names, last names, and phone numbers for customers with accounts?", "rationale": ["Identify the required fields: first names, last names, and phone numbers of customers.", "Determine the relevant tables: Customers and Accounts.", "Establish the relationship between the tables: Customers are linked to Accounts via customer_id.", "Use a JOIN operation to combine data from Customers and Accounts based on the customer_id.", "Select distinct values to avoid duplicates in the result set."], "pred_sql": "SELECT DISTINCT c.customer_first_name, c.customer_last_name, c.phone_number \nFROM Customers c \nJOIN Accounts a ON c.customer_id = a.customer_id;", "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name ,  T1.phone_number FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"]}
{"sample_id": 1563, "db_id": "customers_and_invoices", "question": "Show customer ids who don't have an account.", "rationale": ["Identify the main table to query from, which is 'Customers' since we want customer ids.", "We need to find customers who do not have an account, so we will use a subquery to get all customer_ids from the 'Accounts' table.", "The subquery will select all customer_ids from the 'Accounts' table.", "The main query will select customer_ids from the 'Customers' table where the customer_id is not in the list of customer_ids returned by the subquery."], "pred_sql": "SELECT customer_id FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts);", "gold_sql": "SELECT customer_id FROM Customers EXCEPT SELECT customer_id FROM Accounts", "source_tables": ["accounts", "customers"]}
{"sample_id": 1564, "db_id": "customers_and_invoices", "question": "What are the customer ids for customers who do not have an account?", "rationale": ["Identify the Customers table which contains customer_id.", "Identify the Accounts table which contains customer_id for customers who have accounts.", "Use a subquery to select customer_ids from the Accounts table.", "Use the NOT IN clause to filter out customer_ids that are present in the Accounts table from the Customers table."], "pred_sql": "SELECT customer_id FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts);", "gold_sql": "SELECT customer_id FROM Customers EXCEPT SELECT customer_id FROM Accounts", "source_tables": ["accounts", "customers"]}
{"sample_id": 1565, "db_id": "customers_and_invoices", "question": "How many accounts does each customer have? List the number and customer id.", "rationale": ["Identify the relevant table: The Accounts table contains the customer_id and account_id, which are needed to count the number of accounts per customer.", "Use the COUNT() function to count the number of accounts for each customer.", "Group the results by customer_id to get the count of accounts for each individual customer."], "pred_sql": "SELECT customer_id, COUNT(account_id) AS account_count FROM Accounts GROUP BY customer_id;", "gold_sql": "SELECT count(*) ,  customer_id FROM Accounts GROUP BY customer_id", "source_tables": ["accounts"]}
{"sample_id": 1566, "db_id": "customers_and_invoices", "question": "Count the number of accounts corresponding to each customer id.", "rationale": ["Identify the table that contains the relevant data: The Accounts table contains customer_id and account_id.", "Determine the required output: We need to count the number of accounts for each customer_id.", "Use the COUNT() function to count the account_id for each customer_id.", "Group the results by customer_id to get the count for each customer.", "Construct the SQL query using SELECT, COUNT(), and GROUP BY clauses."], "pred_sql": "SELECT customer_id, COUNT(account_id) AS account_count FROM Accounts GROUP BY customer_id;", "gold_sql": "SELECT count(*) ,  customer_id FROM Accounts GROUP BY customer_id", "source_tables": ["accounts"]}
{"sample_id": 1567, "db_id": "customers_and_invoices", "question": "What is the customer id, first and last name with most number of accounts.", "rationale": ["Identify the relevant columns needed for the output: customer_id, customer_first_name, and customer_last_name from the Customers table.", "Determine the criteria for selecting the customer: the one with the most accounts.", "To find the customer with the most accounts, a subquery is needed that counts the number of accounts for each customer in the Accounts table.", "Group the results of the subquery by customer_id and order them by the count of accounts in descending order.", "Limit the results of the subquery to 1 to get the customer with the highest count of accounts.", "Use the result of the subquery to filter the Customers table to get the required customer details."], "pred_sql": "SELECT customer_id, customer_first_name, customer_last_name \nFROM Customers \nWHERE customer_id IN (\n    SELECT customer_id \n    FROM Accounts \n    GROUP BY customer_id \n    ORDER BY COUNT(account_id) DESC \n    LIMIT 1\n)", "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["accounts", "customers"]}
{"sample_id": 1568, "db_id": "customers_and_invoices", "question": "Return the id and full name of the customer with the most accounts.", "rationale": ["We need to find the customer with the most accounts, so we will join the Customers table with the Accounts table on the customer_id.", "We will group the results by customer_id to count the number of accounts each customer has.", "To find the customer with the most accounts, we will order the results by the count of accounts in descending order.", "Finally, we will limit the results to just one record to get the customer with the highest count of accounts.", "We will select the customer_id and concatenate the first name, middle initial, and last name to form the full name of the customer."], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_middle_initial || ' ' || c.customer_last_name AS full_name \nFROM Customers c \nJOIN Accounts a ON c.customer_id = a.customer_id \nGROUP BY c.customer_id \nORDER BY COUNT(a.account_id) DESC \nLIMIT 1;", "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["accounts", "customers"]}
{"sample_id": 1569, "db_id": "customers_and_invoices", "question": "Show id, first name and last name for all customers and the number of accounts.", "rationale": ["Identify the columns needed: customer_id, customer_first_name, customer_last_name from Customers table and the count of accounts from Accounts table.", "Use a LEFT JOIN to connect Customers with Accounts on the customer_id field to ensure all customers are included even if they have no accounts.", "Use COUNT() function to count the number of accounts for each customer.", "Group the results by customer_id, customer_first_name, and customer_last_name to get the count of accounts per customer."], "pred_sql": "SELECT Customers.customer_id, Customers.customer_first_name, Customers.customer_last_name, COUNT(Accounts.account_id) AS number_of_accounts\nFROM Customers\nLEFT JOIN Accounts ON Customers.customer_id = Accounts.customer_id\nGROUP BY Customers.customer_id, Customers.customer_first_name, Customers.customer_last_name;", "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"]}
{"sample_id": 1570, "db_id": "customers_and_invoices", "question": "What are the the full names and ids for all customers, and how many accounts does each have?", "rationale": ["Identify the required fields: customer_id, full name (first and last), and account count.", "To get the full name, concatenate customer_first_name and customer_last_name.", "Count the number of accounts for each customer, which requires joining the Customers table with the Accounts table.", "Use a LEFT JOIN to ensure all customers are included, even those without accounts.", "Group the results by customer_id and the concatenated full name to get the count of accounts per customer."], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name, COUNT(a.account_id) AS account_count\nFROM Customers c\nLEFT JOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name;", "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"]}
{"sample_id": 1571, "db_id": "customers_and_invoices", "question": "Show first name and id for all customers with at least 2 accounts.", "rationale": ["We need to select the first name and customer ID of customers.", "The relevant table for customer information is 'Customers'.", "We also need to consider the 'Accounts' table to count the number of accounts per customer.", "To find customers with at least 2 accounts, we will join the 'Customers' table with the 'Accounts' table on 'customer_id'.", "We will group the results by 'customer_id' to aggregate the accounts for each customer.", "Finally, we will use the HAVING clause to filter groups that have 2 or more accounts."], "pred_sql": "SELECT c.customer_first_name, c.customer_id \nFROM Customers c \nJOIN Accounts a ON c.customer_id = a.customer_id \nGROUP BY c.customer_id \nHAVING COUNT(a.account_id) >= 2;", "gold_sql": "SELECT T2.customer_first_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  2", "source_tables": ["accounts", "customers"]}
{"sample_id": 1572, "db_id": "customers_and_invoices", "question": "What are the first names and ids for customers who have two or more accounts?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to find customers who have two or more accounts, so we will focus on the Accounts table to count the number of accounts per customer.", "Use a subquery to group the Accounts by customer_id and count the number of accounts for each customer.", "Filter the results in the subquery to include only those customers with a count of accounts greater than or equal to 2 using HAVING clause.", "Select the customer_first_name and customer_id from the Customers table where the customer_id matches those identified in the subquery."], "pred_sql": "SELECT customer_first_name, customer_id FROM Customers WHERE customer_id IN (SELECT customer_id FROM Accounts GROUP BY customer_id HAVING COUNT(account_id) >= 2);", "gold_sql": "SELECT T2.customer_first_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  2", "source_tables": ["accounts", "customers"]}
{"sample_id": 1573, "db_id": "customers_and_invoices", "question": "Show the number of customers.", "rationale": ["Identify the goal: We need to count the number of customers in the Customers table.", "Determine the appropriate SQL function: The COUNT() function is used to count the number of rows in a table.", "Specify the table: We will be counting rows from the Customers table.", "Construct the SQL query: Use SELECT COUNT(*) to get the total number of customers and alias it as number_of_customers."], "pred_sql": "SELECT COUNT(*) AS number_of_customers FROM Customers;", "gold_sql": "SELECT count(*) FROM Customers", "source_tables": ["customers"]}
{"sample_id": 1574, "db_id": "customers_and_invoices", "question": "Count the number of customers.", "rationale": ["Identify the goal: Count the number of customers in the Customers table.", "Determine the appropriate SQL function: Use COUNT() to count the number of rows in the Customers table.", "Construct the SQL query: SELECT COUNT(*) AS customer_count FROM Customers;"], "pred_sql": "SELECT COUNT(*) AS customer_count FROM Customers;", "gold_sql": "SELECT count(*) FROM Customers", "source_tables": ["customers"]}
{"sample_id": 1575, "db_id": "customers_and_invoices", "question": "Show the number of customers for each gender.", "rationale": ["Identify the table that contains customer information, which is the 'Customers' table.", "Determine the relevant column for gender, which is 'gender'.", "To count the number of customers for each gender, use the COUNT() function on 'customer_id'.", "Group the results by the 'gender' column to get the count for each gender category."], "pred_sql": "SELECT gender, COUNT(customer_id) AS number_of_customers FROM Customers GROUP BY gender;", "gold_sql": "SELECT gender ,  count(*) FROM Customers GROUP BY gender", "source_tables": ["customers"]}
{"sample_id": 1576, "db_id": "customers_and_invoices", "question": "How many customers are there of each gender?", "rationale": ["Identify the relevant table: The 'Customers' table contains the gender information.", "Determine the required output: We need to count the number of customers for each gender.", "Use the COUNT() function to count the number of customers, grouping the results by gender.", "Construct the SQL query to select the gender and the count of customers, grouping by gender."], "pred_sql": "SELECT gender, COUNT(*) AS customer_count FROM Customers GROUP BY gender;", "gold_sql": "SELECT gender ,  count(*) FROM Customers GROUP BY gender", "source_tables": ["customers"]}
{"sample_id": 1577, "db_id": "customers_and_invoices", "question": "How many transactions do we have?", "rationale": ["Identify the table that contains transaction data, which is 'Financial_Transactions'.", "To find out how many transactions there are, we need to count the number of records in this table.", "Use the COUNT() function to count all entries in the 'Financial_Transactions' table.", "Select the count with an alias 'transaction_count' for clarity."], "pred_sql": "SELECT COUNT(*) AS transaction_count FROM Financial_Transactions;", "gold_sql": "SELECT count(*) FROM Financial_transactions", "source_tables": ["financial_transactions"]}
{"sample_id": 1578, "db_id": "customers_and_invoices", "question": "Count the number of transactions.", "rationale": ["Identify the table that contains transaction data, which is 'Financial_Transactions'.", "To count the number of transactions, use the COUNT() function in SQL.", "Select the total count of records from the 'Financial_Transactions' table by using 'SELECT COUNT(*)'.", "Alias the count result as 'transaction_count' for clarity."], "pred_sql": "SELECT COUNT(*) AS transaction_count FROM Financial_Transactions;", "gold_sql": "SELECT count(*) FROM Financial_transactions", "source_tables": ["financial_transactions"]}
{"sample_id": 1579, "db_id": "customers_and_invoices", "question": "How many transaction does each account have? Show the number and account id.", "rationale": ["Identify the relevant table: Financial_Transactions contains the transaction data.", "We need to count the number of transactions for each account, so we will use the COUNT() function.", "We need to group the results by account_id to get the count for each account, which requires the GROUP BY clause.", "Select the account_id and the count of transactions, giving the count an alias for clarity."], "pred_sql": "SELECT account_id, COUNT(transaction_id) AS transaction_count FROM Financial_Transactions GROUP BY account_id;", "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"]}
{"sample_id": 1580, "db_id": "customers_and_invoices", "question": "Count the number of financial transactions that correspond to each account id.", "rationale": ["Identify the relevant table: Financial_Transactions contains the transaction data.", "Determine the columns needed: We need account_id to group the transactions and transaction_id to count them.", "Use the COUNT() function to count the number of transactions for each account_id.", "Group the results by account_id to get the count for each account."], "pred_sql": "SELECT account_id, COUNT(transaction_id) AS transaction_count FROM Financial_Transactions GROUP BY account_id;", "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"]}
{"sample_id": 1581, "db_id": "customers_and_invoices", "question": "How many transaction does account with name 337 have?", "rationale": ["Identify the table that contains the relevant information about transactions, which is the Financial_Transactions table.", "Determine that we need to count the number of transactions, so we will use the COUNT() function.", "To find transactions related to a specific account, we need to filter the Financial_Transactions table by account_id.", "The account_id can be found in the Accounts table, so we will create a subquery to select the account_id for the account with the name '337'.", "Combine the COUNT() function with a WHERE clause that uses the subquery to filter transactions for the specified account."], "pred_sql": "SELECT COUNT(*) AS transaction_count FROM Financial_Transactions WHERE account_id IN (SELECT account_id FROM Accounts WHERE account_name = '337');", "gold_sql": "SELECT count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id WHERE T2.account_name  =  '337'", "source_tables": ["accounts", "financial_transactions"]}
{"sample_id": 1582, "db_id": "customers_and_invoices", "question": "Count the number of financial transactions that the account with the name 337 has.", "rationale": ["Identify the relevant tables: Financial_Transactions and Accounts.", "Determine the relationship between the tables: Financial_Transactions is linked to Accounts via account_id.", "We need to count the number of transactions, so we will use the COUNT() function.", "Filter the results to only include transactions for the account with the name '337'.", "Construct the SQL query using a JOIN to connect Financial_Transactions and Accounts, and apply the COUNT() function with the appropriate WHERE clause."], "pred_sql": "SELECT COUNT(*) AS transaction_count FROM Financial_Transactions ft JOIN Accounts a ON ft.account_id = a.account_id WHERE a.account_name = '337';", "gold_sql": "SELECT count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id WHERE T2.account_name  =  '337'", "source_tables": ["accounts", "financial_transactions"]}
{"sample_id": 1583, "db_id": "customers_and_invoices", "question": "What is the average, minimum, maximum, and total transaction amount?", "rationale": ["Identify the table that contains the transaction amounts, which is the Financial_Transactions table.", "Determine the required calculations: average, minimum, maximum, and total of the transaction amounts.", "Use the SQL aggregate functions AVG(), MIN(), MAX(), and SUM() to perform these calculations on the transaction_amount column.", "Construct the SQL SELECT statement to retrieve these calculated values from the Financial_Transactions table."], "pred_sql": "SELECT AVG(transaction_amount) AS average_transaction_amount, MIN(transaction_amount) AS minimum_transaction_amount, MAX(transaction_amount) AS maximum_transaction_amount, SUM(transaction_amount) AS total_transaction_amount FROM Financial_Transactions;", "gold_sql": "SELECT avg(transaction_amount) ,  min(transaction_amount) ,  max(transaction_amount) ,   sum(transaction_amount) FROM Financial_transactions", "source_tables": ["financial_transactions"]}
{"sample_id": 1584, "db_id": "customers_and_invoices", "question": "Return the average, minimum, maximum, and total transaction amounts.", "rationale": ["Identify the table that contains the transaction amounts, which is the Financial_Transactions table.", "Determine the required calculations: average, minimum, maximum, and total of the transaction amounts.", "Use the SQL aggregate functions AVG(), MIN(), MAX(), and SUM() to perform these calculations on the transaction_amount column.", "Construct the SQL SELECT statement to retrieve these calculated values from the Financial_Transactions table."], "pred_sql": "SELECT AVG(transaction_amount) AS average_amount, MIN(transaction_amount) AS minimum_amount, MAX(transaction_amount) AS maximum_amount, SUM(transaction_amount) AS total_amount FROM Financial_Transactions;", "gold_sql": "SELECT avg(transaction_amount) ,  min(transaction_amount) ,  max(transaction_amount) ,   sum(transaction_amount) FROM Financial_transactions", "source_tables": ["financial_transactions"]}
{"sample_id": 1585, "db_id": "customers_and_invoices", "question": "Show ids for all transactions whose amounts are greater than the average.", "rationale": ["Identify the table that contains the transaction data, which is the Financial_Transactions table.", "Determine the relevant column for the transaction amount, which is 'transaction_amount'.", "To find transactions with amounts greater than the average, we need to calculate the average transaction amount using the AVG() function.", "Construct a subquery to calculate the average transaction amount: (SELECT AVG(transaction_amount) FROM Financial_Transactions).", "Use this subquery in the WHERE clause to filter transactions where 'transaction_amount' is greater than the average.", "Select the 'transaction_id' from the Financial_Transactions table where the condition is met."], "pred_sql": "SELECT transaction_id FROM Financial_Transactions WHERE transaction_amount > (SELECT AVG(transaction_amount) FROM Financial_Transactions);", "gold_sql": "SELECT transaction_id FROM Financial_transactions WHERE transaction_amount  >  (SELECT avg(transaction_amount) FROM Financial_transactions)", "source_tables": ["financial_transactions"]}
{"sample_id": 1586, "db_id": "customers_and_invoices", "question": "What are the ids for transactions that have an amount greater than the average amount of a transaction?", "rationale": ["Identify the table that contains transaction information, which is the Financial_Transactions table.", "Determine the relevant column for the transaction amount, which is transaction_amount.", "To find transactions with an amount greater than the average, we need to calculate the average transaction amount using the AVG() function.", "Construct a subquery to calculate the average transaction amount: (SELECT AVG(transaction_amount) FROM Financial_Transactions).", "Use this subquery in the WHERE clause to filter transactions that have an amount greater than this average.", "Select the transaction_id from the Financial_Transactions table where the condition is met."], "pred_sql": "SELECT transaction_id FROM Financial_Transactions WHERE transaction_amount > (SELECT AVG(transaction_amount) FROM Financial_Transactions)", "gold_sql": "SELECT transaction_id FROM Financial_transactions WHERE transaction_amount  >  (SELECT avg(transaction_amount) FROM Financial_transactions)", "source_tables": ["financial_transactions"]}
{"sample_id": 1587, "db_id": "customers_and_invoices", "question": "Show the transaction types and the total amount of transactions.", "rationale": ["Identify the relevant table: The 'Financial_Transactions' table contains the transaction types and amounts.", "Select the columns needed: We need 'transaction_type' and the sum of 'transaction_amount'.", "Use the SUM() function to calculate the total amount for each transaction type.", "Group the results by 'transaction_type' to get the total amount for each type."], "pred_sql": "SELECT transaction_type, SUM(transaction_amount) AS total_amount FROM Financial_Transactions GROUP BY transaction_type;", "gold_sql": "SELECT transaction_type ,  sum(transaction_amount) FROM Financial_transactions GROUP BY transaction_type", "source_tables": ["financial_transactions"]}
{"sample_id": 1588, "db_id": "customers_and_invoices", "question": "What are total transaction amounts for each transaction type?", "rationale": ["Identify the table that contains transaction amounts, which is the Financial_Transactions table.", "Determine the relevant columns: transaction_type for grouping and transaction_amount for summing.", "Use the SUM() function to calculate the total amounts for each transaction type.", "Group the results by transaction_type to get the total for each type."], "pred_sql": "SELECT transaction_type, SUM(transaction_amount) AS total_amount FROM Financial_Transactions GROUP BY transaction_type;", "gold_sql": "SELECT transaction_type ,  sum(transaction_amount) FROM Financial_transactions GROUP BY transaction_type", "source_tables": ["financial_transactions"]}
{"sample_id": 1589, "db_id": "customers_and_invoices", "question": "Show the account name, id and the number of transactions for each account.", "rationale": ["We need to select the account name and account id from the Accounts table.", "We also need to count the number of transactions for each account, which is stored in the Financial_Transactions table.", "To get the number of transactions per account, we will perform a LEFT JOIN between the Accounts table and the Financial_Transactions table on the account_id.", "We will use COUNT() to count the transaction_id from the Financial_Transactions table, which gives us the number of transactions for each account.", "Finally, we will group the results by account_id and account_name to ensure we get the count for each unique account."], "pred_sql": "SELECT a.account_name, a.account_id, COUNT(ft.transaction_id) AS number_of_transactions\nFROM Accounts a\nLEFT JOIN Financial_Transactions ft ON a.account_id = ft.account_id\nGROUP BY a.account_id, a.account_name;", "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"]}
{"sample_id": 1590, "db_id": "customers_and_invoices", "question": "Return the names and ids of each account, as well as the number of transactions.", "rationale": ["We need to retrieve account names and IDs from the Accounts table.", "We also need to count the number of transactions associated with each account from the Financial_Transactions table.", "To achieve this, we will perform a LEFT JOIN between the Accounts table and the Financial_Transactions table on the account_id field.", "We will use the COUNT function to count the number of transactions for each account.", "Finally, we will group the results by account_id and account_name to get the count for each account."], "pred_sql": "SELECT Accounts.account_id, Accounts.account_name, COUNT(Financial_Transactions.transaction_id) AS transaction_count\nFROM Accounts\nLEFT JOIN Financial_Transactions ON Accounts.account_id = Financial_Transactions.account_id\nGROUP BY Accounts.account_id, Accounts.account_name;", "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"]}
{"sample_id": 1591, "db_id": "customers_and_invoices", "question": "Show the account id with most number of transactions.", "rationale": ["Identify the table that contains the account information related to transactions, which is the Financial_Transactions table.", "We need to count the number of transactions for each account, so we will use the COUNT() function on the transaction_id column.", "To group the results by account, we will use the GROUP BY clause on the account_id column.", "To find the account with the most transactions, we will order the results in descending order using ORDER BY COUNT(transaction_id) DESC.", "Finally, we will limit the results to only one account using LIMIT 1."], "pred_sql": "SELECT account_id FROM Financial_Transactions GROUP BY account_id ORDER BY COUNT(transaction_id) DESC LIMIT 1;", "gold_sql": "SELECT account_id FROM Financial_transactions GROUP BY account_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["financial_transactions"]}
{"sample_id": 1592, "db_id": "customers_and_invoices", "question": "What is the id of the account with the most transactions?", "rationale": ["Identify the table that contains account information related to transactions, which is the Financial_Transactions table.", "We need to count the number of transactions for each account, so we will use the COUNT() function on the transaction_id column.", "To group the results by account, we will use the GROUP BY clause on the account_id column.", "To find the account with the most transactions, we will order the results in descending order using ORDER BY COUNT(transaction_id) DESC.", "Finally, we will limit the results to only one account using LIMIT 1."], "pred_sql": "SELECT account_id FROM Financial_Transactions GROUP BY account_id ORDER BY COUNT(transaction_id) DESC LIMIT 1;", "gold_sql": "SELECT account_id FROM Financial_transactions GROUP BY account_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["financial_transactions"]}
{"sample_id": 1593, "db_id": "customers_and_invoices", "question": "Show the account id and name with at least 4 transactions.", "rationale": ["We need to select the account_id and account_name from the Accounts table.", "To find accounts with at least 4 transactions, we will join the Accounts table with the Financial_Transactions table on the account_id.", "We will group the results by account_id and account_name to aggregate the transaction counts for each account.", "Using the HAVING clause, we will filter the groups to include only those with a count of transactions greater than or equal to 4."], "pred_sql": "SELECT a.account_id, a.account_name \nFROM Accounts a \nJOIN Financial_Transactions ft ON a.account_id = ft.account_id \nGROUP BY a.account_id, a.account_name \nHAVING COUNT(ft.transaction_id) >= 4;", "gold_sql": "SELECT T1.account_id ,  T2.account_name FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id HAVING count(*)  >=  4", "source_tables": ["accounts", "financial_transactions"]}
{"sample_id": 1594, "db_id": "customers_and_invoices", "question": "What are the ids and names of accounts with 4 or more transactions?", "rationale": ["Identify the relevant tables: Accounts and Financial_Transactions.", "We need to retrieve account IDs and names, so we will select 'account_id' and 'account_name' from the Accounts table.", "To find accounts with 4 or more transactions, we will join the Accounts table with the Financial_Transactions table on 'account_id'.", "We will group the results by 'account_id' and 'account_name' to aggregate the transaction counts for each account.", "Finally, we will use the HAVING clause to filter groups that have a count of transactions greater than or equal to 4."], "pred_sql": "SELECT a.account_id, a.account_name \nFROM Accounts a \nJOIN Financial_Transactions ft ON a.account_id = ft.account_id \nGROUP BY a.account_id, a.account_name \nHAVING COUNT(ft.transaction_id) >= 4;", "gold_sql": "SELECT T1.account_id ,  T2.account_name FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id HAVING count(*)  >=  4", "source_tables": ["accounts", "financial_transactions"]}
{"sample_id": 1595, "db_id": "customers_and_invoices", "question": "Show all product sizes.", "rationale": ["Identify the table that contains product sizes, which is the Products table.", "To retrieve all unique product sizes, use the SELECT statement with DISTINCT to avoid duplicates.", "Specify the column 'product_size' to be selected from the Products table."], "pred_sql": "SELECT DISTINCT product_size FROM Products;", "gold_sql": "SELECT DISTINCT product_size FROM Products", "source_tables": ["products"]}
{"sample_id": 1596, "db_id": "customers_and_invoices", "question": "What are the different product sizes?", "rationale": ["Identify the table that contains product size information, which is the Products table.", "Determine the column that holds the product sizes, which is 'product_size'.", "Since we want to know the different product sizes, we will use the DISTINCT keyword to ensure that we get unique sizes.", "Construct the SQL query to select distinct product sizes from the Products table."], "pred_sql": "SELECT DISTINCT product_size FROM Products;", "gold_sql": "SELECT DISTINCT product_size FROM Products", "source_tables": ["products"]}
{"sample_id": 1597, "db_id": "customers_and_invoices", "question": "Show all product colors.", "rationale": ["Identify the table that contains product color information, which is the Products table.", "Determine the column that holds the color of the products, which is 'product_color'.", "Since we want to show all product colors, we will use the SELECT statement to retrieve the 'product_color' column.", "To avoid duplicate colors in the result, we will use the DISTINCT keyword to ensure each color is listed only once."], "pred_sql": "SELECT DISTINCT product_color FROM Products;", "gold_sql": "SELECT DISTINCT product_color FROM Products", "source_tables": ["products"]}
{"sample_id": 1598, "db_id": "customers_and_invoices", "question": "What are the different product colors?", "rationale": ["Identify the table that contains product color information, which is the Products table.", "Determine the column that holds the color information, which is 'product_color'.", "Since we want to know the different product colors, we need to use the DISTINCT keyword to avoid duplicate colors in the result.", "Construct the SQL query to select distinct product colors from the Products table."], "pred_sql": "SELECT DISTINCT product_color FROM Products;", "gold_sql": "SELECT DISTINCT product_color FROM Products", "source_tables": ["products"]}
{"sample_id": 1599, "db_id": "customers_and_invoices", "question": "Show the invoice number and the number of transactions for each invoice.", "rationale": ["Identify the relevant tables: Invoices and Financial_Transactions.", "We need to select the invoice number from the Invoices table.", "We need to count the number of transactions associated with each invoice, which requires joining the Financial_Transactions table on the invoice number.", "Use a LEFT JOIN to ensure we include invoices even if there are no transactions associated with them.", "Group the results by invoice number to get the count of transactions for each invoice."], "pred_sql": "SELECT Invoices.invoice_number, COUNT(Financial_Transactions.transaction_id) AS number_of_transactions\nFROM Invoices\nLEFT JOIN Financial_Transactions ON Invoices.invoice_number = Financial_Transactions.invoice_number\nGROUP BY Invoices.invoice_number;", "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"]}
{"sample_id": 1600, "db_id": "customers_and_invoices", "question": "How many transactions correspond to each invoice number?", "rationale": ["Identify the relevant table: Financial_Transactions contains the transaction data and includes the invoice_number.", "We need to count the number of transactions for each invoice number, which requires a GROUP BY clause on the invoice_number.", "Use the COUNT() function to count the number of transaction_id entries for each invoice_number.", "Select the invoice_number and the count of transactions as transaction_count."], "pred_sql": "SELECT invoice_number, COUNT(transaction_id) AS transaction_count FROM Financial_Transactions GROUP BY invoice_number;", "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"]}
{"sample_id": 1601, "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date for the invoice with most number of transactions?", "rationale": ["Identify the relevant tables: Invoices and Financial_Transactions.", "We need to find the invoice number and invoice date, so we will select these columns from the Invoices table.", "To determine the invoice with the most transactions, we will join the Invoices table with the Financial_Transactions table on the invoice number.", "We will group the results by invoice number and invoice date to count the number of transactions for each invoice.", "We will order the results in descending order based on the count of transactions to get the invoice with the most transactions at the top.", "Finally, we will limit the results to 1 to get only the invoice with the most transactions."], "pred_sql": "SELECT i.invoice_number, i.invoice_date\nFROM Invoices i\nJOIN Financial_Transactions ft ON i.invoice_number = ft.invoice_number\nGROUP BY i.invoice_number, i.invoice_date\nORDER BY COUNT(ft.transaction_id) DESC\nLIMIT 1;", "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"]}
{"sample_id": 1602, "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?", "rationale": ["Identify the table that contains the invoice information, which is the Invoices table.", "Determine the relevant columns needed from the Invoices table, which are invoice_number and invoice_date.", "To find the invoice with the greatest number of transactions, we need to look at the Financial_Transactions table.", "Group the transactions by order_id and count the number of transactions for each order_id.", "Order the results by the count of transactions in descending order to get the order_id with the most transactions at the top.", "Limit the results to 1 to get only the order_id with the greatest number of transactions.", "Use the order_id obtained from the previous step to filter the Invoices table to get the corresponding invoice_number and invoice_date."], "pred_sql": "SELECT invoice_number, invoice_date FROM Invoices WHERE order_id = (SELECT order_id FROM Financial_Transactions GROUP BY order_id ORDER BY COUNT(transaction_id) DESC LIMIT 1)", "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"]}
{"sample_id": 1603, "db_id": "customers_and_invoices", "question": "How many invoices do we have?", "rationale": ["Identify the table that contains invoice data, which is the Invoices table.", "To find out how many invoices there are, we need to count the number of records in the Invoices table.", "Use the COUNT() function to count the total number of invoices.", "Select the count and label it as total_invoices for clarity."], "pred_sql": "SELECT COUNT(*) AS total_invoices FROM Invoices;", "gold_sql": "SELECT count(*) FROM Invoices", "source_tables": ["invoices"]}
{"sample_id": 1604, "db_id": "customers_and_invoices", "question": "Count the number of invoices.", "rationale": ["Identify the table that contains the data needed for the query, which is the Invoices table.", "Determine the requirement to count the number of invoices, which can be achieved using the COUNT() function in SQL.", "Construct the SQL query to select the count of all records from the Invoices table."], "pred_sql": "SELECT COUNT(*) AS invoice_count FROM Invoices;", "gold_sql": "SELECT count(*) FROM Invoices", "source_tables": ["invoices"]}
{"sample_id": 1605, "db_id": "customers_and_invoices", "question": "Show invoice dates and order id and details for all invoices.", "rationale": ["Identify the required fields: invoice dates, order id, and order details.", "Determine the relevant tables: Invoices and Orders.", "Establish the relationship between the tables: Invoices are linked to Orders through the order_id.", "Construct the SQL SELECT statement to retrieve the specified fields from the joined tables."], "pred_sql": "SELECT Invoices.invoice_date, Orders.order_id, Orders.order_details \nFROM Invoices \nJOIN Orders ON Invoices.order_id = Orders.order_id;", "gold_sql": "SELECT T1.invoice_date ,  T1.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id", "source_tables": ["orders", "invoices"]}
{"sample_id": 1606, "db_id": "customers_and_invoices", "question": "What are the invoice dates, order ids, and order details for all invoices?", "rationale": ["Identify the required fields: invoice dates, order ids, and order details.", "Determine the relevant tables: Invoices and Orders.", "Establish the relationship between the tables: Invoices are linked to Orders through the order_id.", "Construct the SQL SELECT statement to retrieve the specified fields from the joined tables."], "pred_sql": "SELECT Invoices.invoice_date, Orders.order_id, Orders.order_details \nFROM Invoices \nJOIN Orders ON Invoices.order_id = Orders.order_id;", "gold_sql": "SELECT T1.invoice_date ,  T1.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id", "source_tables": ["orders", "invoices"]}
{"sample_id": 1607, "db_id": "customers_and_invoices", "question": "Show the order ids and the number of invoices for each order.", "rationale": ["We need to retrieve the order IDs and the count of invoices associated with each order.", "The relevant tables for this query are 'Orders' and 'Invoices'.", "We will perform a LEFT JOIN between 'Orders' and 'Invoices' on the common column 'order_id'.", "Using COUNT() function will allow us to count the number of invoices for each order.", "We will group the results by 'Orders.order_id' to get the count of invoices for each specific order."], "pred_sql": "SELECT Orders.order_id, COUNT(Invoices.invoice_number) AS number_of_invoices\nFROM Orders\nLEFT JOIN Invoices ON Orders.order_id = Invoices.order_id\nGROUP BY Orders.order_id;", "gold_sql": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id", "source_tables": ["invoices"]}
{"sample_id": 1608, "db_id": "customers_and_invoices", "question": "How many invoices correspond to each order id?", "rationale": ["Identify the relevant tables: Invoices contains the invoice data and includes the order_id.", "Determine the required output: We need to count the number of invoices for each order_id.", "Use the COUNT() function to count the invoices associated with each order_id.", "Group the results by order_id to get the count for each unique order_id."], "pred_sql": "SELECT order_id, COUNT(invoice_number) AS invoice_count FROM Invoices GROUP BY order_id;", "gold_sql": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id", "source_tables": ["invoices"]}
{"sample_id": 1609, "db_id": "customers_and_invoices", "question": "What is the order id and order details for the order more than two invoices.", "rationale": ["Identify the relevant tables: Orders and Invoices are needed to get order details and their associated invoices.", "We need to select the order_id and order_details from the Orders table.", "To find orders with more than two invoices, we will join the Orders table with the Invoices table on the order_id.", "We will group the results by order_id and order_details to aggregate the invoices for each order.", "Using the HAVING clause, we will filter the groups to include only those with a count of invoices greater than 2."], "pred_sql": "SELECT Orders.order_id, Orders.order_details \nFROM Orders \nJOIN Invoices ON Orders.order_id = Invoices.order_id \nGROUP BY Orders.order_id, Orders.order_details \nHAVING COUNT(Invoices.invoice_number) > 2;", "gold_sql": "SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  2", "source_tables": ["orders", "invoices"]}
{"sample_id": 1610, "db_id": "customers_and_invoices", "question": "Return the order ids and details for orderes with two or more invoices.", "rationale": ["Identify the relevant tables: Orders and Invoices.", "We need to return order ids and details, so we will select 'order_id' and 'order_details' from the Orders table.", "To find orders with two or more invoices, we will join the Orders table with the Invoices table on 'order_id'.", "We will group the results by 'order_id' to aggregate the invoices associated with each order.", "Using the HAVING clause, we will filter the groups to include only those with a count of invoices greater than or equal to 2."], "pred_sql": "SELECT o.order_id, o.order_details \nFROM Orders o \nJOIN Invoices i ON o.order_id = i.order_id \nGROUP BY o.order_id \nHAVING COUNT(i.invoice_number) >= 2;", "gold_sql": "SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  2", "source_tables": ["orders", "invoices"]}
{"sample_id": 1611, "db_id": "customers_and_invoices", "question": "What is the customer last name, id and phone number with most number of orders?", "rationale": ["Identify the relevant tables: Customers and Orders.", "We need to retrieve the last name, customer ID, and phone number of customers.", "Join the Customers table with the Orders table on the customer_id field to associate customers with their orders.", "Group the results by customer_id to count the number of orders for each customer.", "Order the results by the count of orders in descending order to find the customer with the most orders.", "Limit the results to 1 to get only the top customer."], "pred_sql": "SELECT c.customer_last_name, c.customer_id, c.phone_number \nFROM Customers c \nJOIN Orders o ON c.customer_id = o.customer_id \nGROUP BY c.customer_id \nORDER BY COUNT(o.order_id) DESC \nLIMIT 1;", "gold_sql": "SELECT T2.customer_last_name ,  T1.customer_id ,  T2.phone_number FROM Orders AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["orders", "customers"]}
{"sample_id": 1612, "db_id": "customers_and_invoices", "question": "Return the last name, id and phone number of the customer who has made the greatest number of orders.", "rationale": ["We need to retrieve the last name, customer ID, and phone number of the customer with the most orders.", "To do this, we will join the Customers table with the Orders table on the customer_id field.", "We will group the results by customer_id to count the number of orders each customer has made.", "Next, we will order the results in descending order based on the count of orders to find the customer with the greatest number of orders.", "Finally, we will limit the results to just one record to get the customer with the highest order count."], "pred_sql": "SELECT c.customer_last_name, c.customer_id, c.phone_number\nFROM Customers c\nJOIN Orders o ON c.customer_id = o.customer_id\nGROUP BY c.customer_id\nORDER BY COUNT(o.order_id) DESC\nLIMIT 1;", "gold_sql": "SELECT T2.customer_last_name ,  T1.customer_id ,  T2.phone_number FROM Orders AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["orders", "customers"]}
{"sample_id": 1613, "db_id": "customers_and_invoices", "question": "Show all product names without an order.", "rationale": ["Identify the table that contains product names, which is the Products table.", "To find products without an order, we need to check the Order_Items table, which links products to orders.", "We will use a subquery to select all product_ids from the Order_Items table.", "The main query will select product names from the Products table where the product_id is not in the list of product_ids returned by the subquery."], "pred_sql": "SELECT product_name FROM Products WHERE product_id NOT IN (SELECT product_id FROM Order_Items)", "gold_sql": "SELECT product_name FROM Products EXCEPT SELECT T1.product_name FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id", "source_tables": ["products", "order_items"]}
{"sample_id": 1614, "db_id": "customers_and_invoices", "question": "What are the names of products that have never been ordered?", "rationale": ["Identify the table that contains product information, which is the Products table.", "Determine the relevant column for product identification, which is product_id.", "Identify the table that contains order information, specifically the Order_Items table, which links products to orders.", "Construct a subquery to select all product_ids from the Order_Items table, which represents products that have been ordered.", "Use the NOT IN clause to filter out products that are present in the Order_Items subquery from the Products table, thus retrieving products that have never been ordered."], "pred_sql": "SELECT product_name FROM Products WHERE product_id NOT IN (SELECT product_id FROM Order_Items)", "gold_sql": "SELECT product_name FROM Products EXCEPT SELECT T1.product_name FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id", "source_tables": ["products", "order_items"]}
{"sample_id": 1615, "db_id": "customers_and_invoices", "question": "Show all product names and the total quantity ordered for each product name.", "rationale": ["We need to retrieve product names and the total quantity ordered for each product.", "The relevant tables for this query are 'Products' and 'Order_Items'.", "We will join these two tables on the 'product_id' column, which is common to both tables.", "We will select the 'product_name' from the 'Products' table and the sum of 'product_quantity' from the 'Order_Items' table.", "To get the total quantity ordered for each product, we will use the SUM() function and group the results by 'product_name'."], "pred_sql": "SELECT Products.product_name, SUM(Order_Items.product_quantity) AS total_quantity_ordered\nFROM Products\nJOIN Order_Items ON Products.product_id = Order_Items.product_id\nGROUP BY Products.product_name;", "gold_sql": "SELECT T2.product_name ,  sum(T1.product_quantity) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id GROUP BY T2.product_name", "source_tables": ["products", "order_items"]}
{"sample_id": 1616, "db_id": "customers_and_invoices", "question": "What are the different product names, and what is the sum of quantity ordered for each product?", "rationale": ["Identify the relevant tables: Products and Order_Items are needed to get product names and quantities ordered.", "Select the product name from the Products table.", "Use the SUM function to calculate the total quantity ordered for each product from the Order_Items table.", "Join the Products table with the Order_Items table on the product_id to link products with their ordered quantities.", "Group the results by product name to get the sum of quantities for each product."], "pred_sql": "SELECT p.product_name, SUM(oi.product_quantity) AS total_quantity_ordered\nFROM Products p\nJOIN Order_Items oi ON p.product_id = oi.product_id\nGROUP BY p.product_name;", "gold_sql": "SELECT T2.product_name ,  sum(T1.product_quantity) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id GROUP BY T2.product_name", "source_tables": ["products", "order_items"]}
{"sample_id": 1617, "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["Identify the tables needed: We need data from the Orders table for order IDs and the Order_Items table to count the number of items in each order.", "Select the order_id from the Orders table and count the order_item_id from the Order_Items table to get the number of items per order.", "Use a LEFT JOIN to connect Orders and Order_Items on the order_id, ensuring we include all orders even if they have no items.", "Group the results by order_id to aggregate the count of items for each order."], "pred_sql": "SELECT Orders.order_id, COUNT(Order_Items.order_item_id) AS number_of_items\nFROM Orders\nLEFT JOIN Order_Items ON Orders.order_id = Order_Items.order_id\nGROUP BY Orders.order_id;", "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"]}
{"sample_id": 1618, "db_id": "customers_and_invoices", "question": "How many order items correspond to each order id?", "rationale": ["Identify the relevant table: The query is asking about order items, which are stored in the Order_Items table.", "Determine the required columns: We need the order_id and a count of order items for each order.", "Use the COUNT() function: This function will count the number of order_item_id entries for each order_id.", "Group the results: To get the count per order, we will use GROUP BY on the order_id column."], "pred_sql": "SELECT order_id, COUNT(order_item_id) AS order_item_count FROM Order_Items GROUP BY order_id;", "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"]}
{"sample_id": 1619, "db_id": "customers_and_invoices", "question": "Show the product ids and the number of unique orders containing each product.", "rationale": ["We need to show the product ids and the number of unique orders for each product.", "To achieve this, we will use the Order_Items table to get the product ids and the Orders table to count the unique orders.", "We will perform a JOIN between Order_Items and Orders on the order_id to link products to their respective orders.", "We will use COUNT(DISTINCT o.order_id) to count the unique orders for each product.", "Finally, we will group the results by product_id to get the count for each product."], "pred_sql": "SELECT oi.product_id, COUNT(DISTINCT o.order_id) AS unique_order_count\nFROM Order_Items oi\nJOIN Orders o ON oi.order_id = o.order_id\nGROUP BY oi.product_id;", "gold_sql": "SELECT product_id ,  count(DISTINCT order_id) FROM Order_items GROUP BY product_id", "source_tables": ["order_items"]}
{"sample_id": 1620, "db_id": "customers_and_invoices", "question": "How many distinct order ids correspond to each product?", "rationale": ["We need to find the distinct order IDs for each product, which means we will be working with the Order_Items table where each order item is linked to a product.", "We will select the product_id from the Order_Items table to group our results by product.", "To count the distinct order IDs, we will use the COUNT function with the DISTINCT keyword on the order_id column.", "Finally, we will group the results by product_id to get the count of distinct order IDs for each product."], "pred_sql": "SELECT product_id, COUNT(DISTINCT order_id) AS distinct_order_count FROM Order_Items GROUP BY product_id;", "gold_sql": "SELECT product_id ,  count(DISTINCT order_id) FROM Order_items GROUP BY product_id", "source_tables": ["order_items"]}
{"sample_id": 1621, "db_id": "customers_and_invoices", "question": "Show all product names and the number of customers having an order on each product.", "rationale": ["We need to retrieve product names and the count of customers who have ordered each product.", "Start by selecting the product name from the Products table.", "To count the number of customers, we will need to join the Orders table to link orders to products.", "Next, we join the Order_Items table to connect products to their respective orders.", "Finally, we join the Customers table to associate customers with their orders.", "We will use COUNT(DISTINCT Customers.customer_id) to ensure we count each customer only once per product.", "Group the results by product name to get the count of customers for each product."], "pred_sql": "SELECT Products.product_name, COUNT(DISTINCT Customers.customer_id) AS customer_count\nFROM Products\nJOIN Order_Items ON Products.product_id = Order_Items.product_id\nJOIN Orders ON Order_Items.order_id = Orders.order_id\nJOIN Customers ON Orders.customer_id = Customers.customer_id\nGROUP BY Products.product_name;", "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"]}
{"sample_id": 1622, "db_id": "customers_and_invoices", "question": "What are teh names of the different products, as well as the number of customers who have ordered each product.", "rationale": ["Identify the relevant tables: Products, Order_Items, and Orders are needed to get product names and customer counts.", "Select the product name from the Products table.", "Count the distinct customer IDs from the Orders table to get the number of customers who ordered each product.", "Join the Products table with the Order_Items table on product_id to link products with their orders.", "Join the Order_Items table with the Orders table on order_id to link orders with customers.", "Group the results by product name to aggregate the customer counts for each product."], "pred_sql": "SELECT Products.product_name, COUNT(DISTINCT Orders.customer_id) AS customer_count\nFROM Products\nJOIN Order_Items ON Products.product_id = Order_Items.product_id\nJOIN Orders ON Order_Items.order_id = Orders.order_id\nGROUP BY Products.product_name;", "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"]}
{"sample_id": 1623, "db_id": "customers_and_invoices", "question": "Show order ids and the number of products in each order.", "rationale": ["Identify the tables needed: We need data from the Orders table for order IDs and the Order_Items table to count the products in each order.", "Join the Orders table with the Order_Items table on the order_id to link orders with their respective items.", "Use the COUNT() function to count the number of products for each order.", "Group the results by order_id to get the count of products for each individual order."], "pred_sql": "SELECT Orders.order_id, COUNT(Order_Items.product_id) AS number_of_products\nFROM Orders\nJOIN Order_Items ON Orders.order_id = Order_Items.order_id\nGROUP BY Orders.order_id;", "gold_sql": "SELECT order_id ,  count(DISTINCT product_id) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"]}
{"sample_id": 1624, "db_id": "customers_and_invoices", "question": "How many different products correspond to each order id?", "rationale": ["Identify the relevant table: The 'Order_Items' table contains the relationship between orders and products.", "Determine the required information: We need to count the distinct products for each order.", "Use the COUNT function to count distinct product IDs for each order ID.", "Group the results by 'order_id' to get the count of different products for each order."], "pred_sql": "SELECT order_id, COUNT(DISTINCT product_id) AS different_product_count FROM Order_Items GROUP BY order_id;", "gold_sql": "SELECT order_id ,  count(DISTINCT product_id) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"]}
{"sample_id": 1625, "db_id": "customers_and_invoices", "question": "Show order ids and the total quantity in each order.", "rationale": ["Identify the tables involved: We need data from the Orders and Order_Items tables to get order ids and their corresponding quantities.", "Determine the columns needed: We need 'order_id' from the Orders table and the sum of 'product_quantity' from the Order_Items table.", "Establish the relationship: The Orders table is linked to the Order_Items table through 'order_id'.", "Use the SUM function to calculate the total quantity for each order.", "Group the results by 'order_id' to get the total quantity for each individual order."], "pred_sql": "SELECT Orders.order_id, SUM(Order_Items.product_quantity) AS total_quantity\nFROM Orders\nJOIN Order_Items ON Orders.order_id = Order_Items.order_id\nGROUP BY Orders.order_id;", "gold_sql": "SELECT order_id ,  sum(product_quantity) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"]}
{"sample_id": 1626, "db_id": "customers_and_invoices", "question": "Give the order ids for all orders, as well as the total product quantity in each.", "rationale": ["We need to retrieve order ids and the total product quantity for each order.", "The relevant tables are 'Orders' and 'Order_Items' since 'Order_Items' contains the product quantities associated with each order.", "We will perform a JOIN operation between 'Orders' and 'Order_Items' on the common column 'order_id'.", "To get the total product quantity for each order, we will use the SUM() function on 'Order_Items.product_quantity'.", "Finally, we will group the results by 'Orders.order_id' to ensure we get the total quantity for each specific order."], "pred_sql": "SELECT Orders.order_id, SUM(Order_Items.product_quantity) AS total_product_quantity\nFROM Orders\nJOIN Order_Items ON Orders.order_id = Order_Items.order_id\nGROUP BY Orders.order_id;", "gold_sql": "SELECT order_id ,  sum(product_quantity) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"]}
{"sample_id": 1627, "db_id": "customers_and_invoices", "question": "How many products were not included in any order?", "rationale": ["Identify the Products table to get the list of all products.", "Use a subquery to find all product_ids that are included in any order by checking the Order_Items table.", "Count the number of products whose product_id is not in the list obtained from the subquery."], "pred_sql": "SELECT COUNT(*) AS products_not_in_orders FROM Products WHERE product_id NOT IN (SELECT product_id FROM Order_Items);", "gold_sql": "SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )", "source_tables": ["products", "order_items"]}
{"sample_id": 1628, "db_id": "customers_and_invoices", "question": "Count the number of products that were never ordered.", "rationale": ["We need to count the number of products that have never been ordered.", "To find products that were never ordered, we can look at the 'Products' table and check which product IDs are not present in the 'Order_Items' table.", "The 'Order_Items' table contains the 'product_id' for each product that has been ordered.", "We can use a subquery to select all 'product_id's from 'Order_Items' and then use the NOT IN clause to filter out those from the 'Products' table.", "Finally, we will use COUNT(*) to get the total number of products that meet this condition."], "pred_sql": "SELECT COUNT(*) AS never_ordered_count\nFROM Products\nWHERE product_id NOT IN (\n    SELECT product_id\n    FROM Order_Items\n);", "gold_sql": "SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )", "source_tables": ["products", "order_items"]}
{"sample_id": 1629, "db_id": "wedding", "question": "How many churches opened before 1850 are there?", "rationale": ["Identify the table that contains information about churches, which is the 'church' table.", "Determine the relevant column for the opening date of the churches, which is 'Open_Date'.", "Specify the condition to filter churches that opened before the year 1850, using the condition 'Open_Date < 1850'.", "Use the COUNT() function to count the number of records that meet the specified condition.", "Construct the SQL query to select the count of churches from the 'church' table with the specified condition."], "pred_sql": "SELECT COUNT(*) AS Church_Count FROM church WHERE Open_Date < 1850;", "gold_sql": "SELECT count(*) FROM Church WHERE Open_Date  <  1850", "source_tables": ["church"]}
{"sample_id": 1630, "db_id": "wedding", "question": "Show the name, open date, and organizer for all churches.", "rationale": ["Identify the table that contains the required information: the 'church' table.", "Determine the specific columns needed: 'Name', 'Open_Date', and 'Organized_by'.", "Construct the SQL SELECT statement to retrieve these columns from the 'church' table."], "pred_sql": "SELECT Name, Open_Date, Organized_by FROM church;", "gold_sql": "SELECT name ,  open_date ,  organized_by FROM Church", "source_tables": ["church"]}
{"sample_id": 1631, "db_id": "wedding", "question": "List all church names in descending order of opening date.", "rationale": ["Identify the table that contains the church names, which is the 'church' table.", "Determine the column that holds the church names, which is 'Name'.", "Identify the column that holds the opening dates, which is 'Open_Date'.", "Construct the SQL query to select the 'Name' from the 'church' table and order the results by 'Open_Date' in descending order."], "pred_sql": "SELECT Name FROM church ORDER BY Open_Date DESC;", "gold_sql": "SELECT name FROM church ORDER BY open_date DESC", "source_tables": ["church"]}
{"sample_id": 1632, "db_id": "wedding", "question": "Show the opening year in whcih at least two churches opened.", "rationale": ["Identify the relevant table: The 'church' table contains the 'Open_Date' column which indicates when each church was established.", "We need to find the years in which at least two churches opened, so we will group the results by 'Open_Date'.", "Using the COUNT function, we can count the number of churches that opened in each year.", "We will use the HAVING clause to filter the results to only include years where the count of churches is 2 or more."], "pred_sql": "SELECT Open_Date FROM church GROUP BY Open_Date HAVING COUNT(Church_ID) >= 2;", "gold_sql": "SELECT open_date FROM church GROUP BY open_date HAVING count(*)  >=  2", "source_tables": ["church"]}
{"sample_id": 1633, "db_id": "wedding", "question": "Show the organizer and name for churches that opened between 1830 and 1840.", "rationale": ["Identify the relevant table: The query requires information about churches, so we will use the 'church' table.", "Determine the columns needed: We need the 'Organized_by' and 'Name' columns from the 'church' table.", "Filter the results: The query specifies a date range for when the churches opened, which is between 1830 and 1840. We will use the WHERE clause with the BETWEEN operator to filter the 'Open_Date' column accordingly."], "pred_sql": "SELECT Organized_by, Name FROM church WHERE Open_Date BETWEEN 1830 AND 1840;", "gold_sql": "SELECT organized_by ,  name FROM church WHERE open_date BETWEEN 1830 AND 1840", "source_tables": ["church"]}
{"sample_id": 1634, "db_id": "wedding", "question": "Show all opening years and the number of churches that opened in that year.", "rationale": ["Identify the relevant table: The 'church' table contains the 'Open_Date' and 'Church_ID' columns needed for this query.", "Select the 'Open_Date' column to show the years when churches opened.", "Count the number of churches for each opening year using COUNT(Church_ID).", "Group the results by 'Open_Date' to aggregate the counts for each year."], "pred_sql": "SELECT Open_Date, COUNT(Church_ID) AS Number_of_Churches FROM church GROUP BY Open_Date;", "gold_sql": "SELECT open_date ,  count(*) FROM church GROUP BY open_date", "source_tables": ["church"]}
{"sample_id": 1635, "db_id": "wedding", "question": "Show the name and opening year for three churches that opened most recently.", "rationale": ["Identify the relevant table: The query requires information about churches, so we will use the 'church' table.", "Select the required columns: We need the 'Name' and 'Open_Date' of the churches.", "Order the results: To find the most recently opened churches, we will order the results by 'Open_Date' in descending order.", "Limit the results: Since we only need the top three most recent churches, we will use 'LIMIT 3' to restrict the output."], "pred_sql": "SELECT Name, Open_Date FROM church ORDER BY Open_Date DESC LIMIT 3;", "gold_sql": "SELECT name ,  open_date FROM church ORDER BY open_date DESC LIMIT 3", "source_tables": ["church"]}
{"sample_id": 1636, "db_id": "wedding", "question": "How many female people are older than 30 in our record?", "rationale": ["Identify the table to query: 'people'.", "Determine the condition for filtering: we need female people, which corresponds to 'Is_Male = 'no'.", "Determine the age condition: we want people older than 30, which translates to 'Age > '30'.", "Combine the conditions to form the WHERE clause: 'WHERE Is_Male = 'no' AND Age > '30'.'", "Use the COUNT function to count the number of records that meet the criteria: 'SELECT COUNT(*)'.", "Construct the full SQL query: 'SELECT COUNT(*) FROM people WHERE Is_Male = 'no' AND Age > '30';'"], "pred_sql": "SELECT COUNT(*) FROM people WHERE Is_Male = 'no' AND Age > '30';", "gold_sql": "SELECT count(*) FROM people WHERE is_male  =  'F' AND age  >  30", "source_tables": ["people"]}
{"sample_id": 1637, "db_id": "wedding", "question": "Show the country where people older than 30 and younger than 25 are from.", "rationale": ["Identify the table to query: 'people' table contains the relevant information about individuals.", "Determine the conditions for filtering: we need to find people older than 30 or younger than 25.", "Use the 'Age' column to apply the conditions: 'Age > 30' and 'Age < 25'.", "Select the 'Country' column to show where these people are from.", "Use DISTINCT to ensure that each country is listed only once in the results."], "pred_sql": "SELECT DISTINCT Country FROM people WHERE Age > 30 OR Age < 25;", "gold_sql": "SELECT country FROM people WHERE age  <  25 INTERSECT SELECT country FROM people WHERE age  >  30", "source_tables": ["people"]}
{"sample_id": 1638, "db_id": "wedding", "question": "Show the minimum, maximum, and average age for all people.", "rationale": ["Identify the required calculations: minimum, maximum, and average age.", "Determine the relevant table: 'people' contains the age information.", "Use aggregate functions: MIN(), MAX(), and AVG() to calculate the respective values.", "Construct the SQL query to select these aggregate values from the 'people' table."], "pred_sql": "SELECT MIN(Age) AS Minimum_Age, MAX(Age) AS Maximum_Age, AVG(Age) AS Average_Age FROM people;", "gold_sql": "SELECT min(age) ,  max(age) ,  avg(age) FROM people", "source_tables": ["people"]}
{"sample_id": 1639, "db_id": "wedding", "question": "Show the name and country for all people whose age is smaller than the average.", "rationale": ["Identify the columns needed: Name and Country from the people table.", "Determine the condition: Age should be less than the average age of all people.", "Use a subquery to calculate the average age: SELECT AVG(Age) FROM people.", "Combine the selection of Name and Country with the condition using a WHERE clause."], "pred_sql": "SELECT Name, Country FROM people WHERE Age < (SELECT AVG(Age) FROM people);", "gold_sql": "SELECT name ,  country FROM people WHERE age  <  (SELECT avg(age) FROM people)", "source_tables": ["people"]}
{"sample_id": 1640, "db_id": "wedding", "question": "Show the pair of male and female names in all weddings after year 2014", "rationale": ["Identify the tables involved: 'wedding' for wedding details and 'people' for participant names.", "We need to join the 'wedding' table with the 'people' table twice: once for the male participant and once for the female participant.", "Select the names of the male and female participants from the joined tables.", "Filter the results to include only those weddings that occurred after the year 2014."], "pred_sql": "SELECT p1.Name AS Male_Name, p2.Name AS Female_Name \nFROM wedding w \nJOIN people p1 ON w.Male_ID = p1.People_ID \nJOIN people p2 ON w.Female_ID = p2.People_ID \nWHERE w.Year > '2014';", "gold_sql": "SELECT T2.name ,  T3.name FROM wedding AS T1 JOIN people AS T2 ON T1.male_id  =  T2.people_id JOIN people AS T3 ON T1.female_id  =  T3.people_id WHERE T1.year  >  2014", "source_tables": ["wedding", "people"]}
{"sample_id": 1641, "db_id": "wedding", "question": "Show the name and age for all male people who don't have a wedding.", "rationale": ["Identify the columns needed: Name and Age from the people table.", "Filter for male individuals by checking the Is_Male column for 'yes'.", "Determine which male individuals have had a wedding by checking the Male_ID in the wedding table.", "Use a subquery to find all People_IDs that are either Male_ID or Female_ID in the wedding table.", "Use NOT IN to exclude those who have had a wedding from the selection of male individuals."], "pred_sql": "SELECT Name, Age FROM people WHERE Is_Male = 'yes' AND People_ID NOT IN (SELECT Male_ID FROM wedding UNION SELECT Female_ID FROM wedding);", "gold_sql": "SELECT name ,  age FROM people WHERE is_male  =  'T' AND people_id NOT IN (SELECT male_id FROM wedding)", "source_tables": ["wedding", "people"]}
{"sample_id": 1642, "db_id": "wedding", "question": "Show all church names except for those that had a wedding in year 2015.", "rationale": ["Identify the main table to query from, which is the 'church' table, as we want to show church names.", "We need to exclude churches that had weddings in the year 2015.", "To do this, we will use a subquery that selects Church_IDs from the 'wedding' table where the Year is '2015'.", "The main query will select the Name from the 'church' table where the Church_ID is not in the list returned by the subquery."], "pred_sql": "SELECT Name FROM church WHERE Church_ID NOT IN (SELECT Church_ID FROM wedding WHERE Year = '2015');", "gold_sql": "SELECT name FROM church EXCEPT SELECT T1.name FROM church AS T1 JOIN wedding AS T2 ON T1.church_id  =  T2.church_id WHERE T2.year  =  2015", "source_tables": ["wedding", "church"]}
{"sample_id": 1643, "db_id": "wedding", "question": "Show all church names that have hosted least two weddings.", "rationale": ["We need to find church names that have hosted at least two weddings.", "To do this, we will join the 'church' table with the 'wedding' table on the 'Church_ID' column.", "Next, we will group the results by 'Church_ID' to aggregate the number of weddings per church.", "We will use the COUNT function to count the number of weddings for each church.", "Finally, we will filter the results using the HAVING clause to include only those churches that have hosted two or more weddings."], "pred_sql": "SELECT church.Name FROM church JOIN wedding ON church.Church_ID = wedding.Church_ID GROUP BY church.Church_ID HAVING COUNT(wedding.Church_ID) >= 2;", "gold_sql": "SELECT T1.name FROM church AS T1 JOIN wedding AS T2 ON T1.church_id  =  T2.church_id GROUP BY T1.church_id HAVING count(*)  >=  2", "source_tables": ["wedding", "church"]}
{"sample_id": 1644, "db_id": "wedding", "question": "Show the names for all females from Canada having a wedding in year 2016.", "rationale": ["Identify the relevant tables: 'people' for personal information and 'wedding' for wedding details.", "We need to find females, so we will filter the 'people' table where 'Is_Male' is 'no'.", "We also need to filter by country, specifically 'Canada'.", "Next, we need to filter the weddings that occurred in the year 2016.", "To get the names of the females, we will select the 'Name' column from the 'people' table.", "We will join the 'people' table with the 'wedding' table on the 'Female_ID' to match the females who had weddings.", "The final SQL query will select the names of females from Canada who had weddings in 2016."], "pred_sql": "SELECT p.Name FROM people p JOIN wedding w ON p.People_ID = w.Female_ID WHERE p.Country = 'Canada' AND w.Year = '2016';", "gold_sql": "SELECT T2.name FROM wedding AS T1 JOIN people AS T2 ON T1.female_id  =  T2.people_id WHERE T1.year  =  2016 AND T2.is_male  =  'F' AND T2.country  =  'Canada'", "source_tables": ["wedding", "people"]}
{"sample_id": 1645, "db_id": "wedding", "question": "How many weddings are there in year 2016?", "rationale": ["Identify the relevant table: The 'wedding' table contains information about weddings.", "Determine the required information: We need to count the number of weddings that occurred in the year 2016.", "Formulate the SQL query: Use the COUNT() function to count the rows in the 'wedding' table where the 'Year' column matches '2016'.", "Construct the final SQL query: SELECT COUNT(*) AS Total_Weddings FROM wedding WHERE Year = '2016';"], "pred_sql": "SELECT COUNT(*) AS Total_Weddings FROM wedding WHERE Year = '2016';", "gold_sql": "SELECT count(*) FROM wedding WHERE YEAR  =  2016", "source_tables": ["wedding"]}
{"sample_id": 1646, "db_id": "wedding", "question": "Show the church names for the weddings of all people older than 30.", "rationale": ["Identify the tables involved: 'church', 'wedding', and 'people'.", "Determine the relationships: 'wedding' links 'church' and 'people' through foreign keys.", "We need to find church names associated with weddings of people older than 30.", "Use a JOIN to combine 'church' and 'wedding' on 'Church_ID', and 'wedding' and 'people' on 'Male_ID' and 'Female_ID'.", "Filter the results where the age of people is greater than 30.", "Select distinct church names to avoid duplicates."], "pred_sql": "SELECT DISTINCT church.Name FROM church JOIN wedding ON church.Church_ID = wedding.Church_ID JOIN people ON wedding.Male_ID = people.People_ID OR wedding.Female_ID = people.People_ID WHERE people.Age > '30';", "gold_sql": "SELECT T4.name FROM wedding AS T1 JOIN people AS T2 ON T1.male_id  =  T2.people_id JOIN people AS T3 ON T1.female_id  =  T3.people_id JOIN church AS T4 ON T4.church_id  =  T1.church_id WHERE T2.age  >  30 OR T3.age  >  30", "source_tables": ["wedding", "church", "people"]}
{"sample_id": 1647, "db_id": "wedding", "question": "Show all countries and the number of people from each country.", "rationale": ["Identify the table that contains the relevant data: the 'people' table.", "Determine the columns needed: 'Country' for grouping and a count of people for aggregation.", "Use the COUNT() function to count the number of people in each country.", "Group the results by 'Country' to get the count for each distinct country."], "pred_sql": "SELECT Country, COUNT(*) AS Number_of_People FROM people GROUP BY Country;", "gold_sql": "SELECT country ,  count(*) FROM people GROUP BY country", "source_tables": ["people"]}
{"sample_id": 1648, "db_id": "wedding", "question": "How many churches have a wedding in year 2016?", "rationale": ["Identify the relevant table: The 'wedding' table contains information about weddings and the churches where they took place.", "Determine the requirement: We need to count the number of distinct churches that had weddings in the year 2016.", "Use the COUNT function to count distinct Church_IDs from the wedding table where the Year is '2016'.", "Construct the SQL query to select the count of distinct Church_IDs from the wedding table with the specified condition."], "pred_sql": "SELECT COUNT(DISTINCT Church_ID) AS Number_of_Churches FROM wedding WHERE Year = '2016';", "gold_sql": "SELECT COUNT (DISTINCT church_id) FROM wedding WHERE YEAR  =  2016", "source_tables": ["wedding"]}
{"sample_id": 1649, "db_id": "theme_gallery", "question": "How many artists do we have?", "rationale": ["Identify the table that contains the information about artists, which is the 'artist' table.", "To find out how many artists there are, we need to count the number of entries in the 'artist' table.", "Use the COUNT() function to count the total number of artists.", "Select the count with an alias 'total_artists' for clarity in the result."], "pred_sql": "SELECT COUNT(*) AS total_artists FROM artist;", "gold_sql": "SELECT count(*) FROM artist", "source_tables": ["artist"]}
{"sample_id": 1650, "db_id": "theme_gallery", "question": "Count the number of artists.", "rationale": ["Identify the table that contains the artist information, which is the 'artist' table.", "To count the number of artists, we need to use the COUNT() function in SQL.", "The SQL query should select the count of all records from the 'artist' table.", "The final SQL query will be 'SELECT COUNT(*) AS Number_of_Artists FROM artist;' to get the total number of artists."], "pred_sql": "SELECT COUNT(*) AS Number_of_Artists FROM artist;", "gold_sql": "SELECT count(*) FROM artist", "source_tables": ["artist"]}
{"sample_id": 1651, "db_id": "theme_gallery", "question": "Show all artist name, age, and country ordered by the yeared they joined.", "rationale": ["Identify the columns needed: Name, Age, and Country from the artist table.", "Determine the order of the results: we need to order by the Year_Join column.", "Construct the SQL SELECT statement to retrieve the specified columns from the artist table.", "Add the ORDER BY clause to sort the results by Year_Join."], "pred_sql": "SELECT Name, Age, Country FROM artist ORDER BY Year_Join;", "gold_sql": "SELECT name ,  age ,  country FROM artist ORDER BY Year_Join", "source_tables": ["artist"]}
{"sample_id": 1652, "db_id": "theme_gallery", "question": "What are the names, ages, and countries of artists, sorted by the year they joined?", "rationale": ["Identify the columns needed: Name, Age, and Country from the artist table.", "Determine the sorting requirement: the results should be sorted by the Year_Join column.", "Construct the SQL SELECT statement to retrieve the specified columns from the artist table.", "Add the ORDER BY clause to sort the results by Year_Join."], "pred_sql": "SELECT Name, Age, Country FROM artist ORDER BY Year_Join;", "gold_sql": "SELECT name ,  age ,  country FROM artist ORDER BY Year_Join", "source_tables": ["artist"]}
{"sample_id": 1653, "db_id": "theme_gallery", "question": "What are all distinct country for artists?", "rationale": ["Identify the table that contains the information about artists, which is the 'artist' table.", "Determine the column that holds the country information, which is 'Country'.", "To get all distinct countries, use the DISTINCT keyword in the SQL query.", "Construct the SQL query to select distinct countries from the artist table."], "pred_sql": "SELECT DISTINCT Country FROM artist;", "gold_sql": "SELECT DISTINCT country FROM artist", "source_tables": ["artist"]}
{"sample_id": 1654, "db_id": "theme_gallery", "question": "Return the different countries for artists.", "rationale": ["Identify the table that contains the information about artists, which is the 'artist' table.", "Determine the column that holds the country information, which is the 'Country' column.", "To get different countries, use the DISTINCT keyword to ensure that each country is listed only once.", "Construct the SQL query to select distinct countries from the artist table."], "pred_sql": "SELECT DISTINCT Country FROM artist;", "gold_sql": "SELECT DISTINCT country FROM artist", "source_tables": ["artist"]}
{"sample_id": 1655, "db_id": "theme_gallery", "question": "Show all artist names and the year joined who are not from United States.", "rationale": ["Identify the table that contains the required information: the 'artist' table has the columns 'Name' and 'Year_Join'.", "Determine the condition for filtering: we need artists who are not from the United States, which translates to 'Country != 'United States''.", "Construct the SQL SELECT statement to retrieve the 'Name' and 'Year_Join' columns from the 'artist' table with the specified condition."], "pred_sql": "SELECT Name, Year_Join FROM artist WHERE Country != 'United States';", "gold_sql": "SELECT name ,  year_join FROM artist WHERE country != 'United States'", "source_tables": ["artist"]}
{"sample_id": 1656, "db_id": "theme_gallery", "question": "What are the names and year of joining for artists that do not have the country \"United States\"?", "rationale": ["Identify the columns needed: 'Name' and 'Year_Join' from the 'artist' table.", "Determine the condition: we want artists whose 'Country' is not 'United States'.", "Construct the SQL SELECT statement to retrieve the specified columns from the 'artist' table with the appropriate WHERE clause."], "pred_sql": "SELECT Name, Year_Join FROM artist WHERE Country != 'United States';", "gold_sql": "SELECT name ,  year_join FROM artist WHERE country != 'United States'", "source_tables": ["artist"]}
{"sample_id": 1657, "db_id": "theme_gallery", "question": "How many artists are above age 46 and joined after 1990?", "rationale": ["Identify the table that contains the relevant data: the 'artist' table.", "Determine the conditions for filtering: artists above age 46 and those who joined after 1990.", "Use the COUNT() function to count the number of artists that meet these conditions.", "Construct the SQL query using the SELECT statement to count the artists, applying the WHERE clause for the specified conditions."], "pred_sql": "SELECT COUNT(*) AS Artist_Count FROM artist WHERE Age > '46' AND Year_Join > '1990';", "gold_sql": "SELECT count(*) FROM artist WHERE age  >  46 AND year_join  >  1990", "source_tables": ["artist"]}
{"sample_id": 1658, "db_id": "theme_gallery", "question": "Count the number of artists who are older than 46 and joined after 1990.", "rationale": ["Identify the table to query: The 'artist' table contains the relevant information about artists.", "Determine the conditions: We need to count artists who are older than 46 and joined after 1990.", "Translate the conditions into SQL: Use the COUNT function to count the number of records that meet the specified conditions.", "Construct the SQL query: SELECT COUNT(*) FROM artist WHERE Age > '46' AND Year_Join > '1990';"], "pred_sql": "SELECT COUNT(*) FROM artist WHERE Age > '46' AND Year_Join > '1990';", "gold_sql": "SELECT count(*) FROM artist WHERE age  >  46 AND year_join  >  1990", "source_tables": ["artist"]}
{"sample_id": 1659, "db_id": "theme_gallery", "question": "What is the average and minimum age of all artists from United States.", "rationale": ["Identify the table that contains the relevant data: the 'artist' table holds information about artists including their age and country.", "Determine the specific columns needed for the query: we need to calculate the average and minimum age, so we will use the 'Age' column.", "Apply a filter to focus on artists from the United States: this requires a WHERE clause to specify 'Country = 'United States'.", "Use aggregate functions to calculate the average and minimum age: we will use AVG() for the average and MIN() for the minimum age.", "Construct the SQL query by combining these elements into a SELECT statement that retrieves the average and minimum age for the specified artists."], "pred_sql": "SELECT AVG(Age) AS Average_Age, MIN(Age) AS Minimum_Age FROM artist WHERE Country = 'United States';", "gold_sql": "SELECT avg(age) ,  min(age) FROM artist WHERE country  =  'United States'", "source_tables": ["artist"]}
{"sample_id": 1660, "db_id": "theme_gallery", "question": "Return the average and minimum ages across artists from the United States.", "rationale": ["Identify the table that contains the age information, which is the 'artist' table.", "Determine the condition needed to filter the artists, which is to select only those from the 'United States'.", "Use the AVG() function to calculate the average age of the filtered artists.", "Use the MIN() function to find the minimum age of the filtered artists.", "Construct the SQL query to select the average and minimum ages from the 'artist' table where the country is 'United States'."], "pred_sql": "SELECT AVG(Age) AS Average_Age, MIN(Age) AS Minimum_Age FROM artist WHERE Country = 'United States';", "gold_sql": "SELECT avg(age) ,  min(age) FROM artist WHERE country  =  'United States'", "source_tables": ["artist"]}
{"sample_id": 1661, "db_id": "theme_gallery", "question": "What is the name of the artist who joined latest?", "rationale": ["Identify the table that contains the artist information, which is the 'artist' table.", "To find the artist who joined latest, we need to sort the artists by the 'Year_Join' column in descending order.", "Using 'ORDER BY Year_Join DESC' will arrange the artists starting from the most recent join year.", "To get only the latest artist, we will limit the results to 1 using 'LIMIT 1'.", "Finally, we select the 'Name' of the artist from the sorted results."], "pred_sql": "SELECT Name FROM artist ORDER BY Year_Join DESC LIMIT 1;", "gold_sql": "SELECT name FROM artist ORDER BY year_join DESC LIMIT 1", "source_tables": ["artist"]}
{"sample_id": 1662, "db_id": "theme_gallery", "question": "Return the name of the artist who has the latest join year.", "rationale": ["Identify the table that contains the artist's name and join year, which is the 'artist' table.", "To find the artist with the latest join year, we need to sort the records by 'Year_Join' in descending order.", "Using 'ORDER BY Year_Join DESC' will arrange the artists starting from the most recent join year.", "To get only the top result (the artist with the latest join year), we will use 'LIMIT 1' to restrict the output to one record."], "pred_sql": "SELECT Name FROM artist ORDER BY Year_Join DESC LIMIT 1;", "gold_sql": "SELECT name FROM artist ORDER BY year_join DESC LIMIT 1", "source_tables": ["artist"]}
{"sample_id": 1663, "db_id": "theme_gallery", "question": "How many exhibition are there in year 2005 or after?", "rationale": ["Identify the table that contains the relevant data: the 'exhibition' table.", "Determine the column that holds the year of the exhibition: the 'Year' column.", "Formulate a condition to filter exhibitions that occurred in the year 2005 or later: 'Year >= 2005'.", "Use the COUNT() function to count the number of exhibitions that meet the condition.", "Construct the final SQL query to select the count from the exhibition table with the specified condition."], "pred_sql": "SELECT COUNT(*) AS Exhibition_Count FROM exhibition WHERE Year >= 2005;", "gold_sql": "SELECT count(*) FROM exhibition WHERE YEAR  >=  2005", "source_tables": ["exhibition"]}
{"sample_id": 1664, "db_id": "theme_gallery", "question": "Count the number of exhibitions that happened in or after 2005.", "rationale": ["Identify the table that contains the relevant data: the 'exhibition' table holds information about the exhibitions including the year they occurred.", "Determine the condition for filtering the exhibitions: we need to count exhibitions that happened in or after the year 2005.", "Construct the SQL query to count the number of records in the 'exhibition' table that meet the specified condition using COUNT(*) and a WHERE clause."], "pred_sql": "SELECT COUNT(*) AS Exhibition_Count FROM exhibition WHERE Year >= 2005;", "gold_sql": "SELECT count(*) FROM exhibition WHERE YEAR  >=  2005", "source_tables": ["exhibition"]}
{"sample_id": 1665, "db_id": "theme_gallery", "question": "Show theme and year for all exhibitions with ticket prices lower than 15.", "rationale": ["Identify the relevant table: The query requires information about exhibitions, so we will use the 'exhibition' table.", "Determine the columns needed: The user wants to see the 'Theme' and 'Year' of the exhibitions.", "Set the condition: We need to filter the exhibitions where the 'Ticket_Price' is lower than 15.", "Construct the SQL SELECT statement: We will select 'Theme' and 'Year' from the 'exhibition' table with the specified condition."], "pred_sql": "SELECT Theme, Year FROM exhibition WHERE Ticket_Price < 15;", "gold_sql": "SELECT theme ,  YEAR FROM exhibition WHERE ticket_price  <  15", "source_tables": ["exhibition"]}
{"sample_id": 1666, "db_id": "theme_gallery", "question": "What are the theme and year for all exhibitions that have a ticket price under 15?", "rationale": ["Identify the relevant table: The query is about exhibitions, so we will use the 'exhibition' table.", "Determine the columns needed: We need the 'Theme' and 'Year' columns from the 'exhibition' table.", "Specify the condition: We want exhibitions where the 'Ticket_Price' is under 15.", "Construct the SQL query: We will select 'Theme' and 'Year' from the 'exhibition' table with the specified condition."], "pred_sql": "SELECT Theme, Year FROM exhibition WHERE Ticket_Price < 15;", "gold_sql": "SELECT theme ,  YEAR FROM exhibition WHERE ticket_price  <  15", "source_tables": ["exhibition"]}
{"sample_id": 1667, "db_id": "theme_gallery", "question": "Show all artist names and the number of exhibitions for each artist.", "rationale": ["Identify the tables needed: We need data from the 'artist' table for artist names and the 'exhibition' table to count the number of exhibitions.", "Determine the relationship: The 'artist' table is linked to the 'exhibition' table through the 'Artist_ID'.", "Use a LEFT JOIN to include all artists even if they have no exhibitions, ensuring we count exhibitions correctly.", "Select the artist's name and count the number of exhibitions for each artist using COUNT() function.", "Group the results by artist to get the count of exhibitions per artist."], "pred_sql": "SELECT artist.Name, COUNT(exhibition.Exhibition_ID) AS Number_of_Exhibitions\nFROM artist\nLEFT JOIN exhibition ON artist.Artist_ID = exhibition.Artist_ID\nGROUP BY artist.Artist_ID;", "gold_sql": "SELECT T2.name ,  count(*) FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id GROUP BY T1.artist_id", "source_tables": ["artist", "exhibition"]}
{"sample_id": 1668, "db_id": "theme_gallery", "question": "How many exhibitions has each artist had?", "rationale": ["Identify the tables involved: We need data from the 'artist' and 'exhibition' tables.", "Determine the relationship: The 'artist' table has a unique identifier 'Artist_ID' that links to the 'exhibition' table.", "Count the number of exhibitions for each artist: We will use the COUNT() function to count the 'Exhibition_ID' from the 'exhibition' table.", "Group the results by artist: We will use GROUP BY on 'artist.Artist_ID' to get the count for each artist.", "Select the artist's name and the count of exhibitions: We will select 'artist.Name' and the count as 'Exhibition_Count'.", "Use LEFT JOIN to include artists with no exhibitions: This ensures that all artists are listed, even if they have zero exhibitions."], "pred_sql": "SELECT artist.Name, COUNT(exhibition.Exhibition_ID) AS Exhibition_Count\nFROM artist\nLEFT JOIN exhibition ON artist.Artist_ID = exhibition.Artist_ID\nGROUP BY artist.Artist_ID;", "gold_sql": "SELECT T2.name ,  count(*) FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id GROUP BY T1.artist_id", "source_tables": ["artist", "exhibition"]}
{"sample_id": 1669, "db_id": "theme_gallery", "question": "What is the name and country for the artist with most number of exhibitions?", "rationale": ["Identify the relevant tables: artist and exhibition.", "We need to find the artist with the most exhibitions, so we will join the artist table with the exhibition table on Artist_ID.", "We will group the results by artist to count the number of exhibitions each artist has.", "We will order the results by the count of exhibitions in descending order to get the artist with the most exhibitions at the top.", "Finally, we will limit the results to 1 to get only the top artist.", "Select the Name and Country of the artist from the result."], "pred_sql": "SELECT a.Name, a.Country FROM artist a JOIN exhibition e ON a.Artist_ID = e.Artist_ID GROUP BY a.Artist_ID ORDER BY COUNT(e.Exhibition_ID) DESC LIMIT 1;", "gold_sql": "SELECT T2.name , T2.country FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id GROUP BY T1.artist_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["artist", "exhibition"]}
{"sample_id": 1670, "db_id": "theme_gallery", "question": "Return the name and country corresponding to the artist who has had the most exhibitions.", "rationale": ["We need to find the artist with the most exhibitions.", "To do this, we will join the 'artist' table with the 'exhibition' table on the 'Artist_ID'.", "We will group the results by 'Artist_ID' to count the number of exhibitions each artist has.", "We will order the results in descending order based on the count of exhibitions.", "Finally, we will limit the results to only the top artist (the one with the most exhibitions).", "We will select the 'Name' and 'Country' of the artist in the final output."], "pred_sql": "SELECT a.Name, a.Country\nFROM artist a\nJOIN exhibition e ON a.Artist_ID = e.Artist_ID\nGROUP BY a.Artist_ID\nORDER BY COUNT(e.Exhibition_ID) DESC\nLIMIT 1;", "gold_sql": "SELECT T2.name , T2.country FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id GROUP BY T1.artist_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["artist", "exhibition"]}
{"sample_id": 1671, "db_id": "theme_gallery", "question": "Show names for artists without any exhibition.", "rationale": ["Identify the table that contains artist information, which is the 'artist' table.", "Determine the requirement to find artists without any exhibitions, which means we need to check for artists whose IDs are not present in the 'exhibition' table.", "Use a subquery to select all Artist_IDs from the 'exhibition' table.", "Use the NOT IN clause to filter out those artists from the 'artist' table whose IDs are found in the 'exhibition' table.", "Select the 'Name' column from the filtered results to get the names of artists without any exhibitions."], "pred_sql": "SELECT Name FROM artist WHERE Artist_ID NOT IN (SELECT Artist_ID FROM exhibition)", "gold_sql": "SELECT name FROM artist WHERE artist_id NOT IN (SELECT artist_id FROM exhibition)", "source_tables": ["exhibition", "artist"]}
{"sample_id": 1672, "db_id": "theme_gallery", "question": "What are the names of artists that have not had any exhibitions?", "rationale": ["Identify the main requirement: We need the names of artists who have not had any exhibitions.", "To find artists without exhibitions, we can use a subquery to select all Artist_IDs from the exhibition table.", "We will then select the names from the artist table where the Artist_ID is not in the list of Artist_IDs obtained from the exhibition table."], "pred_sql": "SELECT Name FROM artist WHERE Artist_ID NOT IN (SELECT Artist_ID FROM exhibition);", "gold_sql": "SELECT name FROM artist WHERE artist_id NOT IN (SELECT artist_id FROM exhibition)", "source_tables": ["exhibition", "artist"]}
{"sample_id": 1673, "db_id": "theme_gallery", "question": "What is the theme and artist name for the exhibition with a ticket price higher than the average?", "rationale": ["Identify the relevant tables: exhibition and artist.", "Determine the columns needed: Theme from exhibition and Name from artist.", "Establish the relationship between the tables using the Artist_ID foreign key.", "Calculate the average ticket price using a subquery: SELECT AVG(Ticket_Price) FROM exhibition.", "Filter the exhibitions where the ticket price is greater than the average ticket price.", "Combine the results using a JOIN to get the artist names corresponding to the exhibitions."], "pred_sql": "SELECT e.Theme, a.Name \nFROM exhibition e \nJOIN artist a ON e.Artist_ID = a.Artist_ID \nWHERE e.Ticket_Price > (SELECT AVG(Ticket_Price) FROM exhibition);", "gold_sql": "SELECT T1.theme ,  T2.name FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id WHERE T1.ticket_price  >  (SELECT avg(ticket_price) FROM exhibition)", "source_tables": ["artist", "exhibition"]}
{"sample_id": 1674, "db_id": "theme_gallery", "question": "Return the names of artists and the themes of their exhibitions that had a ticket price higher than average.", "rationale": ["Identify the tables involved: 'artist' and 'exhibition'.", "We need to return the names of artists and the themes of their exhibitions, so we will select 'Name' from the 'artist' table and 'Theme' from the 'exhibition' table.", "To link the two tables, we will use the 'Artist_ID' column which is common in both tables.", "We need to filter the exhibitions based on the ticket price being higher than the average ticket price.", "To find the average ticket price, we will use a subquery that calculates the average from the 'exhibition' table's 'Ticket_Price' column.", "The final SQL query will join the two tables and apply the filter for ticket price."], "pred_sql": "SELECT a.Name, e.Theme \nFROM artist a \nJOIN exhibition e ON a.Artist_ID = e.Artist_ID \nWHERE e.Ticket_Price > (SELECT AVG(Ticket_Price) FROM exhibition)", "gold_sql": "SELECT T1.theme ,  T2.name FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id WHERE T1.ticket_price  >  (SELECT avg(ticket_price) FROM exhibition)", "source_tables": ["artist", "exhibition"]}
{"sample_id": 1675, "db_id": "theme_gallery", "question": "Show the average, minimum, and maximum ticket prices for exhibitions for all years before 2009.", "rationale": ["Identify the relevant table: The 'exhibition' table contains the 'Ticket_Price' and 'Year' columns needed for the query.", "Determine the required calculations: We need to calculate the average, minimum, and maximum ticket prices.", "Set the condition for the years: We want to filter the exhibitions to only include those that occurred before 2009.", "Construct the SQL query: Use the SELECT statement to retrieve the average, minimum, and maximum ticket prices, applying the appropriate aggregate functions (AVG, MIN, MAX) and the WHERE clause for the year condition."], "pred_sql": "SELECT AVG(Ticket_Price) AS Average_Ticket_Price, MIN(Ticket_Price) AS Minimum_Ticket_Price, MAX(Ticket_Price) AS Maximum_Ticket_Price FROM exhibition WHERE Year < 2009;", "gold_sql": "SELECT avg(ticket_price) ,  min(ticket_price) ,  max(ticket_price) FROM exhibition WHERE YEAR  <  2009", "source_tables": ["exhibition"]}
{"sample_id": 1676, "db_id": "theme_gallery", "question": "What are the average, minimum, and maximum ticket prices for exhibitions that happened prior to 2009?", "rationale": ["Identify the relevant table: The 'exhibition' table contains the 'Ticket_Price' and 'Year' columns needed for the query.", "Determine the conditions: We need to filter exhibitions that occurred prior to the year 2009.", "Select the required statistics: We need to calculate the average, minimum, and maximum ticket prices for the filtered exhibitions.", "Construct the SQL query: Use the SELECT statement to retrieve the average, minimum, and maximum ticket prices, applying the appropriate aggregate functions (AVG, MIN, MAX) and the WHERE clause for the year condition."], "pred_sql": "SELECT AVG(Ticket_Price) AS Average_Ticket_Price, MIN(Ticket_Price) AS Minimum_Ticket_Price, MAX(Ticket_Price) AS Maximum_Ticket_Price FROM exhibition WHERE Year < 2009;", "gold_sql": "SELECT avg(ticket_price) ,  min(ticket_price) ,  max(ticket_price) FROM exhibition WHERE YEAR  <  2009", "source_tables": ["exhibition"]}
{"sample_id": 1677, "db_id": "theme_gallery", "question": "Show theme and year for all exhibitions in an descending order of ticket price.", "rationale": ["Identify the relevant table: The query requires information about exhibitions, so we will use the 'exhibition' table.", "Determine the required columns: The user wants to see the 'Theme' and 'Year' of the exhibitions.", "Specify the sorting order: The exhibitions should be ordered by 'Ticket_Price' in descending order.", "Construct the SQL query: We will select the 'Theme' and 'Year' from the 'exhibition' table and order the results by 'Ticket_Price' in descending order."], "pred_sql": "SELECT Theme, Year FROM exhibition ORDER BY Ticket_Price DESC;", "gold_sql": "SELECT theme ,  YEAR FROM exhibition ORDER BY ticket_price DESC", "source_tables": ["exhibition"]}
{"sample_id": 1678, "db_id": "theme_gallery", "question": "What are the themes and years for exhibitions, sorted by ticket price descending?", "rationale": ["Identify the relevant table: The query requires information about exhibitions, which is found in the 'exhibition' table.", "Determine the required columns: The user wants to know the 'Theme' and 'Year' of the exhibitions.", "Sort the results: The user requests the results to be sorted by 'Ticket_Price' in descending order.", "Construct the SQL query: Use SELECT to choose the 'Theme' and 'Year' from the 'exhibition' table, and apply ORDER BY to sort by 'Ticket_Price' in descending order."], "pred_sql": "SELECT Theme, Year FROM exhibition ORDER BY Ticket_Price DESC;", "gold_sql": "SELECT theme ,  YEAR FROM exhibition ORDER BY ticket_price DESC", "source_tables": ["exhibition"]}
{"sample_id": 1679, "db_id": "theme_gallery", "question": "What is the theme, date, and attendance for the exhibition in year 2004?", "rationale": ["Identify the relevant tables: exhibition and exhibition_record.", "Determine the columns needed: Theme from exhibition, Date and Attendance from exhibition_record.", "Establish the relationship between the tables using the Exhibition_ID foreign key.", "Filter the results to only include exhibitions from the year 2004."], "pred_sql": "SELECT exhibition.Theme, exhibition_record.Date, exhibition_record.Attendance \nFROM exhibition \nJOIN exhibition_record ON exhibition.Exhibition_ID = exhibition_record.Exhibition_ID \nWHERE exhibition.Year = 2004;", "gold_sql": "SELECT T2.theme ,  T1.date ,  T1.attendance FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T2.year  =  2004", "source_tables": ["exhibition", "exhibition_record"]}
{"sample_id": 1680, "db_id": "theme_gallery", "question": "Return the themes, dates, and attendance for exhibitions that happened in 2004.", "rationale": ["Identify the relevant tables: exhibition and exhibition_record.", "Determine the columns needed: Theme from exhibition, Date and Attendance from exhibition_record.", "Establish the relationship between the tables using the Exhibition_ID foreign key.", "Filter the results to include only those exhibitions that occurred in the year 2004."], "pred_sql": "SELECT exhibition.Theme, exhibition_record.Date, exhibition_record.Attendance \nFROM exhibition \nJOIN exhibition_record ON exhibition.Exhibition_ID = exhibition_record.Exhibition_ID \nWHERE exhibition.Year = 2004;", "gold_sql": "SELECT T2.theme ,  T1.date ,  T1.attendance FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T2.year  =  2004", "source_tables": ["exhibition", "exhibition_record"]}
{"sample_id": 1681, "db_id": "theme_gallery", "question": "Show all artist names who didn't have an exhibition in 2004.", "rationale": ["Identify the main requirement: to find artist names who did not have an exhibition in 2004.", "To achieve this, we need to select names from the artist table.", "We need to filter out artists who had exhibitions in 2004. This requires a subquery.", "The subquery will select Artist_IDs from the exhibition table where the Year is 2004.", "The main query will then select names from the artist table where the Artist_ID is not in the list returned by the subquery."], "pred_sql": "SELECT Name FROM artist WHERE Artist_ID NOT IN (SELECT Artist_ID FROM exhibition WHERE Year = 2004);", "gold_sql": "SELECT name FROM artist EXCEPT SELECT T2.name FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id WHERE T1.year  =  2004", "source_tables": ["exhibition", "artist"]}
{"sample_id": 1682, "db_id": "theme_gallery", "question": "What are the names of artists who did not have an exhibition in 2004?", "rationale": ["Identify the main requirement: We need the names of artists who did not have an exhibition in 2004.", "To find this, we first need to identify which artists had exhibitions in 2004. This can be done by selecting the Artist_ID from the exhibition table where the Year is 2004.", "Next, we need to select the names of artists from the artist table whose Artist_ID is not in the list of Artist_IDs obtained from the previous step.", "The final SQL query combines these steps using a subquery to filter out the artists who had exhibitions in 2004."], "pred_sql": "SELECT Name FROM artist WHERE Artist_ID NOT IN (SELECT Artist_ID FROM exhibition WHERE Year = 2004);", "gold_sql": "SELECT name FROM artist EXCEPT SELECT T2.name FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id WHERE T1.year  =  2004", "source_tables": ["exhibition", "artist"]}
{"sample_id": 1683, "db_id": "theme_gallery", "question": "Show the theme for exhibitions with both records of an attendance below 100 and above 500.", "rationale": ["Identify the tables involved: 'exhibition' and 'exhibition_record'.", "Determine the columns needed: 'Theme' from 'exhibition' and 'Attendance' from 'exhibition_record'.", "Establish the relationship between the tables using the foreign key: 'exhibition.Exhibition_ID' links to 'exhibition_record.Exhibition_ID'.", "Set the conditions for attendance: we want records where attendance is either below 100 or above 500.", "Use DISTINCT to ensure unique themes are returned, as multiple records may exist for the same theme."], "pred_sql": "SELECT DISTINCT e.Theme FROM exhibition e JOIN exhibition_record er ON e.Exhibition_ID = er.Exhibition_ID WHERE er.Attendance < 100 OR er.Attendance > 500;", "gold_sql": "SELECT T2.theme FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T1.attendance  <  100 INTERSECT SELECT T2.theme FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T1.attendance  >  500", "source_tables": ["exhibition", "exhibition_record"]}
{"sample_id": 1684, "db_id": "theme_gallery", "question": "Which themes have had corresponding exhibitions that have had attendance both below 100 and above 500?", "rationale": ["Identify the relevant tables: We need to look at the 'exhibition' and 'exhibition_record' tables since we are interested in themes and attendance.", "Join the tables: We will join 'exhibition' and 'exhibition_record' on 'Exhibition_ID' to correlate exhibitions with their attendance records.", "Filter the attendance: We need to filter the records to find those with attendance both below 100 and above 500. This requires using a conditional count in the HAVING clause.", "Group by theme: We will group the results by the 'Theme' column to aggregate the attendance data for each theme.", "Use HAVING clause: We will use the HAVING clause to ensure that each theme has at least one exhibition with attendance below 100 and at least one with attendance above 500."], "pred_sql": "SELECT DISTINCT e.Theme\nFROM exhibition e\nJOIN exhibition_record er ON e.Exhibition_ID = er.Exhibition_ID\nWHERE er.Attendance < 100 OR er.Attendance > 500\nGROUP BY e.Theme\nHAVING COUNT(CASE WHEN er.Attendance < 100 THEN 1 END) > 0\n   AND COUNT(CASE WHEN er.Attendance > 500 THEN 1 END) > 0;", "gold_sql": "SELECT T2.theme FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T1.attendance  <  100 INTERSECT SELECT T2.theme FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T1.attendance  >  500", "source_tables": ["exhibition", "exhibition_record"]}
{"sample_id": 1685, "db_id": "theme_gallery", "question": "How many exhibitions have a attendance more than 100 or have a ticket price below 10?", "rationale": ["Identify the tables involved: exhibition and exhibition_record.", "Determine the relevant columns: Attendance from exhibition_record and Ticket_Price from exhibition.", "Establish the condition for counting: Attendance greater than 100 or Ticket_Price less than 10.", "Use a JOIN to connect exhibition and exhibition_record on Exhibition_ID.", "Count the number of records that meet the specified conditions."], "pred_sql": "SELECT COUNT(*) FROM exhibition e JOIN exhibition_record er ON e.Exhibition_ID = er.Exhibition_ID WHERE er.Attendance > 100 OR e.Ticket_Price < 10;", "gold_sql": "SELECT count(*) FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T1.attendance  >  100 OR T2.ticket_price  <  10", "source_tables": ["exhibition", "exhibition_record"]}
{"sample_id": 1686, "db_id": "theme_gallery", "question": "Count the number of exhibitions that have had an attendnance of over 100 or a ticket prices under 10.", "rationale": ["Identify the tables involved: exhibition and exhibition_record.", "Determine the columns needed: we need to count exhibitions based on attendance and ticket price.", "Join the exhibition and exhibition_record tables on Exhibition_ID to access both attendance and ticket price.", "Set the conditions for counting: attendance must be greater than 100 or ticket price must be less than 10.", "Use COUNT(*) to get the total number of exhibitions that meet the criteria."], "pred_sql": "SELECT COUNT(*) FROM exhibition e JOIN exhibition_record er ON e.Exhibition_ID = er.Exhibition_ID WHERE er.Attendance > 100 OR e.Ticket_Price < 10;", "gold_sql": "SELECT count(*) FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id WHERE T1.attendance  >  100 OR T2.ticket_price  <  10", "source_tables": ["exhibition", "exhibition_record"]}
{"sample_id": 1687, "db_id": "theme_gallery", "question": "Show all artist names with an average exhibition attendance over 200.", "rationale": ["We need to retrieve the names of artists who have an average exhibition attendance over 200.", "To do this, we will join the 'artist', 'exhibition', and 'exhibition_record' tables based on their relationships.", "The 'artist' table will provide the artist names, the 'exhibition' table will link artists to their exhibitions, and the 'exhibition_record' table will provide attendance data for those exhibitions.", "We will group the results by artist to calculate the average attendance for each artist.", "Finally, we will use the HAVING clause to filter out artists whose average attendance is 200 or less."], "pred_sql": "SELECT a.Name \nFROM artist a \nJOIN exhibition e ON a.Artist_ID = e.Artist_ID \nJOIN exhibition_record er ON e.Exhibition_ID = er.Exhibition_ID \nGROUP BY a.Artist_ID \nHAVING AVG(er.Attendance) > 200;", "gold_sql": "SELECT T3.name FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id JOIN artist AS T3 ON T3.artist_id  =  T2.artist_id GROUP BY T3.artist_id HAVING avg(T1.attendance)  >  200", "source_tables": ["artist", "exhibition", "exhibition_record"]}
{"sample_id": 1688, "db_id": "theme_gallery", "question": "What are the names of artist whose exhibitions draw over 200 attendees on average?", "rationale": ["Identify the tables involved: artist, exhibition, and exhibition_record.", "We need to find artists whose exhibitions have an average attendance of over 200.", "Join the artist table with the exhibition table on Artist_ID to link artists to their exhibitions.", "Join the exhibition table with the exhibition_record table on Exhibition_ID to access attendance data.", "Group the results by artist to calculate the average attendance for each artist's exhibitions.", "Use the HAVING clause to filter the groups where the average attendance exceeds 200."], "pred_sql": "SELECT a.Name FROM artist a JOIN exhibition e ON a.Artist_ID = e.Artist_ID JOIN exhibition_record er ON e.Exhibition_ID = er.Exhibition_ID GROUP BY a.Artist_ID HAVING AVG(er.Attendance) > 200;", "gold_sql": "SELECT T3.name FROM exhibition_record AS T1 JOIN exhibition AS T2 ON T1.exhibition_id  =  T2.exhibition_id JOIN artist AS T3 ON T3.artist_id  =  T2.artist_id GROUP BY T3.artist_id HAVING avg(T1.attendance)  >  200", "source_tables": ["artist", "exhibition", "exhibition_record"]}
{"sample_id": 1689, "db_id": "epinions_1", "question": "Find the id of the item whose title is \"orange\".", "rationale": ["Identify the table that contains the title of the item, which is the 'item' table.", "Determine the column that holds the title, which is 'title'.", "Formulate a SELECT statement to retrieve the 'i_id' of the item.", "Add a WHERE clause to filter the results to only include the item with the title 'orange'."], "pred_sql": "SELECT i_id FROM item WHERE title = 'orange';", "gold_sql": "SELECT i_id FROM item WHERE title  =  'orange'", "source_tables": ["item"]}
{"sample_id": 1690, "db_id": "epinions_1", "question": "List all information in the item table.", "rationale": ["The user wants to list all information from the item table.", "To retrieve all columns from a table in SQL, we use the SELECT statement followed by an asterisk (*) which represents all columns.", "The table we are querying is 'item'.", "Therefore, the complete SQL query is 'SELECT * FROM item;'"], "pred_sql": "SELECT * FROM item;", "gold_sql": "SELECT * FROM item", "source_tables": ["item"]}
{"sample_id": 1691, "db_id": "epinions_1", "question": "Find the number of reviews.", "rationale": ["Identify the goal: We need to find the number of reviews.", "Determine the relevant table: The 'review' table contains all the reviews.", "Use the COUNT() function to count the total number of entries in the 'review' table.", "Construct the SQL query to select the count from the review table."], "pred_sql": "SELECT COUNT(*) AS number_of_reviews FROM review;", "gold_sql": "SELECT count(*) FROM review", "source_tables": ["review"]}
{"sample_id": 1692, "db_id": "epinions_1", "question": "How many users are there?", "rationale": ["Identify the goal of the query: to count the number of users.", "Determine the relevant table: the 'useracct' table contains user information.", "Use the COUNT() function to count the total number of entries in the 'useracct' table.", "Construct the SQL query to select the count from the 'useracct' table."], "pred_sql": "SELECT COUNT(*) AS user_count FROM useracct;", "gold_sql": "SELECT count(*) FROM useracct", "source_tables": ["useracct"]}
{"sample_id": 1693, "db_id": "epinions_1", "question": "Find the average and maximum rating of all reviews.", "rationale": ["Identify the required calculations: average and maximum ratings.", "Determine the relevant table: the 'review' table contains the ratings.", "Use the AVG() function to calculate the average rating and the MAX() function to find the maximum rating.", "Construct the SQL query to select the average and maximum ratings from the review table."], "pred_sql": "SELECT AVG(rating) AS average_rating, MAX(rating) AS maximum_rating FROM review;", "gold_sql": "SELECT avg(rating) ,  max(rating) FROM review", "source_tables": ["review"]}
{"sample_id": 1694, "db_id": "epinions_1", "question": "Find the highest rank of all reviews.", "rationale": ["Identify the table that contains the rank information, which is the 'review' table.", "To find the highest rank, we need to use the MAX() function, which returns the maximum value of a specified column.", "We will select the 'rank' column from the 'review' table and apply the MAX() function to it.", "The final SQL query will select the maximum rank from the review table."], "pred_sql": "SELECT MAX(rank) AS highest_rank FROM review;", "gold_sql": "SELECT min(rank) FROM review", "source_tables": ["review"]}
{"sample_id": 1695, "db_id": "epinions_1", "question": "How many different users wrote some reviews?", "rationale": ["Identify the table that contains user information related to reviews, which is the 'review' table.", "To find out how many different users wrote reviews, we need to count distinct user IDs (u_id) in the 'review' table.", "Use the COUNT function to count the distinct user IDs.", "The final SQL query selects the count of distinct user IDs from the 'review' table."], "pred_sql": "SELECT COUNT(DISTINCT u_id) AS different_users FROM review;", "gold_sql": "SELECT count(DISTINCT u_id) FROM review", "source_tables": ["review"]}
{"sample_id": 1696, "db_id": "epinions_1", "question": "How many different items were reviewed by some users?", "rationale": ["Identify the relevant table: The 'review' table contains the information about the items that have been reviewed.", "Determine the requirement: We need to count the number of different items that have been reviewed by users.", "Use the COUNT function: To count the distinct items, we will use COUNT(DISTINCT i_id).", "Formulate the SQL query: The query will select the count of distinct item IDs from the review table."], "pred_sql": "SELECT COUNT(DISTINCT i_id) AS different_items_reviewed FROM review;", "gold_sql": "SELECT count(DISTINCT i_id) FROM review", "source_tables": ["review"]}
{"sample_id": 1697, "db_id": "epinions_1", "question": "Find the number of items that did not receive any review.", "rationale": ["Identify the main goal: Count the number of items without any reviews.", "To find items without reviews, we need to check which item IDs in the 'item' table do not exist in the 'review' table.", "Use a subquery to select all item IDs from the 'review' table.", "Use the NOT IN clause to filter out those item IDs from the 'item' table.", "Finally, count the remaining items that do not have any reviews."], "pred_sql": "SELECT COUNT(*) AS num_items_without_reviews FROM item WHERE i_id NOT IN (SELECT i_id FROM review);", "gold_sql": "SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)", "source_tables": ["review", "item"]}
{"sample_id": 1698, "db_id": "epinions_1", "question": "Find the names of users who did not leave any review.", "rationale": ["Identify the table that contains user information, which is 'useracct'.", "We need to find users who did not leave any review, so we will look for users whose 'u_id' is not present in the 'review' table.", "To achieve this, we can use a subquery that selects all 'u_id' from the 'review' table.", "The main query will select 'name' from 'useracct' where 'u_id' is not in the list of 'u_id' from the subquery."], "pred_sql": "SELECT name FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)", "gold_sql": "SELECT name FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)", "source_tables": ["useracct", "review"]}
{"sample_id": 1699, "db_id": "epinions_1", "question": "Find the names of goods that receive a rating of 10.", "rationale": ["Identify the tables involved: We need to get the names of goods (items) and their ratings, which involves the 'item' and 'review' tables.", "Determine the relationship: The 'item' table has a unique identifier 'i_id' that corresponds to 'i_id' in the 'review' table, allowing us to join these tables.", "Specify the condition: We are interested in items that have a rating of 10, so we will filter the results based on the 'rating' column in the 'review' table.", "Construct the SQL query: We will select the 'title' from the 'item' table, joining it with the 'review' table on 'i_id', and applying the condition for the rating."], "pred_sql": "SELECT item.title FROM item JOIN review ON item.i_id = review.i_id WHERE review.rating = 10;", "gold_sql": "SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id WHERE T2.rating  =  10", "source_tables": ["review", "item"]}
{"sample_id": 1700, "db_id": "epinions_1", "question": "Find the titles of items whose rating is higher than the average review rating of all items.", "rationale": ["Identify the tables involved: 'item' and 'review'.", "We need to find item titles, so we will select 'item.title'.", "We need to join the 'item' table with the 'review' table on the common column 'i_id'.", "We need to filter the results where the rating of the review is greater than the average rating of all reviews.", "To find the average rating, we will use a subquery: SELECT AVG(rating) FROM review.", "Combine all these elements into a SQL query."], "pred_sql": "SELECT item.title FROM item JOIN review ON item.i_id = review.i_id WHERE review.rating > (SELECT AVG(rating) FROM review);", "gold_sql": "SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id WHERE T2.rating  >  (SELECT avg(rating) FROM review)", "source_tables": ["review", "item"]}
{"sample_id": 1701, "db_id": "epinions_1", "question": "Find the titles of items that received any rating below 5.", "rationale": ["Identify the tables involved: We need to get item titles, which are in the 'item' table, and we need to check ratings, which are in the 'review' table.", "Determine the relationship between the tables: The 'review' table has a foreign key 'i_id' that references 'item.i_id', allowing us to join these two tables.", "Formulate the SQL query: We will select the 'title' from the 'item' table where the corresponding 'rating' in the 'review' table is less than 5.", "Construct the JOIN clause to combine the 'item' and 'review' tables based on the 'i_id' field.", "Add the WHERE clause to filter for ratings below 5."], "pred_sql": "SELECT item.title FROM item JOIN review ON item.i_id = review.i_id WHERE review.rating < 5;", "gold_sql": "SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id WHERE T2.rating  <  5", "source_tables": ["review", "item"]}
{"sample_id": 1702, "db_id": "epinions_1", "question": "Find the titles of items that received both a rating higher than 8 and a rating below 5.", "rationale": ["Identify the tables involved: We need to get item titles, so we will use the 'item' table and the 'review' table to filter based on ratings.", "Determine the conditions for filtering: We need items that have ratings higher than 8 or ratings below 5.", "Join the 'item' and 'review' tables on the item identifier (i_id) to access both item titles and their corresponding ratings.", "Use a SELECT statement to retrieve the distinct titles of items that meet the rating conditions."], "pred_sql": "SELECT DISTINCT item.title FROM item JOIN review ON item.i_id = review.i_id WHERE review.rating > 8 OR review.rating < 5;", "gold_sql": "SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id WHERE T2.rating  >  8 INTERSECT SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id WHERE T2.rating  <  5", "source_tables": ["review", "item"]}
{"sample_id": 1703, "db_id": "epinions_1", "question": "Find the names of items whose rank is higher than 3 and whose average rating is above 5.", "rationale": ["We need to find items based on their rank and average rating.", "First, we will select the title of the items from the 'item' table.", "We will join the 'item' table with the 'review' table on the item identifier (i_id).", "Next, we will group the results by item identifier to calculate the average rating for each item.", "We will use the HAVING clause to filter the results based on two conditions: the average rating must be greater than 5 and the maximum rank must be greater than 3.", "Finally, we will select the titles of the items that meet these criteria."], "pred_sql": "SELECT item.title\nFROM item\nJOIN review ON item.i_id = review.i_id\nGROUP BY item.i_id\nHAVING AVG(review.rating) > 5 AND MAX(review.rank) > 3;", "gold_sql": "SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id WHERE T2.rank  >  3 INTERSECT SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id GROUP BY T2.i_id HAVING avg(T2.rating)  >  5", "source_tables": ["review", "item"]}
{"sample_id": 1704, "db_id": "epinions_1", "question": "Find the name of the item with the lowest average rating.", "rationale": ["We need to find the item with the lowest average rating.", "To do this, we will join the 'item' table with the 'review' table on the item identifier (i_id).", "Next, we will group the results by the item identifier to calculate the average rating for each item.", "We will then order the results by the average rating in ascending order to get the item with the lowest average rating at the top.", "Finally, we will limit the results to just one item to get the name of the item with the lowest average rating."], "pred_sql": "SELECT item.title FROM item JOIN review ON item.i_id = review.i_id GROUP BY item.i_id ORDER BY AVG(review.rating) ASC LIMIT 1;", "gold_sql": "SELECT T1.title FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id GROUP BY T2.i_id ORDER BY avg(T2.rating) LIMIT 1", "source_tables": ["review", "item"]}
{"sample_id": 1705, "db_id": "epinions_1", "question": "List the titles of all items in alphabetic order .", "rationale": ["Identify the table that contains the item titles, which is the 'item' table.", "Determine the column that holds the titles, which is 'title'.", "Specify that we want to select the 'title' column from the 'item' table.", "To list the titles in alphabetic order, use the ORDER BY clause with 'title' and specify ASC for ascending order."], "pred_sql": "SELECT title FROM item ORDER BY title ASC;", "gold_sql": "SELECT title FROM item ORDER BY title", "source_tables": ["item"]}
{"sample_id": 1706, "db_id": "epinions_1", "question": "Find the name of the user who gives the most reviews.", "rationale": ["Identify the relevant tables: useracct (for user names) and review (for reviews).", "Join the useracct table with the review table on the user ID (u_id) to associate users with their reviews.", "Group the results by user ID to aggregate the number of reviews each user has given.", "Count the number of reviews for each user using COUNT(r.a_id).", "Order the results in descending order to find the user with the most reviews.", "Limit the results to 1 to get only the top user."], "pred_sql": "SELECT u.name FROM useracct u JOIN review r ON u.u_id = r.u_id GROUP BY u.u_id ORDER BY COUNT(r.a_id) DESC LIMIT 1;", "gold_sql": "SELECT T1.name FROM useracct AS T1 JOIN review AS T2 ON T1.u_id  =  T2.u_id GROUP BY T2.u_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["useracct", "review"]}
{"sample_id": 1707, "db_id": "epinions_1", "question": "Find the name and id of the item with the highest average rating.", "rationale": ["We need to find the item with the highest average rating.", "To do this, we will join the 'item' table with the 'review' table on the item ID ('i_id').", "Next, we will group the results by the item ID to calculate the average rating for each item.", "We will use the AVG() function to compute the average rating for each item.", "To find the item with the highest average rating, we will order the results in descending order based on the average rating.", "Finally, we will limit the results to only one item using LIMIT 1."], "pred_sql": "SELECT item.title, item.i_id FROM item JOIN review ON item.i_id = review.i_id GROUP BY item.i_id ORDER BY AVG(review.rating) DESC LIMIT 1;", "gold_sql": "SELECT T1.title ,  T1.i_id FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id GROUP BY T2.i_id ORDER BY avg(T2.rating) DESC LIMIT 1", "source_tables": ["review", "item"]}
{"sample_id": 1708, "db_id": "epinions_1", "question": "Find the name and id of the good with the highest average rank.", "rationale": ["Identify the tables involved: We need data from the 'item' and 'review' tables.", "Determine the required fields: We need the 'title' and 'i_id' from the 'item' table.", "Calculate the average rank: We need to calculate the average rank of reviews for each item, which requires grouping by 'item.i_id'.", "Sort the results: We need to sort the items by their average rank in descending order to find the highest average rank.", "Limit the results: We only need the item with the highest average rank, so we will limit the results to 1."], "pred_sql": "SELECT item.title, item.i_id FROM item JOIN review ON item.i_id = review.i_id GROUP BY item.i_id ORDER BY AVG(review.rank) DESC LIMIT 1;", "gold_sql": "SELECT T1.title ,  T1.i_id FROM item AS T1 JOIN review AS T2 ON T1.i_id  =  T2.i_id GROUP BY T2.i_id ORDER BY avg(T2.rank) DESC LIMIT 1", "source_tables": ["review", "item"]}
{"sample_id": 1709, "db_id": "epinions_1", "question": "For each user, return the name and the average rating of reviews given by them.", "rationale": ["Identify the tables needed: We need user names from the 'useracct' table and ratings from the 'review' table.", "Determine the relationship: The 'review' table has a foreign key 'u_id' that links to 'useracct'.", "Select the required fields: We need the user's name and the average rating of their reviews.", "Use the AVG() function to calculate the average rating for each user.", "Group the results by user ID to ensure we get one average rating per user."], "pred_sql": "SELECT u.name, AVG(r.rating) AS average_rating\nFROM useracct u\nJOIN review r ON u.u_id = r.u_id\nGROUP BY u.u_id;", "gold_sql": "SELECT T1.name ,  avg(T2.rating) FROM useracct AS T1 JOIN review AS T2 ON T1.u_id  =  T2.u_id GROUP BY T2.u_id", "source_tables": ["useracct", "review"]}
{"sample_id": 1710, "db_id": "epinions_1", "question": "For each user, find their name and the number of reviews written by them.", "rationale": ["Identify the tables needed: useracct for user names and review for counting reviews.", "We need to count the number of reviews written by each user, which requires a join between useracct and review on the user ID (u_id).", "Use a LEFT JOIN to ensure that users with zero reviews are still included in the results.", "Select the user's name from useracct and count the review IDs from review to get the number of reviews.", "Group the results by user ID to aggregate the count of reviews for each user."], "pred_sql": "SELECT useracct.name, COUNT(review.a_id) AS review_count\nFROM useracct\nLEFT JOIN review ON useracct.u_id = review.u_id\nGROUP BY useracct.u_id;", "gold_sql": "SELECT T1.name ,  count(*) FROM useracct AS T1 JOIN review AS T2 ON T1.u_id  =  T2.u_id GROUP BY T2.u_id", "source_tables": ["useracct", "review"]}
{"sample_id": 1711, "db_id": "epinions_1", "question": "Find the name of the user who gave the highest rating.", "rationale": ["Identify the relevant tables: useracct and review.", "We need to find the user who gave the highest rating, so we will join the useracct table with the review table on the user ID (u_id).", "To find the highest rating, we will use a subquery that selects the maximum rating from the review table.", "Finally, we will select the name of the user from the useracct table where the rating matches the maximum rating found in the subquery."], "pred_sql": "SELECT u.name FROM useracct u JOIN review r ON u.u_id = r.u_id WHERE r.rating = (SELECT MAX(rating) FROM review)", "gold_sql": "SELECT T1.name FROM useracct AS T1 JOIN review AS T2 ON T1.u_id  =  T2.u_id ORDER BY T2.rating DESC LIMIT 1", "source_tables": ["useracct", "review"]}
{"sample_id": 1712, "db_id": "epinions_1", "question": "Find the name of the source user with the highest average trust score.", "rationale": ["Identify the relevant tables: useracct and trust.", "We need to calculate the average trust score for each source user, so we will use the trust table and group by source_u_id.", "Use the AVG() function to calculate the average trust score for each source user.", "Join the result with the useracct table to get the names of the users.", "Order the results by average trust score in descending order to find the highest.", "Limit the results to 1 to get only the user with the highest average trust score."], "pred_sql": "SELECT ua.name\nFROM useracct ua\nJOIN (\n    SELECT source_u_id, AVG(trust) AS avg_trust\n    FROM trust\n    GROUP BY source_u_id\n) AS avg_trusts ON ua.u_id = avg_trusts.source_u_id\nORDER BY avg_trust DESC\nLIMIT 1;", "gold_sql": "SELECT T1.name FROM useracct AS T1 JOIN trust AS T2 ON T1.u_id  =  T2.source_u_id GROUP BY T2.source_u_id ORDER BY avg(trust) DESC LIMIT 1", "source_tables": ["trust", "useracct"]}
{"sample_id": 1713, "db_id": "epinions_1", "question": "Find each target user's name and average trust score.", "rationale": ["Identify the tables needed: useracct for user names and trust for trust scores.", "We need to join the useracct table with the trust table on the user ID, specifically matching useracct.u_id with trust.target_u_id.", "We want to select the user's name from useracct and the average trust score from trust.", "To calculate the average trust score, we will use the AVG() function on the trust column.", "Finally, we need to group the results by the user ID to ensure we get the average trust score for each user."], "pred_sql": "SELECT u.name, AVG(t.trust) AS average_trust_score\nFROM useracct u\nJOIN trust t ON u.u_id = t.target_u_id\nGROUP BY u.u_id;", "gold_sql": "SELECT T1.name ,  avg(trust) FROM useracct AS T1 JOIN trust AS T2 ON T1.u_id  =  T2.target_u_id GROUP BY T2.target_u_id", "source_tables": ["trust", "useracct"]}
{"sample_id": 1714, "db_id": "epinions_1", "question": "Find the name of the target user with the lowest trust score.", "rationale": ["Identify the relevant tables: useracct (for user names) and trust (for trust scores).", "Join the useracct table with the trust table on the user ID (u_id) to associate user names with their trust scores.", "Order the results by the trust score in ascending order to find the lowest trust score.", "Limit the results to 1 to get only the target user with the lowest trust score."], "pred_sql": "SELECT u.name FROM useracct u JOIN trust t ON u.u_id = t.target_u_id ORDER BY t.trust ASC LIMIT 1;", "gold_sql": "SELECT T1.name FROM useracct AS T1 JOIN trust AS T2 ON T1.u_id  =  T2.target_u_id ORDER BY trust LIMIT 1", "source_tables": ["trust", "useracct"]}
{"sample_id": 1715, "db_id": "epinions_1", "question": "Find the names of the items that did not receive any review.", "rationale": ["Identify the main goal: We need to find items that did not receive any reviews.", "To achieve this, we will look at the 'item' table to get the titles of the items.", "We will also need to check the 'review' table to find out which items have received reviews.", "We can use a subquery to select all 'i_id's from the 'review' table.", "The main query will select titles from the 'item' table where the 'i_id' is not in the list of 'i_id's from the 'review' table."], "pred_sql": "SELECT title FROM item WHERE i_id NOT IN (SELECT i_id FROM review);", "gold_sql": "SELECT title FROM item WHERE i_id NOT IN (SELECT i_id FROM review)", "source_tables": ["review", "item"]}
{"sample_id": 1716, "db_id": "epinions_1", "question": "Find the names of users who did not leave any review.", "rationale": ["Identify the table that contains user information, which is 'useracct'.", "We need to find users who did not leave any review, so we will look for users whose 'u_id' is not present in the 'review' table.", "To achieve this, we can use a subquery that selects all 'u_id' from the 'review' table.", "The main query will select 'name' from 'useracct' where 'u_id' is not in the list of 'u_id' from the subquery."], "pred_sql": "SELECT name FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)", "gold_sql": "SELECT name FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)", "source_tables": ["useracct", "review"]}
{"sample_id": 1717, "db_id": "epinions_1", "question": "Find the number of users who did not write any review.", "rationale": ["Identify the table that contains user information, which is 'useracct'.", "We need to find users who did not write any reviews, so we will look for users whose 'u_id' is not present in the 'review' table.", "To achieve this, we can use a subquery that selects distinct 'u_id' from the 'review' table.", "The main query will count the number of users in 'useracct' whose 'u_id' is not in the list of 'u_id' from the 'review' table."], "pred_sql": "SELECT COUNT(*) AS num_users_without_reviews\nFROM useracct\nWHERE u_id NOT IN (SELECT DISTINCT u_id FROM review);", "gold_sql": "SELECT count(*) FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)", "source_tables": ["useracct", "review"]}
{"sample_id": 1718, "db_id": "epinions_1", "question": "Find the number of items without any review.", "rationale": ["Identify the main goal: Count the number of items that do not have any reviews.", "To find items without reviews, we need to check which item IDs in the 'item' table do not exist in the 'review' table.", "We can achieve this by using a subquery that selects all distinct item IDs from the 'review' table.", "The main query will count all items in the 'item' table whose IDs are not in the list of IDs returned by the subquery."], "pred_sql": "SELECT COUNT(*) AS num_items_without_reviews FROM item WHERE i_id NOT IN (SELECT DISTINCT i_id FROM review);", "gold_sql": "SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)", "source_tables": ["review", "item"]}
{"sample_id": 1719, "db_id": "riding_club", "question": "How many players are there?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "To find out how many players there are, we need to count the number of entries in the 'player' table.", "Use the COUNT() function to count all rows in the 'player' table.", "Select the count with an alias 'player_count' for clarity."], "pred_sql": "SELECT COUNT(*) AS player_count FROM player;", "gold_sql": "SELECT count(*) FROM player", "source_tables": ["player"]}
{"sample_id": 1720, "db_id": "riding_club", "question": "List the names of players in ascending order of votes.", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the column that contains the names of the players, which is 'Player_name'.", "Identify the column that contains the votes received by the players, which is 'Votes'.", "Construct a SQL SELECT statement to retrieve the 'Player_name' from the 'player' table.", "Add an ORDER BY clause to sort the results in ascending order based on the 'Votes' column."], "pred_sql": "SELECT Player_name FROM player ORDER BY Votes ASC;", "gold_sql": "SELECT Player_name FROM player ORDER BY Votes ASC", "source_tables": ["player"]}
{"sample_id": 1721, "db_id": "riding_club", "question": "What are the gender and occupation of players?", "rationale": ["Identify the relevant table: The 'player' table contains the information about players, including their gender and occupation.", "Determine the required columns: The user requested the gender and occupation of players, which are the 'Gender' and 'Occupation' columns in the 'player' table.", "Construct the SQL SELECT statement: Use SELECT to specify the columns to retrieve, and FROM to specify the table from which to retrieve the data."], "pred_sql": "SELECT Gender, Occupation FROM player;", "gold_sql": "SELECT Gender ,  Occupation FROM player", "source_tables": ["player"]}
{"sample_id": 1722, "db_id": "riding_club", "question": "List the name and residence for players whose occupation is not \"Researcher\".", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the columns needed for the output: 'Player_name' and 'Residence'.", "Specify the condition that the 'Occupation' should not be 'Researcher'.", "Construct the SQL SELECT statement to retrieve the required columns from the 'player' table with the specified condition."], "pred_sql": "SELECT Player_name, Residence FROM player WHERE Occupation != 'Researcher';", "gold_sql": "SELECT Player_name ,  residence FROM player WHERE Occupation != 'Researcher'", "source_tables": ["player"]}
{"sample_id": 1723, "db_id": "riding_club", "question": "Show the names of sponsors of players whose residence is either \"Brandon\" or \"Birtle\".", "rationale": ["Identify the table that contains the information about players and their sponsors, which is the 'player' table.", "Determine the relevant column for the sponsor's name, which is 'Sponsor_name'.", "Identify the column that contains the residence information, which is 'Residence'.", "Specify the condition to filter players based on their residence being either 'Brandon' or 'Birtle'.", "Use the SQL 'IN' clause to check for multiple values in the 'Residence' column.", "Construct the SQL SELECT statement to retrieve the 'Sponsor_name' from the 'player' table based on the specified conditions."], "pred_sql": "SELECT Sponsor_name FROM player WHERE Residence IN ('Brandon', 'Birtle');", "gold_sql": "SELECT Sponsor_name FROM player WHERE Residence  =  'Brandon' OR Residence  =  'Birtle'", "source_tables": ["player"]}
{"sample_id": 1724, "db_id": "riding_club", "question": "What is the name of the player with the largest number of votes?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the column that holds the player's name, which is 'Player_name'.", "Identify the column that contains the number of votes, which is 'Votes'.", "To find the player with the largest number of votes, we need to sort the results in descending order based on the 'Votes' column.", "Use the 'ORDER BY' clause to sort by 'Votes' in descending order.", "Limit the results to only one entry using 'LIMIT 1' to get the player with the highest votes."], "pred_sql": "SELECT Player_name FROM player ORDER BY Votes DESC LIMIT 1;", "gold_sql": "SELECT Player_name FROM player ORDER BY Votes DESC LIMIT 1", "source_tables": ["player"]}
{"sample_id": 1725, "db_id": "riding_club", "question": "Show different occupations along with the number of players in each occupation.", "rationale": ["Identify the table that contains the relevant data: The 'player' table contains the 'Occupation' and 'Player_ID' columns.", "We need to count the number of players for each occupation, which requires the use of the COUNT() function.", "To group the results by occupation, we will use the GROUP BY clause on the 'Occupation' column.", "The final SQL query will select the 'Occupation' and the count of 'Player_ID' as 'Number_of_Players' from the 'player' table, grouping the results by 'Occupation'."], "pred_sql": "SELECT Occupation, COUNT(Player_ID) AS Number_of_Players FROM player GROUP BY Occupation;", "gold_sql": "SELECT Occupation ,  COUNT(*) FROM player GROUP BY Occupation", "source_tables": ["player"]}
{"sample_id": 1726, "db_id": "riding_club", "question": "Please show the most common occupation of players.", "rationale": ["Identify the relevant table: The 'player' table contains the 'Occupation' column which we need to analyze.", "Count the occurrences of each occupation: We will use the COUNT() function to count how many players have each occupation.", "Group the results by occupation: We will use GROUP BY to aggregate the counts for each unique occupation.", "Order the results: To find the most common occupation, we will order the results in descending order based on the count.", "Limit the results to one: We will use LIMIT 1 to get only the most common occupation."], "pred_sql": "SELECT Occupation, COUNT(*) as Count FROM player GROUP BY Occupation ORDER BY Count DESC LIMIT 1;", "gold_sql": "SELECT Occupation FROM player GROUP BY Occupation ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["player"]}
{"sample_id": 1727, "db_id": "riding_club", "question": "Show the residences that have at least two players.", "rationale": ["Identify the table that contains the residence information, which is the 'player' table.", "We need to group the results by the 'Residence' column to aggregate the data based on residences.", "To find residences with at least two players, we will use the HAVING clause with COUNT(Player_ID) to filter groups that have two or more players."], "pred_sql": "SELECT Residence FROM player GROUP BY Residence HAVING COUNT(Player_ID) >= 2;", "gold_sql": "SELECT Residence FROM player GROUP BY Residence HAVING COUNT(*)  >=  2", "source_tables": ["player"]}
{"sample_id": 1728, "db_id": "riding_club", "question": "Show the names of players and names of their coaches.", "rationale": ["Identify the tables needed: player, player_coach, and coach.", "We need to retrieve player names and their corresponding coach names.", "The player table contains player names, and the player_coach table links players to their coaches.", "The coach table contains coach names, and we can link it to the player_coach table using Coach_ID.", "Use JOIN operations to combine these tables based on their relationships: player to player_coach and player_coach to coach.", "Select the Player_name from the player table and Coach_name from the coach table."], "pred_sql": "SELECT player.Player_name, coach.Coach_name \nFROM player \nJOIN player_coach ON player.Player_ID = player_coach.Player_ID \nJOIN coach ON player_coach.Coach_ID = coach.Coach_ID;", "gold_sql": "SELECT T3.Player_name ,  T2.coach_name FROM player_coach AS T1 JOIN coach AS T2 ON T1.Coach_ID  =  T2.Coach_ID JOIN player AS T3 ON T1.Player_ID  =  T3.Player_ID", "source_tables": ["player_coach", "coach", "player"]}
{"sample_id": 1729, "db_id": "riding_club", "question": "Show the names of players coached by the rank 1 coach.", "rationale": ["Identify the relevant tables: player, player_coach, and coach are needed to find players and their coaches.", "We need to join the player table with the player_coach table on Player_ID to link players with their coaches.", "Next, we join the coach table on Coach_ID to access the rank of the coach associated with each player.", "We filter the results to include only those players whose coach has a rank of '1'.", "Finally, we select the Player_name from the resulting dataset."], "pred_sql": "SELECT player.Player_name \nFROM player \nJOIN player_coach ON player.Player_ID = player_coach.Player_ID \nJOIN coach ON player_coach.Coach_ID = coach.Coach_ID \nWHERE coach.Rank = '1';", "gold_sql": "SELECT T3.Player_name FROM player_coach AS T1 JOIN coach AS T2 ON T1.Coach_ID  =  T2.Coach_ID JOIN player AS T3 ON T1.Player_ID  =  T3.Player_ID WHERE T2.Rank  =  1", "source_tables": ["player_coach", "coach", "player"]}
{"sample_id": 1730, "db_id": "riding_club", "question": "Show the names and genders of players with a coach starting after 2011.", "rationale": ["Identify the relevant tables: player, player_coach, and coach are needed to get player names and genders along with their coaching information.", "Determine the columns to select: We need 'Player_name' and 'Gender' from the player table.", "Establish the relationships between the tables: Use JOIN to connect player to player_coach and player_coach to coach based on their IDs.", "Set the condition for filtering: We need to filter the results where the 'Starting_year' in the player_coach table is greater than 2011."], "pred_sql": "SELECT player.Player_name, player.Gender \nFROM player \nJOIN player_coach ON player.Player_ID = player_coach.Player_ID \nJOIN coach ON player_coach.Coach_ID = coach.Coach_ID \nWHERE player_coach.Starting_year > '2011';", "gold_sql": "SELECT T3.Player_name ,  T3.gender FROM player_coach AS T1 JOIN coach AS T2 ON T1.Coach_ID  =  T2.Coach_ID JOIN player AS T3 ON T1.Player_ID  =  T3.Player_ID WHERE T1.Starting_year  >  2011", "source_tables": ["player_coach", "coach", "player"]}
{"sample_id": 1731, "db_id": "riding_club", "question": "Show the names of players and names of their coaches in descending order of the votes of players.", "rationale": ["Identify the tables needed: player, coach, and player_coach.", "We need to retrieve player names and their corresponding coach names, which requires joining the player table with the player_coach table and then with the coach table.", "The join condition for player and player_coach is on Player_ID, and for player_coach and coach is on Coach_ID.", "We need to order the results by the number of votes received by the players in descending order, which means we will use the ORDER BY clause on the Votes column from the player table."], "pred_sql": "SELECT player.Player_name, coach.Coach_name \nFROM player \nJOIN player_coach ON player.Player_ID = player_coach.Player_ID \nJOIN coach ON player_coach.Coach_ID = coach.Coach_ID \nORDER BY player.Votes DESC;", "gold_sql": "SELECT T3.Player_name ,  T2.coach_name FROM player_coach AS T1 JOIN coach AS T2 ON T1.Coach_ID  =  T2.Coach_ID JOIN player AS T3 ON T1.Player_ID  =  T3.Player_ID ORDER BY T3.Votes DESC", "source_tables": ["player_coach", "coach", "player"]}
{"sample_id": 1732, "db_id": "riding_club", "question": "List the names of players that do not have coaches.", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relationship between players and coaches, which is represented in the 'player_coach' table.", "To find players without coaches, we need to select players whose IDs are not present in the 'player_coach' table.", "Construct a SQL query that selects the 'Player_name' from the 'player' table where the 'Player_ID' is not in the list of 'Player_ID' from the 'player_coach' table."], "pred_sql": "SELECT Player_name FROM player WHERE Player_ID NOT IN (SELECT Player_ID FROM player_coach);", "gold_sql": "SELECT Player_name FROM player WHERE Player_ID NOT IN (SELECT Player_ID FROM player_coach)", "source_tables": ["player_coach", "player"]}
{"sample_id": 1733, "db_id": "riding_club", "question": "Show the residences that have both a player of gender \"M\" and a player of gender \"F\".", "rationale": ["Identify the requirement to find residences with both male and female players.", "Use a self-join on the player table to compare two instances of the player table: one for male players and one for female players.", "Filter the results to ensure that one instance has a gender of 'M' and the other has a gender of 'F'.", "Ensure that the residences of both players are the same by adding a condition that compares their Residence fields.", "Select distinct residences to avoid duplicates in the final output."], "pred_sql": "SELECT DISTINCT p1.Residence\nFROM player p1, player p2\nWHERE p1.Gender = 'M' AND p2.Gender = 'F' AND p1.Residence = p2.Residence;", "gold_sql": "SELECT Residence FROM player WHERE gender  =  'M' INTERSECT SELECT Residence FROM player WHERE gender  =  'F'", "source_tables": ["player"]}
{"sample_id": 1734, "db_id": "riding_club", "question": "How many coaches does each club has? List the club id, name and the number of coaches.", "rationale": ["Identify the tables needed: We need data from the 'club' table for club details and the 'coach' table to count the number of coaches.", "We need to join the 'club' table with the 'coach' table on the 'Club_ID' to associate coaches with their respective clubs.", "Use a LEFT JOIN to ensure that clubs with no coaches are still included in the results with a count of zero.", "Select the 'Club_ID' and 'Club_name' from the 'club' table and count the 'Coach_ID' from the 'coach' table to get the number of coaches per club.", "Group the results by 'Club_ID' and 'Club_name' to aggregate the count of coaches for each club."], "pred_sql": "SELECT club.Club_ID, club.Club_name, COUNT(coach.Coach_ID) AS Number_of_Coaches\nFROM club\nLEFT JOIN coach ON club.Club_ID = coach.Club_ID\nGROUP BY club.Club_ID, club.Club_name;", "gold_sql": "SELECT T1.club_id ,  T1.club_name, count(*) FROM club AS T1 JOIN coach AS T2 ON T1.club_id  =  T2.club_id GROUP BY T1.club_id", "source_tables": ["coach", "club"]}
{"sample_id": 1735, "db_id": "riding_club", "question": "How many gold medals has the club with the most coaches won?", "rationale": ["Identify the club with the most coaches by counting the number of coaches associated with each club.", "Use a subquery to select the Club_ID of the club that has the maximum number of coaches.", "Join the match_result table with the club table to access the gold medal data for the identified club.", "Sum the gold medals won by the club with the most coaches."], "pred_sql": "SELECT SUM(mr.Gold) AS Total_Gold_Medals\nFROM match_result mr\nJOIN club c ON mr.Club_ID = c.Club_ID\nWHERE c.Club_ID = (\n    SELECT pc.Club_ID\n    FROM player_coach pc\n    GROUP BY pc.Club_ID\n    ORDER BY COUNT(pc.Coach_ID) DESC\n    LIMIT 1\n)", "gold_sql": "SELECT T1.club_id ,  T1.gold FROM match_result AS T1 JOIN coach AS T2 ON T1.club_id  =  T2.club_id GROUP BY T1.club_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["match_result", "coach"]}
{"sample_id": 1736, "db_id": "gymnast", "question": "How many gymnasts are there?", "rationale": ["Identify the requirement to count the number of gymnasts.", "The relevant table for this information is 'gymnast'.", "Use the COUNT() function to count the total number of entries in the 'gymnast' table.", "Construct the SQL query to select the count from the 'gymnast' table."], "pred_sql": "SELECT COUNT(*) AS NumberOfGymnasts FROM gymnast;", "gold_sql": "SELECT count(*) FROM gymnast", "source_tables": ["gymnast"]}
{"sample_id": 1737, "db_id": "gymnast", "question": "Count the number of gymnasts.", "rationale": ["Identify the goal of the query, which is to count the number of gymnasts.", "Determine the appropriate table to query, which is the 'gymnast' table.", "Use the COUNT() function to count the total number of entries in the 'gymnast' table.", "Construct the SQL query to select the count from the 'gymnast' table."], "pred_sql": "SELECT COUNT(*) AS NumberOfGymnasts FROM gymnast;", "gold_sql": "SELECT count(*) FROM gymnast", "source_tables": ["gymnast"]}
{"sample_id": 1738, "db_id": "gymnast", "question": "List the total points of gymnasts in descending order.", "rationale": ["Identify the table that contains the total points for gymnasts, which is the 'gymnast' table.", "Select the 'Total_Points' column from the 'gymnast' table.", "Order the results by 'Total_Points' in descending order to list the highest scores first."], "pred_sql": "SELECT Total_Points FROM gymnast ORDER BY Total_Points DESC;", "gold_sql": "SELECT Total_Points FROM gymnast ORDER BY Total_Points DESC", "source_tables": ["gymnast"]}
{"sample_id": 1739, "db_id": "gymnast", "question": "What are the total points for all gymnasts, ordered by total points descending?", "rationale": ["Identify the table that contains the total points for gymnasts, which is the 'gymnast' table.", "Select the 'Total_Points' column from the 'gymnast' table to retrieve the total points for all gymnasts.", "Use the ORDER BY clause to sort the results by 'Total_Points' in descending order."], "pred_sql": "SELECT Total_Points FROM gymnast ORDER BY Total_Points DESC;", "gold_sql": "SELECT Total_Points FROM gymnast ORDER BY Total_Points DESC", "source_tables": ["gymnast"]}
{"sample_id": 1740, "db_id": "gymnast", "question": "List the total points of gymnasts in descending order of floor exercise points.", "rationale": ["Identify the relevant table: The 'gymnast' table contains the points scored in various events, including floor exercise points and total points.", "Determine the required columns: We need to select 'Total_Points' from the 'gymnast' table.", "Specify the order: The results should be ordered by 'Floor_Exercise_Points' in descending order.", "Construct the SQL query: Use SELECT to get 'Total_Points', and ORDER BY to sort by 'Floor_Exercise_Points' in descending order."], "pred_sql": "SELECT gymnast.Total_Points FROM gymnast ORDER BY gymnast.Floor_Exercise_Points DESC;", "gold_sql": "SELECT Total_Points FROM gymnast ORDER BY Floor_Exercise_Points DESC", "source_tables": ["gymnast"]}
{"sample_id": 1741, "db_id": "gymnast", "question": "What are the total points of gymnasts, ordered by their floor exercise points descending?", "rationale": ["Identify the relevant table: The 'gymnast' table contains the points scored in various events, including floor exercise points and total points.", "Determine the required columns: We need to select 'Total_Points' from the 'gymnast' table.", "Specify the ordering: The results should be ordered by 'Floor_Exercise_Points' in descending order.", "Construct the SQL query: Combine the SELECT statement with the ORDER BY clause to form the complete SQL query."], "pred_sql": "SELECT gymnast.Total_Points FROM gymnast ORDER BY gymnast.Floor_Exercise_Points DESC;", "gold_sql": "SELECT Total_Points FROM gymnast ORDER BY Floor_Exercise_Points DESC", "source_tables": ["gymnast"]}
{"sample_id": 1742, "db_id": "gymnast", "question": "What is the average horizontal bar points for all gymnasts?", "rationale": ["Identify the table that contains the relevant data: the 'gymnast' table holds the scores for various events including the horizontal bar.", "Determine the specific column needed for the average calculation: 'Horizontal_Bar_Points'.", "Use the AVG() function to calculate the average of the 'Horizontal_Bar_Points' column.", "Construct the SQL query to select the average value from the 'gymnast' table."], "pred_sql": "SELECT AVG(Horizontal_Bar_Points) AS Average_Horizontal_Bar_Points FROM gymnast;", "gold_sql": "SELECT avg(Horizontal_Bar_Points) FROM gymnast", "source_tables": ["gymnast"]}
{"sample_id": 1743, "db_id": "gymnast", "question": "Return the average horizontal bar points across all gymnasts.", "rationale": ["Identify the table that contains the relevant data, which is the 'gymnast' table.", "Determine the specific column needed for the average calculation, which is 'Horizontal_Bar_Points'.", "Use the AVG() function to calculate the average of the 'Horizontal_Bar_Points' column.", "Construct the SQL query to select the average value from the 'gymnast' table."], "pred_sql": "SELECT AVG(Horizontal_Bar_Points) AS Average_Horizontal_Bar_Points FROM gymnast;", "gold_sql": "SELECT avg(Horizontal_Bar_Points) FROM gymnast", "source_tables": ["gymnast"]}
{"sample_id": 1744, "db_id": "gymnast", "question": "What are the names of people in ascending alphabetical order?", "rationale": ["Identify the table that contains the names of people, which is the 'people' table.", "Determine the column that holds the names, which is 'Name'.", "Specify that we want to select the 'Name' column from the 'people' table.", "To get the names in ascending alphabetical order, use the ORDER BY clause with 'Name' and specify ASC for ascending order."], "pred_sql": "SELECT Name FROM people ORDER BY Name ASC;", "gold_sql": "SELECT Name FROM People ORDER BY Name ASC", "source_tables": ["people"]}
{"sample_id": 1745, "db_id": "gymnast", "question": "Return the names of people, ordered alphabetically.", "rationale": ["Identify the table to query: The 'people' table contains the names of individuals.", "Determine the specific column needed: We need the 'Name' column from the 'people' table.", "Specify the order of results: The names should be ordered alphabetically, which can be achieved using the ORDER BY clause.", "Construct the SQL query: Combine the SELECT statement with the ORDER BY clause to form the complete SQL query."], "pred_sql": "SELECT Name FROM people ORDER BY Name ASC;", "gold_sql": "SELECT Name FROM People ORDER BY Name ASC", "source_tables": ["people"]}
{"sample_id": 1746, "db_id": "gymnast", "question": "What are the names of gymnasts?", "rationale": ["Identify the relevant tables: 'people' for names and 'gymnast' for gymnasts.", "Determine the relationship between the tables: 'gymnast.Gymnast_ID' is a foreign key that references 'people.People_ID'.", "To get the names of gymnasts, we need to select the 'Name' column from the 'people' table where there is a corresponding entry in the 'gymnast' table.", "Construct the SQL query using a JOIN to combine the two tables based on the foreign key relationship."], "pred_sql": "SELECT p.Name FROM people p JOIN gymnast g ON p.People_ID = g.Gymnast_ID;", "gold_sql": "SELECT T2.Name FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID", "source_tables": ["gymnast", "people"]}
{"sample_id": 1747, "db_id": "gymnast", "question": "Return the names of the gymnasts.", "rationale": ["Identify the tables involved: 'gymnast' and 'people'.", "Determine the relevant columns: we need the 'Name' from the 'people' table.", "Establish the relationship between the tables: 'gymnast.Gymnast_ID' is a foreign key that references 'people.People_ID'.", "Construct the SQL query to select the 'Name' from the 'people' table, joining it with the 'gymnast' table to ensure we only get names of gymnasts."], "pred_sql": "SELECT Name FROM people INNER JOIN gymnast ON gymnast.Gymnast_ID = people.People_ID;", "gold_sql": "SELECT T2.Name FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID", "source_tables": ["gymnast", "people"]}
{"sample_id": 1748, "db_id": "gymnast", "question": "What are the names of gymnasts whose hometown is not \"Santo Domingo\"?", "rationale": ["Identify the relevant tables: 'people' for names and 'gymnast' for gymnasts.", "Determine the relationship between the tables: 'gymnast.Gymnast_ID' is a foreign key that references 'people.People_ID'.", "Select the 'Name' column from the 'people' table.", "Apply a condition to filter out gymnasts whose hometown is 'Santo Domingo' using the WHERE clause."], "pred_sql": "SELECT p.Name FROM people p JOIN gymnast g ON p.People_ID = g.Gymnast_ID WHERE p.Hometown != 'Santo Domingo';", "gold_sql": "SELECT T2.Name FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID WHERE T2.Hometown != 'Santo Domingo'", "source_tables": ["gymnast", "people"]}
{"sample_id": 1749, "db_id": "gymnast", "question": "Return the names of gymnasts who did not grow up in Santo Domingo.", "rationale": ["Identify the relevant tables: 'people' for names and 'gymnast' for gymnasts' IDs.", "We need to find gymnasts who did not grow up in Santo Domingo, which means we need to filter out those who have 'Santo Domingo' as their hometown.", "First, we will select the 'People_ID' from the 'people' table where the 'Hometown' is 'Santo Domingo'.", "Next, we will use this list of IDs to filter out the gymnasts from the 'gymnast' table.", "Finally, we will select the 'Name' from the 'people' table where the 'People_ID' is not in the list of IDs from Santo Domingo."], "pred_sql": "SELECT Name FROM people WHERE People_ID NOT IN (SELECT Gymnast_ID FROM gymnast WHERE Gymnast_ID IN (SELECT People_ID FROM people WHERE Hometown = 'Santo Domingo'));", "gold_sql": "SELECT T2.Name FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID WHERE T2.Hometown != 'Santo Domingo'", "source_tables": ["gymnast", "people"]}
{"sample_id": 1750, "db_id": "gymnast", "question": "What is the age of the tallest person?", "rationale": ["Identify the table that contains the information about people, which is the 'people' table.", "To find the tallest person, we need to determine the maximum height from the 'Height' column in the 'people' table.", "Once we have the maximum height, we can select the 'Age' of the person who has that maximum height.", "The SQL query will use a subquery to find the maximum height and then select the corresponding age from the 'people' table."], "pred_sql": "SELECT Age FROM people WHERE Height = (SELECT MAX(Height) FROM people);", "gold_sql": "SELECT Age FROM people ORDER BY Height DESC LIMIT 1", "source_tables": ["people"]}
{"sample_id": 1751, "db_id": "gymnast", "question": "Return the age of the person with the greatest height.", "rationale": ["Identify the table that contains the age and height information, which is the 'people' table.", "To find the age of the person with the greatest height, we need to first determine the maximum height from the 'people' table.", "Use a subquery to select the maximum height from the 'people' table.", "Then, select the age of the person whose height matches this maximum height."], "pred_sql": "SELECT Age FROM people WHERE Height = (SELECT MAX(Height) FROM people);", "gold_sql": "SELECT Age FROM people ORDER BY Height DESC LIMIT 1", "source_tables": ["people"]}
{"sample_id": 1752, "db_id": "gymnast", "question": "List the names of the top 5 oldest people.", "rationale": ["Identify the table that contains the names of the people, which is the 'people' table.", "To find the top 5 oldest people, we need to sort the results by the 'Age' column in descending order.", "We will use the 'LIMIT' clause to restrict the results to the top 5 entries after sorting."], "pred_sql": "SELECT Name FROM people ORDER BY Age DESC LIMIT 5;", "gold_sql": "SELECT Name FROM People ORDER BY Age DESC LIMIT 5", "source_tables": ["people"]}
{"sample_id": 1753, "db_id": "gymnast", "question": "What are the names of the five oldest people?", "rationale": ["Identify the table that contains the names of the people, which is the 'people' table.", "To find the oldest people, we need to sort the results by the 'Age' column in descending order.", "We want only the names of the people, so we will select the 'Name' column.", "Since we only need the five oldest people, we will use the LIMIT clause to restrict the results to 5."], "pred_sql": "SELECT Name FROM people ORDER BY Age DESC LIMIT 5;", "gold_sql": "SELECT Name FROM People ORDER BY Age DESC LIMIT 5", "source_tables": ["people"]}
{"sample_id": 1754, "db_id": "gymnast", "question": "What is the total point count of the youngest gymnast?", "rationale": ["Identify the youngest gymnast by selecting the minimum age from the people table.", "Use a subquery to find the People_ID of the youngest gymnast.", "Select the Total_Points from the gymnast table where the Gymnast_ID matches the People_ID of the youngest gymnast."], "pred_sql": "SELECT Total_Points FROM gymnast WHERE Gymnast_ID = (SELECT People_ID FROM people ORDER BY Age ASC LIMIT 1)", "gold_sql": "SELECT T1.Total_Points FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID ORDER BY T2.Age ASC LIMIT 1", "source_tables": ["gymnast", "people"]}
{"sample_id": 1755, "db_id": "gymnast", "question": "Return the total points of the gymnast with the lowest age.", "rationale": ["Identify the relevant tables: gymnast and people.", "We need to join these tables on the foreign key relationship where gymnast.Gymnast_ID = people.People_ID.", "To find the gymnast with the lowest age, we need to select the minimum age from the people table.", "Once we have the minimum age, we can filter the joined results to get the Total_Points for the gymnast(s) with that age.", "The final query selects the Total_Points from the gymnast table for the gymnast(s) who have the lowest age."], "pred_sql": "SELECT Total_Points FROM gymnast JOIN people ON gymnast.Gymnast_ID = people.People_ID WHERE Age = (SELECT MIN(Age) FROM people);", "gold_sql": "SELECT T1.Total_Points FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID ORDER BY T2.Age ASC LIMIT 1", "source_tables": ["gymnast", "people"]}
{"sample_id": 1756, "db_id": "gymnast", "question": "What is the average age of all gymnasts?", "rationale": ["Identify the relevant table for age information, which is the 'people' table.", "Determine that we need to calculate the average age of individuals who are gymnasts.", "Use a subquery to filter the 'people' table to only include those whose IDs are present in the 'gymnast' table, ensuring we only consider gymnasts.", "Use the AVG() function to calculate the average age from the filtered results."], "pred_sql": "SELECT AVG(Age) AS Average_Age FROM people WHERE People_ID IN (SELECT Gymnast_ID FROM gymnast);", "gold_sql": "SELECT avg(T2.Age) FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID", "source_tables": ["gymnast", "people"]}
{"sample_id": 1757, "db_id": "gymnast", "question": "Return the average age across all gymnasts.", "rationale": ["Identify the relevant table for age information, which is the 'people' table.", "Determine that we need to calculate the average age, which requires the AVG() function.", "Since we only want the ages of gymnasts, we need to filter the 'people' table to include only those individuals whose IDs are present in the 'gymnast' table.", "Construct a subquery to select Gymnast_IDs from the 'gymnast' table, and use this subquery to filter the 'people' table in the main query."], "pred_sql": "SELECT AVG(Age) AS Average_Age FROM people WHERE People_ID IN (SELECT Gymnast_ID FROM gymnast);", "gold_sql": "SELECT avg(T2.Age) FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID", "source_tables": ["gymnast", "people"]}
{"sample_id": 1758, "db_id": "gymnast", "question": "What are the distinct hometowns of gymnasts with total points more than 57.5?", "rationale": ["Identify the relevant tables: 'gymnast' for scores and 'people' for hometowns.", "We need to find distinct hometowns, so we will use the DISTINCT keyword.", "We need to join the 'gymnast' and 'people' tables on the foreign key relationship (Gymnast_ID = People_ID).", "We need to filter the results to include only those gymnasts whose total points are greater than 57.5.", "The Total_Points column is of type text, so we need to compare it as a string."], "pred_sql": "SELECT DISTINCT p.Hometown FROM gymnast g JOIN people p ON g.Gymnast_ID = p.People_ID WHERE g.Total_Points > '57.5';", "gold_sql": "SELECT DISTINCT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID WHERE T1.Total_Points  >  57.5", "source_tables": ["gymnast", "people"]}
{"sample_id": 1759, "db_id": "gymnast", "question": "Give the different hometowns of gymnasts that have a total point score of above 57.5.", "rationale": ["Identify the relevant tables: 'gymnast' for total points and 'people' for hometowns.", "We need to find gymnasts with a total point score above 57.5, so we will filter the 'gymnast' table based on the 'Total_Points' column.", "To get the hometowns, we will join the 'gymnast' table with the 'people' table using the foreign key relationship (Gymnast_ID = People_ID).", "We want distinct hometowns, so we will use the DISTINCT keyword in our SELECT statement.", "Construct the SQL query to select distinct hometowns from the 'people' table where the corresponding gymnast's total points are above 57.5."], "pred_sql": "SELECT DISTINCT p.Hometown FROM gymnast g JOIN people p ON g.Gymnast_ID = p.People_ID WHERE g.Total_Points > '57.5';", "gold_sql": "SELECT DISTINCT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID WHERE T1.Total_Points  >  57.5", "source_tables": ["gymnast", "people"]}
{"sample_id": 1760, "db_id": "gymnast", "question": "What are the hometowns of gymnasts and the corresponding number of gymnasts?", "rationale": ["Identify the relevant tables: 'gymnast' and 'people'.", "We need to find the hometowns of gymnasts, which is stored in the 'people' table under the 'Hometown' column.", "We also need to count the number of gymnasts from each hometown, which requires a count of 'Gymnast_ID' from the 'gymnast' table.", "To combine data from both tables, we will use a JOIN operation on the foreign key relationship (gymnast.Gymnast_ID = people.People_ID).", "We will group the results by 'Hometown' to get the count of gymnasts for each hometown.", "The final SQL query will select the 'Hometown' and the count of 'Gymnast_ID' as 'Number_of_Gymnasts'."], "pred_sql": "SELECT p.Hometown, COUNT(g.Gymnast_ID) AS Number_of_Gymnasts\nFROM gymnast g\nJOIN people p ON g.Gymnast_ID = p.People_ID\nGROUP BY p.Hometown;", "gold_sql": "SELECT T2.Hometown ,  COUNT(*) FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID GROUP BY T2.Hometown", "source_tables": ["gymnast", "people"]}
{"sample_id": 1761, "db_id": "gymnast", "question": "How many gymnasts are from each hometown?", "rationale": ["Identify the relevant tables: 'people' for hometown information and 'gymnast' for gymnast identification.", "Determine the relationship between the tables: 'gymnast.Gymnast_ID' is a foreign key that references 'people.People_ID'.", "We need to count the number of gymnasts from each hometown, which requires a COUNT function.", "Use a JOIN clause to combine data from both tables based on the foreign key relationship.", "Group the results by hometown to get the count of gymnasts from each hometown."], "pred_sql": "SELECT p.Hometown, COUNT(g.Gymnast_ID) AS Number_of_Gymnasts\nFROM people p\nJOIN gymnast g ON p.People_ID = g.Gymnast_ID\nGROUP BY p.Hometown;", "gold_sql": "SELECT T2.Hometown ,  COUNT(*) FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID GROUP BY T2.Hometown", "source_tables": ["gymnast", "people"]}
{"sample_id": 1762, "db_id": "gymnast", "question": "What is the most common hometown of gymnasts?", "rationale": ["Identify the relevant tables: 'people' for hometown information and 'gymnast' for gymnast identification.", "Join the 'people' table with the 'gymnast' table using the foreign key relationship (Gymnast_ID = People_ID).", "Group the results by 'Hometown' to count how many gymnasts come from each hometown.", "Count the number of occurrences of each hometown using COUNT(*) function.", "Order the results in descending order based on the count to find the most common hometown.", "Limit the results to 1 to get only the most common hometown."], "pred_sql": "SELECT Hometown, COUNT(*) as Count FROM people INNER JOIN gymnast ON people.People_ID = gymnast.Gymnast_ID GROUP BY Hometown ORDER BY Count DESC LIMIT 1;", "gold_sql": "SELECT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID GROUP BY T2.Hometown ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["gymnast", "people"]}
{"sample_id": 1763, "db_id": "gymnast", "question": "Return the hometown that is most common among gymnasts.", "rationale": ["Identify the relevant table: We need to find the hometowns of gymnasts, so we will use the 'people' table.", "Filter the people who are gymnasts: We will filter the 'people' table to include only those whose IDs are present in the 'gymnast' table.", "Group by hometown: To find the most common hometown, we will group the results by the 'Hometown' column.", "Count occurrences: We will count how many times each hometown appears among the gymnasts.", "Order by count: We will order the results in descending order based on the count of occurrences to get the most common hometown at the top.", "Limit the result: Finally, we will limit the result to 1 to get only the most common hometown."], "pred_sql": "SELECT Hometown FROM people WHERE People_ID IN (SELECT Gymnast_ID FROM gymnast) GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1;", "gold_sql": "SELECT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID GROUP BY T2.Hometown ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["gymnast", "people"]}
{"sample_id": 1764, "db_id": "gymnast", "question": "What are the hometowns that are shared by at least two gymnasts?", "rationale": ["Identify the relevant tables: We need to look at the 'people' table to get the hometowns and the 'gymnast' table to identify gymnasts.", "We need to find hometowns that are shared by at least two gymnasts, which means we need to group the results by hometown and count the number of gymnasts in each hometown.", "To do this, we will use a subquery to select the Gymnast_IDs from the 'gymnast' table that correspond to the people in the 'people' table.", "We will then group the results by hometown and use the HAVING clause to filter for those hometowns that have a count of Gymnast_IDs greater than or equal to 2."], "pred_sql": "SELECT hometown FROM people WHERE People_ID IN (SELECT Gymnast_ID FROM gymnast) GROUP BY hometown HAVING COUNT(Gymnast_ID) >= 2;", "gold_sql": "SELECT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID GROUP BY T2.Hometown HAVING COUNT(*)  >=  2", "source_tables": ["gymnast", "people"]}
{"sample_id": 1765, "db_id": "gymnast", "question": "Give the hometowns from which two or more gymnasts are from.", "rationale": ["Identify the relevant tables: 'people' for hometowns and 'gymnast' for gymnasts.", "We need to find hometowns that have two or more gymnasts.", "Use a subquery to select Gymnast_IDs from the 'gymnast' table that are also in the 'people' table.", "Group the results by hometown to aggregate the counts of gymnasts from each hometown.", "Use the HAVING clause to filter groups that have a count of gymnasts greater than or equal to 2."], "pred_sql": "SELECT hometown FROM people WHERE People_ID IN (SELECT Gymnast_ID FROM gymnast) GROUP BY hometown HAVING COUNT(Gymnast_ID) >= 2;", "gold_sql": "SELECT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID GROUP BY T2.Hometown HAVING COUNT(*)  >=  2", "source_tables": ["gymnast", "people"]}
{"sample_id": 1766, "db_id": "gymnast", "question": "List the names of gymnasts in ascending order by their heights.", "rationale": ["Identify the tables involved: 'people' for names and 'gymnast' for the association with gymnasts.", "Determine the columns needed: 'Name' from 'people' and 'Height' from 'people' for ordering.", "Establish the relationship between the tables using the foreign key: 'gymnast.Gymnast_ID' corresponds to 'people.People_ID'.", "Construct the SQL query to select the names from 'people' while joining with 'gymnast' to ensure we are only getting gymnasts.", "Add an ORDER BY clause to sort the results by height in ascending order."], "pred_sql": "SELECT p.Name FROM people p JOIN gymnast g ON p.People_ID = g.Gymnast_ID ORDER BY p.Height ASC;", "gold_sql": "SELECT T2.Name FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID ORDER BY T2.Height ASC", "source_tables": ["gymnast", "people"]}
{"sample_id": 1767, "db_id": "gymnast", "question": "What are the names of gymnasts, ordered by their heights ascending?", "rationale": ["Identify the relevant tables: 'people' for names and 'gymnast' for gymnast IDs.", "Determine the relationship between the tables: 'gymnast.Gymnast_ID' is a foreign key that references 'people.People_ID'.", "Select the 'Name' column from the 'people' table.", "Join the 'people' table with the 'gymnast' table on the foreign key relationship.", "Order the results by the 'Height' column from the 'people' table in ascending order."], "pred_sql": "SELECT p.Name FROM people p JOIN gymnast g ON p.People_ID = g.Gymnast_ID ORDER BY p.Height ASC;", "gold_sql": "SELECT T2.Name FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID ORDER BY T2.Height ASC", "source_tables": ["gymnast", "people"]}
{"sample_id": 1768, "db_id": "gymnast", "question": "List the distinct hometowns that are not associated with any gymnast.", "rationale": ["We need to find distinct hometowns from the 'people' table.", "We want to exclude any hometowns that are associated with gymnasts, which means we need to check the 'gymnast' table.", "To do this, we will use a subquery to select all Gymnast_IDs from the 'gymnast' table.", "The main query will select distinct hometowns from the 'people' table where the People_ID is not in the list of Gymnast_IDs from the subquery."], "pred_sql": "SELECT DISTINCT Hometown FROM people WHERE People_ID NOT IN (SELECT Gymnast_ID FROM gymnast);", "gold_sql": "SELECT DISTINCT Hometown FROM people EXCEPT SELECT DISTINCT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID", "source_tables": ["gymnast", "people"]}
{"sample_id": 1769, "db_id": "gymnast", "question": "From which hometowns did no gymnasts come from?", "rationale": ["Identify the relevant tables: 'people' for hometowns and 'gymnast' for gymnasts.", "We need to find hometowns that have no associated gymnasts.", "This can be achieved by selecting distinct hometowns from the 'people' table where the 'People_ID' is not present in the 'Gymnast_ID' column of the 'gymnast' table.", "The subquery (SELECT Gymnast_ID FROM gymnast) retrieves all IDs of gymnasts, and we use this to filter out any hometowns that have gymnasts."], "pred_sql": "SELECT DISTINCT hometown FROM people WHERE People_ID NOT IN (SELECT Gymnast_ID FROM gymnast);", "gold_sql": "SELECT DISTINCT Hometown FROM people EXCEPT SELECT DISTINCT T2.Hometown FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID", "source_tables": ["gymnast", "people"]}
{"sample_id": 1770, "db_id": "gymnast", "question": "Show the hometowns shared by people older than 23 and younger than 20.", "rationale": ["Identify the table to query: The 'people' table contains the relevant information about age and hometown.", "Determine the age criteria: We need to find people older than 23 or younger than 20.", "Use the WHERE clause to filter the results based on the age criteria: 'p.Age > 23 OR p.Age < 20'.", "Select the distinct hometowns from the filtered results to avoid duplicates: 'SELECT DISTINCT p.Hometown'.", "Combine these elements to form the complete SQL query."], "pred_sql": "SELECT DISTINCT p.Hometown FROM people p WHERE p.Age > 23 OR p.Age < 20;", "gold_sql": "SELECT Hometown FROM people WHERE Age  >  23 INTERSECT SELECT Hometown FROM people WHERE Age  <  20", "source_tables": ["people"]}
{"sample_id": 1771, "db_id": "gymnast", "question": "From which hometowns did both people older than 23 and younger than 20 come from?", "rationale": ["Identify the relevant table: The query involves the 'people' table since we are interested in the age and hometown of individuals.", "Determine the age criteria: We need to find people who are older than 23 or younger than 20.", "Select the hometowns: We want to retrieve the distinct hometowns of these individuals.", "Construct the SQL query: Use a SELECT statement to get distinct hometowns from the 'people' table where the age conditions are met."], "pred_sql": "SELECT DISTINCT p.Hometown FROM people p WHERE p.Age > 23 OR p.Age < 20;", "gold_sql": "SELECT Hometown FROM people WHERE Age  >  23 INTERSECT SELECT Hometown FROM people WHERE Age  <  20", "source_tables": ["people"]}
{"sample_id": 1772, "db_id": "gymnast", "question": "How many distinct hometowns did these people have?", "rationale": ["The query asks for the number of distinct hometowns.", "To find distinct values, we use the COUNT function along with DISTINCT.", "We need to select from the 'people' table where the hometowns are stored.", "The final SQL query will count the distinct hometowns from the 'Hometown' column in the 'people' table."], "pred_sql": "SELECT COUNT(DISTINCT Hometown) AS Distinct_Hometowns FROM people;", "gold_sql": "SELECT count(DISTINCT Hometown) FROM people", "source_tables": ["people"]}
{"sample_id": 1773, "db_id": "gymnast", "question": "Count the number of different hometowns of these people.", "rationale": ["Identify the table that contains the hometown information, which is the 'people' table.", "To count the number of different hometowns, we need to use the COUNT function along with DISTINCT to ensure we only count unique hometowns.", "The SQL query will select the count of distinct hometowns from the 'people' table."], "pred_sql": "SELECT COUNT(DISTINCT Hometown) AS NumberOfDifferentHometowns FROM people;", "gold_sql": "SELECT count(DISTINCT Hometown) FROM people", "source_tables": ["people"]}
{"sample_id": 1774, "db_id": "gymnast", "question": "Show the ages of gymnasts in descending order of total points.", "rationale": ["Identify the tables involved: 'gymnast' for scores and 'people' for ages.", "We need to join the 'gymnast' table with the 'people' table using the foreign key relationship (Gymnast_ID = People_ID).", "Select the 'Age' column from the 'people' table.", "Order the results by 'Total_Points' from the 'gymnast' table in descending order."], "pred_sql": "SELECT p.Age FROM gymnast g JOIN people p ON g.Gymnast_ID = p.People_ID ORDER BY g.Total_Points DESC;", "gold_sql": "SELECT T2.Age FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID ORDER BY T1.Total_Points DESC", "source_tables": ["gymnast", "people"]}
{"sample_id": 1775, "db_id": "gymnast", "question": "What are the ages of the gymnasts, ordered descending by their total points?", "rationale": ["Identify the relevant tables: 'gymnast' for scores and 'people' for ages.", "We need to retrieve the ages of gymnasts, which are stored in the 'people' table.", "To get the ages of gymnasts, we need to join the 'gymnast' table with the 'people' table on the foreign key 'Gymnast_ID' and 'People_ID'.", "We need to order the results by 'Total_Points' in descending order, which is a column in the 'gymnast' table.", "Construct the SQL query to select the 'Age' from the 'people' table, joining it with the 'gymnast' table and ordering by 'Total_Points' in descending order."], "pred_sql": "SELECT p.Age FROM gymnast g JOIN people p ON g.Gymnast_ID = p.People_ID ORDER BY g.Total_Points DESC;", "gold_sql": "SELECT T2.Age FROM gymnast AS T1 JOIN people AS T2 ON T1.Gymnast_ID  =  T2.People_ID ORDER BY T1.Total_Points DESC", "source_tables": ["gymnast", "people"]}
{"sample_id": 1776, "db_id": "small_bank_1", "question": "Find the total savings balance of all accounts except the account with name \u2018Brown\u2019.", "rationale": ["Identify the tables involved: SAVINGS for savings balances and ACCOUNTS for customer names.", "We need to sum the balances from the SAVINGS table, so we will use the SUM() function.", "To filter out the account with the name 'Brown', we will use a WHERE clause.", "We need to join the SAVINGS table with the ACCOUNTS table on the custid to access the names associated with the savings accounts.", "The final query will select the total savings balance while excluding the account with the name 'Brown'."], "pred_sql": "SELECT SUM(S.balance) AS total_savings_balance\nFROM SAVINGS S\nJOIN ACCOUNTS A ON S.custid = A.custid\nWHERE A.name != 'Brown';", "gold_sql": "SELECT sum(T2.balance) FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid WHERE T1.name != 'Brown'", "source_tables": ["accounts", "savings"]}
{"sample_id": 1777, "db_id": "small_bank_1", "question": "What is the total balance of savings accounts not belonging to someone with the name Brown?", "rationale": ["Identify the tables involved: SAVINGS for savings account balances and ACCOUNTS for customer names.", "We need to sum the balances from the SAVINGS table, so we will use the SUM() function.", "To filter out customers with the name 'Brown', we will use a WHERE clause that checks for names not equal to 'Brown'.", "Since the custid in SAVINGS is linked to custid in ACCOUNTS, we will perform a JOIN between these two tables on custid.", "The final query will select the total balance of savings accounts where the customer's name is not 'Brown'."], "pred_sql": "SELECT SUM(S.balance) AS total_savings_balance\nFROM SAVINGS S\nJOIN ACCOUNTS A ON S.custid = A.custid\nWHERE A.name != 'Brown';", "gold_sql": "SELECT sum(T2.balance) FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid WHERE T1.name != 'Brown'", "source_tables": ["accounts", "savings"]}
{"sample_id": 1778, "db_id": "small_bank_1", "question": "How many accounts are there in total?", "rationale": ["Identify the requirement to count the total number of accounts.", "Determine the relevant table, which is ACCOUNTS, as it contains the customer information.", "Use the COUNT() function to count the number of entries in the ACCOUNTS table.", "Construct the SQL query to select the count from the ACCOUNTS table."], "pred_sql": "SELECT COUNT(*) AS total_accounts FROM ACCOUNTS;", "gold_sql": "SELECT count(*) FROM accounts", "source_tables": ["accounts"]}
{"sample_id": 1779, "db_id": "small_bank_1", "question": "Count the number of accounts.", "rationale": ["Identify the goal: Count the number of accounts.", "Determine the relevant table: The ACCOUNTS table contains the account information.", "Use the COUNT() function to count the total number of entries in the ACCOUNTS table.", "Construct the SQL query to select the count from the ACCOUNTS table."], "pred_sql": "SELECT COUNT(*) AS account_count FROM ACCOUNTS;", "gold_sql": "SELECT count(*) FROM accounts", "source_tables": ["accounts"]}
{"sample_id": 1780, "db_id": "small_bank_1", "question": "What is the total checking balance in all accounts?", "rationale": ["Identify the table that contains the checking account balances, which is the CHECKING table.", "To find the total checking balance, we need to sum the 'balance' column in the CHECKING table.", "Use the SQL SUM() function to calculate the total of the 'balance' column.", "Construct the SQL query to select the sum of the balance and give it an alias 'total_checking_balance'."], "pred_sql": "SELECT SUM(balance) AS total_checking_balance FROM CHECKING;", "gold_sql": "SELECT sum(balance) FROM checking", "source_tables": ["checking"]}
{"sample_id": 1781, "db_id": "small_bank_1", "question": "Find the total balance across checking accounts.", "rationale": ["Identify the table that contains the checking account balances, which is the CHECKING table.", "Determine the column that holds the balance information, which is the 'balance' column in the CHECKING table.", "Use the SUM() function to calculate the total of all balances in the 'balance' column.", "Construct the SQL query to select the sum of the balance from the CHECKING table."], "pred_sql": "SELECT SUM(balance) AS total_checking_balance FROM CHECKING;", "gold_sql": "SELECT sum(balance) FROM checking", "source_tables": ["checking"]}
{"sample_id": 1782, "db_id": "small_bank_1", "question": "Find the average checking balance.", "rationale": ["Identify the table that contains the checking account balances, which is the CHECKING table.", "Determine the specific column that holds the balance information, which is the 'balance' column in the CHECKING table.", "Use the AVG() function to calculate the average of the 'balance' column.", "Construct the SQL query to select the average balance from the CHECKING table."], "pred_sql": "SELECT AVG(balance) AS average_checking_balance FROM CHECKING;", "gold_sql": "SELECT avg(balance) FROM checking", "source_tables": ["checking"]}
{"sample_id": 1783, "db_id": "small_bank_1", "question": "What is the average balance in checking accounts?", "rationale": ["Identify the table that contains the checking account balances, which is the CHECKING table.", "Determine the column that holds the balance information, which is the 'balance' column in the CHECKING table.", "Use the AVG() function to calculate the average of the 'balance' column.", "Construct the SQL query to select the average balance from the CHECKING table."], "pred_sql": "SELECT AVG(balance) AS average_checking_balance FROM CHECKING;", "gold_sql": "SELECT avg(balance) FROM checking", "source_tables": ["checking"]}
{"sample_id": 1784, "db_id": "small_bank_1", "question": "How many accounts have a savings balance above the average savings balance?", "rationale": ["Identify the table that contains the savings balance, which is the SAVINGS table.", "To find accounts with a savings balance above the average, we need to calculate the average savings balance using the AVG() function.", "We will use a subquery to calculate the average balance from the SAVINGS table.", "The main query will count the number of accounts where the balance is greater than the average calculated in the subquery."], "pred_sql": "SELECT COUNT(*) FROM SAVINGS WHERE balance > (SELECT AVG(balance) FROM SAVINGS);", "gold_sql": "SELECT count(*) FROM savings WHERE balance  >  (SELECT avg(balance) FROM savings)", "source_tables": ["savings"]}
{"sample_id": 1785, "db_id": "small_bank_1", "question": "Find the number of accounts with a savings balance that is higher than the average savings balance.", "rationale": ["Identify the table that contains the savings balance, which is the SAVINGS table.", "To find accounts with a savings balance higher than the average, we need to calculate the average savings balance using the AVG() function.", "We will use a subquery to calculate the average balance from the SAVINGS table.", "The main query will count the number of accounts where the balance is greater than the average calculated in the subquery.", "The final SQL query will select the count of such accounts."], "pred_sql": "SELECT COUNT(*) AS account_count FROM SAVINGS WHERE balance > (SELECT AVG(balance) FROM SAVINGS);", "gold_sql": "SELECT count(*) FROM savings WHERE balance  >  (SELECT avg(balance) FROM savings)", "source_tables": ["savings"]}
{"sample_id": 1786, "db_id": "small_bank_1", "question": "Find the name and id of accounts whose checking balance is below the maximum checking balance.", "rationale": ["Identify the tables involved: ACCOUNTS and CHECKING.", "We need to retrieve the name and custid from the ACCOUNTS table.", "We need to join the ACCOUNTS table with the CHECKING table on the custid column to access the checking balance.", "We need to filter the results where the checking balance is below the maximum checking balance.", "To find the maximum checking balance, we will use a subquery that selects the MAX(balance) from the CHECKING table."], "pred_sql": "SELECT A.name, A.custid FROM ACCOUNTS A JOIN CHECKING C ON A.custid = C.custid WHERE C.balance < (SELECT MAX(balance) FROM CHECKING)", "gold_sql": "SELECT T1.custid ,  T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT max(balance) FROM checking)", "source_tables": ["accounts", "checking"]}
{"sample_id": 1787, "db_id": "small_bank_1", "question": "What are the customer id and name corresponding to accounts with a checking balance less than the largest checking balance?", "rationale": ["Identify the relevant tables: ACCOUNTS and CHECKING.", "We need to select the customer id and name, which are in the ACCOUNTS table.", "We need to join the ACCOUNTS table with the CHECKING table on the custid column to access the checking balance.", "The condition specifies that we want checking balances that are less than the largest checking balance.", "To find the largest checking balance, we can use a subquery that selects the maximum balance from the CHECKING table."], "pred_sql": "SELECT A.custid, A.name \nFROM ACCOUNTS A \nJOIN CHECKING C ON A.custid = C.custid \nWHERE C.balance < (SELECT MAX(balance) FROM CHECKING)", "gold_sql": "SELECT T1.custid ,  T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT max(balance) FROM checking)", "source_tables": ["accounts", "checking"]}
{"sample_id": 1788, "db_id": "small_bank_1", "question": "What is the checking balance of the account whose owner\u2019s name contains the substring \u2018ee\u2019?", "rationale": ["Identify the relevant tables: CHECKING and ACCOUNTS.", "We need to retrieve the checking balance, so we will select the 'balance' column from the CHECKING table.", "To find the account owner based on their name, we will join the CHECKING table with the ACCOUNTS table using the 'custid' column, which is common in both tables.", "We need to filter the results to only include accounts where the owner's name contains the substring 'ee'. This can be done using the LIKE operator with wildcards in the WHERE clause."], "pred_sql": "SELECT CHECKING.balance FROM CHECKING JOIN ACCOUNTS ON CHECKING.custid = ACCOUNTS.custid WHERE ACCOUNTS.name LIKE '%ee%';", "gold_sql": "SELECT T2.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T1.name LIKE '%ee%'", "source_tables": ["accounts", "checking"]}
{"sample_id": 1789, "db_id": "small_bank_1", "question": "Find the balance of the checking account belonging to an owner whose name contains 'ee'.", "rationale": ["Identify the tables involved: CHECKING and ACCOUNTS.", "Determine the relationship between the tables: CHECKING is linked to ACCOUNTS via custid.", "We need to find the balance from the CHECKING table.", "We need to filter the results based on the owner's name from the ACCOUNTS table.", "The condition specifies that the name should contain 'ee', which can be expressed using the LIKE operator with wildcards.", "Construct the SQL query to select the balance from CHECKING, joining it with ACCOUNTS, and applying the name filter."], "pred_sql": "SELECT CHECKING.balance FROM CHECKING JOIN ACCOUNTS ON CHECKING.custid = ACCOUNTS.custid WHERE ACCOUNTS.name LIKE '%ee%';", "gold_sql": "SELECT T2.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T1.name LIKE '%ee%'", "source_tables": ["accounts", "checking"]}
{"sample_id": 1790, "db_id": "small_bank_1", "question": "Find the checking balance and saving balance in the Brown\u2019s account.", "rationale": ["Identify the tables needed: ACCOUNTS for customer names, SAVINGS for savings balances, and CHECKING for checking balances.", "Determine the columns to select: the customer's name, the savings balance, and the checking balance.", "Use JOINs to combine the ACCOUNTS table with the SAVINGS and CHECKING tables based on the custid.", "Filter the results to only include the account for the customer named 'Brown'."], "pred_sql": "SELECT A.name, S.balance AS savings_balance, C.balance AS checking_balance \nFROM ACCOUNTS A \nJOIN SAVINGS S ON A.custid = S.custid \nJOIN CHECKING C ON A.custid = C.custid \nWHERE A.name = 'Brown'", "gold_sql": "SELECT T2.balance ,  T3.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid WHERE T1.name  =  'Brown'", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1791, "db_id": "small_bank_1", "question": "What are the checking and savings balances in accounts belonging to Brown?", "rationale": ["Identify the tables needed: ACCOUNTS for customer names, SAVINGS for savings balances, and CHECKING for checking balances.", "Determine the relationships: SAVINGS and CHECKING tables are linked to the ACCOUNTS table via custid.", "Select the relevant columns: We need the name from ACCOUNTS, balance from SAVINGS, and balance from CHECKING.", "Use JOINs to combine the data from the three tables based on the custid.", "Filter the results to include only those accounts where the name contains 'Brown' using a WHERE clause."], "pred_sql": "SELECT A.name, S.balance AS savings_balance, C.balance AS checking_balance \nFROM ACCOUNTS A \nJOIN SAVINGS S ON A.custid = S.custid \nJOIN CHECKING C ON A.custid = C.custid \nWHERE A.name LIKE '%Brown%';", "gold_sql": "SELECT T2.balance ,  T3.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid WHERE T1.name  =  'Brown'", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1792, "db_id": "small_bank_1", "question": "Find the names of accounts whose checking balance is above the average checking balance, but savings balance is below the average savings balance.", "rationale": ["Identify the tables involved: ACCOUNTS, CHECKING, and SAVINGS.", "Determine the columns needed: 'name' from ACCOUNTS, 'balance' from CHECKING and SAVINGS.", "Join the ACCOUNTS table with CHECKING and SAVINGS on 'custid' to access all necessary data.", "Use subqueries to calculate the average checking balance and average savings balance.", "Filter the results to include only those accounts where the checking balance is above the average and the savings balance is below the average."], "pred_sql": "SELECT A.name \nFROM ACCOUNTS A \nJOIN CHECKING C ON A.custid = C.custid \nJOIN SAVINGS S ON A.custid = S.custid \nWHERE C.balance > (SELECT AVG(balance) FROM CHECKING) \nAND S.balance < (SELECT AVG(balance) FROM SAVINGS);", "gold_sql": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  >  (SELECT avg(balance) FROM checking) INTERSECT SELECT T1.name FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT avg(balance) FROM savings)", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1793, "db_id": "small_bank_1", "question": "What are the names of accounts with checking balances greater than the average checking balance and savings balances below the average savings balance?", "rationale": ["Identify the tables involved: ACCOUNTS, CHECKING, and SAVINGS.", "We need to select the 'name' from the ACCOUNTS table.", "Join the ACCOUNTS table with the CHECKING and SAVINGS tables on 'custid' to access the balances.", "Use a subquery to calculate the average checking balance: (SELECT AVG(balance) FROM CHECKING).", "Use a subquery to calculate the average savings balance: (SELECT AVG(balance) FROM SAVINGS).", "Filter the results where the checking balance is greater than the average checking balance and the savings balance is less than the average savings balance."], "pred_sql": "SELECT A.name \nFROM ACCOUNTS A \nJOIN CHECKING C ON A.custid = C.custid \nJOIN SAVINGS S ON A.custid = S.custid \nWHERE C.balance > (SELECT AVG(balance) FROM CHECKING) \nAND S.balance < (SELECT AVG(balance) FROM SAVINGS);", "gold_sql": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  >  (SELECT avg(balance) FROM checking) INTERSECT SELECT T1.name FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT avg(balance) FROM savings)", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1794, "db_id": "small_bank_1", "question": "Find the checking balance of the accounts whose savings balance is higher than the average savings balance.", "rationale": ["Identify the tables involved: CHECKING and SAVINGS.", "We need to find the checking balance, so we will select the 'balance' column from the CHECKING table.", "We need to filter the results based on the condition that the savings balance is higher than the average savings balance.", "To find the average savings balance, we will use a subquery that calculates the average of the 'balance' column from the SAVINGS table.", "We will join the CHECKING and SAVINGS tables on the 'custid' column to link the accounts with their respective balances.", "The final query will select the checking balance where the savings balance exceeds the average savings balance."], "pred_sql": "SELECT CHECKING.balance FROM CHECKING JOIN SAVINGS ON CHECKING.custid = SAVINGS.custid WHERE SAVINGS.balance > (SELECT AVG(balance) FROM SAVINGS);", "gold_sql": "SELECT T2.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T1.name IN (SELECT T1.name FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  >  (SELECT avg(balance) FROM savings))", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1795, "db_id": "small_bank_1", "question": "What are the balances of checking accounts belonging to people with savings balances greater than the average savings balance?", "rationale": ["Identify the relevant tables: CHECKING and SAVINGS.", "We need to find checking account balances, so we will select the 'balance' column from the CHECKING table.", "To filter the results based on savings balances, we will join the CHECKING table with the SAVINGS table on the 'custid' column, which is common to both tables.", "We need to find savings balances that are greater than the average savings balance, so we will use a subquery to calculate the average savings balance using 'SELECT AVG(balance) FROM SAVINGS'.", "Finally, we will apply the condition in the WHERE clause to filter the checking account balances based on the calculated average savings balance."], "pred_sql": "SELECT CHECKING.balance \nFROM CHECKING \nJOIN SAVINGS ON CHECKING.custid = SAVINGS.custid \nWHERE SAVINGS.balance > (SELECT AVG(balance) FROM SAVINGS);", "gold_sql": "SELECT T2.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T1.name IN (SELECT T1.name FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  >  (SELECT avg(balance) FROM savings))", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1796, "db_id": "small_bank_1", "question": "List all customers\u2019 names in the alphabetical order.", "rationale": ["Identify the table that contains customer names, which is the ACCOUNTS table.", "Select the 'name' column from the ACCOUNTS table.", "Use the ORDER BY clause to sort the results in alphabetical order by the 'name' column."], "pred_sql": "SELECT name FROM ACCOUNTS ORDER BY name ASC;", "gold_sql": "SELECT name FROM accounts ORDER BY name", "source_tables": ["accounts"]}
{"sample_id": 1797, "db_id": "small_bank_1", "question": "What are the names of all the customers in alphabetical order?", "rationale": ["Identify the table that contains customer names, which is the ACCOUNTS table.", "Select the 'name' column from the ACCOUNTS table.", "Order the results alphabetically by the 'name' column in ascending order."], "pred_sql": "SELECT name FROM ACCOUNTS ORDER BY name ASC;", "gold_sql": "SELECT name FROM accounts ORDER BY name", "source_tables": ["accounts"]}
{"sample_id": 1798, "db_id": "small_bank_1", "question": "Find the name of account that has the lowest total checking and saving balance.", "rationale": ["Identify the tables involved: ACCOUNTS, SAVINGS, and CHECKING.", "We need to find the total balance, which is the sum of the savings and checking balances for each customer.", "Join the ACCOUNTS table with the SAVINGS and CHECKING tables using the custid as the foreign key.", "Calculate the total balance by adding the balance from the SAVINGS and CHECKING tables.", "Order the results by the total balance in ascending order to find the lowest balance.", "Limit the results to 1 to get only the account with the lowest total balance."], "pred_sql": "SELECT A.name FROM ACCOUNTS A JOIN SAVINGS S ON A.custid = S.custid JOIN CHECKING C ON A.custid = C.custid ORDER BY (S.balance + C.balance) ASC LIMIT 1;", "gold_sql": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T2.balance + T3.balance LIMIT 1", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1799, "db_id": "small_bank_1", "question": "What is the name corresponding to the accoung with the lowest sum of checking and savings balances?", "rationale": ["Identify the tables involved: ACCOUNTS, SAVINGS, and CHECKING.", "We need to join these tables on the custid to access the names and balances.", "Calculate the sum of the checking and savings balances for each customer.", "Order the results by the calculated sum in ascending order to find the lowest sum.", "Limit the results to 1 to get only the customer with the lowest sum of balances."], "pred_sql": "SELECT A.name FROM ACCOUNTS A JOIN SAVINGS S ON A.custid = S.custid JOIN CHECKING C ON A.custid = C.custid ORDER BY (S.balance + C.balance) ASC LIMIT 1;", "gold_sql": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T2.balance + T3.balance LIMIT 1", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1800, "db_id": "small_bank_1", "question": "Find the names and total checking and savings balances of accounts whose savings balance is higher than the average savings balance.", "rationale": ["Identify the tables needed: ACCOUNTS, SAVINGS, and CHECKING.", "We need to select the names from the ACCOUNTS table and the total balances from both SAVINGS and CHECKING tables.", "To get the total balance, we will sum the balances from both SAVINGS and CHECKING tables. We will use COALESCE to handle cases where a customer may not have a balance in one of the accounts.", "We need to filter the results to only include accounts where the savings balance is higher than the average savings balance.", "To find the average savings balance, we will use a subquery that calculates the average from the SAVINGS table."], "pred_sql": "SELECT A.name, COALESCE(S.balance, 0) + COALESCE(C.balance, 0) AS total_balance\nFROM ACCOUNTS A\nLEFT JOIN SAVINGS S ON A.custid = S.custid\nLEFT JOIN CHECKING C ON A.custid = C.custid\nWHERE S.balance > (SELECT AVG(balance) FROM SAVINGS)", "gold_sql": "SELECT T1.name ,  T2.balance + T3.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid WHERE T3.balance  >  (SELECT avg(balance) FROM savings)", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1801, "db_id": "small_bank_1", "question": "What are the names and sum of checking and savings balances for accounts with savings balances higher than the average savings balance?", "rationale": ["Identify the required information: names of customers and the sum of their checking and savings balances.", "Determine the tables involved: ACCOUNTS for customer names, SAVINGS for savings balances, and CHECKING for checking balances.", "Join the ACCOUNTS table with the SAVINGS and CHECKING tables on the custid to access all necessary data.", "Use a subquery to calculate the average savings balance from the SAVINGS table.", "Filter the results to include only those accounts where the savings balance is greater than the average savings balance.", "Group the results by customer name to calculate the total balance for each customer.", "Select the customer name and the sum of their checking and savings balances, using the SUM function."], "pred_sql": "SELECT A.name, SUM(S.balance + C.balance) AS total_balance\nFROM ACCOUNTS A\nJOIN SAVINGS S ON A.custid = S.custid\nJOIN CHECKING C ON A.custid = C.custid\nWHERE S.balance > (SELECT AVG(balance) FROM SAVINGS)\nGROUP BY A.name;", "gold_sql": "SELECT T1.name ,  T2.balance + T3.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid WHERE T3.balance  >  (SELECT avg(balance) FROM savings)", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1802, "db_id": "small_bank_1", "question": "Find the name and checking balance of the account with the lowest savings balance.", "rationale": ["Identify the tables involved: ACCOUNTS, SAVINGS, and CHECKING.", "We need to find the name and checking balance, so we will select 'name' from ACCOUNTS and 'balance' from CHECKING.", "To find the account with the lowest savings balance, we need to join the SAVINGS table to access the balance information.", "We will use a subquery to find the minimum balance in the SAVINGS table.", "The main query will join the ACCOUNTS table with the SAVINGS and CHECKING tables on 'custid' to get the required information for the customer with the lowest savings balance."], "pred_sql": "SELECT A.name, C.balance \nFROM ACCOUNTS A \nJOIN SAVINGS S ON A.custid = S.custid \nJOIN CHECKING C ON A.custid = C.custid \nWHERE S.balance = (SELECT MIN(balance) FROM SAVINGS)", "gold_sql": "SELECT T1.name ,  T2.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T3.balance LIMIT 1", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1803, "db_id": "small_bank_1", "question": "What are the names and balances of checking accounts belonging to the customer with the lowest savings balance?", "rationale": ["Identify the relevant tables: ACCOUNTS, CHECKING, and SAVINGS.", "We need to retrieve the names and balances of checking accounts, so we will select the 'name' from ACCOUNTS and 'balance' from CHECKING.", "To find the customer with the lowest savings balance, we will need to perform a subquery on the SAVINGS table.", "The subquery will select the 'custid' from the SAVINGS table, ordering by 'balance' in ascending order and limiting the result to 1 to get the customer with the lowest balance.", "We will join the ACCOUNTS table with the CHECKING table on 'custid' to get the corresponding checking account balance for the customer identified in the subquery.", "Finally, we will construct the main query to select the name and balance based on the condition that the 'custid' matches the one from the subquery."], "pred_sql": "SELECT A.name, C.balance \nFROM ACCOUNTS A \nJOIN CHECKING C ON A.custid = C.custid \nWHERE A.custid = (SELECT S.custid \n                   FROM SAVINGS S \n                   ORDER BY S.balance ASC \n                   LIMIT 1);", "gold_sql": "SELECT T1.name ,  T2.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T3.balance LIMIT 1", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1804, "db_id": "small_bank_1", "question": "Find the number of checking accounts for each account name.", "rationale": ["We need to find the number of checking accounts for each account name.", "To do this, we will select the 'name' from the ACCOUNTS table.", "We will also need to count the number of checking accounts, which requires joining the CHECKING table.", "The join will be done on the 'custid' column, which is common in both ACCOUNTS and CHECKING tables.", "Since not all customers may have a checking account, we will use a LEFT JOIN to ensure all account names are included in the result.", "We will group the results by the account name to get the count of checking accounts for each name."], "pred_sql": "SELECT A.name, COUNT(C.custid) AS checking_account_count\nFROM ACCOUNTS A\nLEFT JOIN CHECKING C ON A.custid = C.custid\nGROUP BY A.name;", "gold_sql": "SELECT count(*) ,  T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid GROUP BY T1.name", "source_tables": ["accounts", "checking"]}
{"sample_id": 1805, "db_id": "small_bank_1", "question": "What are the names of customers with accounts, and how many checking accounts do each of them have?", "rationale": ["Identify the tables involved: ACCOUNTS for customer names and CHECKING for checking accounts.", "We need to count the number of checking accounts for each customer, so we will use a COUNT function.", "To get the names of customers along with the count of their checking accounts, we will perform a LEFT JOIN between ACCOUNTS and CHECKING on the custid column.", "Using GROUP BY on custid and name will allow us to aggregate the results by each customer.", "The final query will select the customer's name and the count of their checking accounts."], "pred_sql": "SELECT A.name, COUNT(C.custid) AS checking_account_count \nFROM ACCOUNTS A \nLEFT JOIN CHECKING C ON A.custid = C.custid \nGROUP BY A.custid, A.name;", "gold_sql": "SELECT count(*) ,  T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid GROUP BY T1.name", "source_tables": ["accounts", "checking"]}
{"sample_id": 1806, "db_id": "small_bank_1", "question": "Find the total saving balance for each account name.", "rationale": ["Identify the tables involved: ACCOUNTS and SAVINGS.", "We need to retrieve the account names from the ACCOUNTS table and the savings balances from the SAVINGS table.", "To get the total savings balance for each account name, we will use a JOIN operation on the custid column, which is common in both tables.", "We will use the SUM function to calculate the total savings balance for each account.", "Finally, we will group the results by the account name to get the total savings balance for each individual account."], "pred_sql": "SELECT A.name, SUM(S.balance) AS total_savings_balance\nFROM ACCOUNTS A\nJOIN SAVINGS S ON A.custid = S.custid\nGROUP BY A.name;", "gold_sql": "SELECT sum(T2.balance) ,  T1.name FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid GROUP BY T1.name", "source_tables": ["accounts", "savings"]}
{"sample_id": 1807, "db_id": "small_bank_1", "question": "What are the names of customers with accounts, and what are the total savings balances for each?", "rationale": ["Identify the tables needed: ACCOUNTS for customer names and SAVINGS for balances.", "We need to join the ACCOUNTS table with the SAVINGS table on the custid column to link customers with their savings balances.", "We want to select the customer's name and the total savings balance, which requires summing the balance from the SAVINGS table.", "Use the SUM function to calculate the total savings balance for each customer.", "Group the results by customer name to ensure we get one row per customer with their total savings balance."], "pred_sql": "SELECT A.name, SUM(S.balance) AS total_savings_balance\nFROM ACCOUNTS A\nJOIN SAVINGS S ON A.custid = S.custid\nGROUP BY A.name;", "gold_sql": "SELECT sum(T2.balance) ,  T1.name FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid GROUP BY T1.name", "source_tables": ["accounts", "savings"]}
{"sample_id": 1808, "db_id": "small_bank_1", "question": "Find the name of accounts whose checking balance is below the average checking balance.", "rationale": ["Identify the tables involved: ACCOUNTS and CHECKING.", "Determine the relationship between the tables: CHECKING has a foreign key 'custid' that links to 'custid' in ACCOUNTS.", "We need to find names from the ACCOUNTS table where the checking balance is below the average checking balance.", "To find the average checking balance, we can use a subquery that calculates the average of the 'balance' column in the CHECKING table.", "Join the ACCOUNTS table with the CHECKING table on 'custid' to access the names and balances together.", "Use a WHERE clause to filter the results where the checking balance is less than the average calculated in the subquery."], "pred_sql": "SELECT A.name FROM ACCOUNTS A JOIN CHECKING C ON A.custid = C.custid WHERE C.balance < (SELECT AVG(C2.balance) FROM CHECKING C2);", "gold_sql": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT avg(balance) FROM checking)", "source_tables": ["accounts", "checking"]}
{"sample_id": 1809, "db_id": "small_bank_1", "question": "What are the names of customers with checking balances lower than the average checking balance?", "rationale": ["Identify the relevant tables: ACCOUNTS and CHECKING.", "We need to retrieve customer names, so we will select the 'name' column from the ACCOUNTS table.", "To find customers with checking balances lower than the average, we need to join the ACCOUNTS table with the CHECKING table on 'custid'.", "Calculate the average checking balance using a subquery: SELECT AVG(C2.balance) FROM CHECKING C2.", "Use a WHERE clause to filter customers whose checking balance is less than the calculated average."], "pred_sql": "SELECT A.name FROM ACCOUNTS A JOIN CHECKING C ON A.custid = C.custid WHERE C.balance < (SELECT AVG(C2.balance) FROM CHECKING C2);", "gold_sql": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid WHERE T2.balance  <  (SELECT avg(balance) FROM checking)", "source_tables": ["accounts", "checking"]}
{"sample_id": 1810, "db_id": "small_bank_1", "question": "Find the saving balance of the account with the highest checking balance.", "rationale": ["Identify the relevant tables: SAVINGS and CHECKING.", "We need to find the checking balance that is the highest, so we will use a subquery to get the maximum balance from the CHECKING table.", "Join the SAVINGS and CHECKING tables on the custid to link the accounts with their respective balances.", "Select the balance from the SAVINGS table where the checking balance matches the maximum balance found in the subquery."], "pred_sql": "SELECT S.balance FROM SAVINGS S JOIN CHECKING C ON S.custid = C.custid WHERE C.balance = (SELECT MAX(balance) FROM CHECKING)", "gold_sql": "SELECT T3.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T2.balance DESC LIMIT 1", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1811, "db_id": "small_bank_1", "question": "What is the savings balance of the account belonging to the customer with the highest checking balance?", "rationale": ["Identify the relevant tables: SAVINGS and CHECKING.", "We need to find the customer with the highest checking balance, so we will use the CHECKING table to get the maximum balance.", "To get the savings balance of that customer, we will join the SAVINGS table with the CHECKING table on the custid column.", "The final query will select the savings balance from the SAVINGS table where the checking balance matches the maximum checking balance found in the previous step."], "pred_sql": "SELECT S.balance FROM SAVINGS S JOIN CHECKING C ON S.custid = C.custid WHERE C.balance = (SELECT MAX(balance) FROM CHECKING)", "gold_sql": "SELECT T3.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T2.balance DESC LIMIT 1", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1812, "db_id": "small_bank_1", "question": "Find the total checking and saving balance of all accounts sorted by the total balance in ascending order.", "rationale": ["Identify the tables involved: ACCOUNTS, SAVINGS, and CHECKING.", "We need to retrieve the customer ID and name from the ACCOUNTS table.", "We need to calculate the total balance, which is the sum of the balances from the SAVINGS and CHECKING tables.", "Use LEFT JOIN to include all accounts even if they don't have a savings or checking account.", "Use IFNULL to treat NULL balances as 0 when calculating the total balance.", "Order the results by the total balance in ascending order."], "pred_sql": "SELECT A.custid, A.name, (IFNULL(S.balance, 0) + IFNULL(C.balance, 0)) AS total_balance \nFROM ACCOUNTS A \nLEFT JOIN SAVINGS S ON A.custid = S.custid \nLEFT JOIN CHECKING C ON A.custid = C.custid \nORDER BY total_balance ASC;", "gold_sql": "SELECT T1.balance + T2.balance FROM checking AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid ORDER BY T1.balance + T2.balance", "source_tables": ["savings", "checking"]}
{"sample_id": 1813, "db_id": "small_bank_1", "question": "What is the sum of checking and savings balances for all customers, ordered by the total balance?", "rationale": ["Identify the tables involved: ACCOUNTS, SAVINGS, and CHECKING.", "We need to sum the balances from both the SAVINGS and CHECKING tables for each customer.", "To get the total balance, we will use a LEFT JOIN to include all customers from the ACCOUNTS table, even if they do not have a savings or checking account.", "Use IFNULL to handle cases where a customer may not have a balance in either account, treating NULL as 0.", "Select the customer's name and the calculated total balance, and order the results by total balance in descending order."], "pred_sql": "SELECT A.name, (IFNULL(S.balance, 0) + IFNULL(C.balance, 0)) AS total_balance \nFROM ACCOUNTS A \nLEFT JOIN SAVINGS S ON A.custid = S.custid \nLEFT JOIN CHECKING C ON A.custid = C.custid \nORDER BY total_balance DESC;", "gold_sql": "SELECT T1.balance + T2.balance FROM checking AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid ORDER BY T1.balance + T2.balance", "source_tables": ["savings", "checking"]}
{"sample_id": 1814, "db_id": "small_bank_1", "question": "Find the name and checking balance of the account with the lowest saving balance.", "rationale": ["Identify the tables involved: ACCOUNTS, SAVINGS, and CHECKING.", "We need to retrieve the name from the ACCOUNTS table and the checking balance from the CHECKING table.", "To find the account with the lowest savings balance, we need to join the SAVINGS table with the ACCOUNTS table and the CHECKING table on the custid.", "Use a subquery to find the minimum balance in the SAVINGS table.", "Filter the results to only include the account(s) with the lowest savings balance."], "pred_sql": "SELECT A.name, C.balance \nFROM ACCOUNTS A \nJOIN SAVINGS S ON A.custid = S.custid \nJOIN CHECKING C ON A.custid = C.custid \nWHERE S.balance = (SELECT MIN(balance) FROM SAVINGS)", "gold_sql": "SELECT T2.balance ,  T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T3.balance LIMIT 1", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1815, "db_id": "small_bank_1", "question": "What is the name and checking balance of the account which has the lowest savings balance?", "rationale": ["Identify the required information: name and checking balance of the account with the lowest savings balance.", "To get the name, we need to join the ACCOUNTS table with the SAVINGS and CHECKING tables using the custid.", "We need to find the minimum balance in the SAVINGS table to identify the account with the lowest savings balance.", "Use a subquery to find the minimum savings balance: (SELECT MIN(balance) FROM SAVINGS).", "Join the tables: ACCOUNTS, SAVINGS, and CHECKING on custid to get the name and checking balance for the account with the lowest savings balance."], "pred_sql": "SELECT A.name, C.balance FROM ACCOUNTS A JOIN SAVINGS S ON A.custid = S.custid JOIN CHECKING C ON A.custid = C.custid WHERE S.balance = (SELECT MIN(balance) FROM SAVINGS);", "gold_sql": "SELECT T2.balance ,  T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T3.balance LIMIT 1", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1816, "db_id": "small_bank_1", "question": "Find the name, checking balance and saving balance of all accounts in the bank.", "rationale": ["Identify the required information: name, checking balance, and savings balance.", "Determine the tables involved: ACCOUNTS for customer names, CHECKING for checking balances, and SAVINGS for savings balances.", "Establish the relationships between the tables using the custid as the foreign key.", "Use JOIN operations to combine the data from the three tables based on the custid.", "Select the relevant columns: name from ACCOUNTS, balance from CHECKING, and balance from SAVINGS."], "pred_sql": "SELECT A.name, C.balance AS checking_balance, S.balance AS savings_balance\nFROM ACCOUNTS A\nJOIN CHECKING C ON A.custid = C.custid\nJOIN SAVINGS S ON A.custid = S.custid;", "gold_sql": "SELECT T2.balance ,  T3.balance ,  T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1817, "db_id": "small_bank_1", "question": "What are the names, checking balances, and savings balances for all customers?", "rationale": ["Identify the required information: names, checking balances, and savings balances for all customers.", "Determine the tables involved: ACCOUNTS for names, CHECKING for checking balances, and SAVINGS for savings balances.", "Establish the relationships between the tables using the custid as the foreign key.", "Use JOIN operations to combine the data from the ACCOUNTS, CHECKING, and SAVINGS tables based on the custid.", "Select the appropriate columns: name from ACCOUNTS, balance from CHECKING (aliased as checking_balance), and balance from SAVINGS (aliased as savings_balance).", "Construct the SQL query to retrieve the desired information."], "pred_sql": "SELECT A.name, C.balance AS checking_balance, S.balance AS savings_balance \nFROM ACCOUNTS A \nJOIN CHECKING C ON A.custid = C.custid \nJOIN SAVINGS S ON A.custid = S.custid;", "gold_sql": "SELECT T2.balance ,  T3.balance ,  T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1818, "db_id": "small_bank_1", "question": "Find the name, checking balance and savings balance of all accounts in the bank sorted by their total checking and savings balance in descending order.", "rationale": ["Identify the tables needed: ACCOUNTS, CHECKING, and SAVINGS.", "Select the required columns: name from ACCOUNTS, balance from CHECKING, and balance from SAVINGS.", "Join the ACCOUNTS table with CHECKING and SAVINGS on custid to get the related balances for each account.", "Calculate the total balance by adding the checking and savings balances together.", "Sort the results in descending order based on the total balance."], "pred_sql": "SELECT A.name, C.balance AS checking_balance, S.balance AS savings_balance\nFROM ACCOUNTS A\nJOIN CHECKING C ON A.custid = C.custid\nJOIN SAVINGS S ON A.custid = S.custid\nORDER BY (C.balance + S.balance) DESC;", "gold_sql": "SELECT T2.balance ,  T3.balance ,  T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T2.balance + T3.balance DESC", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1819, "db_id": "small_bank_1", "question": "What are the names, checking balances, and savings balances of customers, ordered by the total of checking and savings balances descending?", "rationale": ["Identify the required information: names, checking balances, and savings balances of customers.", "Determine the tables needed: ACCOUNTS for names, CHECKING for checking balances, and SAVINGS for savings balances.", "Use JOIN operations to combine data from the ACCOUNTS, CHECKING, and SAVINGS tables based on the custid.", "Select the relevant columns: name from ACCOUNTS, balance from CHECKING, and balance from SAVINGS.", "Calculate the total balance by adding checking and savings balances in the ORDER BY clause.", "Sort the results in descending order based on the total balance."], "pred_sql": "SELECT A.name, C.balance AS checking_balance, S.balance AS savings_balance\nFROM ACCOUNTS A\nJOIN CHECKING C ON A.custid = C.custid\nJOIN SAVINGS S ON A.custid = S.custid\nORDER BY (C.balance + S.balance) DESC;", "gold_sql": "SELECT T2.balance ,  T3.balance ,  T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid ORDER BY T2.balance + T3.balance DESC", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1820, "db_id": "small_bank_1", "question": "Find the name of accounts whose checking balance is higher than corresponding saving balance.", "rationale": ["Identify the tables involved: ACCOUNTS, CHECKING, and SAVINGS.", "Determine the relationship between the tables: CHECKING and SAVINGS are linked to ACCOUNTS via custid.", "We need to find accounts where the checking balance is greater than the savings balance.", "Use a JOIN to combine the ACCOUNTS table with both CHECKING and SAVINGS tables on custid.", "Select the name from the ACCOUNTS table where the condition of checking balance being greater than savings balance is met."], "pred_sql": "SELECT A.name FROM ACCOUNTS A JOIN CHECKING C ON A.custid = C.custid JOIN SAVINGS S ON A.custid = S.custid WHERE C.balance > S.balance;", "gold_sql": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid WHERE T2.balance  >  T3.balance", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1821, "db_id": "small_bank_1", "question": "What are the names of customers with a higher checking balance than savings balance?", "rationale": ["Identify the tables involved: ACCOUNTS, CHECKING, and SAVINGS.", "Determine the relationship between the tables: CHECKING and SAVINGS are linked to ACCOUNTS via custid.", "We need to select customer names from the ACCOUNTS table where the checking balance is greater than the savings balance.", "Use JOIN to combine the ACCOUNTS table with CHECKING and SAVINGS based on custid.", "Apply the condition to filter customers where the checking balance exceeds the savings balance."], "pred_sql": "SELECT A.name FROM ACCOUNTS A JOIN CHECKING C ON A.custid = C.custid JOIN SAVINGS S ON A.custid = S.custid WHERE C.balance > S.balance;", "gold_sql": "SELECT T1.name FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid WHERE T2.balance  >  T3.balance", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1822, "db_id": "small_bank_1", "question": "Find the name and total checking and savings balance of the accounts whose savings balance is lower than corresponding checking balance.", "rationale": ["Identify the tables involved: ACCOUNTS, SAVINGS, and CHECKING.", "We need to retrieve the customer's name from the ACCOUNTS table.", "We need to retrieve the balances from both the SAVINGS and CHECKING tables.", "To get the total balance, we will sum the savings and checking balances.", "We need to filter the results to include only those accounts where the savings balance is less than the checking balance.", "Construct the SQL query using JOINs to combine the relevant tables and apply the necessary conditions."], "pred_sql": "SELECT A.name, (S.balance + C.balance) AS total_balance\nFROM ACCOUNTS A\nJOIN SAVINGS S ON A.custid = S.custid\nJOIN CHECKING C ON A.custid = C.custid\nWHERE S.balance < C.balance;", "gold_sql": "SELECT T1.name ,  T3.balance + T2.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid WHERE T3.balance  <  T2.balance", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1823, "db_id": "small_bank_1", "question": "What are the names of customers who have a savings balance lower than their checking balance, and what is the total of their checking and savings balances?", "rationale": ["Identify the tables involved: ACCOUNTS, SAVINGS, and CHECKING.", "We need to retrieve customer names, so we will select the 'name' column from the ACCOUNTS table.", "We need to compare savings and checking balances, so we will join the SAVINGS and CHECKING tables on the 'custid' column.", "The condition states that the savings balance should be lower than the checking balance, so we will use a WHERE clause for this comparison.", "We also need to calculate the total of the checking and savings balances, which can be done by adding the 'balance' columns from both the SAVINGS and CHECKING tables.", "Finally, we will select the name of the customer and the calculated total balance in the SELECT statement."], "pred_sql": "SELECT A.name, (S.balance + C.balance) AS total_balance\nFROM ACCOUNTS A\nJOIN SAVINGS S ON A.custid = S.custid\nJOIN CHECKING C ON A.custid = C.custid\nWHERE S.balance < C.balance;", "gold_sql": "SELECT T1.name ,  T3.balance + T2.balance FROM accounts AS T1 JOIN checking AS T2 ON T1.custid  =  T2.custid JOIN savings AS T3 ON T1.custid  =  T3.custid WHERE T3.balance  <  T2.balance", "source_tables": ["accounts", "checking", "savings"]}
{"sample_id": 1824, "db_id": "small_bank_1", "question": "Find the name and savings balance of the top 3 accounts with the highest saving balance sorted by savings balance in descending order.", "rationale": ["Identify the tables needed: ACCOUNTS for customer names and SAVINGS for savings balances.", "Determine the columns to select: the customer's name from ACCOUNTS and the savings balance from SAVINGS.", "Establish the relationship between the tables using a JOIN on the custid column, which is common to both tables.", "Sort the results by the savings balance in descending order to get the highest balances first.", "Limit the results to the top 3 accounts to meet the requirement of finding the top 3 accounts."], "pred_sql": "SELECT A.name, S.balance FROM ACCOUNTS A JOIN SAVINGS S ON A.custid = S.custid ORDER BY S.balance DESC LIMIT 3;", "gold_sql": "SELECT T1.name ,  T2.balance FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid ORDER BY T2.balance DESC LIMIT 3", "source_tables": ["accounts", "savings"]}
{"sample_id": 1825, "db_id": "small_bank_1", "question": "What are names and savings balances of the three accounts with the highest savings balances?", "rationale": ["Identify the tables needed: ACCOUNTS for customer names and SAVINGS for savings balances.", "Determine the relationship between the tables: ACCOUNTS and SAVINGS are linked by custid.", "Select the required columns: We need the name from ACCOUNTS and the balance from SAVINGS.", "Join the ACCOUNTS and SAVINGS tables on custid to combine the relevant data.", "Order the results by the savings balance in descending order to get the highest balances first.", "Limit the results to the top three entries to get the three accounts with the highest savings balances."], "pred_sql": "SELECT A.name, S.balance FROM ACCOUNTS A JOIN SAVINGS S ON A.custid = S.custid ORDER BY S.balance DESC LIMIT 3;", "gold_sql": "SELECT T1.name ,  T2.balance FROM accounts AS T1 JOIN savings AS T2 ON T1.custid  =  T2.custid ORDER BY T2.balance DESC LIMIT 3", "source_tables": ["accounts", "savings"]}
{"sample_id": 1826, "db_id": "browser_web", "question": "How many main stream browsers whose market share is at least 5 exist?", "rationale": ["Identify the table that contains the relevant data, which is the 'browser' table.", "Determine the condition for filtering the browsers, which is that their market share must be at least 5.", "Use the COUNT() function to count the number of browsers that meet this condition.", "Construct the SQL query to select the count of browsers from the 'browser' table where the market_share is greater than or equal to 5."], "pred_sql": "SELECT COUNT(*) AS browser_count FROM browser WHERE market_share >= 5;", "gold_sql": "SELECT count(*) FROM browser WHERE market_share  >=  5", "source_tables": ["browser"]}
{"sample_id": 1827, "db_id": "browser_web", "question": "List the name of browsers in descending order by market share.", "rationale": ["Identify the table that contains the browser information, which is the 'browser' table.", "Determine the column that contains the names of the browsers, which is the 'name' column.", "Identify the column that contains the market share information, which is the 'market_share' column.", "Construct a SQL query to select the 'name' column from the 'browser' table.", "Add an ORDER BY clause to sort the results by 'market_share' in descending order."], "pred_sql": "SELECT name FROM browser ORDER BY market_share DESC;", "gold_sql": "SELECT name FROM browser ORDER BY market_share DESC", "source_tables": ["browser"]}
{"sample_id": 1828, "db_id": "browser_web", "question": "List the ids, names and market shares of all browsers.", "rationale": ["Identify the table that contains the required information, which is the 'browser' table.", "Determine the specific columns needed: 'id', 'name', and 'market_share'.", "Construct the SQL SELECT statement to retrieve these columns from the 'browser' table."], "pred_sql": "SELECT id, name, market_share FROM browser;", "gold_sql": "SELECT id ,  name ,  market_share FROM browser", "source_tables": ["browser"]}
{"sample_id": 1829, "db_id": "browser_web", "question": "What is the maximum, minimum and average market share of the listed browsers?", "rationale": ["Identify the table that contains the market share data, which is the 'browser' table.", "To find the maximum, minimum, and average market share, we will use the aggregate functions MAX(), MIN(), and AVG().", "We will select these aggregate values from the 'market_share' column in the 'browser' table.", "The final SQL query will combine these functions in a SELECT statement."], "pred_sql": "SELECT MAX(market_share) AS max_market_share, MIN(market_share) AS min_market_share, AVG(market_share) AS avg_market_share FROM browser;", "gold_sql": "SELECT max(market_share) ,  min(market_share) ,  avg(market_share) FROM browser", "source_tables": ["browser"]}
{"sample_id": 1830, "db_id": "browser_web", "question": "What is the id and market share of the browser Safari?", "rationale": ["Identify the table that contains the required information about browsers, which is the 'browser' table.", "Determine the specific columns needed from the 'browser' table, which are 'id' and 'market_share'.", "Formulate a SQL SELECT statement to retrieve the 'id' and 'market_share' columns.", "Add a WHERE clause to filter the results to only include the browser named 'Safari'."], "pred_sql": "SELECT id, market_share FROM browser WHERE name = 'Safari';", "gold_sql": "SELECT id ,  market_share FROM browser WHERE name  =  'Safari'", "source_tables": ["browser"]}
{"sample_id": 1831, "db_id": "browser_web", "question": "What are the name and os of web client accelerators that do not work with only a 'Broadband' type connection?", "rationale": ["Identify the relevant table: Web_client_accelerator contains the information about web client accelerators.", "Determine the columns needed: We need the 'name' and 'Operating_system' columns from the Web_client_accelerator table.", "Define the condition: We want to find accelerators that do not work with only a 'Broadband' type connection.", "To achieve this, we need to exclude those accelerators that are associated with 'Broadband' connections.", "This requires a subquery to find all accelerator_ids that are linked to 'Broadband' connections in the accelerator_compatible_browser table.", "Finally, we select the name and Operating_system of the accelerators that are not in the list of those that work with 'Broadband' connections."], "pred_sql": "SELECT name, Operating_system FROM Web_client_accelerator WHERE id NOT IN (SELECT accelerator_id FROM accelerator_compatible_browser WHERE browser_id IN (SELECT id FROM browser WHERE market_share = 100))", "gold_sql": "SELECT name ,  operating_system FROM web_client_accelerator WHERE CONNECTION != 'Broadband'", "source_tables": ["web_client_accelerator"]}
{"sample_id": 1832, "db_id": "browser_web", "question": "What is the name of the browser that became compatible with the accelerator 'CProxy' after year 1998 ?", "rationale": ["Identify the tables involved: We need to get the browser name, which is in the 'browser' table, and we need to check compatibility with the 'Web_client_accelerator' table.", "Determine the relationship: The 'accelerator_compatible_browser' table links the 'browser' and 'Web_client_accelerator' tables through their respective IDs.", "Filter conditions: We need to filter for the accelerator name 'CProxy' and ensure the compatibility year is greater than 1998.", "Construct the SQL query: Use JOINs to connect the tables and apply the WHERE clause to filter the results accordingly."], "pred_sql": "SELECT b.name FROM browser b JOIN accelerator_compatible_browser acb ON b.id = acb.browser_id JOIN Web_client_accelerator wca ON acb.accelerator_id = wca.id WHERE wca.name = 'CProxy' AND acb.compatible_since_year > '1998';", "gold_sql": "SELECT T1.name FROM browser AS T1 JOIN accelerator_compatible_browser AS T2 ON T1.id  =  T2.browser_id JOIN web_client_accelerator AS T3 ON T2.accelerator_id  =  T3.id WHERE T3.name  =  'CProxy' AND T2.compatible_since_year  >  1998", "source_tables": ["browser", "accelerator_compatible_browser", "web_client_accelerator"]}
{"sample_id": 1833, "db_id": "browser_web", "question": "What are the ids and names of the web accelerators that are compatible with two or more browsers?", "rationale": ["We need to find web accelerators that are compatible with two or more browsers.", "This requires joining the 'Web_client_accelerator' table with the 'accelerator_compatible_browser' table on the accelerator ID.", "We will select the 'id' and 'name' from the 'Web_client_accelerator' table.", "To find those compatible with two or more browsers, we will group the results by the 'id' and 'name' of the web accelerators.", "We will use the HAVING clause to filter groups that have a count of browser IDs greater than or equal to 2."], "pred_sql": "SELECT wca.id, wca.name \nFROM Web_client_accelerator wca \nJOIN accelerator_compatible_browser acb ON wca.id = acb.accelerator_id \nGROUP BY wca.id, wca.name \nHAVING COUNT(acb.browser_id) >= 2;", "gold_sql": "SELECT T1.id ,  T1.Name FROM web_client_accelerator AS T1 JOIN accelerator_compatible_browser AS T2 ON T2.accelerator_id  =  T1.id GROUP BY T1.id HAVING count(*)  >=  2", "source_tables": ["accelerator_compatible_browser", "web_client_accelerator"]}
{"sample_id": 1834, "db_id": "browser_web", "question": "What is the id and name of the browser that is compatible with the most web accelerators?", "rationale": ["We need to find the browser that is compatible with the most web accelerators.", "To do this, we will join the 'browser' table with the 'accelerator_compatible_browser' table on the browser's id.", "We will group the results by the browser's id and name to count how many accelerators each browser is compatible with.", "We will order the results in descending order based on the count of compatible accelerators.", "Finally, we will limit the results to only the top entry to get the browser with the most compatibility."], "pred_sql": "SELECT b.id, b.name\nFROM browser b\nJOIN accelerator_compatible_browser acb ON b.id = acb.browser_id\nGROUP BY b.id, b.name\nORDER BY COUNT(acb.accelerator_id) DESC\nLIMIT 1;", "gold_sql": "SELECT T1.id ,  T1.name FROM browser AS T1 JOIN accelerator_compatible_browser AS T2 ON T1.id  =  T2.browser_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["browser", "accelerator_compatible_browser"]}
{"sample_id": 1835, "db_id": "browser_web", "question": "When did the web accelerator 'CACHEbox' and browser 'Internet Explorer' become compatible?", "rationale": ["Identify the tables involved: We need to check compatibility between web accelerators and browsers, so we will use the 'Web_client_accelerator', 'browser', and 'accelerator_compatible_browser' tables.", "Determine the relevant columns: We need the 'compatible_since_year' from the 'accelerator_compatible_browser' table, and we need to filter by the names of the web accelerator ('CACHEbox') and the browser ('Internet Explorer').", "Join the tables: We will join 'accelerator_compatible_browser' with 'Web_client_accelerator' on 'accelerator_id' and with 'browser' on 'browser_id' to get the necessary information about compatibility.", "Construct the WHERE clause: We will filter the results to only include the specific web accelerator and browser mentioned in the query.", "Select the compatible_since_year: Finally, we will select the 'compatible_since_year' to answer the user's question."], "pred_sql": "SELECT compatible_since_year FROM accelerator_compatible_browser acb\nJOIN Web_client_accelerator wca ON acb.accelerator_id = wca.id\nJOIN browser b ON acb.browser_id = b.id\nWHERE wca.name = 'CACHEbox' AND b.name = 'Internet Explorer';", "gold_sql": "SELECT T1.compatible_since_year FROM accelerator_compatible_browser AS T1 JOIN browser AS T2 ON T1.browser_id  =  T2.id JOIN web_client_accelerator AS T3 ON T1.accelerator_id  =  T3.id WHERE T3.name  =  'CACHEbox' AND T2.name  =  'Internet Explorer'", "source_tables": ["browser", "accelerator_compatible_browser", "web_client_accelerator"]}
{"sample_id": 1836, "db_id": "browser_web", "question": "How many different kinds of clients are supported by the web clients accelerators?", "rationale": ["Identify the table that contains the information about clients, which is the 'Web_client_accelerator' table.", "Determine the column that specifies the type of client, which is the 'Client' column.", "To find out how many different kinds of clients are supported, we need to count the distinct values in the 'Client' column.", "Construct the SQL query using COUNT(DISTINCT Client) to get the number of unique clients."], "pred_sql": "SELECT COUNT(DISTINCT Client) AS different_clients FROM Web_client_accelerator;", "gold_sql": "SELECT count(DISTINCT client) FROM web_client_accelerator", "source_tables": ["web_client_accelerator"]}
{"sample_id": 1837, "db_id": "browser_web", "question": "How many accelerators are not compatible with the browsers listed ?", "rationale": ["Identify the main objective: Count the number of web client accelerators that are not compatible with any browsers.", "To find accelerators that are not compatible, we need to look for those whose IDs do not appear in the 'accelerator_compatible_browser' table.", "The 'accelerator_compatible_browser' table links accelerators to compatible browsers, so if an accelerator's ID is not in this table, it means it has no compatible browsers.", "We will use a subquery to select all 'accelerator_id's from the 'accelerator_compatible_browser' table and then use the NOT IN clause to filter out those from the 'Web_client_accelerator' table.", "Finally, we will count the remaining accelerators that do not have any compatible browsers."], "pred_sql": "SELECT COUNT(*) AS incompatible_accelerators_count\nFROM Web_client_accelerator\nWHERE id NOT IN (\n    SELECT accelerator_id\n    FROM accelerator_compatible_browser\n)", "gold_sql": "SELECT count(*) FROM web_client_accelerator WHERE id NOT IN ( SELECT accelerator_id FROM accelerator_compatible_browser );", "source_tables": ["accelerator_compatible_browser", "web_client_accelerator"]}
{"sample_id": 1838, "db_id": "browser_web", "question": "What distinct accelerator names are compatible with the browswers that have market share higher than 15?", "rationale": ["Identify the tables involved: Web_client_accelerator, accelerator_compatible_browser, and browser.", "Determine the relationship between the tables: Web_client_accelerator is linked to accelerator_compatible_browser via accelerator_id, and accelerator_compatible_browser is linked to browser via browser_id.", "We need to select distinct names from the Web_client_accelerator table.", "Filter the results based on the condition that the market share of the browsers is greater than 15.", "Construct the SQL query using JOINs to connect the tables and apply the WHERE clause for filtering."], "pred_sql": "SELECT DISTINCT wca.name \nFROM Web_client_accelerator wca \nJOIN accelerator_compatible_browser acb ON wca.id = acb.accelerator_id \nJOIN browser b ON acb.browser_id = b.id \nWHERE b.market_share > 15;", "gold_sql": "SELECT DISTINCT T1.name FROM web_client_accelerator AS T1 JOIN accelerator_compatible_browser AS T2 ON T2.accelerator_id  =  T1.id JOIN browser AS T3 ON T2.browser_id  =  T3.id WHERE T3.market_share  >  15;", "source_tables": ["browser", "accelerator_compatible_browser", "web_client_accelerator"]}
{"sample_id": 1839, "db_id": "browser_web", "question": "List the names of the browser that are compatible with both 'CACHEbox' and 'Fasterfox'.", "rationale": ["Identify the tables involved: We need to retrieve browser names, so we will use the 'browser' table. We also need to check compatibility with 'CACHEbox' and 'Fasterfox', which are in the 'Web_client_accelerator' table. The 'accelerator_compatible_browser' table will help us link browsers to accelerators.", "We need to find browsers that are compatible with both 'CACHEbox' and 'Fasterfox'. This requires joining the 'browser' table with the 'accelerator_compatible_browser' table twice: once for 'CACHEbox' and once for 'Fasterfox'.", "The first join will link the browser to 'CACHEbox' using the 'accelerator_compatible_browser' table and the 'Web_client_accelerator' table. The second join will do the same for 'Fasterfox'.", "In the WHERE clause, we will specify the names of the accelerators to filter the results accordingly. We will select the browser names that meet both conditions."], "pred_sql": "SELECT b.name \nFROM browser b \nJOIN accelerator_compatible_browser acb1 ON b.id = acb1.browser_id \nJOIN Web_client_accelerator wca1 ON acb1.accelerator_id = wca1.id \nJOIN accelerator_compatible_browser acb2 ON b.id = acb2.browser_id \nJOIN Web_client_accelerator wca2 ON acb2.accelerator_id = wca2.id \nWHERE wca1.name = 'CACHEbox' AND wca2.name = 'Fasterfox';", "gold_sql": "SELECT T3.name FROM web_client_accelerator AS T1 JOIN accelerator_compatible_browser AS T2 ON T2.accelerator_id  =  T1.id JOIN browser AS T3 ON T2.browser_id  =  T3.id WHERE T1.name  =  'CACHEbox' INTERSECT SELECT T3.name FROM web_client_accelerator AS T1 JOIN accelerator_compatible_browser AS T2 ON T2.accelerator_id  =  T1.id JOIN browser AS T3 ON T2.browser_id  =  T3.id WHERE T1.name  =  'Fasterfox'", "source_tables": ["browser", "accelerator_compatible_browser", "web_client_accelerator"]}
{"sample_id": 1840, "db_id": "browser_web", "question": "Show the accelerator names and supporting operating systems that are not compatible with the browser named 'Opera'.", "rationale": ["Identify the main table to query from, which is 'Web_client_accelerator' for accelerator names and operating systems.", "We need to find accelerators that are not compatible with the browser named 'Opera'.", "To do this, we will first find the IDs of accelerators that are compatible with 'Opera' by joining the 'accelerator_compatible_browser' and 'browser' tables.", "We will use a subquery to select the 'accelerator_id' from 'accelerator_compatible_browser' where the browser name is 'Opera'.", "Finally, we will select the names and operating systems from 'Web_client_accelerator' where the ID is not in the list of IDs returned by the subquery."], "pred_sql": "SELECT wca.name, wca.Operating_system \nFROM Web_client_accelerator wca \nWHERE wca.id NOT IN (\n    SELECT acb.accelerator_id \n    FROM accelerator_compatible_browser acb \n    JOIN browser b ON acb.browser_id = b.id \n    WHERE b.name = 'Opera'\n);", "gold_sql": "SELECT name ,  operating_system FROM web_client_accelerator EXCEPT SELECT T1.name ,  T1.operating_system FROM web_client_accelerator AS T1 JOIN accelerator_compatible_browser AS T2 ON T2.accelerator_id  =  T1.id JOIN browser AS T3 ON T2.browser_id  =  T3.id WHERE T3.name  =  'Opera'", "source_tables": ["browser", "accelerator_compatible_browser", "web_client_accelerator"]}
{"sample_id": 1841, "db_id": "browser_web", "question": "Which accelerator name contains substring \"Opera\"?", "rationale": ["Identify the table that contains the 'name' of the web client accelerator, which is 'Web_client_accelerator'.", "Determine the condition to filter the names that contain the substring 'Opera'.", "Use the SQL 'LIKE' operator with wildcards '%' to find names that include 'Opera' anywhere in the string.", "Construct the SQL SELECT statement to retrieve the 'name' column from the 'Web_client_accelerator' table with the specified condition."], "pred_sql": "SELECT name FROM Web_client_accelerator WHERE name LIKE '%Opera%';", "gold_sql": "SELECT name FROM web_client_accelerator WHERE name LIKE '%Opera%'", "source_tables": ["web_client_accelerator"]}
{"sample_id": 1842, "db_id": "browser_web", "question": "Find the number of web accelerators used for each Operating system.", "rationale": ["Identify the table that contains the relevant data, which is 'Web_client_accelerator'.", "Determine the columns needed for the query: 'Operating_system' to group the results and 'id' to count the number of accelerators.", "Use the COUNT() function to count the number of entries for each operating system.", "Group the results by 'Operating_system' to get the count for each unique operating system."], "pred_sql": "SELECT Operating_system, COUNT(*) AS number_of_accelerators FROM Web_client_accelerator GROUP BY Operating_system;", "gold_sql": "SELECT Operating_system ,  count(*) FROM web_client_accelerator GROUP BY Operating_system", "source_tables": ["web_client_accelerator"]}
{"sample_id": 1843, "db_id": "browser_web", "question": "give me names of all compatible browsers and accelerators in the descending order of compatible year", "rationale": ["Identify the tables involved: We need data from the 'accelerator_compatible_browser', 'browser', and 'Web_client_accelerator' tables.", "Determine the columns to select: We want the names of the compatible browsers and accelerators, as well as the year they became compatible.", "Use JOINs to combine the tables: We will join 'accelerator_compatible_browser' with 'browser' on 'browser_id' and with 'Web_client_accelerator' on 'accelerator_id'.", "Specify the ORDER BY clause: We need to order the results by 'compatible_since_year' in descending order."], "pred_sql": "SELECT b.name AS browser_name, wca.name AS accelerator_name, acb.compatible_since_year \nFROM accelerator_compatible_browser acb \nJOIN browser b ON acb.browser_id = b.id \nJOIN Web_client_accelerator wca ON acb.accelerator_id = wca.id \nORDER BY acb.compatible_since_year DESC;", "gold_sql": "SELECT T2.name ,  T3.name FROM accelerator_compatible_browser AS T1 JOIN browser AS T2 ON T1.browser_id  =  T2.id JOIN web_client_accelerator AS T3 ON T1.accelerator_id  =  T3.id ORDER BY T1.compatible_since_year DESC", "source_tables": ["browser", "accelerator_compatible_browser", "web_client_accelerator"]}
{"sample_id": 1844, "db_id": "wrestler", "question": "How many wrestlers are there?", "rationale": ["The user wants to know the total number of wrestlers.", "To get the count of wrestlers, we will use the COUNT() function in SQL.", "We will select from the 'wrestler' table, which contains the information about wrestlers.", "The final SQL query will be 'SELECT COUNT(*) AS total_wrestlers FROM wrestler;' to return the total count of wrestlers."], "pred_sql": "SELECT COUNT(*) AS total_wrestlers FROM wrestler;", "gold_sql": "SELECT count(*) FROM wrestler", "source_tables": ["wrestler"]}
{"sample_id": 1845, "db_id": "wrestler", "question": "Count the number of wrestlers.", "rationale": ["Identify the goal of the query: to count the number of wrestlers.", "Determine the appropriate table to query: the 'wrestler' table contains the relevant data.", "Use the COUNT() function to count the total number of entries in the 'wrestler' table.", "Construct the SQL query to select the count from the 'wrestler' table."], "pred_sql": "SELECT COUNT(*) AS NumberOfWrestlers FROM wrestler;", "gold_sql": "SELECT count(*) FROM wrestler", "source_tables": ["wrestler"]}
{"sample_id": 1846, "db_id": "wrestler", "question": "List the names of wrestlers in descending order of days held.", "rationale": ["Identify the table that contains the names of the wrestlers, which is the 'wrestler' table.", "Determine the column that contains the names, which is 'Name'.", "Identify the column that contains the number of days held, which is 'Days_held'.", "Specify that the results should be ordered in descending order based on the 'Days_held' column.", "Construct the SQL query to select the 'Name' from the 'wrestler' table and order the results by 'Days_held' in descending order."], "pred_sql": "SELECT Name FROM wrestler ORDER BY Days_held DESC;", "gold_sql": "SELECT Name FROM wrestler ORDER BY Days_held DESC", "source_tables": ["wrestler"]}
{"sample_id": 1847, "db_id": "wrestler", "question": "What are the names of the wrestlers, ordered descending by days held?", "rationale": ["Identify the table that contains the required information: the 'wrestler' table has the 'Name' and 'Days_held' columns.", "Select the 'Name' column from the 'wrestler' table.", "Order the results by the 'Days_held' column in descending order to get the wrestlers who held their titles the longest at the top."], "pred_sql": "SELECT Name FROM wrestler ORDER BY Days_held DESC;", "gold_sql": "SELECT Name FROM wrestler ORDER BY Days_held DESC", "source_tables": ["wrestler"]}
{"sample_id": 1848, "db_id": "wrestler", "question": "What is the name of the wrestler with the fewest days held?", "rationale": ["Identify the table that contains the relevant data: the 'wrestler' table has the 'Days_held' column.", "To find the wrestler with the fewest days held, we need to sort the results by the 'Days_held' column in ascending order.", "We will select the 'Name' of the wrestler from the 'wrestler' table.", "To get only the wrestler with the fewest days held, we will limit the results to 1 using 'LIMIT 1'."], "pred_sql": "SELECT Name FROM wrestler ORDER BY Days_held ASC LIMIT 1;", "gold_sql": "SELECT Name FROM wrestler ORDER BY Days_held ASC LIMIT 1", "source_tables": ["wrestler"]}
{"sample_id": 1849, "db_id": "wrestler", "question": "Return the name of the wrestler who had the lowest number of days held.", "rationale": ["Identify the table that contains the relevant data, which is the 'wrestler' table.", "We need to retrieve the 'Name' of the wrestler.", "To find the wrestler with the lowest number of days held, we will sort the results by the 'Days_held' column in ascending order.", "We will limit the results to 1 to get only the wrestler with the lowest days held."], "pred_sql": "SELECT Name FROM wrestler ORDER BY Days_held ASC LIMIT 1;", "gold_sql": "SELECT Name FROM wrestler ORDER BY Days_held ASC LIMIT 1", "source_tables": ["wrestler"]}
{"sample_id": 1850, "db_id": "wrestler", "question": "What are the distinct reigns of wrestlers whose location is not \"Tokyo,Japan\" ?", "rationale": ["Identify the table that contains the relevant data: the 'wrestler' table.", "Determine the specific column needed: 'Reign' for the distinct title reigns.", "Apply a condition to filter out locations: we want locations that are not 'Tokyo,Japan'.", "Use the DISTINCT keyword to ensure that only unique reigns are returned."], "pred_sql": "SELECT DISTINCT Reign FROM wrestler WHERE Location != 'Tokyo,Japan';", "gold_sql": "SELECT DISTINCT Reign FROM wrestler WHERE LOCATION != 'Tokyo , Japan'", "source_tables": ["wrestler"]}
{"sample_id": 1851, "db_id": "wrestler", "question": "Give the different reigns of wrestlers who are not located in Tokyo, Japan.", "rationale": ["Identify the table that contains the relevant information about wrestlers, which is the 'wrestler' table.", "Determine the columns needed for the query: we need the 'Reign' column to get the different reigns of wrestlers.", "Apply a condition to filter out wrestlers located in Tokyo, Japan. This is done using the WHERE clause with the condition 'Location != 'Tokyo, Japan'.", "Use DISTINCT to ensure that we only get unique reigns, avoiding duplicates in the results."], "pred_sql": "SELECT DISTINCT Reign FROM wrestler WHERE Location != 'Tokyo, Japan';", "gold_sql": "SELECT DISTINCT Reign FROM wrestler WHERE LOCATION != 'Tokyo , Japan'", "source_tables": ["wrestler"]}
{"sample_id": 1852, "db_id": "wrestler", "question": "What are the names and location of the wrestlers?", "rationale": ["Identify the required columns: 'Name' and 'Location'.", "Determine the table from which to retrieve these columns, which is the 'wrestler' table.", "Construct the SQL SELECT statement to fetch the specified columns from the 'wrestler' table."], "pred_sql": "SELECT Name, Location FROM wrestler;", "gold_sql": "SELECT Name ,  LOCATION FROM wrestler", "source_tables": ["wrestler"]}
{"sample_id": 1853, "db_id": "wrestler", "question": "Give the names and locations of all wrestlers.", "rationale": ["Identify the required columns: 'Name' and 'Location'.", "Determine the table from which to retrieve this data, which is the 'wrestler' table.", "Construct the SQL SELECT statement to fetch the specified columns from the 'wrestler' table."], "pred_sql": "SELECT Name, Location FROM wrestler;", "gold_sql": "SELECT Name ,  LOCATION FROM wrestler", "source_tables": ["wrestler"]}
{"sample_id": 1854, "db_id": "wrestler", "question": "What are the elimination moves of wrestlers whose team is \"Team Orton\"?", "rationale": ["Identify the relevant tables: Elimination and wrestler.", "Determine the columns needed: Elimination_Move from the Elimination table.", "Filter the results based on the team name 'Team Orton'.", "Join the Elimination table with the wrestler table on Wrestler_ID to ensure we are getting the correct wrestlers.", "Construct the SQL query to select the Elimination_Move for wrestlers in 'Team Orton'."], "pred_sql": "SELECT e.Elimination_Move FROM Elimination e JOIN wrestler w ON e.Wrestler_ID = w.Wrestler_ID WHERE e.Team = (SELECT Team FROM Elimination WHERE Team = 'Team Orton')", "gold_sql": "SELECT Elimination_Move FROM Elimination WHERE Team  =  'Team Orton'", "source_tables": ["elimination"]}
{"sample_id": 1855, "db_id": "wrestler", "question": "Return the elimination movies of wrestlers on Team Orton.", "rationale": ["Identify the relevant tables: Elimination and wrestler.", "We need to find the elimination moves of wrestlers on Team Orton, so we need to join the Elimination table with the wrestler table on the Wrestler_ID.", "To find Team Orton, we need to first identify the Team associated with the wrestler named 'Orton'.", "Use a subquery to get the Team ID for the wrestler 'Orton'.", "Then, filter the Elimination records to get the Elimination_Move for wrestlers who are part of that Team."], "pred_sql": "SELECT e.Elimination_Move FROM Elimination e JOIN wrestler w ON e.Wrestler_ID = w.Wrestler_ID WHERE e.Team = (SELECT Team FROM Elimination WHERE Wrestler_ID = (SELECT Wrestler_ID FROM wrestler WHERE Name = 'Orton'))", "gold_sql": "SELECT Elimination_Move FROM Elimination WHERE Team  =  'Team Orton'", "source_tables": ["elimination"]}
{"sample_id": 1856, "db_id": "wrestler", "question": "What are the names of wrestlers and the elimination moves?", "rationale": ["Identify the tables involved: 'wrestler' and 'Elimination'.", "Determine the columns needed: 'Name' from 'wrestler' and 'Elimination_Move' from 'Elimination'.", "Establish the relationship between the tables using the foreign key: 'Elimination.Wrestler_ID' references 'wrestler.Wrestler_ID'.", "Construct the SQL query using a JOIN to combine the two tables based on the relationship, selecting the required columns."], "pred_sql": "SELECT wrestler.Name, Elimination.Elimination_Move FROM wrestler JOIN Elimination ON wrestler.Wrestler_ID = Elimination.Wrestler_ID;", "gold_sql": "SELECT T2.Name ,  T1.Elimination_Move FROM elimination AS T1 JOIN wrestler AS T2 ON T1.Wrestler_ID  =  T2.Wrestler_ID", "source_tables": ["elimination", "wrestler"]}
{"sample_id": 1857, "db_id": "wrestler", "question": "Give the names of wrestlers and their elimination moves.", "rationale": ["Identify the tables involved: 'wrestler' and 'Elimination'.", "Determine the columns needed: 'Name' from 'wrestler' and 'Elimination_Move' from 'Elimination'.", "Establish the relationship between the tables using the foreign key: Elimination.Wrestler_ID = wrestler.Wrestler_ID.", "Construct the SQL SELECT statement to retrieve the desired columns from the joined tables."], "pred_sql": "SELECT wrestler.Name, Elimination.Elimination_Move FROM wrestler JOIN Elimination ON wrestler.Wrestler_ID = Elimination.Wrestler_ID;", "gold_sql": "SELECT T2.Name ,  T1.Elimination_Move FROM elimination AS T1 JOIN wrestler AS T2 ON T1.Wrestler_ID  =  T2.Wrestler_ID", "source_tables": ["elimination", "wrestler"]}
{"sample_id": 1858, "db_id": "wrestler", "question": "List the names of wrestlers and the teams in elimination in descending order of days held.", "rationale": ["Identify the tables involved: 'wrestler' and 'Elimination'.", "Determine the columns needed: 'Name' from 'wrestler' and 'Team' from 'Elimination'.", "Establish the relationship between the tables using the foreign key: 'Elimination.Wrestler_ID' references 'wrestler.Wrestler_ID'.", "Use a JOIN clause to combine data from both tables based on the wrestler's ID.", "Sort the results in descending order based on 'Days_held' from the 'wrestler' table."], "pred_sql": "SELECT w.Name, e.Team FROM wrestler w JOIN Elimination e ON w.Wrestler_ID = e.Wrestler_ID ORDER BY w.Days_held DESC;", "gold_sql": "SELECT T2.Name ,  T1.Team FROM elimination AS T1 JOIN wrestler AS T2 ON T1.Wrestler_ID  =  T2.Wrestler_ID ORDER BY T2.Days_held DESC", "source_tables": ["elimination", "wrestler"]}
{"sample_id": 1859, "db_id": "wrestler", "question": "What are the names of wrestlers and their teams in elimination, ordered descending by days held?", "rationale": ["Identify the tables involved: 'wrestler' and 'Elimination'.", "Determine the columns needed: 'Name' from 'wrestler' and 'Team' from 'Elimination'.", "Establish the relationship between the tables using the foreign key: 'Elimination.Wrestler_ID' references 'wrestler.Wrestler_ID'.", "Use a JOIN clause to combine data from both tables based on the relationship.", "Add an ORDER BY clause to sort the results by 'Days_held' in descending order."], "pred_sql": "SELECT w.Name, e.Team FROM wrestler w JOIN Elimination e ON w.Wrestler_ID = e.Wrestler_ID ORDER BY w.Days_held DESC;", "gold_sql": "SELECT T2.Name ,  T1.Team FROM elimination AS T1 JOIN wrestler AS T2 ON T1.Wrestler_ID  =  T2.Wrestler_ID ORDER BY T2.Days_held DESC", "source_tables": ["elimination", "wrestler"]}
{"sample_id": 1860, "db_id": "wrestler", "question": "List the time of elimination of the wrestlers with largest days held.", "rationale": ["Identify the relevant tables: 'wrestler' for wrestler details and 'Elimination' for elimination events.", "Determine the information needed: the time of elimination for wrestlers with the largest days held.", "Find the wrestler(s) with the maximum 'Days_held'. This requires a subquery to get the maximum value from the 'Days_held' column in the 'wrestler' table.", "Join the 'Elimination' table with the 'wrestler' table on 'Wrestler_ID' to link eliminations to the corresponding wrestlers.", "Filter the results to only include those wrestlers whose 'Days_held' matches the maximum value found in the subquery.", "Select the 'Time' of elimination from the filtered results."], "pred_sql": "SELECT e.Time FROM Elimination e JOIN wrestler w ON e.Wrestler_ID = w.Wrestler_ID WHERE w.Days_held = (SELECT MAX(Days_held) FROM wrestler)", "gold_sql": "SELECT T1.Time FROM elimination AS T1 JOIN wrestler AS T2 ON T1.Wrestler_ID  =  T2.Wrestler_ID ORDER BY T2.Days_held DESC LIMIT 1", "source_tables": ["elimination", "wrestler"]}
{"sample_id": 1861, "db_id": "wrestler", "question": "What is the time of elimination for the wrestler with the most days held?", "rationale": ["Identify the wrestler with the most days held by using a subquery to find the maximum value in the 'Days_held' column of the 'wrestler' table.", "Join the 'Elimination' table with the 'wrestler' table on the 'Wrestler_ID' to access the elimination times for the identified wrestler.", "Select the 'Time' of elimination from the 'Elimination' table where the 'Wrestler_ID' corresponds to the wrestler with the maximum days held."], "pred_sql": "SELECT e.Time FROM Elimination e JOIN wrestler w ON e.Wrestler_ID = w.Wrestler_ID WHERE w.Days_held = (SELECT MAX(Days_held) FROM wrestler);", "gold_sql": "SELECT T1.Time FROM elimination AS T1 JOIN wrestler AS T2 ON T1.Wrestler_ID  =  T2.Wrestler_ID ORDER BY T2.Days_held DESC LIMIT 1", "source_tables": ["elimination", "wrestler"]}
{"sample_id": 1862, "db_id": "wrestler", "question": "Show times of elimination of wrestlers with days held more than 50.", "rationale": ["Identify the relevant tables: Elimination and wrestler.", "Determine the columns needed: we need the 'Time' of elimination from the Elimination table.", "We need to filter wrestlers based on the condition of 'Days_held' being more than 50, which is in the wrestler table.", "Join the Elimination table with the wrestler table on the common column 'Wrestler_ID'.", "Construct the SQL query to select the 'Time' from the Elimination table where the corresponding wrestler's 'Days_held' is greater than 50."], "pred_sql": "SELECT e.Time FROM Elimination e JOIN wrestler w ON e.Wrestler_ID = w.Wrestler_ID WHERE w.Days_held > '50';", "gold_sql": "SELECT T1.Time FROM elimination AS T1 JOIN wrestler AS T2 ON T1.Wrestler_ID  =  T2.Wrestler_ID WHERE T2.Days_held  >  50", "source_tables": ["elimination", "wrestler"]}
{"sample_id": 1863, "db_id": "wrestler", "question": "What are the times of elimination for wrestlers with over 50 days held?", "rationale": ["Identify the relevant tables: Elimination and wrestler.", "Determine the columns needed: we need the 'Time' from the Elimination table and we need to filter based on 'Days_held' from the wrestler table.", "Join the two tables on the common column 'Wrestler_ID'.", "Apply the condition to filter wrestlers who have held the title for more than 50 days.", "Construct the SQL query to select the 'Time' of elimination for those wrestlers."], "pred_sql": "SELECT e.Time FROM Elimination e JOIN wrestler w ON e.Wrestler_ID = w.Wrestler_ID WHERE w.Days_held > '50';", "gold_sql": "SELECT T1.Time FROM elimination AS T1 JOIN wrestler AS T2 ON T1.Wrestler_ID  =  T2.Wrestler_ID WHERE T2.Days_held  >  50", "source_tables": ["elimination", "wrestler"]}
{"sample_id": 1864, "db_id": "wrestler", "question": "Show different teams in eliminations and the number of eliminations from each team.", "rationale": ["Identify the relevant table: The Elimination table contains information about eliminations and teams.", "Determine the required output: We need to show different teams and the count of eliminations for each team.", "Use the COUNT() function to count the number of eliminations for each team.", "Group the results by the Team column to get the count for each distinct team."], "pred_sql": "SELECT Team, COUNT(*) AS Number_of_Eliminations FROM Elimination GROUP BY Team;", "gold_sql": "SELECT Team ,  COUNT(*) FROM elimination GROUP BY Team", "source_tables": ["elimination"]}
{"sample_id": 1865, "db_id": "wrestler", "question": "How many eliminations did each team have?", "rationale": ["Identify the relevant table: The Elimination table contains the data about eliminations and teams.", "Determine the required information: We need to count the number of eliminations for each team.", "Use the COUNT() function: This function will help us count the number of eliminations per team.", "Group the results by Team: To get the count for each team, we will use the GROUP BY clause on the Team column."], "pred_sql": "SELECT Team, COUNT(*) AS Total_Eliminations FROM Elimination GROUP BY Team;", "gold_sql": "SELECT Team ,  COUNT(*) FROM elimination GROUP BY Team", "source_tables": ["elimination"]}
{"sample_id": 1866, "db_id": "wrestler", "question": "Show teams that have suffered more than three eliminations.", "rationale": ["Identify the relevant table: The 'Elimination' table contains information about eliminations, including the team involved.", "Determine the necessary columns: We need the 'Team' column to identify which teams are involved in eliminations and a count of eliminations for each team.", "Use the COUNT() function: This function will help us count the number of eliminations for each team.", "Group the results: We will use GROUP BY on the 'Team' column to aggregate the elimination counts for each team.", "Filter the results: We will use HAVING to filter teams that have more than three eliminations."], "pred_sql": "SELECT Team, COUNT(*) AS Elimination_Count FROM Elimination GROUP BY Team HAVING COUNT(*) > 3;", "gold_sql": "SELECT Team FROM elimination GROUP BY Team HAVING COUNT(*)  >  3", "source_tables": ["elimination"]}
{"sample_id": 1867, "db_id": "wrestler", "question": "Which teams had more than 3 eliminations?", "rationale": ["Identify the relevant table: The query is about teams and eliminations, so we will use the 'Elimination' table.", "We need to count the number of eliminations for each team. This requires grouping the results by the 'Team' column.", "Use the COUNT() function to count the number of eliminations for each team.", "To filter the results to only include teams with more than 3 eliminations, we will use the HAVING clause with COUNT(*) > 3."], "pred_sql": "SELECT Team, COUNT(*) AS Elimination_Count FROM Elimination GROUP BY Team HAVING COUNT(*) > 3;", "gold_sql": "SELECT Team FROM elimination GROUP BY Team HAVING COUNT(*)  >  3", "source_tables": ["elimination"]}
{"sample_id": 1868, "db_id": "wrestler", "question": "Show the reign and days held of wrestlers.", "rationale": ["Identify the required columns: 'Reign' and 'Days_held'.", "Determine the table from which to select these columns, which is the 'wrestler' table.", "Construct the SQL SELECT statement to retrieve the specified columns from the 'wrestler' table."], "pred_sql": "SELECT Reign, Days_held FROM wrestler;", "gold_sql": "SELECT Reign ,  Days_held FROM wrestler", "source_tables": ["wrestler"]}
{"sample_id": 1869, "db_id": "wrestler", "question": "What are the reigns and days held of all wrestlers?", "rationale": ["Identify the required information: reigns and days held of all wrestlers.", "Determine the relevant table: the 'wrestler' table contains the necessary columns.", "Construct the SQL SELECT statement to retrieve 'Reign' and 'Days_held' from the 'wrestler' table."], "pred_sql": "SELECT Reign, Days_held FROM wrestler;", "gold_sql": "SELECT Reign ,  Days_held FROM wrestler", "source_tables": ["wrestler"]}
{"sample_id": 1870, "db_id": "wrestler", "question": "What are the names of wrestlers days held less than 100?", "rationale": ["Identify the table that contains the relevant data: the 'wrestler' table.", "Determine the columns needed: we need the 'Name' of the wrestlers and the 'Days_held' to filter the results.", "Formulate the condition: we want wrestlers whose 'Days_held' is less than 100.", "Construct the SQL SELECT statement to retrieve the 'Name' from the 'wrestler' table where the condition is met."], "pred_sql": "SELECT Name FROM wrestler WHERE Days_held < '100';", "gold_sql": "SELECT Name FROM wrestler WHERE Days_held  <  100", "source_tables": ["wrestler"]}
{"sample_id": 1871, "db_id": "wrestler", "question": "Return the names of wrestlers with fewer than 100 days held.", "rationale": ["Identify the table that contains the relevant data: the 'wrestler' table.", "Determine the column that contains the names of the wrestlers: the 'Name' column.", "Identify the column that indicates the number of days held: the 'Days_held' column.", "Formulate the condition to filter wrestlers with fewer than 100 days held: 'Days_held < 100'.", "Construct the SQL SELECT statement to retrieve the 'Name' of wrestlers that meet the condition."], "pred_sql": "SELECT Name FROM wrestler WHERE Days_held < '100';", "gold_sql": "SELECT Name FROM wrestler WHERE Days_held  <  100", "source_tables": ["wrestler"]}
{"sample_id": 1872, "db_id": "wrestler", "question": "Please show the most common reigns of wrestlers.", "rationale": ["Identify the relevant table: The 'wrestler' table contains the 'Reign' column which is needed to find the most common reigns.", "Use the COUNT function to count occurrences of each reign.", "Group the results by the 'Reign' column to aggregate the counts for each unique reign.", "Order the results in descending order based on the count to show the most common reigns first."], "pred_sql": "SELECT Reign, COUNT(*) as Reign_Count FROM wrestler GROUP BY Reign ORDER BY Reign_Count DESC;", "gold_sql": "SELECT Reign FROM wrestler GROUP BY Reign ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["wrestler"]}
{"sample_id": 1873, "db_id": "wrestler", "question": "Which reign is the most common among wrestlers?", "rationale": ["Identify the relevant table: The 'wrestler' table contains the 'Reign' column which we need to analyze.", "Count the occurrences of each reign: We will use the COUNT() function to count how many times each reign appears.", "Group the results by reign: We will use GROUP BY to group the results based on the 'Reign' column.", "Order the results: To find the most common reign, we will order the results in descending order based on the count of reigns.", "Limit the results: Since we only want the most common reign, we will limit the results to 1."], "pred_sql": "SELECT Reign, COUNT(*) as Reign_Count FROM wrestler GROUP BY Reign ORDER BY Reign_Count DESC LIMIT 1;", "gold_sql": "SELECT Reign FROM wrestler GROUP BY Reign ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["wrestler"]}
{"sample_id": 1874, "db_id": "wrestler", "question": "List the locations that are shared by more than two wrestlers.", "rationale": ["Identify the table that contains the location information, which is the 'wrestler' table.", "We need to group the results by 'Location' to count how many wrestlers are associated with each location.", "Use the COUNT function to count the number of 'Wrestler_ID' entries for each location.", "Apply a HAVING clause to filter the results to only include locations where the count of wrestlers is greater than 2."], "pred_sql": "SELECT Location FROM wrestler GROUP BY Location HAVING COUNT(Wrestler_ID) > 2;", "gold_sql": "SELECT LOCATION FROM wrestler GROUP BY LOCATION HAVING COUNT(*)  >  2", "source_tables": ["wrestler"]}
{"sample_id": 1875, "db_id": "wrestler", "question": "Which locations are shared by more than two wrestlers?", "rationale": ["Identify the relevant table: The 'wrestler' table contains the 'Location' column.", "Determine the requirement: We need to find locations shared by more than two wrestlers.", "Use GROUP BY: We will group the results by 'Location' to aggregate the data for each location.", "Count distinct wrestlers: We will use COUNT(DISTINCT Wrestler_ID) to count the number of unique wrestlers at each location.", "Apply HAVING clause: We will filter the results using HAVING to only include locations where the count of distinct wrestlers is greater than 2."], "pred_sql": "SELECT Location FROM wrestler GROUP BY Location HAVING COUNT(DISTINCT Wrestler_ID) > 2;", "gold_sql": "SELECT LOCATION FROM wrestler GROUP BY LOCATION HAVING COUNT(*)  >  2", "source_tables": ["wrestler"]}
{"sample_id": 1876, "db_id": "wrestler", "question": "List the names of wrestlers that have not been eliminated.", "rationale": ["Identify the main table to query from, which is 'wrestler' for the names of wrestlers.", "We need to find wrestlers who have not been eliminated, which means we need to check against the 'Elimination' table.", "To find wrestlers that have not been eliminated, we can use a subquery to select all 'Wrestler_ID's from the 'Elimination' table.", "We will use the NOT IN clause to filter out those wrestlers from the main query.", "The final SQL query selects the 'Name' of wrestlers whose 'Wrestler_ID' is not present in the list of eliminated wrestlers."], "pred_sql": "SELECT Name FROM wrestler WHERE Wrestler_ID NOT IN (SELECT Wrestler_ID FROM Elimination)", "gold_sql": "SELECT Name FROM wrestler WHERE Wrestler_ID NOT IN (SELECT Wrestler_ID FROM elimination)", "source_tables": ["elimination", "wrestler"]}
{"sample_id": 1877, "db_id": "wrestler", "question": "What are the names of wrestlers who have never been eliminated?", "rationale": ["Identify the main table to query from, which is 'wrestler' for the names of the wrestlers.", "We need to find wrestlers who have never been eliminated, which means we need to check against the 'Elimination' table.", "To find wrestlers who have never been eliminated, we can use a subquery that selects all 'Wrestler_ID's from the 'Elimination' table.", "We will use the NOT IN clause to filter out any wrestlers whose IDs are present in the subquery result.", "Finally, we select the 'Name' column from the 'wrestler' table where the 'Wrestler_ID' is not in the list of eliminated wrestlers."], "pred_sql": "SELECT Name FROM wrestler WHERE Wrestler_ID NOT IN (SELECT Wrestler_ID FROM Elimination)", "gold_sql": "SELECT Name FROM wrestler WHERE Wrestler_ID NOT IN (SELECT Wrestler_ID FROM elimination)", "source_tables": ["elimination", "wrestler"]}
{"sample_id": 1878, "db_id": "wrestler", "question": "Show the teams that have both wrestlers eliminated by \"Orton\" and wrestlers eliminated by \"Benjamin\".", "rationale": ["Identify the requirement to find teams with wrestlers eliminated by both 'Orton' and 'Benjamin'.", "To achieve this, we need to join the Elimination table with itself to find common teams.", "Use a subquery to get the Wrestler_ID for 'Orton' and another subquery for 'Benjamin'.", "Filter the results to ensure that both conditions (eliminated by 'Orton' and 'Benjamin') are met for the same team.", "Select distinct teams to avoid duplicates in the result."], "pred_sql": "SELECT DISTINCT e1.Team\nFROM Elimination e1\nJOIN Elimination e2 ON e1.Team = e2.Team\nWHERE e1.Eliminated_By = (SELECT Wrestler_ID FROM wrestler WHERE Name = 'Orton')\nAND e2.Eliminated_By = (SELECT Wrestler_ID FROM wrestler WHERE Name = 'Benjamin');", "gold_sql": "SELECT Team FROM Elimination WHERE Eliminated_By  =  'Orton' INTERSECT SELECT Team FROM Elimination WHERE Eliminated_By  =  'Benjamin'", "source_tables": ["elimination"]}
{"sample_id": 1879, "db_id": "wrestler", "question": "What are the teams that have both wrestlers eliminated by Orton and wrestlers eliminated by Benjamin?", "rationale": ["Identify the requirement: We need to find teams that have wrestlers eliminated by both Orton and Benjamin.", "To achieve this, we will need to join the Elimination table with itself to find common teams.", "We will filter the first instance of the Elimination table (e1) for eliminations performed by Orton.", "We will filter the second instance of the Elimination table (e2) for eliminations performed by Benjamin.", "We will use a JOIN on the Team column to find teams that appear in both filtered results.", "Finally, we will select distinct teams to avoid duplicates."], "pred_sql": "SELECT DISTINCT e1.Team\nFROM Elimination e1\nJOIN Elimination e2 ON e1.Team = e2.Team\nWHERE e1.Eliminated_By = (SELECT Wrestler_ID FROM wrestler WHERE Name = 'Orton')\nAND e2.Eliminated_By = (SELECT Wrestler_ID FROM wrestler WHERE Name = 'Benjamin');", "gold_sql": "SELECT Team FROM Elimination WHERE Eliminated_By  =  'Orton' INTERSECT SELECT Team FROM Elimination WHERE Eliminated_By  =  'Benjamin'", "source_tables": ["elimination"]}
{"sample_id": 1880, "db_id": "wrestler", "question": "What is the number of distinct teams that suffer elimination?", "rationale": ["Identify the relevant table: The query is about teams suffering elimination, so we focus on the 'Elimination' table.", "Determine the required information: We need to count the distinct teams that have been eliminated.", "Use the COUNT function: To get the number of distinct teams, we will use COUNT(DISTINCT Team).", "Construct the SQL query: We will select the count of distinct teams from the Elimination table."], "pred_sql": "SELECT COUNT(DISTINCT Team) AS Distinct_Teams_Eliminated FROM Elimination;", "gold_sql": "SELECT COUNT (DISTINCT team) FROM elimination", "source_tables": ["elimination"]}
{"sample_id": 1881, "db_id": "wrestler", "question": "How many different teams have had eliminated wrestlers?", "rationale": ["Identify the relevant table: The query is about teams that have eliminated wrestlers, so we will focus on the 'Elimination' table.", "Determine the required information: We need to count the number of distinct teams that have had eliminated wrestlers.", "Use the COUNT function: To get the number of different teams, we will use the COUNT function along with DISTINCT to ensure we only count unique teams.", "Construct the SQL query: The final SQL query will select the count of distinct teams from the Elimination table."], "pred_sql": "SELECT COUNT(DISTINCT Team) AS Different_Teams FROM Elimination;", "gold_sql": "SELECT COUNT (DISTINCT team) FROM elimination", "source_tables": ["elimination"]}
{"sample_id": 1882, "db_id": "wrestler", "question": "Show the times of elimination by \"Punk\" or \"Orton\".", "rationale": ["Identify the relevant tables: Elimination and wrestler.", "Determine the columns needed: we need the 'Time' of elimination from the Elimination table.", "We need to filter the results based on the names of the wrestlers, which are in the wrestler table.", "Join the Elimination table with the wrestler table on the Wrestler_ID to access the names of the wrestlers.", "Use a WHERE clause to filter for wrestlers with the names 'Punk' or 'Orton'.", "Select the 'Time' column from the resulting joined table."], "pred_sql": "SELECT e.Time FROM Elimination e JOIN wrestler w ON e.Wrestler_ID = w.Wrestler_ID WHERE w.Name IN ('Punk', 'Orton');", "gold_sql": "SELECT TIME FROM elimination WHERE Eliminated_By  =  'Punk' OR Eliminated_By  =  'Orton'", "source_tables": ["elimination"]}
{"sample_id": 1883, "db_id": "wrestler", "question": "What are the times of elimination for any instances in which the elimination was done by Punk or Orton?", "rationale": ["Identify the relevant table: The query requires information from the Elimination table, specifically the 'Time' column.", "Determine the condition for elimination: The elimination must be performed by either Punk or Orton.", "Find the Wrestler_IDs for Punk and Orton: This requires a subquery to select the Wrestler_IDs from the wrestler table where the Name is either 'Punk' or 'Orton'.", "Construct the main query: Use the selected Wrestler_IDs to filter the Elimination table for the 'Time' of eliminations done by these wrestlers."], "pred_sql": "SELECT Time FROM Elimination WHERE Eliminated_By IN (SELECT Wrestler_ID FROM wrestler WHERE Name IN ('Punk', 'Orton'));", "gold_sql": "SELECT TIME FROM elimination WHERE Eliminated_By  =  'Punk' OR Eliminated_By  =  'Orton'", "source_tables": ["elimination"]}
{"sample_id": 1884, "db_id": "school_finance", "question": "How many schools are there?", "rationale": ["Identify the requirement to count the number of schools.", "Determine the relevant table, which is 'School'.", "Use the COUNT() function to count the total number of records in the 'School' table.", "Construct the SQL query to select the count from the 'School' table."], "pred_sql": "SELECT COUNT(*) AS total_schools FROM School;", "gold_sql": "SELECT count(*) FROM school", "source_tables": ["school"]}
{"sample_id": 1885, "db_id": "school_finance", "question": "Count the number of schools.", "rationale": ["Identify the goal of the query, which is to count the number of schools.", "Determine the relevant table to query, which is the 'School' table.", "Use the COUNT() function to count the total number of records in the 'School' table.", "Construct the SQL query to select the count from the 'School' table."], "pred_sql": "SELECT COUNT(*) AS number_of_schools FROM School;", "gold_sql": "SELECT count(*) FROM school", "source_tables": ["school"]}
{"sample_id": 1886, "db_id": "school_finance", "question": "Show all school names in alphabetical order.", "rationale": ["Identify the table that contains the school names, which is the 'School' table.", "Select the 'School_name' column from the 'School' table.", "To display the names in alphabetical order, use the ORDER BY clause with 'School_name' and specify ASC for ascending order."], "pred_sql": "SELECT School_name FROM School ORDER BY School_name ASC;", "gold_sql": "SELECT school_name FROM school ORDER BY school_name", "source_tables": ["school"]}
{"sample_id": 1887, "db_id": "school_finance", "question": "List the name, location, mascot for all schools.", "rationale": ["Identify the required columns: School_name, Location, and Mascot.", "Determine the table that contains these columns, which is the School table.", "Construct the SQL SELECT statement to retrieve the specified columns from the School table."], "pred_sql": "SELECT School_name, Location, Mascot FROM School;", "gold_sql": "SELECT school_name ,  LOCATION ,  mascot FROM school", "source_tables": ["school"]}
{"sample_id": 1888, "db_id": "school_finance", "question": "What are the total and average enrollment of all schools?", "rationale": ["Identify the required data: total and average enrollment of all schools.", "Determine the appropriate SQL functions: SUM() for total and AVG() for average.", "Select the 'Enrollment' column from the 'School' table.", "Construct the SQL query to calculate both total and average enrollment using the identified functions."], "pred_sql": "SELECT SUM(Enrollment) AS total_enrollment, AVG(Enrollment) AS average_enrollment FROM School;", "gold_sql": "SELECT sum(enrollment) ,  avg(enrollment) FROM school", "source_tables": ["school"]}
{"sample_id": 1889, "db_id": "school_finance", "question": "What are the mascots for schools with enrollments above the average?", "rationale": ["Identify the relevant table: The query requires information about school mascots, which are found in the 'School' table.", "Determine the condition: We need to find schools with enrollments above the average enrollment.", "Calculate the average enrollment: This can be done using a subquery that selects the average of the 'Enrollment' column from the 'School' table.", "Construct the main query: Select the 'Mascot' from the 'School' table where the 'Enrollment' is greater than the average calculated in the subquery."], "pred_sql": "SELECT Mascot FROM School WHERE Enrollment > (SELECT AVG(Enrollment) FROM School)", "gold_sql": "SELECT mascot FROM school WHERE enrollment  >  (SELECT avg(enrollment) FROM school)", "source_tables": ["school"]}
{"sample_id": 1890, "db_id": "school_finance", "question": "List the name of the school with the smallest enrollment.", "rationale": ["Identify the relevant table: The 'School' table contains the 'School_name' and 'Enrollment' columns.", "Determine the requirement: We need to find the school with the smallest enrollment.", "Use the ORDER BY clause to sort the schools by 'Enrollment' in ascending order.", "Limit the results to 1 to get only the school with the smallest enrollment."], "pred_sql": "SELECT School_name FROM School ORDER BY Enrollment ASC LIMIT 1;", "gold_sql": "SELECT school_name FROM school ORDER BY enrollment LIMIT 1", "source_tables": ["school"]}
{"sample_id": 1891, "db_id": "school_finance", "question": "Show the average, maximum, minimum enrollment of all schools.", "rationale": ["Identify the required calculations: average, maximum, and minimum of the 'Enrollment' column.", "Determine the table that contains the 'Enrollment' data, which is the 'School' table.", "Use aggregate functions in SQL: AVG() for average, MAX() for maximum, and MIN() for minimum.", "Construct the SQL SELECT statement to retrieve the average, maximum, and minimum values from the 'Enrollment' column in the 'School' table."], "pred_sql": "SELECT AVG(Enrollment) AS average_enrollment, MAX(Enrollment) AS maximum_enrollment, MIN(Enrollment) AS minimum_enrollment FROM School;", "gold_sql": "SELECT avg(enrollment) ,  max(enrollment) ,  min(enrollment) FROM school", "source_tables": ["school"]}
{"sample_id": 1892, "db_id": "school_finance", "question": "Show each county along with the number of schools and total enrollment in each county.", "rationale": ["Identify the relevant table: The 'School' table contains the necessary information about schools and their locations.", "Determine the required output: We need to show each county, the number of schools in that county, and the total enrollment for those schools.", "Use aggregate functions: COUNT() will be used to count the number of schools, and SUM() will be used to calculate the total enrollment.", "Group the results: To get the number of schools and total enrollment per county, we will use the GROUP BY clause on the 'County' column."], "pred_sql": "SELECT County, COUNT(School_id) AS Number_of_Schools, SUM(Enrollment) AS Total_Enrollment FROM School GROUP BY County;", "gold_sql": "SELECT county ,  count(*) ,  sum(enrollment) FROM school GROUP BY county", "source_tables": ["school"]}
{"sample_id": 1893, "db_id": "school_finance", "question": "How many donors have endowment for school named \"Glenn\"?", "rationale": ["Identify the relevant tables: We need to use the 'endowment' table to find donors and the 'School' table to filter by school name.", "Determine the relationship: The 'endowment' table has a foreign key 'School_id' that links to the 'School' table, allowing us to join these tables.", "Formulate the query: We want to count distinct donors for the school named 'Glenn'.", "Use a JOIN clause to combine 'endowment' and 'School' on 'School_id'.", "Add a WHERE clause to filter results for the school with the name 'Glenn'.", "Select the count of distinct donor names to get the number of unique donors."], "pred_sql": "SELECT COUNT(DISTINCT e.donator_name) AS donor_count \nFROM endowment e \nJOIN School s ON e.School_id = s.School_id \nWHERE s.School_name = 'Glenn';", "gold_sql": "SELECT count(DISTINCT T1.donator_name) FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  'Glenn'", "source_tables": ["endowment", "school"]}
{"sample_id": 1894, "db_id": "school_finance", "question": "List each donator name and the amount of endowment in descending order of the amount of endowment.", "rationale": ["Identify the relevant table: The endowment table contains the information about donators and the amounts donated.", "Select the required columns: We need to select 'donator_name' and 'amount' from the endowment table.", "Sort the results: The results should be sorted in descending order based on the 'amount' of endowment.", "Construct the SQL query: Combine the SELECT statement with the ORDER BY clause to form the complete SQL query."], "pred_sql": "SELECT donator_name, amount FROM endowment ORDER BY amount DESC;", "gold_sql": "SELECT donator_name ,  sum(amount) FROM endowment GROUP BY donator_name ORDER BY sum(amount) DESC", "source_tables": ["endowment"]}
{"sample_id": 1895, "db_id": "school_finance", "question": "List the names of the schools without any endowment.", "rationale": ["Identify the main table to query, which is the 'School' table since we need the names of the schools.", "We need to filter out schools that have endowments, which are listed in the 'endowment' table.", "To find schools without endowments, we can use a subquery that selects all 'School_id's from the 'endowment' table.", "The main query will select 'School_name' from the 'School' table where the 'School_id' is not in the list of 'School_id's returned by the subquery."], "pred_sql": "SELECT School_name FROM School WHERE School_id NOT IN (SELECT School_id FROM endowment);", "gold_sql": "SELECT school_name FROM school WHERE school_id NOT IN (SELECT school_id FROM endowment)", "source_tables": ["endowment", "school"]}
{"sample_id": 1896, "db_id": "school_finance", "question": "List all the names of schools with an endowment amount smaller than or equal to 10.", "rationale": ["Identify the tables involved: We need to retrieve school names and endowment amounts, so we will use the 'School' and 'endowment' tables.", "Determine the relationship: The 'endowment' table has a foreign key 'School_id' that relates to the 'School' table, allowing us to join these tables.", "Specify the selection criteria: We want to filter the results to include only those endowment amounts that are less than or equal to 10.", "Construct the SQL query: We will use a SELECT statement to get 'School_name' from the 'School' table, joining it with the 'endowment' table on 'School_id', and applying the WHERE clause for the endowment amount."], "pred_sql": "SELECT School_name FROM School JOIN endowment ON School.School_id = endowment.School_id WHERE amount <= 10;", "gold_sql": "SELECT T2.school_name FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id GROUP BY T1.school_id HAVING sum(T1.amount)  <=  10", "source_tables": ["endowment", "school"]}
{"sample_id": 1897, "db_id": "school_finance", "question": "Show the names of donors who donated to both school \"Glenn\" and \"Triton.\"", "rationale": ["Identify the tables involved: We need to look at the 'endowment' table to find donor names and the 'School' table to filter by school names.", "We need to find donors who donated to both 'Glenn' and 'Triton'. This requires us to find the intersection of donors from both schools.", "First, we will select the distinct donor names from the 'endowment' table where the associated school is 'Glenn'.", "Next, we will select the distinct donor names from the 'endowment' table where the associated school is 'Triton'.", "To find donors who donated to both schools, we will use the INTERSECT operator to combine the results of the two queries."], "pred_sql": "SELECT DISTINCT e1.donator_name \nFROM endowment e1 \nJOIN School s1 ON e1.School_id = s1.School_id \nWHERE s1.School_name = 'Glenn' \nINTERSECT \nSELECT DISTINCT e2.donator_name \nFROM endowment e2 \nJOIN School s2 ON e2.School_id = s2.School_id \nWHERE s2.School_name = 'Triton';", "gold_sql": "SELECT T1.donator_name FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  'Glenn' INTERSECT SELECT T1.donator_name FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  'Triton'", "source_tables": ["endowment", "school"]}
{"sample_id": 1898, "db_id": "school_finance", "question": "Show the names of all the donors except those whose donation amount less than 9.", "rationale": ["Identify the relevant table: The 'endowment' table contains information about donors and their donation amounts.", "Select the column of interest: We need the 'donator_name' column to show the names of the donors.", "Apply the condition: We want to exclude donors whose donation amount is less than 9, so we will use a WHERE clause to filter the results based on the 'amount' column."], "pred_sql": "SELECT donator_name FROM endowment WHERE amount >= 9;", "gold_sql": "SELECT donator_name FROM endowment EXCEPT SELECT donator_name FROM endowment WHERE amount  <  9", "source_tables": ["endowment"]}
{"sample_id": 1899, "db_id": "school_finance", "question": "List the amount and donor name for the largest amount of donation.", "rationale": ["Identify the relevant table: The 'endowment' table contains the donation information including the amount and donor name.", "Determine the requirement: We need to find the largest donation amount and the corresponding donor name.", "Use a subquery to find the maximum donation amount: This can be done using the MAX() function on the 'amount' column in the 'endowment' table.", "Select the donor name and amount where the amount matches the maximum amount found in the subquery."], "pred_sql": "SELECT donator_name, amount FROM endowment WHERE amount = (SELECT MAX(amount) FROM endowment);", "gold_sql": "SELECT amount ,  donator_name FROM endowment ORDER BY amount DESC LIMIT 1", "source_tables": ["endowment"]}
{"sample_id": 1900, "db_id": "school_finance", "question": "How many budgets are above 3000 in year 2001 or before?", "rationale": ["Identify the table to query: The 'budget' table contains the relevant information about budgets.", "Determine the condition for filtering: We need to find budgets that are above 3000.", "Specify the year condition: We are interested in budgets from the year 2001 or before.", "Construct the SQL query: Use COUNT(*) to count the number of records that meet the conditions."], "pred_sql": "SELECT COUNT(*) FROM budget WHERE Budgeted > 3000 AND Year <= '2001';", "gold_sql": "SELECT count(*) FROM budget WHERE budgeted  >  3000 AND YEAR  <=  2001", "source_tables": ["budget"]}
{"sample_id": 1901, "db_id": "school_finance", "question": "Count the number of budgets in year 2001 or before whose budgeted amount is greater than 3000", "rationale": ["Identify the table that contains budget information, which is the 'budget' table.", "Determine the columns needed for the query: 'Year' and 'Budgeted'.", "Set the condition to filter budgets from the year 2001 or before, which translates to 'Year <= '2001' '.", "Set the condition to filter budgets where the budgeted amount is greater than 3000, which translates to 'Budgeted > '3000' '.", "Combine the conditions using the AND operator to ensure both conditions are met.", "Use the COUNT() function to count the number of records that meet the criteria."], "pred_sql": "SELECT COUNT(*) FROM budget WHERE Year <= '2001' AND Budgeted > '3000';", "gold_sql": "SELECT count(*) FROM budget WHERE budgeted  >  3000 AND YEAR  <=  2001", "source_tables": ["budget"]}
{"sample_id": 1902, "db_id": "school_finance", "question": "Show each school name, its budgeted amount, and invested amount in year 2002 or after.", "rationale": ["Identify the required columns: School name, budgeted amount, and invested amount.", "Determine the tables that contain these columns: 'School' for school name and 'budget' for budgeted and invested amounts.", "Establish the relationship between the tables using the foreign key: budget.School_id = School.School_id.", "Filter the results to include only those records where the year is 2002 or later.", "Construct the SQL SELECT statement to retrieve the desired columns from the joined tables with the specified condition."], "pred_sql": "SELECT School.School_name, budget.Budgeted, budget.Invested \nFROM School \nJOIN budget ON School.School_id = budget.School_id \nWHERE budget.Year >= '2002';", "gold_sql": "SELECT T2.school_name ,  T1.budgeted ,  T1.invested FROM budget AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T1.year  >=  2002", "source_tables": ["budget", "school"]}
{"sample_id": 1903, "db_id": "school_finance", "question": "Show all donor names.", "rationale": ["Identify the table that contains donor information, which is the 'endowment' table.", "Determine the specific column that holds the names of the donors, which is 'donator_name'.", "Construct the SQL query to select the 'donator_name' from the 'endowment' table."], "pred_sql": "SELECT donator_name FROM endowment;", "gold_sql": "SELECT DISTINCT donator_name FROM endowment", "source_tables": ["endowment"]}
{"sample_id": 1904, "db_id": "school_finance", "question": "How many budget record has a budget amount smaller than the invested amount?", "rationale": ["Identify the table that contains budget records, which is the 'budget' table.", "Determine the columns needed to compare the budgeted amount and the invested amount, which are 'Budgeted' and 'Invested'.", "Formulate a condition to filter records where the budgeted amount is less than the invested amount: 'Budgeted < Invested'.", "Use the COUNT() function to count the number of records that meet this condition.", "Construct the final SQL query to select the count from the 'budget' table with the specified condition."], "pred_sql": "SELECT COUNT(*) AS budget_records_count FROM budget WHERE Budgeted < Invested;", "gold_sql": "SELECT count(*) FROM budget WHERE budgeted  <  invested", "source_tables": ["budget"]}
{"sample_id": 1905, "db_id": "school_finance", "question": "What is the total budget amount for school \"Glenn\" in all years?", "rationale": ["Identify the relevant tables: 'budget' for budget information and 'School' for school names.", "We need to find the total budget amount for a specific school, which requires joining the 'budget' table with the 'School' table on the 'School_id'.", "Filter the results to only include the school named 'Glenn'.", "Use the SUM function to calculate the total budgeted amount across all years for the specified school."], "pred_sql": "SELECT SUM(budgeted) AS total_budget_amount FROM budget JOIN School ON budget.School_id = School.School_id WHERE School_name = 'Glenn';", "gold_sql": "SELECT sum(T1.budgeted) FROM budget AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T2.school_name  =  'Glenn'", "source_tables": ["budget", "school"]}
{"sample_id": 1906, "db_id": "school_finance", "question": "Show the names of schools with a total budget amount greater than 100 or a total endowment greater than 10.", "rationale": ["Identify the tables involved: School, budget, and endowment.", "Determine the columns needed: We need the School_name from the School table.", "Establish the conditions: We want schools with a total budget greater than 100 or a total endowment greater than 10.", "Join the tables on the School_id to access the relevant data from budget and endowment tables.", "Construct the SQL query using SELECT to get the School_name, JOIN to combine the tables, and WHERE to filter based on the specified conditions."], "pred_sql": "SELECT School.School_name \nFROM School \nJOIN budget ON School.School_id = budget.School_id \nJOIN endowment ON School.School_id = endowment.School_id \nWHERE budget.Budgeted > 100 OR endowment.amount > 10;", "gold_sql": "SELECT T2.school_name FROM budget AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id JOIN endowment AS T3 ON T2.school_id  =  T3.school_id GROUP BY T2.school_name HAVING sum(T1.budgeted)  >  100 OR sum(T3.amount)  >  10", "source_tables": ["budget", "school", "endowment"]}
{"sample_id": 1907, "db_id": "school_finance", "question": "Find the names of schools that have more than one donator with donation amount above 8.5.", "rationale": ["Identify the relevant tables: We need to look at the 'School' and 'endowment' tables since we are interested in school names and donation information.", "Join the tables: We will join the 'School' table with the 'endowment' table on the 'School_id' to link schools with their respective donations.", "Filter the donations: We need to filter the donations to only include those that are greater than 8.5, as specified in the query.", "Group the results: We will group the results by 'School_id' to count the number of donators for each school.", "Count the donators: We will use the HAVING clause to ensure that we only select schools that have more than one donator."], "pred_sql": "SELECT School.School_name \nFROM School \nJOIN endowment ON School.School_id = endowment.School_id \nWHERE endowment.amount > 8.5 \nGROUP BY School.School_id \nHAVING COUNT(endowment.donator_name) > 1;", "gold_sql": "SELECT T2.School_name FROM endowment AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id WHERE T1.amount  >  8.5 GROUP BY T1.school_id HAVING count(*)  >  1", "source_tables": ["endowment", "school"]}
{"sample_id": 1908, "db_id": "school_finance", "question": "Find the number of schools that have more than one donator whose donation amount is less than 8.5.", "rationale": ["We need to find schools with more than one donator.", "We will use the 'endowment' table since it contains information about donations.", "We will filter the donations to include only those with an amount less than 8.5.", "We will group the results by 'School_id' to count the number of donators for each school.", "We will use the HAVING clause to filter groups that have more than one donator.", "Finally, we will count the distinct 'School_id' values that meet these criteria."], "pred_sql": "SELECT COUNT(DISTINCT e.School_id) AS number_of_schools\nFROM endowment e\nWHERE e.amount < 8.5\nGROUP BY e.School_id\nHAVING COUNT(e.donator_name) > 1;", "gold_sql": "SELECT count(*) FROM (SELECT * FROM endowment WHERE amount  >  8.5 GROUP BY school_id HAVING count(*)  >  1)", "source_tables": ["endowment"]}
{"sample_id": 1909, "db_id": "school_finance", "question": "List the name, IHSAA Football Class, and Mascot of the schools that have more than 6000 of budgeted amount or were founded before 2003, in the order of percent of total invested budget and total budgeted budget.", "rationale": ["Identify the columns needed: School_name, IHSAA_Football_Class, and Mascot from the School table.", "Join the School table with the budget table on School_id to access budget information.", "Filter the results to include schools with a budgeted amount greater than 6000 or those founded before 2003 (assuming founded schools are represented in the endowment table).", "Use a subquery to check for schools that have received endowments, which implies they were founded before 2003.", "Order the results by total_budget_percent_invested and total_budget_percent_budgeted, converting them to appropriate numeric types for accurate sorting."], "pred_sql": "SELECT School.School_name, School.IHSAA_Football_Class, School.Mascot \nFROM School \nJOIN budget ON School.School_id = budget.School_id \nWHERE (CAST(budget.Budgeted AS INTEGER) > 6000 OR School.School_id IN (SELECT School_id FROM endowment WHERE endowment.amount > 0)) \nORDER BY CAST(budget.total_budget_percent_invested AS FLOAT), CAST(budget.total_budget_percent_budgeted AS FLOAT);", "gold_sql": "SELECT T1.School_name ,  T1.Mascot ,  T1.IHSAA_Football_Class FROM school AS T1 JOIN budget AS T2 ON T1.school_id  =  T2.school_id WHERE Budgeted  >  6000 OR YEAR  <  2003 ORDER BY T2.total_budget_percent_invested ,  T2.total_budget_percent_budgeted", "source_tables": ["budget", "school"]}
{"sample_id": 1910, "db_id": "protein_institute", "question": "How many buildings are there?", "rationale": ["Identify the requirement to count the number of buildings.", "Determine the relevant table, which is 'building'.", "Use the COUNT() function to count all entries in the 'building' table.", "Construct the SQL query to select the count from the 'building' table."], "pred_sql": "SELECT COUNT(*) AS total_buildings FROM building;", "gold_sql": "SELECT count(*) FROM building", "source_tables": ["building"]}
{"sample_id": 1911, "db_id": "protein_institute", "question": "Show the name, street address, and number of floors for all buildings ordered by the number of floors.", "rationale": ["Identify the columns needed: Name, Street_address, and Floors from the building table.", "Determine the table to query: the building table.", "Specify the order of the results: order by the number of Floors in ascending order."], "pred_sql": "SELECT Name, Street_address, Floors FROM building ORDER BY Floors;", "gold_sql": "SELECT name ,  street_address ,  floors FROM building ORDER BY floors", "source_tables": ["building"]}
{"sample_id": 1912, "db_id": "protein_institute", "question": "What is the name of the tallest building?", "rationale": ["Identify the table that contains the building information, which is the 'building' table.", "Determine the column that holds the name of the building, which is 'Name'.", "Identify the column that indicates the height of the building, which is 'Height_feet'.", "To find the tallest building, we need to sort the results by 'Height_feet' in descending order.", "Limit the results to only one entry to get the tallest building's name."], "pred_sql": "SELECT Name FROM building ORDER BY Height_feet DESC LIMIT 1;", "gold_sql": "SELECT name FROM building ORDER BY height_feet DESC LIMIT 1", "source_tables": ["building"]}
{"sample_id": 1913, "db_id": "protein_institute", "question": "What are the average, maximum, and minimum number of floors for all buildings?", "rationale": ["Identify the required calculations: average, maximum, and minimum of the 'Floors' column.", "Determine the table to query: the 'building' table contains the 'Floors' data.", "Use aggregate functions in SQL: AVG() for average, MAX() for maximum, and MIN() for minimum.", "Construct the SQL SELECT statement to retrieve the average, maximum, and minimum values from the 'Floors' column in the 'building' table."], "pred_sql": "SELECT AVG(Floors) AS average_floors, MAX(Floors) AS max_floors, MIN(Floors) AS min_floors FROM building;", "gold_sql": "SELECT avg(floors) ,  max(floors) ,  min(floors) FROM building", "source_tables": ["building"]}
{"sample_id": 1914, "db_id": "protein_institute", "question": "Show the number of buildings with a height above the average or a number of floors above the average.", "rationale": ["Identify the requirement to count buildings based on height and floors.", "Determine the average height of buildings using the AVG() function on the Height_feet column.", "Determine the average number of floors using the AVG() function on the Floors column.", "Construct a SQL query that counts the number of buildings where the height is greater than the average height or the number of floors is greater than the average number of floors."], "pred_sql": "SELECT COUNT(*) AS building_count FROM building WHERE Height_feet > (SELECT AVG(Height_feet) FROM building) OR Floors > (SELECT AVG(Floors) FROM building);", "gold_sql": "SELECT count(*) FROM building WHERE height_feet  >  (SELECT avg(height_feet) FROM building) OR floors  >  (SELECT avg(floors) FROM building)", "source_tables": ["building"]}
{"sample_id": 1915, "db_id": "protein_institute", "question": "List the names of buildings with at least 200 feet of height and with at least 20 floors.", "rationale": ["Identify the table that contains the relevant data: the 'building' table.", "Determine the columns needed: 'Name', 'Height_feet', and 'Floors'.", "Set the conditions for the query: buildings must have a height of at least 200 feet and at least 20 floors.", "Construct the SQL SELECT statement to retrieve the 'Name' of buildings that meet these conditions."], "pred_sql": "SELECT Name FROM building WHERE Height_feet >= '200' AND Floors >= '20';", "gold_sql": "SELECT name FROM building WHERE height_feet  >=  200 AND floors  >=  20", "source_tables": ["building"]}
{"sample_id": 1916, "db_id": "protein_institute", "question": "Show the names and locations of institutions that are founded after 1990 and have the type \"Private\".", "rationale": ["Identify the columns needed: Institution and Location from the Institution table.", "Determine the conditions: Founded after 1990 and Type is 'Private'.", "Construct the SQL SELECT statement to retrieve the specified columns from the Institution table.", "Add the WHERE clause to filter the results based on the conditions identified."], "pred_sql": "SELECT Institution, Location FROM Institution WHERE Founded > '1990' AND Type = 'Private';", "gold_sql": "SELECT institution ,  LOCATION FROM institution WHERE founded  >  1990 AND TYPE  =  'Private'", "source_tables": ["institution"]}
{"sample_id": 1917, "db_id": "protein_institute", "question": "Show institution types, along with the number of institutions and total enrollment for each type.", "rationale": ["Identify the relevant table: The query requires information about institutions, which is found in the 'Institution' table.", "Determine the required columns: We need the 'Type' of institution, the count of institutions, and the total enrollment. This means we will use the 'Type' column, and we will aggregate the data using COUNT() and SUM() functions.", "Use GROUP BY clause: To get the number of institutions and total enrollment for each type, we will group the results by the 'Type' column.", "Construct the SQL query: Combine the selected columns and the aggregation functions into a complete SQL query."], "pred_sql": "SELECT Type, COUNT(*) AS Number_of_Institutions, SUM(Enrollment) AS Total_Enrollment \nFROM Institution \nGROUP BY Type;", "gold_sql": "SELECT TYPE ,  count(*) ,  sum(enrollment) FROM institution GROUP BY TYPE", "source_tables": ["institution"]}
{"sample_id": 1918, "db_id": "protein_institute", "question": "Show the institution type with the largest number of institutions.", "rationale": ["Identify the relevant table: The query requires information about institutions, so we will use the 'Institution' table.", "Determine the required columns: We need the 'Type' of the institution and a count of how many institutions belong to each type.", "Use the COUNT function: To find the number of institutions for each type, we will use the COUNT(*) function.", "Group the results: We will group the results by 'Type' to aggregate the counts for each type of institution.", "Order the results: To find the type with the largest number of institutions, we will order the results in descending order based on the count.", "Limit the results: Since we only want the institution type with the largest number, we will limit the results to 1."], "pred_sql": "SELECT Type, COUNT(*) as institution_count FROM Institution GROUP BY Type ORDER BY institution_count DESC LIMIT 1;", "gold_sql": "SELECT TYPE FROM institution GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1", "source_tables": ["institution"]}
{"sample_id": 1919, "db_id": "protein_institute", "question": "Show the institution type with an institution founded after 1990 and an institution with at least 1000 enrollment.", "rationale": ["Identify the relevant table: The query requires information from the Institution table.", "Determine the columns needed: We need the 'Type' column from the Institution table.", "Set the conditions for the query: We need institutions founded after 1990 and with an enrollment of at least 1000.", "Construct the SQL query: Use SELECT to get the 'Type' from the Institution table with the specified conditions in the WHERE clause."], "pred_sql": "SELECT Type FROM Institution WHERE Founded > '1990' AND Enrollment >= '1000';", "gold_sql": "SELECT TYPE FROM institution WHERE founded  >  1990 AND enrollment  >=  1000", "source_tables": ["institution"]}
{"sample_id": 1920, "db_id": "protein_institute", "question": "Show the name of buildings that do not have any institution.", "rationale": ["Identify the main table to query from, which is 'building'.", "We need to find buildings that do not have any associated institutions.", "To do this, we can use a subquery to select all 'building_id's from the 'Institution' table.", "We will then use the NOT IN clause to filter out those buildings that have a corresponding 'building_id' in the 'Institution' table.", "Finally, we select the 'Name' of the buildings that meet this criterion."], "pred_sql": "SELECT Name FROM building WHERE building_id NOT IN (SELECT building_id FROM Institution);", "gold_sql": "SELECT name FROM building WHERE building_id NOT IN (SELECT building_id FROM institution)", "source_tables": ["building", "institution"]}
{"sample_id": 1921, "db_id": "protein_institute", "question": "Show the names of buildings except for those having an institution founded in 2003.", "rationale": ["Identify the main table to query from, which is the 'building' table, specifically the 'Name' column.", "Determine the condition to exclude buildings associated with institutions founded in 2003.", "To find these buildings, a subquery is needed that selects 'building_id' from the 'Institution' table where 'Founded' is '2003'.", "Use the NOT IN clause to filter out the buildings that have a 'building_id' present in the result of the subquery."], "pred_sql": "SELECT Name FROM building WHERE building_id NOT IN (SELECT building_id FROM Institution WHERE Founded = '2003');", "gold_sql": "SELECT name FROM building EXCEPT SELECT T1.name FROM building AS T1 JOIN institution AS T2 ON T1.building_id  =  T2.building_id WHERE T2.founded  =  2003", "source_tables": ["building", "institution"]}
{"sample_id": 1922, "db_id": "protein_institute", "question": "For each building, show the name of the building and the number of institutions in it.", "rationale": ["Identify the tables involved: 'building' and 'Institution'.", "We need to show the name of the building, which is in the 'building' table, and the count of institutions, which is in the 'Institution' table.", "To count the number of institutions per building, we will use a LEFT JOIN to connect the 'building' table with the 'Institution' table on the 'building_id'.", "We will use COUNT(i.Institution_id) to count the number of institutions associated with each building.", "To ensure we get a count for buildings with no institutions, we use LEFT JOIN instead of INNER JOIN.", "Finally, we will group the results by the building's ID and name to get the count of institutions for each building."], "pred_sql": "SELECT b.Name, COUNT(i.Institution_id) AS number_of_institutions\nFROM building b\nLEFT JOIN Institution i ON b.building_id = i.building_id\nGROUP BY b.building_id, b.Name;", "gold_sql": "SELECT T1.name ,  count(*) FROM building AS T1 JOIN institution AS T2 ON T1.building_id  =  T2.building_id GROUP BY T1.building_id", "source_tables": ["building", "institution"]}
{"sample_id": 1923, "db_id": "protein_institute", "question": "Show the names and heights of buildings with at least two institutions founded after 1880.", "rationale": ["Identify the required columns: 'Name' and 'Height_feet' from the 'building' table.", "Determine the condition: buildings must have at least two associated institutions founded after 1880.", "Join the 'building' table with the 'Institution' table on the 'building_id' to link buildings with their institutions.", "Filter the institutions based on the founding year being greater than 1880.", "Group the results by 'building_id' to count the number of institutions associated with each building.", "Use the HAVING clause to ensure that only buildings with two or more institutions are included in the final result."], "pred_sql": "SELECT b.Name, b.Height_feet \nFROM building b \nJOIN Institution i ON b.building_id = i.building_id \nWHERE i.Founded > 1880 \nGROUP BY b.building_id \nHAVING COUNT(i.Institution_id) >= 2;", "gold_sql": "SELECT T1.name ,  T1.height_feet FROM building AS T1 JOIN institution AS T2 ON T1.building_id  =  T2.building_id WHERE T2.founded  >  1880 GROUP BY T1.building_id HAVING count(*)  >=  2", "source_tables": ["building", "institution"]}
{"sample_id": 1924, "db_id": "protein_institute", "question": "Show all the distinct institution types.", "rationale": ["Identify the table that contains the information about institution types, which is the 'Institution' table.", "To get distinct values, we will use the DISTINCT keyword in the SQL query.", "The specific column we are interested in is 'Type', which represents the type of institution.", "Construct the SQL query to select distinct types from the Institution table."], "pred_sql": "SELECT DISTINCT Type FROM Institution;", "gold_sql": "SELECT DISTINCT TYPE FROM institution", "source_tables": ["institution"]}
{"sample_id": 1925, "db_id": "protein_institute", "question": "Show institution names along with the number of proteins for each institution.", "rationale": ["Identify the tables involved: 'Institution' and 'protein'.", "We need to retrieve the institution names, which are in the 'Institution' table under the column 'Institution'.", "We also need to count the number of proteins associated with each institution, which requires a count of entries in the 'protein' table.", "To link the two tables, we will use the foreign key relationship: 'Institution.Institution_id' to 'protein.Institution_id'.", "Since some institutions may not have any associated proteins, we will use a LEFT JOIN to ensure all institutions are included in the results.", "We will group the results by the institution name to get the count of proteins for each institution."], "pred_sql": "SELECT Institution.Institution, COUNT(protein.common_name) AS protein_count \nFROM Institution \nLEFT JOIN protein ON Institution.Institution_id = protein.Institution_id \nGROUP BY Institution.Institution;", "gold_sql": "SELECT T1.institution ,  count(*) FROM institution AS T1 JOIN protein AS T2 ON T1.institution_id  =  T2.institution_id GROUP BY T1.institution_id", "source_tables": ["protein", "institution"]}
{"sample_id": 1926, "db_id": "protein_institute", "question": "How many proteins are associated with an institution founded after 1880 or an institution with type \"Private\"?", "rationale": ["Identify the relevant tables: 'protein' and 'Institution'.", "We need to count the number of proteins, so we will use the COUNT() function.", "To find proteins associated with institutions founded after 1880 or of type 'Private', we need to join the 'protein' table with the 'Institution' table on the 'Institution_id'.", "The condition for the count will be that the 'Founded' year in the 'Institution' table is greater than 1880 or the 'Type' is 'Private'.", "Construct the SQL query using the SELECT statement to count the proteins with the specified conditions."], "pred_sql": "SELECT COUNT(*) FROM protein p JOIN Institution i ON p.Institution_id = i.Institution_id WHERE i.Founded > '1880' OR i.Type = 'Private';", "gold_sql": "SELECT count(*) FROM institution AS T1 JOIN protein AS T2 ON T1.institution_id  =  T2.institution_id WHERE T1.founded  >  1880 OR T1.type  =  'Private'", "source_tables": ["protein", "institution"]}
{"sample_id": 1927, "db_id": "protein_institute", "question": "Show the protein name and the institution name.", "rationale": ["Identify the columns needed: 'protein_name' from the 'protein' table and 'Institution' from the 'Institution' table.", "Determine the relationship between the tables: 'protein' is linked to 'Institution' through 'Institution_id'.", "Use a JOIN clause to combine the 'protein' and 'Institution' tables based on the matching 'Institution_id'.", "Construct the SELECT statement to retrieve the desired columns from the joined tables."], "pred_sql": "SELECT protein.protein_name, Institution.Institution FROM protein JOIN Institution ON protein.Institution_id = Institution.Institution_id;", "gold_sql": "SELECT T2.protein_name ,  T1.institution FROM institution AS T1 JOIN protein AS T2 ON T1.institution_id  =  T2.institution_id", "source_tables": ["protein", "institution"]}
{"sample_id": 1928, "db_id": "protein_institute", "question": "How many proteins are associated with an institution in a building with at least 20 floors?", "rationale": ["Identify the tables involved: protein, Institution, and building.", "Determine the relationship between the tables: protein is linked to Institution via Institution_id, and Institution is linked to building via building_id.", "We need to count the number of proteins, so we will use the COUNT() function.", "We need to filter the buildings to only those with at least 20 floors, so we will add a WHERE clause to check the Floors column in the building table.", "Join the tables appropriately to access the necessary columns for filtering and counting."], "pred_sql": "SELECT COUNT(*) AS protein_count \nFROM protein p \nJOIN Institution i ON p.Institution_id = i.Institution_id \nJOIN building b ON i.building_id = b.building_id \nWHERE b.Floors >= '20';", "gold_sql": "SELECT count(*) FROM institution AS T1 JOIN protein AS T2 ON T1.institution_id  =  T2.institution_id JOIN building AS T3 ON T3.building_id  =  T1.building_id WHERE T3.floors  >=  20", "source_tables": ["protein", "building", "institution"]}
{"sample_id": 1929, "db_id": "protein_institute", "question": "How many institutions do not have an associated protein in our record?", "rationale": ["Identify the table that contains institutions, which is the 'Institution' table.", "We need to count the number of institutions that do not have an associated protein.", "To find institutions without associated proteins, we can use a subquery to select all Institution_ids from the 'protein' table.", "We will use the NOT IN clause to filter out those Institution_ids from the 'Institution' table.", "Finally, we will use COUNT(*) to get the total number of institutions that meet this criterion."], "pred_sql": "SELECT COUNT(*) FROM Institution WHERE Institution_id NOT IN (SELECT Institution_id FROM protein);", "gold_sql": "SELECT count(*) FROM institution WHERE institution_id NOT IN (SELECT institution_id FROM protein)", "source_tables": ["protein", "institution"]}
{"sample_id": 1930, "db_id": "cinema", "question": "Show all the locations where no cinema has capacity over 800.", "rationale": ["Identify the table that contains the relevant information about cinemas, which is the 'cinema' table.", "Determine the condition specified in the query, which is to find locations where no cinema has a capacity over 800.", "This means we need to select locations from the 'cinema' table where the 'Capacity' column is less than or equal to 800.", "Construct the SQL query to select the 'Location' column from the 'cinema' table with the specified condition."], "pred_sql": "SELECT Location FROM cinema WHERE Capacity <= 800;", "gold_sql": "SELECT LOCATION FROM cinema EXCEPT SELECT LOCATION FROM cinema WHERE capacity  >  800", "source_tables": ["cinema"]}
{"sample_id": 1931, "db_id": "cinema", "question": "Show all the locations where some cinemas were opened in both year 2010 and year 2011.", "rationale": ["We need to find locations where cinemas were opened in both 2010 and 2011.", "To do this, we will select the 'Location' column from the 'cinema' table.", "We will filter the results to include only those rows where 'Openning_year' is either 2010 or 2011 using the IN clause.", "To ensure that we only get locations that have cinemas opened in both years, we will group the results by 'Location'.", "We will use the HAVING clause to count the distinct 'Openning_year' values for each location and ensure that it equals 2, meaning both years are present."], "pred_sql": "SELECT DISTINCT Location FROM cinema WHERE Openning_year IN (2010, 2011) GROUP BY Location HAVING COUNT(DISTINCT Openning_year) = 2;", "gold_sql": "SELECT LOCATION FROM cinema WHERE openning_year  =  2010 INTERSECT SELECT LOCATION FROM cinema WHERE openning_year  =  2011", "source_tables": ["cinema"]}
{"sample_id": 1932, "db_id": "cinema", "question": "How many cinema do we have?", "rationale": ["Identify the requirement: We need to find out how many cinemas are available.", "Determine the relevant table: The 'cinema' table contains the information about cinemas.", "Use the COUNT() function to count the number of entries in the 'cinema' table.", "Construct the SQL query to select the count from the 'cinema' table."], "pred_sql": "SELECT COUNT(*) AS total_cinemas FROM cinema;", "gold_sql": "SELECT count(*) FROM cinema", "source_tables": ["cinema"]}
{"sample_id": 1933, "db_id": "cinema", "question": "Count the number of cinemas.", "rationale": ["Identify the table that contains information about cinemas, which is the 'cinema' table.", "To count the number of cinemas, we need to use the COUNT() function in SQL.", "The SQL query will select the count of all records from the 'cinema' table.", "The final SQL query will be 'SELECT COUNT(*) AS Number_of_Cinemas FROM cinema;' to get the total number of cinemas."], "pred_sql": "SELECT COUNT(*) AS Number_of_Cinemas FROM cinema;", "gold_sql": "SELECT count(*) FROM cinema", "source_tables": ["cinema"]}
{"sample_id": 1934, "db_id": "cinema", "question": "Show name, opening year, and capacity for each cinema.", "rationale": ["Identify the required columns: Name, Openning_year, and Capacity from the cinema table.", "Formulate the SQL SELECT statement to retrieve these columns from the cinema table."], "pred_sql": "SELECT Name, Openning_year, Capacity FROM cinema;", "gold_sql": "SELECT name ,  openning_year ,  capacity FROM cinema", "source_tables": ["cinema"]}
{"sample_id": 1935, "db_id": "cinema", "question": "Show the cinema name and location for cinemas with capacity above average.", "rationale": ["Identify the columns needed: 'Name' and 'Location' from the 'cinema' table.", "Determine the condition: we need cinemas with a capacity above average.", "Calculate the average capacity: use a subquery to find the average capacity from the 'cinema' table.", "Combine the selection of columns and the condition into a SQL SELECT statement."], "pred_sql": "SELECT Name, Location FROM cinema WHERE Capacity > (SELECT AVG(Capacity) FROM cinema);", "gold_sql": "SELECT name ,  LOCATION FROM cinema WHERE capacity  >  (SELECT avg(capacity) FROM cinema)", "source_tables": ["cinema"]}
{"sample_id": 1936, "db_id": "cinema", "question": "What are all the locations with a cinema?", "rationale": ["Identify the table that contains information about cinemas, which is the 'cinema' table.", "Determine the relevant column that contains the location information, which is 'Location'.", "Since we want to find all unique locations where cinemas are present, we will use the DISTINCT keyword to avoid duplicate entries.", "Construct the SQL query to select distinct locations from the cinema table."], "pred_sql": "SELECT DISTINCT Location FROM cinema;", "gold_sql": "SELECT DISTINCT LOCATION FROM cinema", "source_tables": ["cinema"]}
{"sample_id": 1937, "db_id": "cinema", "question": "Find the distinct locations that has a cinema.", "rationale": ["Identify the table that contains information about cinemas, which is the 'cinema' table.", "Determine the column that represents the geographical location of the cinema, which is 'Location'.", "Use the DISTINCT keyword to ensure that only unique locations are returned in the result set.", "Construct the SQL query to select distinct locations from the 'cinema' table."], "pred_sql": "SELECT DISTINCT Location FROM cinema;", "gold_sql": "SELECT DISTINCT LOCATION FROM cinema", "source_tables": ["cinema"]}
{"sample_id": 1938, "db_id": "cinema", "question": "Show all the cinema names and opening years in descending order of opening year.", "rationale": ["Identify the table needed: The query requires information about cinemas, so we will use the 'cinema' table.", "Determine the columns to select: We need the 'Name' and 'Openning_year' columns from the 'cinema' table.", "Specify the order of results: The results should be ordered by 'Openning_year' in descending order.", "Construct the SQL query: Combine the SELECT statement with the ORDER BY clause to form the complete SQL query."], "pred_sql": "SELECT Name, Openning_year FROM cinema ORDER BY Openning_year DESC;", "gold_sql": "SELECT name ,  openning_year FROM cinema ORDER BY openning_year DESC", "source_tables": ["cinema"]}
{"sample_id": 1939, "db_id": "cinema", "question": "What are the name and location of the cinema with the largest capacity?", "rationale": ["Identify the relevant table: The query requires information about cinemas, so we will use the 'cinema' table.", "Determine the columns needed: We need the 'Name' and 'Location' of the cinema.", "Find the cinema with the largest capacity: We will use a subquery to find the maximum capacity from the 'cinema' table.", "Construct the SQL query: We will select the 'Name' and 'Location' from the 'cinema' table where the 'Capacity' matches the maximum capacity found in the subquery."], "pred_sql": "SELECT Name, Location FROM cinema WHERE Capacity = (SELECT MAX(Capacity) FROM cinema);", "gold_sql": "SELECT name ,  LOCATION FROM cinema ORDER BY capacity DESC LIMIT 1", "source_tables": ["cinema"]}
{"sample_id": 1940, "db_id": "cinema", "question": "Show the average, minimum, and maximum capacity for all the cinemas opened in year 2011 or later.", "rationale": ["Identify the table needed: The query requires information about cinema capacities, so we will use the 'cinema' table.", "Determine the columns needed: We need to calculate the average, minimum, and maximum of the 'Capacity' column.", "Apply the necessary conditions: We need to filter the cinemas that were opened in the year 2011 or later, which means we will use a WHERE clause with 'Openning_year >= 2011'.", "Construct the SQL query: We will use the SELECT statement to get the average, minimum, and maximum capacities from the 'Capacity' column, applying the filter for the opening year."], "pred_sql": "SELECT AVG(Capacity) AS Average_Capacity, MIN(Capacity) AS Minimum_Capacity, MAX(Capacity) AS Maximum_Capacity FROM cinema WHERE Openning_year >= 2011;", "gold_sql": "SELECT avg(capacity) ,  min(capacity) ,  max(capacity) FROM cinema WHERE openning_year  >=  2011", "source_tables": ["cinema"]}
{"sample_id": 1941, "db_id": "cinema", "question": "Show each location and the number of cinemas there.", "rationale": ["Identify the relevant table: The query requires information about cinemas and their locations, so we will use the 'cinema' table.", "Select the columns needed: We need to show each location and count the number of cinemas in that location. Therefore, we will select 'Location' and use the COUNT function on 'Cinema_ID'.", "Group the results: To get the number of cinemas per location, we need to group the results by 'Location'.", "Construct the SQL query: Combine the SELECT statement with the COUNT function and the GROUP BY clause to form the complete SQL query."], "pred_sql": "SELECT Location, COUNT(Cinema_ID) AS Number_of_Cinemas FROM cinema GROUP BY Location;", "gold_sql": "SELECT LOCATION ,  count(*) FROM cinema GROUP BY LOCATION", "source_tables": ["cinema"]}
{"sample_id": 1942, "db_id": "cinema", "question": "What is the location with the most cinemas opened in year 2010 or later?", "rationale": ["Identify the relevant table: The 'cinema' table contains information about cinemas, including their opening year and location.", "Filter the cinemas: We need to filter the cinemas that were opened in the year 2010 or later. This is done using the WHERE clause with the condition 'Openning_year >= 2010'.", "Count the number of cinemas: We need to count the number of cinemas for each location. This can be achieved using the COUNT() function and grouping the results by 'Location'.", "Group the results: Use the GROUP BY clause to group the results by 'Location'.", "Order the results: To find the location with the most cinemas, we will order the results in descending order based on the count of cinemas.", "Limit the results: Since we only want the location with the most cinemas, we will limit the results to 1 using the LIMIT clause."], "pred_sql": "SELECT Location, COUNT(*) AS Number_of_Cinemas\nFROM cinema\nWHERE Openning_year >= 2010\nGROUP BY Location\nORDER BY Number_of_Cinemas DESC\nLIMIT 1;", "gold_sql": "SELECT LOCATION FROM cinema WHERE openning_year  >=  2010 GROUP BY LOCATION ORDER BY count(*) DESC LIMIT 1", "source_tables": ["cinema"]}
{"sample_id": 1943, "db_id": "cinema", "question": "Show all the locations with at least two cinemas with capacity above 300.", "rationale": ["Identify the relevant table: The query requires information about cinemas and their locations, so we will use the 'cinema' table.", "Filter cinemas based on capacity: We need to find cinemas with a capacity greater than 300, so we will add a WHERE clause to filter these records.", "Group by location: To find locations with at least two cinemas, we will group the results by the 'Location' column.", "Count the number of cinemas per location: We will use the COUNT function to count the number of cinemas in each location.", "Filter groups: We will use the HAVING clause to filter the groups to only include those with a count of at least 2."], "pred_sql": "SELECT Location FROM cinema WHERE Capacity > 300 GROUP BY Location HAVING COUNT(Cinema_ID) >= 2;", "gold_sql": "SELECT LOCATION FROM cinema WHERE capacity  >  300 GROUP BY LOCATION HAVING count(*)  >=  2", "source_tables": ["cinema"]}
{"sample_id": 1944, "db_id": "cinema", "question": "Which locations have 2 or more cinemas with capacity over 300?", "rationale": ["Identify the relevant table: The query involves the 'cinema' table since it contains information about cinema locations and their capacities.", "Filter cinemas based on capacity: We need to find cinemas with a capacity greater than 300, so we will use a WHERE clause to filter these records.", "Group by location: To find locations with multiple cinemas, we will group the results by the 'Location' column.", "Count the number of cinemas per location: We will use the COUNT function to count the number of cinemas in each location.", "Apply the condition for having 2 or more cinemas: We will use the HAVING clause to filter groups that have a count of 2 or more cinemas."], "pred_sql": "SELECT Location FROM cinema WHERE Capacity > 300 GROUP BY Location HAVING COUNT(Cinema_ID) >= 2;", "gold_sql": "SELECT LOCATION FROM cinema WHERE capacity  >  300 GROUP BY LOCATION HAVING count(*)  >=  2", "source_tables": ["cinema"]}
{"sample_id": 1945, "db_id": "cinema", "question": "Show the title and director for all films.", "rationale": ["Identify the table that contains the required information: The 'film' table contains the 'Title' and 'Directed_by' columns.", "Determine the columns to be selected: We need to select 'Title' and 'Directed_by'.", "Construct the SQL SELECT statement: Use SELECT to specify the columns and FROM to specify the table.", "Combine the elements to form the complete SQL query."], "pred_sql": "SELECT Title, Directed_by FROM film;", "gold_sql": "SELECT title ,  directed_by FROM film", "source_tables": ["film"]}
{"sample_id": 1946, "db_id": "cinema", "question": "What are the title and director of each film?", "rationale": ["Identify the relevant table: The query asks for information about films, which is stored in the 'film' table.", "Determine the required columns: The user wants the 'Title' and 'Directed_by' of each film.", "Construct the SQL SELECT statement: Use SELECT to specify the columns to retrieve from the 'film' table."], "pred_sql": "SELECT Title, Directed_by FROM film;", "gold_sql": "SELECT title ,  directed_by FROM film", "source_tables": ["film"]}
{"sample_id": 1947, "db_id": "cinema", "question": "Show all directors.", "rationale": ["Identify the table that contains the information about directors, which is the 'film' table.", "To show all directors, we need to select the 'Directed_by' column from the 'film' table.", "Since we want to show all unique directors, we will use the DISTINCT keyword to avoid duplicate entries.", "Construct the SQL query: SELECT DISTINCT Directed_by FROM film."], "pred_sql": "SELECT DISTINCT Directed_by FROM film;", "gold_sql": "SELECT DISTINCT directed_by FROM film", "source_tables": ["film"]}
{"sample_id": 1948, "db_id": "cinema", "question": "Who are all the directors?", "rationale": ["Identify the information needed: the query asks for all directors.", "Determine the relevant table: the 'film' table contains the 'Directed_by' column.", "Use the SELECT statement to retrieve the 'Directed_by' column from the 'film' table.", "Use DISTINCT to ensure that each director is listed only once, even if they directed multiple films."], "pred_sql": "SELECT DISTINCT Directed_by FROM film;", "gold_sql": "SELECT DISTINCT directed_by FROM film", "source_tables": ["film"]}
{"sample_id": 1949, "db_id": "cinema", "question": "List all directors along with the number of films directed by each director.", "rationale": ["Identify the relevant table: The 'film' table contains information about films and their directors.", "Determine the required columns: We need the 'Directed_by' column to list directors and a count of films directed by each.", "Use the COUNT() function to count the number of films for each director.", "Group the results by the 'Directed_by' column to aggregate the counts for each director."], "pred_sql": "SELECT Directed_by, COUNT(*) AS Number_of_Films FROM film GROUP BY Directed_by;", "gold_sql": "SELECT directed_by ,  count(*) FROM film GROUP BY directed_by", "source_tables": ["film"]}
{"sample_id": 1950, "db_id": "cinema", "question": "What is total number of show times per dat for each cinema?", "rationale": ["Identify the tables involved: We need data from the 'cinema' and 'schedule' tables.", "Determine the required information: We need the total number of show times per day for each cinema.", "Use the SUM function to calculate the total show times per day from the 'Show_times_per_day' column in the 'schedule' table.", "Join the 'cinema' table with the 'schedule' table on the Cinema_ID to link cinemas with their respective show times.", "Group the results by cinema to get the total show times for each cinema."], "pred_sql": "SELECT cinema.Name, SUM(schedule.Show_times_per_day) AS Total_Show_Times_Per_Day\nFROM cinema\nJOIN schedule ON cinema.Cinema_ID = schedule.Cinema_ID\nGROUP BY cinema.Cinema_ID;", "gold_sql": "SELECT T2.name ,  sum(T1.show_times_per_day) FROM schedule AS T1 JOIN cinema AS T2 ON T1.cinema_id  =  T2.cinema_id GROUP BY T1.cinema_id", "source_tables": ["schedule", "cinema"]}
{"sample_id": 1951, "db_id": "cinema", "question": "What are the title and maximum price of each film?", "rationale": ["Identify the columns needed: 'Title' from the 'film' table and the maximum 'Price' from the 'schedule' table.", "To get the maximum price for each film, we need to join the 'film' table with the 'schedule' table on the 'Film_ID' column.", "Use the SQL aggregate function MAX() to find the maximum price for each film.", "Group the results by 'Title' to ensure we get the maximum price for each unique film title."], "pred_sql": "SELECT Title, MAX(Price) AS Max_Price FROM film JOIN schedule ON film.Film_ID = schedule.Film_ID GROUP BY Title;", "gold_sql": "SELECT T2.title ,  max(T1.price) FROM schedule AS T1 JOIN film AS T2 ON T1.film_id  =  T2.film_id GROUP BY T1.film_id", "source_tables": ["schedule", "film"]}
{"sample_id": 1952, "db_id": "cinema", "question": "Give me the title and highest price for each film.", "rationale": ["Identify the columns needed: Title from the film table and the highest price from the schedule table.", "To find the highest price for each film, we need to join the film and schedule tables on the Film_ID.", "Use the MAX() function to get the highest price for each film.", "Group the results by Title to ensure we get the highest price for each unique film title."], "pred_sql": "SELECT Title, MAX(Price) AS Highest_Price FROM film JOIN schedule ON film.Film_ID = schedule.Film_ID GROUP BY Title;", "gold_sql": "SELECT T2.title ,  max(T1.price) FROM schedule AS T1 JOIN film AS T2 ON T1.film_id  =  T2.film_id GROUP BY T1.film_id", "source_tables": ["schedule", "film"]}
{"sample_id": 1953, "db_id": "cinema", "question": "Show cinema name, film title, date, and price for each record in schedule.", "rationale": ["Identify the required columns: cinema name, film title, date, and price.", "Determine the tables that contain these columns: 'cinema' for cinema name, 'film' for film title, and 'schedule' for date and price.", "Establish the relationships between the tables using JOINs: 'schedule' links to 'cinema' via Cinema_ID and to 'film' via Film_ID.", "Construct the SQL SELECT statement to retrieve the desired columns from the joined tables."], "pred_sql": "SELECT cinema.Name, film.Title, schedule.Date, schedule.Price FROM schedule JOIN cinema ON schedule.Cinema_ID = cinema.Cinema_ID JOIN film ON schedule.Film_ID = film.Film_ID;", "gold_sql": "SELECT T3.name ,  T2.title ,  T1.date ,  T1.price FROM schedule AS T1 JOIN film AS T2 ON T1.film_id  =  T2.film_id JOIN cinema AS T3 ON T1.cinema_id  =  T3.cinema_id", "source_tables": ["schedule", "film", "cinema"]}
{"sample_id": 1954, "db_id": "cinema", "question": "What are the title and director of the films without any schedule?", "rationale": ["Identify the columns needed: Title and Directed_by from the film table.", "Determine the condition: films that do not have any schedule.", "To find films without a schedule, we can use a subquery to select Film_IDs from the schedule table.", "Use the NOT IN clause to filter out films that are present in the schedule subquery.", "Construct the SQL query to select the required columns from the film table with the specified condition."], "pred_sql": "SELECT Title, Directed_by FROM film WHERE Film_ID NOT IN (SELECT Film_ID FROM schedule)", "gold_sql": "SELECT title ,  directed_by FROM film WHERE film_id NOT IN (SELECT film_id FROM schedule)", "source_tables": ["schedule", "film"]}
{"sample_id": 1955, "db_id": "cinema", "question": "Show director with the largest number of show times in total.", "rationale": ["Identify the relevant tables: 'film' and 'schedule' are needed to find the director and the number of show times.", "Join the 'film' table with the 'schedule' table on the Film_ID to combine film details with their show times.", "Use the SUM function to calculate the total number of show times for each director by summing the 'Show_times_per_day' from the 'schedule' table.", "Group the results by 'Directed_by' to aggregate the show times for each director.", "Order the results in descending order based on the total show times to find the director with the largest number.", "Limit the results to 1 to get only the top director."], "pred_sql": "SELECT Directed_by, SUM(Show_times_per_day) AS Total_Show_Times\nFROM film\nJOIN schedule ON film.Film_ID = schedule.Film_ID\nGROUP BY Directed_by\nORDER BY Total_Show_Times DESC\nLIMIT 1;", "gold_sql": "SELECT T2.directed_by FROM schedule AS T1 JOIN film AS T2 ON T1.film_id  =  T2.film_id GROUP BY T2.directed_by ORDER BY sum(T1.show_times_per_day) DESC LIMIT 1", "source_tables": ["schedule", "film"]}
{"sample_id": 1956, "db_id": "cinema", "question": "Find the locations that have more than one movie theater with capacity above 300.", "rationale": ["Identify the relevant table: The query involves the 'cinema' table since we are interested in movie theaters and their capacities.", "Filter the cinemas: We need to find cinemas with a capacity greater than 300, so we will use a WHERE clause to filter the results based on the 'Capacity' column.", "Group by location: To find locations with more than one cinema, we will group the results by the 'Location' column.", "Count the cinemas: We will use the COUNT function to count the number of cinemas in each location.", "Apply the HAVING clause: To filter the grouped results to only include locations with more than one cinema, we will use the HAVING clause with a condition that the count of Cinema_ID must be greater than 1."], "pred_sql": "SELECT Location FROM cinema WHERE Capacity > 300 GROUP BY Location HAVING COUNT(Cinema_ID) > 1;", "gold_sql": "SELECT LOCATION FROM cinema WHERE capacity  >  300 GROUP BY LOCATION HAVING count(*)  >  1", "source_tables": ["cinema"]}
{"sample_id": 1957, "db_id": "cinema", "question": "In which locations are there more than one movie theater with capacity above 300?", "rationale": ["Identify the relevant table: The query involves the 'cinema' table since we are interested in locations and their capacities.", "Filter cinemas: We need to filter cinemas with a capacity greater than 300. This is done using the WHERE clause: 'Capacity > 300'.", "Group by location: To find locations with more than one cinema, we need to group the results by the 'Location' column using GROUP BY.", "Count cinemas per location: We need to count the number of cinemas in each location. This is done using COUNT(Cinema_ID).", "Filter locations: We only want locations with more than one cinema, so we use the HAVING clause to filter groups with a count greater than 1."], "pred_sql": "SELECT Location FROM cinema WHERE Capacity > 300 GROUP BY Location HAVING COUNT(Cinema_ID) > 1;", "gold_sql": "SELECT LOCATION FROM cinema WHERE capacity  >  300 GROUP BY LOCATION HAVING count(*)  >  1", "source_tables": ["cinema"]}
{"sample_id": 1958, "db_id": "cinema", "question": "How many films have the word 'Dummy' in their titles?", "rationale": ["Identify the table that contains the film titles, which is the 'film' table.", "Determine the column that holds the titles, which is 'Title'.", "Use the SQL COUNT function to count the number of records that match the criteria.", "The criteria is that the title must contain the word 'Dummy', which can be checked using the LIKE operator with wildcards.", "Construct the SQL query to select the count of films where the title contains 'Dummy'."], "pred_sql": "SELECT COUNT(*) AS film_count FROM film WHERE Title LIKE '%Dummy%';", "gold_sql": "SELECT count(*) FROM film WHERE title LIKE '%Dummy%'", "source_tables": ["film"]}
{"sample_id": 1959, "db_id": "cinema", "question": "Count the number of films whose title contains the word 'Dummy'.", "rationale": ["Identify the table that contains the film titles, which is the 'film' table.", "Determine the requirement to count the number of films, which suggests using the COUNT() function.", "Recognize that we need to filter the films based on the title containing the word 'Dummy'.", "Use the LIKE operator with wildcards '%' to find titles that contain 'Dummy'.", "Construct the SQL query to select the count of films from the 'film' table where the title matches the specified condition."], "pred_sql": "SELECT COUNT(*) FROM film WHERE Title LIKE '%Dummy%';", "gold_sql": "SELECT count(*) FROM film WHERE title LIKE '%Dummy%'", "source_tables": ["film"]}
{"sample_id": 1960, "db_id": "products_for_hire", "question": "Are the customers holding coupons with amount 500 bad or good?", "rationale": ["Identify the relevant tables: Customers and Discount_Coupons.", "Determine the relationship between the tables: Customers have a coupon_id that links to Discount_Coupons.", "Filter the Discount_Coupons table for coupons with an amount of 500.", "Select the good_or_bad_customer field from the Customers table to determine if they are good or bad customers.", "Count the number of customers in each category (good or bad) using GROUP BY on good_or_bad_customer."], "pred_sql": "SELECT good_or_bad_customer, COUNT(*) AS customer_count \nFROM Customers \nJOIN Discount_Coupons ON Customers.coupon_id = Discount_Coupons.coupon_id \nWHERE Discount_Coupons.coupon_amount = '500' \nGROUP BY good_or_bad_customer;", "gold_sql": "SELECT T1.good_or_bad_customer FROM customers AS T1 JOIN discount_coupons AS T2 ON T1.coupon_id  =  T2.coupon_id WHERE T2.coupon_amount  =  500", "source_tables": ["discount_coupons", "customers"]}
{"sample_id": 1961, "db_id": "products_for_hire", "question": "How many bookings did each customer make? List the customer id, first name, and the count.", "rationale": ["Identify the relevant tables: Customers and Bookings.", "We need to count the number of bookings for each customer, so we will use the COUNT() function on the booking_id from the Bookings table.", "To get the customer details, we will select customer_id and first_name from the Customers table.", "We will perform a LEFT JOIN between Customers and Bookings on the customer_id to ensure we include customers with zero bookings as well.", "We will group the results by customer_id and first_name to get the count of bookings for each customer."], "pred_sql": "SELECT Customers.customer_id, Customers.first_name, COUNT(Bookings.booking_id) AS booking_count\nFROM Customers\nLEFT JOIN Bookings ON Customers.customer_id = Bookings.customer_id\nGROUP BY Customers.customer_id, Customers.first_name;", "gold_sql": "SELECT T1.customer_id ,  T1.first_name ,  count(*) FROM Customers AS T1 JOIN bookings AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["customers", "bookings"]}
{"sample_id": 1962, "db_id": "products_for_hire", "question": "What is the maximum total amount paid by a customer? List the customer id and amount.", "rationale": ["Identify the relevant table: Payments, as it contains the customer_id and amount_paid columns.", "Use the MAX() function to find the maximum amount paid by each customer.", "Group the results by customer_id to get the maximum amount for each individual customer."], "pred_sql": "SELECT customer_id, MAX(amount_paid) AS max_amount_paid FROM Payments GROUP BY customer_id;", "gold_sql": "SELECT customer_id ,  sum(amount_paid) FROM Payments GROUP BY customer_id ORDER BY sum(amount_paid) DESC LIMIT 1", "source_tables": ["payments"]}
{"sample_id": 1963, "db_id": "products_for_hire", "question": "What are the id and the amount of refund of the booking that incurred the most times of payments?", "rationale": ["Identify the relevant tables: Payments and Bookings are needed to get the booking ID and the amount of refund.", "Join the Payments table with the Bookings table on the booking_id to associate payments with their respective bookings.", "Group the results by booking_id to aggregate the payments for each booking.", "Use COUNT(p.payment_id) to count the number of payments for each booking.", "Order the results in descending order based on the count of payments to find the booking with the most payments.", "Select the booking_id and the total amount of refund (which is the sum of amount_paid) for the booking with the most payments.", "Limit the results to 1 to get only the booking with the highest number of payments."], "pred_sql": "SELECT b.booking_id, SUM(p.amount_paid) AS total_refund\nFROM Payments p\nJOIN Bookings b ON p.booking_id = b.booking_id\nGROUP BY b.booking_id\nORDER BY COUNT(p.payment_id) DESC\nLIMIT 1;", "gold_sql": "SELECT T1.booking_id ,  T1.amount_of_refund FROM Bookings AS T1 JOIN Payments AS T2 ON T1.booking_id  =  T2.booking_id GROUP BY T1.booking_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments", "bookings"]}
{"sample_id": 1964, "db_id": "products_for_hire", "question": "What is the id of the product that is booked for 3 times?", "rationale": ["Identify the table that contains information about booked products, which is 'Products_Booked'.", "Determine the relevant column that indicates the number of times a product has been booked, which is 'booked_count'.", "Formulate a SQL query to select the 'product_id' from 'Products_Booked' where 'booked_count' equals 3."], "pred_sql": "SELECT product_id FROM Products_Booked WHERE booked_count = 3;", "gold_sql": "SELECT product_id FROM products_booked GROUP BY product_id HAVING count(*)  =  3", "source_tables": ["products_booked"]}
{"sample_id": 1965, "db_id": "products_for_hire", "question": "What is the product description of the product booked with an amount of 102.76?", "rationale": ["Identify the relevant tables: Products_for_Hire for product descriptions and Products_Booked for booked amounts.", "Determine the relationship between the tables: Products_Booked has a foreign key reference to Products_for_Hire through product_id.", "Formulate the SELECT statement to retrieve the product_description from Products_for_Hire.", "Use a JOIN clause to connect Products_for_Hire and Products_Booked on product_id.", "Add a WHERE clause to filter the results for the specific booked amount of 102.76."], "pred_sql": "SELECT pfh.product_description \nFROM Products_for_Hire pfh \nJOIN Products_Booked pb ON pfh.product_id = pb.product_id \nWHERE pb.booked_amount = 102.76;", "gold_sql": "SELECT T2.product_description FROM products_booked AS T1 JOIN products_for_hire AS T2 ON T1.product_id  =  T2.product_id WHERE T1.booked_amount  =  102.76", "source_tables": ["products_booked", "products_for_hire"]}
{"sample_id": 1966, "db_id": "products_for_hire", "question": "What are the start date and end date of the booking that has booked the product named 'Book collection A'?", "rationale": ["Identify the relevant tables: Bookings, Products_Booked, and Products_for_Hire are needed to get the booking dates and filter by product name.", "We need to select the booking_start_date and booking_end_date from the Bookings table.", "To link the bookings with the products, we will join the Bookings table with the Products_Booked table on booking_id.", "Next, we will join the Products_Booked table with the Products_for_Hire table on product_id to filter by the product name.", "Finally, we will add a WHERE clause to filter the results to only include bookings for the product named 'Book collection A'."], "pred_sql": "SELECT B.booking_start_date, B.booking_end_date \nFROM Bookings B \nJOIN Products_Booked PB ON B.booking_id = PB.booking_id \nJOIN Products_for_Hire P ON PB.product_id = P.product_id \nWHERE P.product_name = 'Book collection A';", "gold_sql": "SELECT T3.booking_start_date ,   T3.booking_end_date FROM Products_for_hire AS T1 JOIN products_booked AS T2 ON T1.product_id  =  T2.product_id JOIN bookings AS T3 ON T2.booking_id  =  T3.booking_id WHERE T1.product_name  =  'Book collection A'", "source_tables": ["products_booked", "products_for_hire", "bookings"]}
{"sample_id": 1967, "db_id": "products_for_hire", "question": "What are the names of products whose availability equals to 1?", "rationale": ["Identify the table that contains product names, which is 'Products_for_Hire'.", "Identify the table that contains availability status, which is 'View_Product_Availability'.", "Determine the condition for availability, which is 'available_yn = 1'.", "Use a subquery to select product_ids from 'View_Product_Availability' where availability equals 1.", "Join the results of the subquery with 'Products_for_Hire' to get the product names corresponding to the available products."], "pred_sql": "SELECT product_name FROM Products_for_Hire WHERE product_id IN (SELECT product_id FROM View_Product_Availability WHERE available_yn = '1');", "gold_sql": "SELECT T2.product_name FROM view_product_availability AS T1 JOIN products_for_hire AS T2 ON T1.product_id  =  T2.product_id WHERE T1.available_yn  =  1", "source_tables": ["products_for_hire", "view_product_availability"]}
{"sample_id": 1968, "db_id": "products_for_hire", "question": "How many different product types are there?", "rationale": ["Identify the table that contains product types, which is 'Products_for_Hire'.", "Determine the column that represents the product type, which is 'product_type_code'.", "To find the number of different product types, use the COUNT function with DISTINCT to count unique values in 'product_type_code'.", "Construct the SQL query to select the count of distinct product types from the 'Products_for_Hire' table."], "pred_sql": "SELECT COUNT(DISTINCT product_type_code) AS different_product_types FROM Products_for_Hire;", "gold_sql": "SELECT count(DISTINCT product_type_code) FROM products_for_hire", "source_tables": ["products_for_hire"]}
{"sample_id": 1969, "db_id": "products_for_hire", "question": "What are the first name, last name, and gender of all the good customers? Order by their last name.", "rationale": ["Identify the relevant table: Customers, as it contains the required fields (first_name, last_name, gender_mf) and the indicator for good customers.", "Select the columns needed: first_name, last_name, and gender_mf.", "Filter the results to include only good customers by using the condition good_or_bad_customer = 1.", "Order the results by last_name to meet the requirement of sorting the output."], "pred_sql": "SELECT first_name, last_name, gender_mf FROM Customers WHERE good_or_bad_customer = 1 ORDER BY last_name;", "gold_sql": "SELECT first_name ,  last_name ,  gender_mf FROM customers WHERE good_or_bad_customer  =  'good' ORDER BY last_name", "source_tables": ["customers"]}
{"sample_id": 1970, "db_id": "products_for_hire", "question": "What is the average amount due for all the payments?", "rationale": ["Identify the table that contains the relevant data: Payments.", "Determine the specific column that holds the amount due: amount_due.", "Use the AVG() function to calculate the average of the amount_due column.", "Construct the SQL query to select the average amount due from the Payments table."], "pred_sql": "SELECT AVG(amount_due) AS average_amount_due FROM Payments;", "gold_sql": "SELECT avg(amount_due) FROM payments", "source_tables": ["payments"]}
{"sample_id": 1971, "db_id": "products_for_hire", "question": "What are the maximum, minimum, and average booked count for the products booked?", "rationale": ["Identify the table that contains the booked count information, which is the 'Products_Booked' table.", "To find the maximum, minimum, and average of the booked count, we will use the aggregate functions MAX(), MIN(), and AVG().", "Construct the SQL query to select these aggregate values from the 'booked_count' column in the 'Products_Booked' table."], "pred_sql": "SELECT MAX(booked_count) AS max_booked_count, MIN(booked_count) AS min_booked_count, AVG(booked_count) AS avg_booked_count FROM Products_Booked;", "gold_sql": "SELECT max(booked_count) ,  min(booked_count) ,  avg(booked_count) FROM products_booked", "source_tables": ["products_booked"]}
{"sample_id": 1972, "db_id": "products_for_hire", "question": "What are all the distinct payment types?", "rationale": ["Identify the table that contains payment information, which is the Payments table.", "Determine the column that represents the type of payment, which is payment_type_code.", "Use the DISTINCT keyword to ensure that only unique payment types are returned.", "Construct the SQL query to select distinct payment_type_code from the Payments table."], "pred_sql": "SELECT DISTINCT payment_type_code FROM Payments;", "gold_sql": "SELECT DISTINCT payment_type_code FROM payments", "source_tables": ["payments"]}
{"sample_id": 1973, "db_id": "products_for_hire", "question": "What are the daily hire costs for the products with substring 'Book' in its name?", "rationale": ["Identify the table that contains the daily hire costs, which is 'Products_for_Hire'.", "Determine the relevant column for the product name, which is 'product_name'.", "Use the SQL 'LIKE' operator to filter product names that contain the substring 'Book'.", "Select the 'daily_hire_cost' column for the products that match the criteria."], "pred_sql": "SELECT daily_hire_cost FROM Products_for_Hire WHERE product_name LIKE '%Book%';", "gold_sql": "SELECT daily_hire_cost FROM Products_for_hire WHERE product_name LIKE '%Book%'", "source_tables": ["products_for_hire"]}
{"sample_id": 1974, "db_id": "products_for_hire", "question": "How many products are never booked with amount higher than 200?", "rationale": ["We need to find products that have never been booked with an amount higher than 200.", "To do this, we will use the Products_for_Hire table to get all products.", "We will perform a LEFT JOIN with the Products_Booked table to find any bookings associated with each product.", "We will also join with the Bookings table to access the amount payable for each booking.", "We will filter the results to include products that have no bookings (pb.booking_id IS NULL) or bookings where the amount payable is less than or equal to 200.", "Finally, we will count the distinct product IDs that meet these criteria."], "pred_sql": "SELECT COUNT(DISTINCT p.product_id) AS never_booked_high_amount\nFROM Products_for_Hire p\nLEFT JOIN Products_Booked pb ON p.product_id = pb.product_id\nLEFT JOIN Bookings b ON pb.booking_id = b.booking_id\nWHERE pb.booking_id IS NULL OR (b.amount_payable <= 200)", "gold_sql": "SELECT count(*) FROM Products_for_hire WHERE product_id NOT IN ( SELECT product_id FROM products_booked WHERE booked_amount  >  200 )", "source_tables": ["products_booked", "products_for_hire"]}
{"sample_id": 1975, "db_id": "products_for_hire", "question": "What are the coupon amount of the coupons owned by both good and bad customers?", "rationale": ["Identify the relevant tables: Discount_Coupons and Customers.", "We need to retrieve the coupon amounts from the Discount_Coupons table.", "To find the coupons owned by customers, we need to join the Discount_Coupons table with the Customers table on the coupon_id.", "We are interested in both good and bad customers, which are indicated by the good_or_bad_customer column in the Customers table.", "The good_or_bad_customer column can have values indicating good (0) and bad (1) customers, so we will filter for both values using an IN clause.", "Select the distinct coupon amounts to avoid duplicates in the results."], "pred_sql": "SELECT DISTINCT dc.coupon_amount \nFROM Discount_Coupons dc \nJOIN Customers c ON dc.coupon_id = c.coupon_id \nWHERE c.good_or_bad_customer IN (0, 1);", "gold_sql": "SELECT T1.coupon_amount FROM Discount_Coupons AS T1 JOIN customers AS T2 ON T1.coupon_id  =  T2.coupon_id WHERE T2.good_or_bad_customer  =  'good' INTERSECT SELECT T1.coupon_amount FROM Discount_Coupons AS T1 JOIN customers AS T2 ON T1.coupon_id  =  T2.coupon_id WHERE T2.good_or_bad_customer  =  'bad'", "source_tables": ["discount_coupons", "customers"]}
{"sample_id": 1976, "db_id": "products_for_hire", "question": "What are the payment date of the payment with amount paid higher than 300 or with payment type is 'Check'", "rationale": ["Identify the table that contains payment information, which is the Payments table.", "Determine the columns needed: payment_date for the output, and amount_paid and payment_type_code for the conditions.", "Formulate the WHERE clause to filter records where amount_paid is greater than 300 or payment_type_code is 'Check'.", "Combine the SELECT statement with the WHERE clause to create the full SQL query."], "pred_sql": "SELECT payment_date FROM Payments WHERE amount_paid > 300 OR payment_type_code = 'Check';", "gold_sql": "SELECT payment_date FROM payments WHERE amount_paid  >  300 OR payment_type_code  =  'Check'", "source_tables": ["payments"]}
{"sample_id": 1977, "db_id": "products_for_hire", "question": "What are the names and descriptions of the products that are of 'Cutlery' type and have daily hire cost lower than 20?", "rationale": ["Identify the table that contains the product information, which is 'Products_for_Hire'.", "Determine the columns needed: 'product_name' and 'product_description'.", "Specify the conditions: the 'product_type_code' must be 'Cutlery' and the 'daily_hire_cost' must be less than 20.", "Construct the SQL SELECT statement to retrieve the required columns from the specified table with the given conditions."], "pred_sql": "SELECT product_name, product_description FROM Products_for_Hire WHERE product_type_code = 'Cutlery' AND daily_hire_cost < 20;", "gold_sql": "SELECT product_name ,  product_description FROM products_for_hire WHERE product_type_code  =  'Cutlery' AND daily_hire_cost  <  20", "source_tables": ["products_for_hire"]}
{"sample_id": 1978, "db_id": "phone_market", "question": "How many phones are there?", "rationale": ["Identify the requirement: The user wants to know the total number of phones.", "Determine the relevant table: The 'phone' table contains the information about phone models.", "Use the COUNT() function to count the total number of entries in the 'phone' table.", "Construct the SQL query to select the count from the 'phone' table."], "pred_sql": "SELECT COUNT(*) AS total_phones FROM phone;", "gold_sql": "SELECT count(*) FROM phone", "source_tables": ["phone"]}
{"sample_id": 1979, "db_id": "phone_market", "question": "List the names of phones in ascending order of price.", "rationale": ["Identify the table that contains the phone names, which is the 'phone' table.", "Determine the column that contains the phone names, which is 'Name'.", "Identify the column that contains the price information, which is 'Price'.", "Specify that the results should be ordered in ascending order based on the 'Price' column.", "Construct the SQL query to select the 'Name' from the 'phone' table and order the results by 'Price' in ascending order."], "pred_sql": "SELECT Name FROM phone ORDER BY Price ASC;", "gold_sql": "SELECT Name FROM phone ORDER BY Price ASC", "source_tables": ["phone"]}
{"sample_id": 1980, "db_id": "phone_market", "question": "What are the memories and carriers of phones?", "rationale": ["Identify the relevant table: The 'phone' table contains the columns 'Memory_in_G' and 'Carrier'.", "Determine the required columns: We need to select 'Memory_in_G' and 'Carrier' from the 'phone' table.", "Construct the SQL SELECT statement: Use SELECT to specify the columns and FROM to specify the table."], "pred_sql": "SELECT Memory_in_G, Carrier FROM phone;", "gold_sql": "SELECT Memory_in_G ,  Carrier FROM phone", "source_tables": ["phone"]}
{"sample_id": 1981, "db_id": "phone_market", "question": "List the distinct carriers of phones with memories bigger than 32.", "rationale": ["Identify the table that contains the relevant information about phones, which is the 'phone' table.", "Determine the column that contains the carrier information, which is 'Carrier'.", "Identify the column that contains the memory information, which is 'Memory_in_G'.", "Formulate a condition to filter the phones with memory greater than 32, using the condition 'Memory_in_G > '32''.", "Use the DISTINCT keyword to ensure that only unique carriers are listed in the result.", "Combine these elements to create the final SQL query."], "pred_sql": "SELECT DISTINCT Carrier FROM phone WHERE Memory_in_G > '32';", "gold_sql": "SELECT DISTINCT Carrier FROM phone WHERE Memory_in_G  >  32", "source_tables": ["phone"]}
{"sample_id": 1982, "db_id": "phone_market", "question": "Show the names of phones with carrier either \"Sprint\" or \"TMobile\".", "rationale": ["Identify the table that contains the phone information, which is the 'phone' table.", "Determine the columns needed for the query; we need the 'Name' of the phones.", "Filter the results based on the 'Carrier' column, specifically looking for phones with carriers 'Sprint' or 'TMobile'.", "Use the SQL 'IN' clause to specify multiple values for the 'Carrier' filter.", "Construct the SQL SELECT statement to retrieve the 'Name' from the 'phone' table where the 'Carrier' matches either 'Sprint' or 'TMobile'."], "pred_sql": "SELECT Name FROM phone WHERE Carrier IN ('Sprint', 'TMobile');", "gold_sql": "SELECT Name FROM phone WHERE Carrier  =  'Sprint' OR Carrier  =  'TMobile'", "source_tables": ["phone"]}
{"sample_id": 1983, "db_id": "phone_market", "question": "What is the carrier of the most expensive phone?", "rationale": ["Identify the table that contains the carrier information, which is the 'phone' table.", "Determine that we need to find the most expensive phone, which requires us to look for the maximum price in the 'phone' table.", "Use a subquery to find the maximum price from the 'phone' table.", "Select the carrier of the phone that has this maximum price."], "pred_sql": "SELECT Carrier FROM phone WHERE Price = (SELECT MAX(Price) FROM phone);", "gold_sql": "SELECT Carrier FROM phone ORDER BY Price DESC LIMIT 1", "source_tables": ["phone"]}
{"sample_id": 1984, "db_id": "phone_market", "question": "Show different carriers of phones together with the number of phones with each carrier.", "rationale": ["Identify the relevant table: The 'phone' table contains the 'Carrier' column and the phone models.", "Determine the required output: We need to show different carriers and the count of phones associated with each carrier.", "Use the COUNT() function to count the number of phones for each carrier.", "Group the results by the 'Carrier' column to get the count for each unique carrier."], "pred_sql": "SELECT Carrier, COUNT(*) AS Number_of_Phones FROM phone GROUP BY Carrier;", "gold_sql": "SELECT Carrier ,  COUNT(*) FROM phone GROUP BY Carrier", "source_tables": ["phone"]}
{"sample_id": 1985, "db_id": "phone_market", "question": "Show the most frequently used carrier of the phones.", "rationale": ["Identify the relevant table: The 'phone' table contains the 'Carrier' column which we need to analyze.", "Count the occurrences of each carrier: We will use the COUNT() function to count how many times each carrier appears in the 'phone' table.", "Group the results by carrier: We will use the GROUP BY clause to group the results based on the 'Carrier' column.", "Order the results by frequency: To find the most frequently used carrier, we will order the results in descending order based on the count of occurrences.", "Limit the results to one: Since we only want the most frequently used carrier, we will use the LIMIT clause to restrict the output to one result."], "pred_sql": "SELECT Carrier, COUNT(*) as Frequency FROM phone GROUP BY Carrier ORDER BY Frequency DESC LIMIT 1;", "gold_sql": "SELECT Carrier FROM phone GROUP BY Carrier ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["phone"]}
{"sample_id": 1986, "db_id": "phone_market", "question": "Show the carriers that have both phones with memory smaller than 32 and phones with memory bigger than 64.", "rationale": ["Identify the requirement to find carriers with two conditions: phones with memory smaller than 32GB and phones with memory larger than 64GB.", "Use a self-join or subquery to filter carriers that meet both conditions.", "Select distinct carriers from the phone table where the memory is less than 32GB.", "Use a subquery to find carriers that have phones with memory greater than 64GB.", "Combine the results to ensure that only carriers meeting both criteria are returned."], "pred_sql": "SELECT DISTINCT p1.Carrier \nFROM phone p1 \nJOIN phone_market pm1 ON p1.Phone_ID = pm1.Phone_ID \nWHERE p1.Memory_in_G < '32' \nAND p1.Carrier IN (\n    SELECT p2.Carrier \n    FROM phone p2 \n    JOIN phone_market pm2 ON p2.Phone_ID = pm2.Phone_ID \n    WHERE p2.Memory_in_G > '64'\n)", "gold_sql": "SELECT Carrier FROM phone WHERE Memory_in_G  <  32 INTERSECT SELECT Carrier FROM phone WHERE Memory_in_G  >  64", "source_tables": ["phone"]}
{"sample_id": 1987, "db_id": "phone_market", "question": "Show the names of phones and the districts of markets they are on.", "rationale": ["Identify the tables needed: 'phone' for phone names and 'market' for market districts.", "Determine the relationship between the tables: 'phone' is linked to 'phone_market' via Phone_ID, and 'market' is linked to 'phone_market' via Market_ID.", "Use JOIN operations to combine the 'phone' and 'market' tables through the 'phone_market' table.", "Select the 'Name' column from the 'phone' table and the 'District' column from the 'market' table."], "pred_sql": "SELECT phone.Name, market.District FROM phone JOIN phone_market ON phone.Phone_ID = phone_market.Phone_ID JOIN market ON phone_market.Market_ID = market.Market_ID;", "gold_sql": "SELECT T3.Name ,  T2.District FROM phone_market AS T1 JOIN market AS T2 ON T1.Market_ID  =  T2.Market_ID JOIN phone AS T3 ON T1.Phone_ID  =  T3.Phone_ID", "source_tables": ["phone", "market", "phone_market"]}
{"sample_id": 1988, "db_id": "phone_market", "question": "Show the names of phones and the districts of markets they are on, in ascending order of the ranking of the market.", "rationale": ["Identify the tables needed: phone, market, and phone_market.", "Determine the columns to select: phone.Name and market.District.", "Establish the relationships between the tables using JOINs: phone_market links phone and market.", "Use INNER JOIN to combine the tables based on the foreign keys: phone_market.Phone_ID with phone.Phone_ID and phone_market.Market_ID with market.Market_ID.", "Sort the results by the market ranking in ascending order using ORDER BY market.Ranking ASC."], "pred_sql": "SELECT phone.Name, market.District FROM phone_market JOIN phone ON phone_market.Phone_ID = phone.Phone_ID JOIN market ON phone_market.Market_ID = market.Market_ID ORDER BY market.Ranking ASC;", "gold_sql": "SELECT T3.Name ,  T2.District FROM phone_market AS T1 JOIN market AS T2 ON T1.Market_ID  =  T2.Market_ID JOIN phone AS T3 ON T1.Phone_ID  =  T3.Phone_ID ORDER BY T2.Ranking", "source_tables": ["phone", "market", "phone_market"]}
{"sample_id": 1989, "db_id": "phone_market", "question": "Show the names of phones that are on market with number of shops greater than 50.", "rationale": ["Identify the tables involved: We need data from the 'phone' table to get the names of the phones, and from the 'market' table to filter markets based on the number of shops.", "Determine the relationship between tables: The 'phone' table is linked to the 'phone_market' table through 'Phone_ID', and the 'phone_market' table is linked to the 'market' table through 'Market_ID'.", "Formulate the SQL query: We will use INNER JOIN to combine these tables based on their relationships, and then apply a WHERE clause to filter markets with more than 50 shops.", "Select the required column: We only need the 'Name' column from the 'phone' table in the final output."], "pred_sql": "SELECT phone.Name FROM phone INNER JOIN phone_market ON phone.Phone_ID = phone_market.Phone_ID INNER JOIN market ON phone_market.Market_ID = market.Market_ID WHERE market.Num_of_shops > 50;", "gold_sql": "SELECT T3.Name FROM phone_market AS T1 JOIN market AS T2 ON T1.Market_ID  =  T2.Market_ID JOIN phone AS T3 ON T1.Phone_ID  =  T3.Phone_ID WHERE T2.Num_of_shops  >  50", "source_tables": ["phone", "market", "phone_market"]}
{"sample_id": 1990, "db_id": "phone_market", "question": "For each phone, show its names and total number of stocks.", "rationale": ["Identify the tables needed: We need data from the 'phone' table for phone names and from the 'phone_market' table for stock numbers.", "Determine the columns to select: We need the 'Name' from the 'phone' table and the total stock from the 'phone_market' table.", "To get the total stock for each phone, we will use the SUM function on 'Num_of_stock' from the 'phone_market' table.", "We need to join the 'phone' and 'phone_market' tables on the 'Phone_ID' column to link phone names with their stock numbers.", "Finally, we will group the results by phone name to get the total stock for each phone."], "pred_sql": "SELECT phone.Name, SUM(phone_market.Num_of_stock) AS Total_Stock\nFROM phone\nJOIN phone_market ON phone.Phone_ID = phone_market.Phone_ID\nGROUP BY phone.Name;", "gold_sql": "SELECT T2.Name ,  sum(T1.Num_of_stock) FROM phone_market AS T1 JOIN phone AS T2 ON T1.Phone_ID  =  T2.Phone_ID GROUP BY T2.Name", "source_tables": ["phone", "phone_market"]}
{"sample_id": 1991, "db_id": "phone_market", "question": "Show the names of phones that have total number of stocks bigger than 2000, in descending order of the total number of stocks.", "rationale": ["We need to select the names of phones from the 'phone' table.", "To find the total number of stocks for each phone, we will join the 'phone' table with the 'phone_market' table on the Phone_ID.", "We will group the results by the phone names to aggregate the stock numbers for each phone.", "We will use the SUM function to calculate the total number of stocks for each phone.", "We will filter the results to include only those phones where the total number of stocks is greater than 2000 using the HAVING clause.", "Finally, we will order the results in descending order based on the total number of stocks."], "pred_sql": "SELECT p.Name FROM phone p JOIN phone_market pm ON p.Phone_ID = pm.Phone_ID GROUP BY p.Name HAVING SUM(pm.Num_of_stock) > 2000 ORDER BY SUM(pm.Num_of_stock) DESC;", "gold_sql": "SELECT T2.Name FROM phone_market AS T1 JOIN phone AS T2 ON T1.Phone_ID  =  T2.Phone_ID GROUP BY T2.Name HAVING sum(T1.Num_of_stock)  >=  2000 ORDER BY sum(T1.Num_of_stock) DESC", "source_tables": ["phone", "phone_market"]}
{"sample_id": 1992, "db_id": "phone_market", "question": "List the names of phones that are not on any market.", "rationale": ["Identify the main table to query from, which is the 'phone' table since we need the names of phones.", "We need to find phones that are not available in any market, which means we need to check against the 'phone_market' table.", "To find phones not in any market, we can use a subquery that selects all Phone_IDs from the 'phone_market' table.", "We will use the NOT IN clause to filter out any Phone_IDs that are present in the 'phone_market' table from our main query on the 'phone' table."], "pred_sql": "SELECT Name FROM phone WHERE Phone_ID NOT IN (SELECT Phone_ID FROM phone_market);", "gold_sql": "SELECT Name FROM phone WHERE Phone_id NOT IN (SELECT Phone_ID FROM phone_market)", "source_tables": ["phone", "phone_market"]}
{"sample_id": 1993, "db_id": "gas_company", "question": "How many gas companies are there?", "rationale": ["Identify the relevant table that contains information about gas companies, which is the 'station_company' table.", "To find the number of gas companies, we need to count the distinct 'Company_ID' entries in the 'station_company' table.", "Use the COUNT function to count the unique 'Company_ID' values, which represent different gas companies."], "pred_sql": "SELECT COUNT(DISTINCT Company_ID) AS Number_of_Gas_Companies FROM station_company;", "gold_sql": "SELECT count(*) FROM company", "source_tables": ["company"]}
{"sample_id": 1994, "db_id": "gas_company", "question": "What is the total number of companies?", "rationale": ["Identify the table that contains the information about companies, which is the 'company' table.", "To find the total number of companies, we need to count the number of entries in the 'company' table.", "Use the COUNT() function to count all rows in the 'company' table.", "Select the count with an alias 'total_companies' for clarity."], "pred_sql": "SELECT COUNT(*) AS total_companies FROM company;", "gold_sql": "SELECT count(*) FROM company", "source_tables": ["company"]}
{"sample_id": 1995, "db_id": "gas_company", "question": "List the company name and rank for all companies in the decreasing order of their sales.", "rationale": ["Identify the columns needed: 'Company' and 'Rank' from the 'company' table.", "Determine the sorting requirement: the results should be ordered by 'Sales_billion' in decreasing order.", "Construct the SQL SELECT statement to retrieve the specified columns from the 'company' table.", "Add the ORDER BY clause to sort the results based on 'Sales_billion' in descending order."], "pred_sql": "SELECT Company, Rank FROM company ORDER BY Sales_billion DESC;", "gold_sql": "SELECT company ,  rank FROM company ORDER BY Sales_billion DESC", "source_tables": ["company"]}
{"sample_id": 1996, "db_id": "gas_company", "question": "What is the name and rank of every company ordered by descending number of sales?", "rationale": ["Identify the columns needed: 'Company' and 'Rank' from the 'company' table.", "Determine the ordering requirement: the results should be ordered by 'Sales_billion' in descending order.", "Construct the SQL SELECT statement to retrieve the specified columns from the 'company' table.", "Add the ORDER BY clause to sort the results based on 'Sales_billion' in descending order."], "pred_sql": "SELECT Company, Rank FROM company ORDER BY Sales_billion DESC;", "gold_sql": "SELECT company ,  rank FROM company ORDER BY Sales_billion DESC", "source_tables": ["company"]}
{"sample_id": 1997, "db_id": "gas_company", "question": "Show the company name and the main industry for all companies whose headquarters are not from USA.", "rationale": ["Identify the columns needed: Company and Main_Industry from the company table.", "Determine the condition: Headquarters should not be 'USA'.", "Construct the SQL SELECT statement to retrieve the specified columns from the company table with the given condition."], "pred_sql": "SELECT Company, Main_Industry FROM company WHERE Headquarters != 'USA';", "gold_sql": "SELECT company ,  main_industry FROM company WHERE headquarters != 'USA'", "source_tables": ["company"]}
{"sample_id": 1998, "db_id": "gas_company", "question": "What are the companies and main industries of all companies that are not headquartered in the United States?", "rationale": ["Identify the relevant table: The query requires information about companies and their main industries, which are found in the 'company' table.", "Select the required columns: We need to retrieve the 'Company' and 'Main_Industry' columns from the 'company' table.", "Apply the filter condition: The query specifies that we only want companies not headquartered in the United States, so we will use a WHERE clause to filter out those companies by checking if 'Headquarters' is not equal to 'United States'."], "pred_sql": "SELECT Company, Main_Industry FROM company WHERE Headquarters != 'United States';", "gold_sql": "SELECT company ,  main_industry FROM company WHERE headquarters != 'USA'", "source_tables": ["company"]}
{"sample_id": 1999, "db_id": "gas_company", "question": "Show all company names and headquarters in the descending order of market value.", "rationale": ["Identify the columns needed: Company and Headquarters from the company table.", "Determine the sorting requirement: descending order based on Market_Value.", "Construct the SQL SELECT statement to retrieve the specified columns.", "Add the ORDER BY clause to sort the results by Market_Value in descending order."], "pred_sql": "SELECT Company, Headquarters FROM company ORDER BY Market_Value DESC;", "gold_sql": "SELECT company ,  headquarters FROM company ORDER BY market_value DESC", "source_tables": ["company"]}
