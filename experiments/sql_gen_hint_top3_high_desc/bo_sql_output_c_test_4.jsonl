{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["Identify the relevant table: Staff_Department_Assignments contains the assignment details of staff members.", "Select the columns needed: staff_id and staff_name from the Staff table.", "Order the results by the date_assigned_from column to find the staff member assigned for the least amount of time.", "Limit the results to 1 to get only the staff member with the earliest assignment date."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name \nFROM Staff_Department_Assignments \nORDER BY date_assigned_from ASC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4753", "db_id": "department_store", "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.", "rationale": ["Identify the Customers table to get customer IDs.", "Join the Customer_Orders table to link customers with their orders.", "Filter the orders to find those that have a status of 'Cancelled'.", "Use a subquery to find the order IDs of cancelled orders.", "Ensure that we only select customers who made orders after the cancelled ones by comparing order dates."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "pred_sql": "SELECT DISTINCT c.customer_id \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nWHERE co.order_id IN (\n    SELECT co2.order_id \n    FROM Customer_Orders co2 \n    WHERE co2.order_status_code = 'Cancelled'\n) \nAND co.order_date > (\n    SELECT MAX(co3.order_date) \n    FROM Customer_Orders co3 \n    WHERE co3.order_status_code = 'Cancelled'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\",\n    \"1\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\"\n}\n"}
{"sample_id": "train.4755", "db_id": "department_store", "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?", "rationale": ["Identify the relevant table: Staff_Department_Assignments contains the staff assignments and their dates.", "Determine the condition: We need to find staff who were assigned to a department earlier than any Clerical Staff.", "Use a subquery to find the earliest assignment date of Clerical Staff: SELECT MIN(date_assigned_from) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical'.", "Construct the main query to select staff_id from Staff_Department_Assignments where their date_assigned_from is less than the result of the subquery."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "pred_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_from < (SELECT MIN(date_assigned_from) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical')", "hint": "\n"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["Identify the relevant table: Customers, which contains customer information including their addresses.", "Determine the columns needed: customer_id and customer_name are required as per the query.", "Use the WHERE clause to filter customers based on their address. The condition is that the address should contain 'TN'.", "Utilize the LIKE operator with wildcards to match any address that includes 'TN'.", "Construct the SQL query to select the specified columns from the Customers table with the appropriate filtering condition."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name FROM Customers WHERE customer_address LIKE '%TN%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\",\n    \"1\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\"\n}\n"}
{"sample_id": "train.4760", "db_id": "department_store", "question": "What are the names and genders of staff who were assigned in 2016?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "We need to retrieve staff names and genders, so we will select staff_name and staff_gender from the Staff table.", "To find out which staff were assigned in 2016, we need to join the Staff table with the Staff_Department_Assignments table on staff_id.", "We will filter the results based on the date_assigned_from and date_assigned_to columns to ensure they fall within the year 2016."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name, staff_gender \nFROM Staff \nJOIN Staff_Department_Assignments ON Staff.staff_id = Staff_Department_Assignments.staff_id \nWHERE date_assigned_from >= '2016-01-01' AND date_assigned_to <= '2016-12-31';", "hint": "\n"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "We need to find staff members who have been assigned multiple jobs, which implies looking for multiple entries in the Staff_Department_Assignments table for the same staff member.", "Join the Staff table with the Staff_Department_Assignments table on staff_id to get the names of the staff along with their job assignments.", "Group the results by staff_id to aggregate the job assignments for each staff member.", "Use the HAVING clause to filter the groups where the count of distinct job_title_code is greater than 1, indicating multiple job assignments."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name\nFROM Staff\nJOIN Staff_Department_Assignments ON Staff.staff_id = Staff_Department_Assignments.staff_id\nGROUP BY Staff.staff_id\nHAVING COUNT(DISTINCT job_title_code) > 1;", "hint": "\n"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["Identify the relevant table: Customers, which contains customer_id, customer_name, customer_address, and payment_method_code.", "Filter customers based on the address containing 'WY'. This is done using the LIKE operator with wildcards: '%WY%'.", "Exclude customers who use a credit card for payment by adding a condition to the WHERE clause: payment_method_code != 'CREDIT_CARD'.", "Select the required fields: customer_id and customer_name from the Customers table."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name \nFROM Customers \nWHERE customer_address LIKE '%WY%' \nAND payment_method_code != 'CREDIT_CARD';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\",\n    \"1\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\"\n}\n"}
{"sample_id": "train.4793", "db_id": "department_store", "question": "Find the average price of all product clothes.", "rationale": ["Identify the table that contains product information, which is the 'Products' table.", "Determine the relevant column for price, which is 'product_price'.", "To find the average price, use the AVG() function.", "Filter the products to only include those that are classified as 'clothes' using the 'product_type_code' column."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "pred_sql": "SELECT AVG(product_price) AS average_price\nFROM Products\nWHERE product_type_code = 'clothes';", "hint": "\n"}
{"sample_id": "train.4795", "db_id": "department_store", "question": "Find the name of the most expensive hardware product.", "rationale": ["Identify the relevant table: Products, which contains product details including name and price.", "Filter the products to only include those of type 'hardware' using the product_type_code column.", "Sort the filtered products by product_price in descending order to get the most expensive product at the top.", "Limit the results to 1 to get only the most expensive hardware product."], "gold_sql": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1", "source_tables": ["products"], "pred_sql": "SELECT product_name FROM Products WHERE product_type_code = 'hardware' ORDER BY product_price DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["Identify the relevant table: The 'product' table contains the 'max_page_size' and 'product_id' columns.", "Group the results by 'max_page_size' to aggregate products with the same page size.", "Use the COUNT function to count the number of products for each 'max_page_size'.", "Apply the HAVING clause to filter groups where the count of products is greater than 3."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING COUNT(product_id) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4903", "db_id": "store_product", "question": "What is the maximum page size for everything that has more than 3 products listed?", "rationale": ["Identify the relevant tables: product, store_product, and store.", "We need to find the maximum page size for products that are listed in stores with more than 3 products.", "Join the product table with the store_product table to link products to stores.", "Join the store_product table with the store table to access store information.", "Group the results by store to count the number of products per store.", "Use the HAVING clause to filter stores that have more than 3 products listed.", "Select the maximum page size from the product table for the filtered stores."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT MAX(p.max_page_size) \nFROM product p \nJOIN store_product sp ON p.product_id = sp.Product_ID \nJOIN store s ON sp.Store_ID = s.Store_ID \nGROUP BY s.Store_ID \nHAVING COUNT(sp.Product_ID) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4913", "db_id": "store_product", "question": "What is the total number of residents for the districts with the 3 largest areas?", "rationale": ["Identify the requirement to find the total number of residents in districts with the largest areas.", "The relevant table for this information is the 'district' table, which contains 'City_Population' and 'City_Area'.", "To find the districts with the largest areas, I will order the districts by 'City_Area' in descending order and limit the results to the top 3 districts.", "Using a subquery, I will select the 'District_ID' of these top 3 districts.", "Finally, I will sum the 'City_Population' for these selected districts to get the total number of residents."], "gold_sql": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3", "source_tables": ["district"], "pred_sql": "SELECT SUM(City_Population) AS Total_Residents\nFROM district\nWHERE District_ID IN (\n    SELECT District_ID\n    FROM district\n    ORDER BY City_Area DESC\n    LIMIT 3\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\"\n}\n"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["Identify the relevant tables: store, store_district, and district are needed to find store names based on district.", "Join the store table with the store_district table on Store_ID to link stores with their respective districts.", "Join the resulting table with the district table on District_ID to access district names.", "Filter the results where the district name is 'Khanewal' to get only the stores located in that district."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT store.Store_Name \nFROM store \nJOIN store_district ON store.Store_ID = store_district.Store_ID \nJOIN district ON store_district.District_ID = district.District_ID \nWHERE district.District_name = 'Khanewal';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\",\n    \"1\": \"This virtual table identifies the names of districts that have stores of a specific type, ensuring that only districts with stores of the same type are returned. The placeholders in the WHERE clause represent the type of store being queried.\"\n}\n"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["To find the city with the most number of stores, we need to join the store, store_district, and district tables.", "We will join the store table with the store_district table on Store_ID to get the districts associated with each store.", "Next, we will join the resulting table with the district table on District_ID to get the city names.", "We will then group the results by the Headquartered_City to count the number of stores in each city.", "Finally, we will order the results in descending order based on the count of stores and limit the result to 1 to get the city with the most stores."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT d.Headquartered_City, COUNT(s.Store_ID) AS Number_of_Stores\nFROM store s\nJOIN store_district sd ON s.Store_ID = sd.Store_ID\nJOIN district d ON sd.District_ID = d.District_ID\nGROUP BY d.Headquartered_City\nORDER BY Number_of_Stores DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\",\n    \"1\": \"This virtual table identifies the names of districts that have stores of a specific type, ensuring that only districts with stores of the same type are returned. The placeholders in the WHERE clause represent the type of store being queried.\"\n}\n"}
{"sample_id": "train.4930", "db_id": "store_product", "question": "Find products with max page size as \"A4\" and pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to filter products based on 'max_page_size' being 'A4' and 'pages_per_minute_color' being less than 5.", "Construct the SQL SELECT statement: We will select all relevant columns from the 'product' table.", "Add the WHERE clause to filter results based on the specified conditions."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT product.product_id, product.product, product.dimensions, product.dpi, product.pages_per_minute_color, product.max_page_size, product.interface \nFROM product \nWHERE product.max_page_size = 'A4' \nAND product.pages_per_minute_color < '5';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4932", "db_id": "store_product", "question": "Find products with max page size as \"A4\" or pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the columns needed for the query.", "Determine the conditions: We need to find products where the max page size is 'A4' or the pages per minute for color is less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table where either of the conditions is met."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < '5';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4935", "db_id": "store_product", "question": "What are all of the products whose name includes the substring \"Scanner\"?", "rationale": ["Identify the table that contains product names or descriptions, which is the 'product' table.", "Determine the requirement to find products whose names include the substring 'Scanner'.", "Use the SQL LIKE operator with wildcards (%) to search for the substring within the product names.", "Construct the SQL query to select all columns from the 'product' table where the product name matches the condition."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE product LIKE '%Scanner%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\",\n    \"1\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\"\n}\n"}
{"sample_id": "train.4937", "db_id": "store_product", "question": "What is the most common maximum page size?", "rationale": ["Identify the column of interest: 'max_page_size' from the 'product' table.", "To find the most common maximum page size, we need to group the results by 'max_page_size'.", "Count the occurrences of each 'max_page_size' using COUNT(*) and order the results in descending order to get the most common one at the top.", "Limit the results to 1 to get only the most common maximum page size."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1", "source_tables": ["product"], "pred_sql": "SELECT max_page_size\nFROM product\nGROUP BY max_page_size\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4938", "db_id": "store_product", "question": "Find the name of the products that are not using the most frequently-used max page size.", "rationale": ["Identify the products from the 'product' table.", "Determine the most frequently-used max page size by grouping the products by 'max_page_size' and counting occurrences.", "Order the results by the count in descending order to find the most common max page size.", "Use a subquery to get the most common max page size.", "Select products that do not match this most common max page size."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "pred_sql": "SELECT product.product \nFROM product \nWHERE product.max_page_size != (SELECT max_page_size \n                                  FROM product \n                                  GROUP BY max_page_size \n                                  ORDER BY COUNT(*) DESC \n                                  LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\"\n}\n"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["The question asks for the average number of students enrolled in each college.", "To find the average enrollment, we need to use the AVG() function on the 'enr' column from the 'College' table.", "The SQL query will select the average enrollment from the College table without any grouping since we want the overall average across all colleges."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "pred_sql": "SELECT AVG(enr) AS average_enrollment FROM College;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n    \"1\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n    \"2\": \"This virtual table describes the names of colleges located in a specific state that have an enrollment number either less than or greater than a specified value. The placeholders in the WHERE clauses represent the enrollment numbers and the state name.\"\n}\n"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["The question asks for the average training hours of players.", "To find the average, we need to use the AVG() function in SQL.", "We assume there is a column 'training_hours' in the Player table that records the training hours for each player.", "The SQL query will select the average of the 'training_hours' column from the Player table."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_training_hours FROM Player;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\"\n}\n"}
{"sample_id": "train.4956", "db_id": "soccer_2", "question": "Find the name and training hours of players whose hours are below 1500.", "rationale": ["Identify the relevant table: The Player table contains the names of players and their training hours.", "Determine the columns needed: We need the player's name (pName) and their training hours.", "Apply the filter: We need to filter players whose training hours are below 1500.", "Construct the SQL query: Use SELECT to get the required columns from the Player table with the specified condition."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "pred_sql": "SELECT pName, hours FROM Player WHERE hours < 1500;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\"\n}\n"}
{"sample_id": "train.4961", "db_id": "soccer_2", "question": "What are the different types of player positions?", "rationale": ["The question asks for the different types of player positions, which suggests we need to retrieve unique values from the 'pPos' column in the 'Tryout' table.", "To get unique player positions, we can use the SQL keyword 'DISTINCT' in our query.", "The relevant table for player positions is 'Tryout', and the column we are interested in is 'pPos'.", "Thus, the SQL query will select distinct player positions from the Tryout table."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT pPos FROM Tryout;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["Identify the relevant table: The 'Tryout' table contains information about players and their decisions after tryouts.", "Determine the condition for acceptance: We need to count the number of players whose decision is 'accepted'.", "Construct the SQL query: Use the COUNT function to count the number of rows in the 'Tryout' table where the decision is 'accepted'."], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) AS accepted_students\nFROM Tryout\nWHERE decision = 'accepted';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"2\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["Identify the need to calculate maximum, average, and minimum training hours for all players.", "Recognize that the relevant table for player information is the Player table.", "Formulate the SQL query to select the maximum, average, and minimum of the training_hours column from the Player table."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT MAX(training_hours) AS max_hours, AVG(training_hours) AS avg_hours, MIN(training_hours) AS min_hours FROM Player;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\"\n}\n"}
{"sample_id": "train.4967", "db_id": "soccer_2", "question": "What is the average, maximum, and minimum for the number of hours spent training?", "rationale": ["Identify the required metrics: average, maximum, and minimum hours spent training.", "Determine the relevant table that contains training hours data, which is assumed to be a 'Training' table.", "Construct the SQL query to select the average, maximum, and minimum of the 'training_hours' column from the 'Training' table."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_hours, MAX(training_hours) AS max_hours, MIN(training_hours) AS min_hours FROM Training;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.4970", "db_id": "soccer_2", "question": "What are the names of players whose training hours is between 500 and 1500?", "rationale": ["Identify the table that contains player names, which is the Player table.", "Determine the relevant column for filtering, which is 'training_hours'.", "Use the BETWEEN clause to filter players whose training hours are between 500 and 1500.", "Construct the SQL query to select player names from the Player table based on the specified training hours condition."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE training_hours BETWEEN 500 AND 1500;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.4971", "db_id": "soccer_2", "question": "What are the names of players who train between 500 and 1500 hours?", "rationale": ["Identify the relevant table: The Player table contains the names of players.", "Determine the filtering criteria: We need to find players who have trained between 500 and 1500 hours.", "Since the training hours are not directly in the schema, we assume that the Tryout table may have some indirect relation to training hours based on the number of tryouts or positions.", "Use a subquery to filter players based on the count of their tryouts, which we assume correlates with training hours.", "Group the results by position and filter using the HAVING clause to get counts between 500 and 1500.", "Finally, select the player names from the Player table based on the filtered player IDs."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE pPos IN (SELECT pPos FROM Tryout GROUP BY pPos HAVING COUNT(pID) BETWEEN 500 AND 1500));", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\"\n}\n"}
{"sample_id": "train.4975", "db_id": "soccer_2", "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?", "rationale": ["Identify the relevant table: The 'College' table contains the necessary information about college names and enrollment numbers.", "Determine the conditions: We need colleges with an enrollment number greater than 10000 and located in Louisiana.", "Construct the SQL query: Use a SELECT statement to retrieve 'cName' and 'enr' from the 'College' table, applying the specified conditions in the WHERE clause."], "gold_sql": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = 'LA'", "source_tables": ["college"], "pred_sql": "SELECT cName, enr FROM College WHERE enr > 10000 AND state = 'Louisiana';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of colleges located in a specific state that have an enrollment number either less than or greater than a specified value. The placeholders in the WHERE clauses represent the enrollment numbers and the state name.\",\n    \"1\": \"This virtual table lists the distinct names of colleges from the 'College' table that have an enrollment number greater than the minimum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\",\n    \"2\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.4981", "db_id": "soccer_2", "question": "What are the name of the players who received a card in descending order of the hours of training?", "rationale": ["Identify the relevant tables: Player and Tryout.", "Determine the condition for players who received a card, which is indicated by the decision in the Tryout table.", "Use a subquery to filter players based on the decision 'received card'.", "Select the player names from the Player table where their IDs match those in the subquery.", "Order the results by the maximum high school attended, grouped by position, in descending order."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE decision = 'received card') ORDER BY (SELECT MAX(HS) FROM Player GROUP BY pPos) DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["To determine the most popular position among players in the tryout, we need to count how many players are trying out for each position.", "We will use the COUNT() function to count the number of players for each position (pPos) in the Tryout table.", "We will group the results by the position (pPos) to aggregate the counts for each position.", "To find the most popular position, we will order the results in descending order based on the count of players for each position.", "Finally, we will limit the results to just one entry to get the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count\nFROM Tryout\nGROUP BY pPos\nORDER BY position_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["Identify the relevant table: The Tryout table contains the position information for players.", "Count the occurrences of each position: Use COUNT(pPos) to count how many players tried out for each position.", "Group the results by position: Use GROUP BY pPos to aggregate the counts for each position.", "Order the results to find the most popular position: Use ORDER BY position_count DESC to sort the positions by their count in descending order.", "Limit the results to the top position: Use LIMIT 1 to get only the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(pPos) AS position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["Identify the relevant tables: Player, Tryout, and College.", "Determine the columns needed: position (pPos) and enrollment (enr).", "Join the Player table with the Tryout table on pID to get player positions.", "Join the Tryout table with the College table on cName to access college information if needed.", "Use the MIN function to find the minimum enrollment number for each position.", "Group the results by position to get the minimum enrollment for each position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(enr) AS min_hours\nFROM Player\nJOIN Tryout ON Player.pID = Tryout.pID\nJOIN College ON Tryout.cName = College.cName\nGROUP BY pPos;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\"\n}\n"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["Identify the relevant tables: We need to find the minimum time students spent practicing for each position, which suggests we need a table that records practice times and player positions.", "Assume there is a 'Practice' table that records practice times along with player positions. We will group the results by position to find the minimum practice time for each.", "Use the MIN() function to calculate the minimum practice time for each position.", "Construct the SQL query to select the position and the minimum practice time, grouping by position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(practice_time) AS min_practice_time\nFROM Practice\nGROUP BY pPos;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"2\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["Identify the tables involved: Player and Tryout.", "We need to select the names of players, which is in the Player table under the column pName.", "We also need to check the decision made during tryouts, which is in the Tryout table under the column decision.", "To find players who received a 'yes' at tryouts, we will filter the results where Tryout.decision = 'yes'.", "We need to join the Player and Tryout tables on the common column pID to correlate players with their tryout decisions."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT Player.pName, Tryout.decision \nFROM Player \nJOIN Tryout ON Player.pID = Tryout.pID \nWHERE Tryout.decision = 'yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\"\n}\n"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find the names of students (players) who successfully tried out for a specific position (striker).", "Join the Player table with the Tryout table on the player ID (pID) to access player names and their tryout details.", "Filter the results to include only those records where the position (pPos) is 'striker' and the decision is 'successful'.", "Select the player names (pName) from the filtered results."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT Player.pName \nFROM Player \nJOIN Tryout ON Player.pID = Tryout.pID \nWHERE Tryout.pPos = 'striker' AND Tryout.decision = 'successful';", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["Identify the relevant tables: Player and Tryout are needed to find players who were rejected.", "Join the Player and Tryout tables on the pID to access player information along with their tryout decisions.", "Filter the results to include only those players whose decision was 'rejected'.", "Select the average of the hours spent practicing from the filtered results."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT AVG(hours) AS average_hours_practicing\nFROM Player\nJOIN Tryout ON Player.pID = Tryout.pID\nWHERE Tryout.decision = 'rejected';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.5018", "db_id": "soccer_2", "question": "Which college has any student who is a goalie and succeeded in the tryout.", "rationale": ["Identify the relevant tables: College, Player, and Tryout.", "We need to find colleges that have students who are goalies and succeeded in their tryouts.", "This requires joining the College table with the Tryout table on the college name, and the Tryout table with the Player table on the player ID.", "We filter the results where the position (pPos) is 'goalie' and the decision is 'succeeded'.", "Finally, we select distinct college names to avoid duplicates."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT College.cName \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nJOIN Player ON Tryout.pID = Player.pID \nWHERE Tryout.pPos = 'goalie' AND Tryout.decision = 'succeeded';", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\"\n}\n"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["Identify the relevant tables: College and Tryout.", "Determine the columns needed: state and enrollment from College, and filter based on the decision in Tryout.", "Use a JOIN to connect College and Tryout on the college name (cName).", "Add a WHERE clause to filter for accepted decisions in the Tryout table."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT College.state, College.enr FROM College JOIN Tryout ON College.cName = Tryout.cName WHERE Tryout.decision = 'accepted';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n    \"1\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n    \"2\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\"\n}\n"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["Identify the tables involved: College and Tryout.", "We need to find the total enrollment of colleges that have accepted students during tryouts, so we will join the College and Tryout tables on the college name (cName).", "We will filter the results to include only those tryouts where the decision was 'accepted'.", "We need to sum the enrollment numbers, which are stored as text, so we will cast them to integers for the summation.", "Finally, we will group the results by the state of the colleges to get the total enrollment per state."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT SUM(CAST(College.enr AS INTEGER)) AS total_enrollment, College.state \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.decision = 'accepted' \nGROUP BY College.state;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n    \"1\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n    \"2\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\"\n}\n"}
{"sample_id": "train.5026", "db_id": "soccer_2", "question": "Find the names of schools that have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant tables: We need to look at the 'Tryout' table since it contains the positions players are trying out for and the colleges associated with those tryouts.", "We need to find colleges where players are trying out for both 'goalie' and 'mid' positions.", "Use the SELECT statement to get distinct college names from the 'Tryout' table.", "Filter the results using a WHERE clause to include only those rows where the position (pPos) is either 'goalie' or 'mid'.", "Group the results by college name to aggregate the data for each college.", "Use the HAVING clause to ensure that only colleges with players trying out for both positions are included, which means we need to count distinct positions and ensure that count equals 2."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT Tryout.cName\nFROM Tryout\nWHERE Tryout.pPos IN ('goalie', 'mid')\nGROUP BY Tryout.cName\nHAVING COUNT(DISTINCT Tryout.pPos) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.5028", "db_id": "soccer_2", "question": "Find the names of states that have some college students playing in goalie and mid positions.", "rationale": ["Identify the tables involved: College and Tryout.", "Determine the relationship between the tables: Tryout references College through cName.", "Focus on the required output: names of states with colleges that have players trying out for 'goalie' and 'mid' positions.", "Use a JOIN to connect College and Tryout on the college name (cName).", "Filter the results using a WHERE clause to include only those records where the position (pPos) is either 'goalie' or 'mid'.", "Select distinct states to avoid duplicates in the final output."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT College.state \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.pPos IN ('goalie', 'mid');", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n    \"2\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.5029", "db_id": "soccer_2", "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find states that have colleges with players trying out for the positions of goalie and mid-field.", "Use a JOIN operation to connect the College and Tryout tables based on the college name (cName).", "Filter the results to include only those tryouts where the position (pPos) is either 'goalie' or 'mid-field'.", "Select distinct states from the College table that meet the criteria."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT College.state\nFROM College\nJOIN Tryout ON College.cName = Tryout.cName\nWHERE Tryout.pPos IN ('goalie', 'mid-field')\nGROUP BY College.state;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n    \"2\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant positions: goalie and mid.", "We need to count distinct colleges (cName) where players are trying out for these positions.", "Use the Tryout table to filter players based on their positions.", "Group the results by college name to aggregate the data.", "Use the HAVING clause to ensure that both positions are represented for each college."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(DISTINCT cName) AS school_count \nFROM Tryout \nWHERE pPos IN ('goalie', 'mid') \nGROUP BY cName \nHAVING COUNT(DISTINCT pPos) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n    \"2\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\"\n}\n"}
{"sample_id": "train.5037", "db_id": "soccer_2", "question": "What is the count of states with college students playing in the mid position but not as goalies?", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to count distinct states from the College table where players are trying out for the 'mid' position.", "Join the College table with the Tryout table on the college name to filter the relevant tryouts.", "Add a condition to filter for players trying out for the 'mid' position.", "Use a subquery to exclude states where players are trying out for the 'goalie' position.", "The subquery selects college names from the Tryout table where the position is 'goalie' and ensures these colleges are excluded from the main query."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')", "source_tables": ["tryout", "college"], "pred_sql": "SELECT COUNT(DISTINCT College.state) \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nWHERE Tryout.pPos = 'mid' \nAND College.cName NOT IN (\n    SELECT College.cName \n    FROM College \n    JOIN Tryout ON College.cName = Tryout.cName \n    WHERE Tryout.pPos = 'goalie'\n);", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n    \"1\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n    \"2\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["Identify the requirement to find states with colleges that have enrollments less than some other college.", "Use a subquery to find the minimum enrollment number from the College table.", "Select distinct states from the College table where the enrollment number is less than the minimum enrollment number found in the subquery."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE enr < (SELECT MIN(enr) FROM College)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of colleges located in a specific state that have an enrollment number either less than or greater than a specified value. The placeholders in the WHERE clauses represent the enrollment numbers and the state name.\",\n    \"1\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n    \"2\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\"\n}\n"}
{"sample_id": "train.5102", "db_id": "cre_Drama_Workshop_Groups", "question": "Show the minimum, average, maximum order quantity of all invoices.", "rationale": ["Identify the relevant table: The task requires information about invoices, specifically the order quantities, which are found in the Invoice_Items table.", "Determine the required calculations: We need to calculate the minimum, average, and maximum order quantities.", "Construct the SQL query: Use the SELECT statement to retrieve the minimum, average, and maximum order quantities from the Invoice_Items table."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "pred_sql": "SELECT MIN(Order_Quantity) AS Min_Quantity, AVG(Order_Quantity) AS Avg_Quantity, MAX(Order_Quantity) AS Max_Quantity\nFROM Invoice_Items;", "hint": "\n"}
{"sample_id": "train.5118", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the payment method code used by the most orders?", "rationale": ["Identify the relevant table: Invoices contains the payment_method_code and Order_ID.", "Group the results by payment_method_code to count the number of orders for each payment method.", "Use COUNT(Order_ID) to count the number of orders associated with each payment method.", "Order the results in descending order to get the payment method with the most orders at the top.", "Limit the results to 1 to get only the payment method code used by the most orders."], "gold_sql": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices"], "pred_sql": "SELECT payment_method_code\nFROM Invoices\nGROUP BY payment_method_code\nORDER BY COUNT(Order_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5127", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the descriptions of the service types that cost more than 100.", "rationale": ["Identify the relevant tables: We need to retrieve service type descriptions, which are in the Ref_Service_Types table, and we also need to check the price of services, which are in the Services table.", "Join the tables: We will join the Services table with the Ref_Service_Types table on the Service_Type_Code to get the descriptions of the service types associated with the services.", "Filter the results: We need to filter the services to only include those that cost more than 100, which will be done using a WHERE clause on the Product_Price column in the Services table."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT Ref_Service_Types.Service_Type_Description \nFROM Services \nJOIN Ref_Service_Types ON Services.Service_Type_Code = Ref_Service_Types.Service_Type_Code \nWHERE Services.Product_Price > 100;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the descriptions of service types associated with a specific product name from the 'Services' table, ensuring that the same product name is used in both parts of the query. The placeholders represent the product name that the user can specify to filter the results accordingly.\"\n}\n"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["Identify the relevant tables: 'Drama_Workshop_Groups' for workshop group names and 'Services' for the product name.", "Join the 'Drama_Workshop_Groups' table with the 'Services' table on the 'Workshop_Group_ID' to link workshop groups with their services.", "Filter the results to only include services where the product name is 'film'.", "Select distinct workshop group names to avoid duplicates in the results."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "pred_sql": "SELECT DISTINCT DWG.Store_Name \nFROM Drama_Workshop_Groups DWG \nJOIN Services S ON DWG.Workshop_Group_ID = S.Workshop_Group_ID \nWHERE S.Product_Name = 'film';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular product. The placeholder in the WHERE clause represents the name of the product being queried.\",\n    \"1\": \"This virtual table retrieves the descriptions of service types associated with a specific product name from the 'Services' table, ensuring that the same product name is used in both parts of the query. The placeholders represent the product name that the user can specify to filter the results accordingly.\"\n}\n"}
{"sample_id": "train.5142", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the order details of the products with price higher than 2000?", "rationale": ["Identify the relevant tables: Order_Items and Products are needed to get order details and product prices.", "Determine the columns needed: We need Order_Item_ID, Order_ID, Product_ID, Order_Quantity from Order_Items and Product_Name, Product_Price from Products.", "Establish the relationship: Use a JOIN to connect Order_Items with Products on Product_ID.", "Apply the filter: Use a WHERE clause to filter products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_Items.Order_Item_ID, Order_Items.Order_ID, Order_Items.Product_ID, Order_Items.Order_Quantity, Products.Product_Name, Products.Product_Price \nFROM Order_Items \nJOIN Products ON Order_Items.Product_ID = Products.Product_ID \nWHERE Products.Product_Price > 2000;", "hint": "\n"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["Identify the relevant tables: Order_Items and Products.", "Determine the columns needed: Order_Item_ID, Order_ID, Product_ID, Order_Quantity from Order_Items and Product_Price from Products.", "Establish the relationship between Order_Items and Products using the Product_ID.", "Filter the results to include only those products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_Items.Order_Item_ID, Order_Items.Order_ID, Order_Items.Product_ID, Order_Items.Order_Quantity, Products.Product_Price \nFROM Order_Items \nJOIN Products ON Order_Items.Product_ID = Products.Product_ID \nWHERE Products.Product_Price > 2000;", "hint": "\n"}
{"sample_id": "train.5160", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the most frequent status of bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most frequent status of bookings, which means we need to count occurrences of each status code.", "Use the COUNT function: We will count the number of bookings for each status code using COUNT(*) and group the results by 'Status_Code'.", "Sort the results: To find the most frequent status, we will order the results in descending order based on the count of bookings.", "Limit the results: Since we only want the most frequent status, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Frequency\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most common status code, which implies counting occurrences of each status code.", "Use the COUNT function: We will count how many times each status code appears in the 'Bookings' table.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each unique status code.", "Order the results: To find the most common status code, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most common status code, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(Status_Code) AS Count\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["Identify the relevant tables: We need to find workshop groups and their bookings, so we will use the Drama_Workshop_Groups and Bookings tables.", "Determine the relationship: The Drama_Workshop_Groups table is linked to the Bookings table through the Workshop_Group_ID.", "Select the required fields: We need the names of the workshop groups, which corresponds to the Store_Name in the Drama_Workshop_Groups table.", "Apply the filter: We need to filter the bookings to only include those with a status code of 'stop'.", "Use DISTINCT to ensure we only get unique workshop group names."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "pred_sql": "SELECT DISTINCT DWG.Store_Name \nFROM Drama_Workshop_Groups DWG \nJOIN Bookings B ON DWG.Workshop_Group_ID = B.Workshop_Group_ID \nWHERE B.Status_Code = 'stop';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular product. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5171", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the description of the service type that offers not only the photo product but also the film product.", "rationale": ["Identify the relevant tables: We need to retrieve service type descriptions, so we will use the 'Ref_Service_Types' table and the 'Services' table.", "Join the tables: We will join 'Services' with 'Ref_Service_Types' on the 'Service_Type_Code' to get the descriptions of the service types.", "Filter for specific products: We need to filter the services to only those that offer both 'photo' and 'film' products. This can be done using a WHERE clause with an IN condition.", "Group the results: We will group the results by 'Service_Type_Description' to aggregate the services that match our criteria.", "Count distinct products: We will use HAVING to ensure that only service types that offer both products are included, which means we need to count distinct product names and check that it equals 2."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT DISTINCT Ref_Service_Types.Service_Type_Description \nFROM Services \nJOIN Ref_Service_Types ON Services.Service_Type_Code = Ref_Service_Types.Service_Type_Code \nWHERE Services.Product_Name IN ('photo', 'film') \nGROUP BY Ref_Service_Types.Service_Type_Description \nHAVING COUNT(DISTINCT Services.Product_Name) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the descriptions of service types associated with a specific product name from the 'Services' table, ensuring that the same product name is used in both parts of the query. The placeholders represent the product name that the user can specify to filter the results accordingly.\",\n    \"1\": \"This virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular product. The placeholder in the WHERE clause represents the name of the product being queried.\"\n}\n"}
{"sample_id": "train.5459", "db_id": "voter_2", "question": "Find the average age of female students.", "rationale": ["Identify the table needed: The 'Student' table contains the necessary information about students, including their age and gender.", "Determine the required calculation: We need to calculate the average age, which can be done using the AVG() function in SQL.", "Filter the results: We only want the average age of female students, so we will add a WHERE clause to filter by 'Sex = 'Female'.", "Construct the SQL query: Combine the SELECT statement with the AVG() function, the FROM clause to specify the 'Student' table, and the WHERE clause for filtering by gender."], "gold_sql": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  'F'", "source_tables": ["student"], "pred_sql": "SELECT AVG(Age) AS Average_Age FROM Student WHERE Sex = 'Female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"1\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"2\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\"\n}\n"}
{"sample_id": "train.5466", "db_id": "voter_2", "question": "What are the distinct president votes on 08/30/2015?", "rationale": ["Identify the relevant table: The Voting_record table contains the voting information, including the President_Vote column.", "Determine the required information: The question asks for distinct president votes on a specific date (08/30/2015).", "Filter the records based on the date: Use the WHERE clause to filter records where the Registration_Date matches '2015-08-30'.", "Select distinct values: Use the DISTINCT keyword to ensure that only unique president votes are returned."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote \nFROM Voting_record \nWHERE Registration_Date = '2015-08-30';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n    \"1\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"2\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\"\n}\n"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["Identify the relevant tables: We need to retrieve data from the Student and Voting_record tables.", "Determine the necessary columns: We want distinct first and last names of students who voted for president.", "Establish the relationship between tables: The Student table is linked to the Voting_record table through the StuID column.", "Filter the results: We need to filter the voting records to only include those with a specific registration date (08/30/2015) and ensure that the president vote is not null."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT Student.Fname, Student.LName \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Voting_record.President_Vote IS NOT NULL \nAND Voting_record.Registration_Date = '2015-08-30';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n    \"1\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"2\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\"\n}\n"}
{"sample_id": "train.5476", "db_id": "voter_2", "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for student details and the 'Voting_record' table for voting details.", "Determine the columns needed: We need the distinct ages of students, which is in the 'Student' table under the 'Age' column.", "Establish the relationship between tables: The 'StuID' in the 'Student' table is linked to the 'StuID' in the 'Voting_record' table, allowing us to join these tables.", "Filter the results: We need to filter for students who have cast a vote for the secretary, which means checking if 'Secretary_Vote' is not null. Additionally, we need to specify the election cycle as 'fall'.", "Construct the SQL query: Using the SELECT statement to get distinct ages, joining the two tables on 'StuID', and applying the necessary filters."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Age FROM Student INNER JOIN Voting_record ON Student.StuID = Voting_record.StuID WHERE Voting_record.Secretary_Vote IS NOT NULL AND Voting_record.Election_Cycle = 'fall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"1\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"2\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\"\n}\n"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for advisor information and the 'Voting_record' table for voting details.", "Determine the relationship: The 'Voting_record' table has a foreign key 'StuID' that links to the 'Student' table, allowing us to join these tables on 'StuID'.", "Specify the condition: We want to find students who have cast votes for treasurer, which means we need to check if 'Treasurer_Vote' is not null.", "Filter by election cycle: We need to specify that we are only interested in the spring election cycle, so we will add a condition for 'Election_Cycle'.", "Select the advisor: Finally, we want to select the distinct advisors of these students."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Student.Advisor \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Voting_record.Treasurer_Vote IS NOT NULL \nAND Voting_record.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.\",\n    \"1\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n    \"2\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\"\n}\n"}
{"sample_id": "train.5486", "db_id": "voter_2", "question": "How many male (sex is M) students have class senator votes in the fall election cycle?", "rationale": ["Identify the relevant tables: We need to use both the 'Student' and 'Voting_record' tables to get the required information about male students and their voting records.", "Determine the criteria: We are looking for male students (Sex = 'M') who have class senator votes in the fall election cycle.", "Join the tables: We will join the 'Student' table with the 'Voting_record' table on the StuID to link students with their voting records.", "Count distinct male students: We will count the distinct StuID from the joined tables where the conditions for sex and election cycle are met."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Student.Sex = 'M' \nAND Voting_record.Election_Cycle = 'fall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n    \"1\": \"This virtual table provides a list of distinct first and last names of students from the 'Student' table who have voted for a presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n    \"2\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\"\n}\n"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["Identify the tables involved: We need data from the 'Student' table for age and city code, and from the 'Voting_record' table for the secretary votes and election cycle.", "Determine the conditions: We need to filter students who have the city code 'NYC' and have cast a vote for the secretary in the spring election cycle.", "Join the tables: We will join the 'Student' table with the 'Voting_record' table on the StuID to correlate students with their voting records.", "Calculate the average age: We will use the AVG() function to calculate the average age of the filtered students."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(Age) AS Average_Age\nFROM Student\nJOIN Voting_record ON Student.StuID = Voting_record.StuID\nWHERE Student.city_code = 'NYC' AND Voting_record.Secretary_Vote IS NOT NULL AND Voting_record.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"1\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"2\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\"\n}\n"}
{"sample_id": "train.5492", "db_id": "voter_2", "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.", "rationale": ["Identify the relevant tables: We need to use the 'Student' table to get the age and gender of students, and the 'Voting_record' table to check for secretary votes and the election cycle.", "We need to filter for female students, which means we will add a condition for 'Sex' = 'F'.", "We also need to ensure that the students have voted for the secretary, so we will check that 'Secretary_Vote' is not null in the 'Voting_record' table.", "Additionally, we need to filter for the spring election cycle, which will be done by checking the 'Election_Cycle' column in the 'Voting_record' table.", "Finally, we will calculate the average age of the filtered results using the AVG() function and select it as 'Average_Age'."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(Age) AS Average_Age\nFROM Student S\nJOIN Voting_record V ON S.StuID = V.StuID\nWHERE S.Sex = 'F' AND V.Secretary_Vote IS NOT NULL AND V.Election_Cycle = 'spring';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"1\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"2\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\"\n}\n"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["We need to find distinct first names of students who voted for the vice president.", "To do this, we will join the Student table with the Voting_record table on the StuID column, which is the unique identifier for students in both tables.", "We will filter the results to include only those records where the Vice_President_Vote is not null, indicating that the student has cast a vote for the vice president.", "Additionally, we will filter out students whose city code is 'PIT' by adding a condition that city_code should not equal 'PIT'.", "Finally, we will select only the distinct first names (Fname) from the resulting dataset."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Fname FROM Student JOIN Voting_record ON Student.StuID = Voting_record.StuID WHERE Vice_President_Vote IS NOT NULL AND city_code != 'PIT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n    \"1\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"2\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\"\n}\n"}
{"sample_id": "train.5495", "db_id": "voter_2", "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?", "rationale": ["Identify the relevant tables: We need to retrieve first names from the Student table and check voting records from the Voting_record table.", "Determine the relationship: The Student table and Voting_record table are linked by the StuID column.", "Filter criteria: We want students who have voted for the vice president, which means we need to check that the Vice_President_Vote column is not null.", "Additional filter: We also need to ensure that the city_code is not 'PIT'.", "Construct the SQL query: We will select distinct first names from the Student table, joining it with the Voting_record table, and applying the necessary filters."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Fname FROM Student JOIN Voting_record ON Student.StuID = Voting_record.StuID WHERE Vice_President_Vote IS NOT NULL AND city_code != 'PIT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"1\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n    \"2\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\"\n}\n"}
{"sample_id": "train.5496", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is not 2192.", "rationale": ["We need to find distinct last names of students who voted for a presidential candidate.", "To do this, we will join the Student table with the Voting_record table on the StuID column, which is the unique identifier for students.", "We will filter the results to include only those records where the President_Vote is not null, indicating that the student has cast a vote for president.", "Additionally, we will exclude students whose advisor is '2192' by adding a condition in the WHERE clause.", "Finally, we will select only the distinct last names from the resulting dataset."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Student.LName \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Voting_record.President_Vote IS NOT NULL \nAND Student.Advisor != '2192';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n    \"1\": \"This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.\",\n    \"2\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\"\n}\n"}
{"sample_id": "train.5499", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes and have 8741 as the advisor?", "rationale": ["Identify the relevant tables: We need to get last names from the Student table and filter based on voting records from the Voting_record table.", "Join the Student and Voting_record tables on the StuID column to combine student information with their voting records.", "Filter the results to include only those students who have cast a vote for president (i.e., where President_Vote is not null).", "Additionally, filter the results to include only those students whose advisor is '8741'.", "Select distinct last names to ensure that we do not have duplicate entries in the result."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Student.LName \nFROM Student \nJOIN Voting_record ON Student.StuID = Voting_record.StuID \nWHERE Voting_record.President_Vote IS NOT NULL \nAND Student.Advisor = '8741';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n    \"1\": \"This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.\",\n    \"2\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\"\n}\n"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and gender.", "Filter the records: We need to focus on female students, so we will filter the records where 'Sex' is 'F'.", "Group the results: To find the most common major, we will group the results by the 'Major' column.", "Count occurrences: For each major, we will count how many female students are enrolled in that major using COUNT(*).", "Order the results: We will order the results in descending order based on the count of students in each major to find the most common one.", "Limit the results: Since we only want the most common major, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as MajorCount \nFROM Student \nWHERE Sex = 'F' \nGROUP BY Major \nORDER BY MajorCount DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n    \"1\": \"This virtual table provides a list of distinct first and last names of students from the 'Student' table who have voted for a presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\"\n}\n"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and gender.", "Filter the records: We need to focus on female students, so we will filter the records where 'Sex' is 'Female'.", "Count the number of female students per major: We will use the COUNT function and group the results by 'Major'.", "Order the results: To find the major with the most female students, we will order the results in descending order based on the count of female students.", "Limit the results: Since we only want the major with the highest count, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as Female_Count \nFROM Student \nWHERE Sex = 'Female' \nGROUP BY Major \nORDER BY Female_Count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n    \"1\": \"This virtual table provides a list of distinct first and last names of students from the 'Student' table who have voted for a presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n    \"2\": \"This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.\"\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to count the number of products, so we will use the COUNT() function.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to filter by category.", "Add a WHERE clause to filter for products in the 'Spices' category.", "Add another condition in the WHERE clause to filter for products with a typical selling price greater than 1000."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT COUNT(*) AS product_count\nFROM Products\nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code\nWHERE Ref_Product_Categories.product_category_description = 'Spices'\nAND Products.typical_selling_price > 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the relevant tables: We need to get product category descriptions, so we will use the Ref_Product_Categories table.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to link products to their categories.", "Filter the products based on the condition that their product descriptions contain the letter 't'.", "Use the LIKE operator with wildcards to find product descriptions that contain 't'.", "Select distinct product category descriptions to avoid duplicates in the results."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description \nFROM Ref_Product_Categories rpc \nJOIN Products p ON rpc.product_category_code = p.product_category_code \nWHERE p.product_description LIKE '%t%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n    \"1\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\"\n}\n"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["Identify the relevant tables: Products, Product_Characteristics, and Characteristics are needed to find the distinct characteristic names for the product 'cumin'.", "Use a JOIN to connect Products with Product_Characteristics on product_id, and then join Product_Characteristics with Characteristics on characteristic_id.", "Filter the results to only include the product with the name 'cumin' using a WHERE clause.", "Count the distinct characteristic names using COUNT(DISTINCT ...) to get the number of unique characteristic names associated with the product."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT Characteristics.characteristic_name) AS distinct_characteristic_count\nFROM Products\nJOIN Product_Characteristics ON Products.product_id = Product_Characteristics.product_id\nJOIN Characteristics ON Product_Characteristics.characteristic_id = Characteristics.characteristic_id\nWHERE Products.product_name = 'cumin';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\"\n}\n"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["Identify the tables involved: Products, Product_Characteristics, Characteristics, and Ref_Colors.", "We need to count products that either have a color described as 'white' or have a characteristic named 'hot'.", "To find products with the color 'white', we will join the Products table with the Ref_Colors table to filter by color description.", "To find products with the characteristic 'hot', we will join the Products table with Product_Characteristics and then with Characteristics to filter by characteristic name.", "Use COUNT(DISTINCT p.product_id) to ensure we count each product only once, even if it meets both conditions.", "Combine the conditions using an OR clause in the WHERE statement."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT p.product_id) \nFROM Products p \nLEFT JOIN Product_Characteristics pc ON p.product_id = pc.product_id \nLEFT JOIN Characteristics c ON pc.characteristic_id = c.characteristic_id \nWHERE p.color_code = (SELECT color_code FROM Ref_Colors WHERE color_description = 'white') \n   OR c.characteristic_name = 'hot';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n    \"1\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: We need to find the unit of measure for 'Herb' products, which involves the Products table and the Ref_Product_Categories table.", "Determine the relationship: The Products table has a foreign key relationship with the Ref_Product_Categories table through the product_category_code.", "Formulate the query: We will select the unit_of_measure from Ref_Product_Categories and join it with Products on product_category_code.", "Filter the results: We need to filter the products to only those that have 'Herb' in their product name using a LIKE clause."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT pc.unit_of_measure \nFROM Ref_Product_Categories pc \nJOIN Products p ON pc.product_category_code = p.product_category_code \nWHERE p.product_name LIKE '%Herb%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n    \"1\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to find the unit of measurement and product category code for a specific product named 'chervil'.", "The product category code is in the Ref_Product_Categories table, and we can join it with the Products table using the product_category_code.", "We will filter the results by the product name 'chervil' in the Products table.", "Select the required fields: product_category_code and unit_of_measure from the joined tables."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT pc.product_category_code, p.product_category_code\nFROM Products p\nJOIN Ref_Product_Categories pc ON p.product_category_code = pc.product_category_code\nWHERE p.product_name = 'chervil';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n    \"1\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\"\n}\n"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["Identify the relevant tables: Products and Ref_Colors are needed to get product descriptions and their associated colors.", "Join the Products table with the Ref_Colors table on the color_code to access color descriptions for each product.", "Group the results by color description to count how many products are associated with each color.", "Order the results by the count of products in descending order to find the color associated with the most products.", "Limit the results to 1 to get only the top color description."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT Ref_Colors.color_description, COUNT(Products.product_id) AS product_count\nFROM Products\nJOIN Ref_Colors ON Products.color_code = Ref_Colors.color_code\nGROUP BY Ref_Colors.color_description\nORDER BY product_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n    \"1\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["We need to find the color description used by the least number of products.", "To do this, we will join the Ref_Colors table with the Products table on the color_code.", "We will group the results by color_code to count how many products are associated with each color.", "Next, we will order the results in ascending order based on the count of products, so that the color with the least products comes first.", "Finally, we will limit the results to just one entry to get the color description used by the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT c.color_description\nFROM Ref_Colors c\nJOIN Products p ON c.color_code = p.color_code\nGROUP BY c.color_code\nORDER BY COUNT(p.product_id) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\"\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To do this, we will join the 'Characteristics' table with the 'Product_Characteristics' table using the 'characteristic_id'.", "Next, we will group the results by 'characteristic_name' to aggregate the data for each characteristic.", "We will use the HAVING clause to filter the groups, ensuring that we only include those characteristics that are linked to two or more distinct products (using COUNT(DISTINCT pc.product_id))."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT c.characteristic_name\nFROM Characteristics c\nJOIN Product_Characteristics pc ON c.characteristic_id = pc.characteristic_id\nGROUP BY c.characteristic_name\nHAVING COUNT(DISTINCT pc.product_id) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n    \"1\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\"\n}\n"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to query.", "Select the 'Builder' column: We want to list the builders, so we will select this column.", "Use DISTINCT to avoid duplicate entries: Since multiple railways can have the same builder, we will use DISTINCT to ensure each builder is listed only once.", "Order the results: We need the results in ascending alphabetical order, so we will use ORDER BY Builder ASC.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "pred_sql": "SELECT DISTINCT Builder FROM railway ORDER BY Builder ASC;", "hint": "\n"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["Identify the relevant tables: railway and train.", "We need to find the railway associated with the most trains, so we will join the railway table with the train table on the Railway_ID.", "We will group the results by Railway_ID and Builder to count the number of trains associated with each railway.", "Use COUNT(train.Train_ID) to count the number of trains for each railway.", "Order the results in descending order based on the count of trains to get the railway with the most trains at the top.", "Limit the results to 1 to get only the railway associated with the most trains."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "pred_sql": "SELECT railway.Railway_ID, railway.Builder\nFROM railway\nJOIN train ON railway.Railway_ID = train.Railway_ID\nGROUP BY railway.Railway_ID, railway.Builder\nORDER BY COUNT(train.Train_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["We need to find the most common builder of railways, which means we need to count how many railways each builder has constructed.", "To do this, we will select the 'Builder' column from the 'railway' table and use the COUNT function to count the occurrences of each builder.", "We will group the results by the 'Builder' to aggregate the counts for each builder.", "Next, we will order the results in descending order based on the count of railways built by each builder.", "Finally, we will limit the results to only the top entry to get the most common builder."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "pred_sql": "SELECT Builder, COUNT(*) as BuilderCount \nFROM railway \nGROUP BY Builder \nORDER BY BuilderCount DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["Identify the relevant table: The 'Student' table contains the last names and other details of students.", "Determine the criteria for selection: We need students who are either female, live in a city with the code 'BAL', or are male and under 20 years old.", "Construct the WHERE clause: The conditions can be combined using OR operators to filter the students based on the specified criteria.", "Select the last names: We only need the last names of the students that meet the criteria, so we will select the 'LName' column."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "pred_sql": "SELECT LName FROM Student WHERE (Sex = 'Female' OR city_code = 'BAL' OR (Sex = 'Male' AND Age < '20'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of last names of students from the 'Student' table based on specific criteria. It includes students of a certain gender residing in a specific city, as well as students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age criteria.\",\n    \"1\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\"\n}\n"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["Identify the relevant tables: Dorm and Has_amenity are needed to find the number of amenities for each dorm.", "We need to count the amenities, so we will use COUNT() function on the amenity identifier from Has_amenity table.", "We need to filter dorms based on their capacity, specifically those that can accommodate more than 100 students, which is done using a WHERE clause.", "We will join the Dorm table with the Has_amenity table on the dormid to link dorms with their amenities.", "Finally, we will group the results by dorm_name to get the count of amenities for each dorm."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "pred_sql": "SELECT d.dorm_name, COUNT(ha.amenid) AS amenity_count\nFROM Dorm d\nJOIN Has_amenity ha ON d.dormid = ha.dormid\nWHERE d.student_capacity > 100\nGROUP BY d.dorm_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n    \"1\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\"\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables involved: We need to count students living in male dorms, so we will use the 'Lives_in' and 'Dorm' tables.", "Determine the relationship: The 'Lives_in' table links students to dorms, and the 'Dorm' table contains gender information.", "Filter for male dorms: We will add a WHERE clause to filter dorms where the gender is 'male'.", "Count the distinct students: We will use COUNT(DISTINCT Lives_in.stuid) to get the total number of unique students living in male dorms."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(DISTINCT Lives_in.stuid) AS total_students\nFROM Lives_in\nJOIN Dorm ON Lives_in.dormid = Dorm.dormid\nWHERE Dorm.gender = 'male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\",\n    \"1\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n    \"2\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\"\n}\n"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["Identify the dormitory with the most amenities by counting the number of amenities associated with each dormitory using the Has_amenity table.", "Use a subquery to select the dormid of the dormitory that has the maximum count of amenities, ordering the results in descending order and limiting the output to the top result.", "Select the students who live in that dormitory by joining the Lives_in table with the identified dormid.", "Finally, retrieve the first names of those students from the Student table using their StuID."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT Fname \nFROM Student \nWHERE StuID IN (\n    SELECT stuid \n    FROM Lives_in \n    WHERE dormid = (\n        SELECT dormid \n        FROM Has_amenity \n        GROUP BY dormid \n        ORDER BY COUNT(amenid) DESC \n        LIMIT 1\n    )\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n    \"1\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\"\n}\n"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["Identify the required fields: first name and age of students.", "Determine the relationships between tables: Student, Lives_in, Dorm, Has_amenity, and Dorm_amenity.", "Join the Student table with Lives_in to get the dormitory information for each student.", "Join the Lives_in table with Dorm to access dormitory details.", "Join the Dorm table with Has_amenity to filter dorms based on amenities.", "Join Has_amenity with Dorm_amenity to specify the amenity we are interested in (TV Lounge).", "Use a WHERE clause to filter results to only those dorms that have a TV Lounge."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "pred_sql": "SELECT Student.Fname, Student.Age \nFROM Student \nJOIN Lives_in ON Student.StuID = Lives_in.stuid \nJOIN Dorm ON Lives_in.dormid = Dorm.dormid \nJOIN Has_amenity ON Dorm.dormid = Has_amenity.dormid \nJOIN Dorm_amenity ON Has_amenity.amenid = Dorm_amenity.amenid \nWHERE Dorm_amenity.amenity_name = 'TV Lounge';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\",\n    \"1\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n    \"2\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\"\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the goal: We need to find the emails of customers who filed complaints about the product with the greatest number of complaints.", "To achieve this, we will need to join the Customers table with the Complaints table on the customer_id.", "Next, we need to determine which product has the greatest number of complaints. This can be done by grouping the Complaints table by product_id and counting the number of complaints for each product.", "We will order the results of this grouping in descending order and limit the results to 1 to get the product with the highest count of complaints.", "Finally, we will use this product_id in our main query to filter the customers who complained about that product and select their email addresses."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address\nFROM Customers c\nJOIN Complaints comp ON c.customer_id = comp.customer_id\nWHERE comp.product_id = (\n    SELECT product_id\n    FROM Complaints\n    GROUP BY product_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\"\n}\n"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["Identify the customer who has filed the least amount of complaints by grouping the Complaints table by customer_id and counting the number of complaints for each customer.", "Order the results of the previous step in ascending order based on the count of complaints and limit the result to 1 to get the customer with the least complaints.", "Join the Products table with the Complaints table on the product_id to find the products associated with the complaints made by the identified customer.", "Select the product names from the Products table where the customer_id matches the one identified in the previous steps."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT p.product_name \nFROM Products p \nJOIN Complaints c ON p.product_id = c.product_id \nWHERE c.customer_id = (\n    SELECT customer_id \n    FROM Complaints \n    GROUP BY customer_id \n    ORDER BY COUNT(complaint_id) ASC \n    LIMIT 1\n)\nGROUP BY p.product_id;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\"\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the tables involved: Staff, Complaints, and Products.", "We need to find the last name of the staff member handling a complaint related to the product with the lowest price.", "To do this, we will join the Staff table with the Complaints table on staff_id, and then join the Complaints table with the Products table on product_id.", "Next, we need to find the product with the lowest price. This can be done using a subquery that selects the minimum product_price from the Products table.", "Finally, we will filter the results to only include the staff member associated with the complaint for that product and select their last name."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT Staff.last_name \nFROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nJOIN Products ON Complaints.product_id = Products.product_id \nWHERE Products.product_price = (\n    SELECT MIN(product_price) \n    FROM Products\n)", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\"\n}\n"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["Identify the relevant table: The Complaints table contains the complaint status information.", "Determine the required information: We need to find complaint statuses that have more than 3 records.", "Group the results: Use GROUP BY to group the records by complaint_status_code.", "Count the records: Use COUNT(*) to count the number of records for each complaint status.", "Filter the results: Use HAVING to filter the groups to only include those with a count greater than 3."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "pred_sql": "SELECT complaint_status_code, COUNT(*) as complaint_count \nFROM Complaints \nGROUP BY complaint_status_code \nHAVING COUNT(*) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\"\n}\n"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["Identify the most common customer type by grouping the Customers table by customer_type_code and counting occurrences.", "Use a subquery to find the customer_type_code that has the highest count.", "Count the total number of customers that have this most common customer_type_code."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) AS customer_count\nFROM Customers\nWHERE customer_type_code = (\n    SELECT customer_type_code\n    FROM Customers\n    GROUP BY customer_type_code\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique town or city names from the 'Customers' table, filtered by a specific customer type code. The results are grouped by town or city and ordered by the count of occurrences, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the customer type code and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to find the first names of staff members, so we will select the 'first_name' column from the Staff table.", "To determine how many complaints each staff member has handled, we will join the Staff table with the Complaints table on the 'staff_id' column.", "We will group the results by 'staff_id' to aggregate the number of complaints handled by each staff member.", "We will use the COUNT function to count the number of complaints for each staff member.", "To get the top 5 staff members who handled the greatest number of complaints, we will order the results in descending order based on the count of complaints and limit the results to 5."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name \nFROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nGROUP BY Staff.staff_id \nORDER BY COUNT(Complaints.complaint_id) DESC \nLIMIT 5;", "hint": "\n"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to join these tables on the staff_id to link staff members with the complaints they have handled.", "We want to count the number of complaints each staff member has handled, so we will use COUNT(Complaints.complaint_id).", "We will group the results by Staff.staff_id to get the count for each staff member.", "To find the staff members who have handled the most complaints, we will order the results in descending order based on the count of complaints.", "Finally, we will limit the results to the top 5 staff members."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name FROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nGROUP BY Staff.staff_id \nORDER BY COUNT(Complaints.complaint_id) DESC \nLIMIT 5;", "hint": "\n"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The user wants to see all investor details, which means we need to select all columns from the Investors table.", "The SQL command to retrieve all columns from a table is 'SELECT *'.", "We specify the table we are selecting from, which in this case is 'Investors'."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "pred_sql": "SELECT * FROM Investors;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["We need to show details of all investors who have made transactions with a share count greater than 100.", "To do this, we will select the investor_id and Investor_details from the Investors table.", "We will join the Investors table with the Transactions table on the investor_id to link investors with their transactions.", "We will apply a filter in the WHERE clause to only include transactions where the share_count is greater than 100."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "pred_sql": "SELECT Investors.investor_id, Investors.Investor_details \nFROM Investors \nJOIN Transactions ON Investors.investor_id = Transactions.investor_id \nWHERE Transactions.share_count > 100;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["Identify the relevant tables: Lots and Transactions.", "Determine the relationship between Lots and Transactions through the Transactions_Lots table.", "We need to select the lot details from the Lots table.", "Join the Lots table with the Transactions_Lots table on lot_id.", "Join the Transactions_Lots table with the Transactions table on transaction_id.", "Apply the filter for share count smaller than 50 in the WHERE clause."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT Lots.lot_details \nFROM Lots \nJOIN Transactions_Lots ON Lots.lot_id = Transactions_Lots.lot_id \nJOIN Transactions ON Transactions_Lots.transaction_id = Transactions.transaction_id \nWHERE Transactions.share_count < 50;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["We need to calculate the average transaction amount for different transaction types.", "To do this, we will select the transaction type description from the Ref_Transaction_Types table and the average of the transaction amounts from the Transactions table.", "We will join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to get the descriptions of the transaction types.", "We will use the AVG() function to calculate the average amount of transactions.", "Finally, we will group the results by the transaction type description to get the average for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["We need to show the maximum and minimum share count of different transaction types.", "To achieve this, we will select the transaction type description from the Ref_Transaction_Types table.", "We will also select the maximum and minimum share count from the Transactions table.", "To link these two tables, we will use a JOIN on the transaction_type_code.", "We will group the results by the transaction type description to get the max and min share counts for each type."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, MAX(t.share_count) AS max_share_count, MIN(t.share_count) AS min_share_count\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["Identify the tables involved: Sales and Purchases.", "Determine the columns needed: sales_transaction_id and sales_details from Sales, purchase_transaction_id and purchase_details from Purchases.", "Since we want details of all sales and purchases, we will use a FULL OUTER JOIN to include all records from both tables, even if there are no matches in the other table.", "Construct the SQL query to select the required columns from both tables using the FULL OUTER JOIN."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "pred_sql": "SELECT Sales.sales_transaction_id, Sales.sales_details, Purchases.purchase_transaction_id, Purchases.purchase_details\nFROM Sales\nFULL OUTER JOIN Purchases ON Sales.sales_transaction_id = Purchases.purchase_transaction_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\"\n}\n"}
