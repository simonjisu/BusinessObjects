{"sample_id": "train.5898", "db_id": "cre_Theme_park", "question": "What is the average price range of five star hotels that allow pets?", "rationale": ["Identify the relevant table: The Hotels table contains information about hotel star ratings, pet policies, and price ranges.", "Determine the conditions: We need to filter for five-star hotels (star_rating_code = '5') and those that allow pets (pets_allowed_yn = 'Yes').", "Calculate the average price range: Use the AVG() function to compute the average of the price_range column for the filtered hotels."], "gold_sql": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  '5' AND pets_allowed_yn  =  1", "source_tables": ["hotels"], "pred_sql": "SELECT AVG(price_range) AS average_price_range \nFROM Hotels \nWHERE star_rating_code = '5' AND pets_allowed_yn = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\"\n}\n"}
{"sample_id": "train.5904", "db_id": "cre_Theme_park", "question": "Find all the locations whose names contain the word \"film\".", "rationale": ["Identify the table that contains location names: Locations.", "Determine the column that holds the names of the locations: Location_Name.", "Use the SQL SELECT statement to retrieve all columns from the Locations table.", "Apply a WHERE clause to filter the results where Location_Name contains the word 'film'.", "Use the LIKE operator with wildcards '%' to match any location names that include 'film' anywhere in the name."], "gold_sql": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE '%film%'", "source_tables": ["locations"], "pred_sql": "SELECT * FROM Locations WHERE Location_Name LIKE '%film%';", "hint": "\n"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["Identify the relevant tables: Museums and Tourist_Attractions.", "Determine the columns needed: Museum_ID and Museum_Details from Museums, and Opening_Hours from Tourist_Attractions.", "Establish the relationship between the tables: Museums are linked to Tourist_Attractions through the Tourist_Attraction_ID.", "Construct the SQL query to select the required details from the joined tables."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT Museums.Museum_ID, Museums.Museum_Details, Tourist_Attractions.Opening_Hours \nFROM Museums \nJOIN Tourist_Attractions ON Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5916", "db_id": "cre_Theme_park", "question": "Give me the detail and opening hour for each museum.", "rationale": ["The user wants details and opening hours for each museum.", "The relevant table for museum details is 'Museums', which contains 'Museum_Details'.", "The 'Tourist_Attractions' table contains the 'Opening_Hours' for each attraction, including museums.", "To get the opening hours for each museum, we need to join the 'Museums' table with the 'Tourist_Attractions' table on the common identifier, which is 'Museum_ID' in 'Museums' and 'Tourist_Attraction_ID' in 'Tourist_Attractions'.", "The final SQL query selects the museum details and their corresponding opening hours."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT Museums.Museum_Details, Tourist_Attractions.Opening_Hours \nFROM Museums \nJOIN Tourist_Attractions ON Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Royal_Family.", "Determine the relationship between the tables: Royal_Family entries are linked to Tourist_Attractions through the Tourist_Attraction_ID.", "Select the desired columns: Name, Description, and How_to_Get_There from the Tourist_Attractions table.", "Construct the SQL query using a JOIN to combine the Tourist_Attractions and Royal_Family tables based on the relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name, Tourist_Attractions.Description, Tourist_Attractions.How_to_Get_There \nFROM Tourist_Attractions \nJOIN Royal_Family ON Tourist_Attractions.Tourist_Attraction_ID = Royal_Family.Royal_Family_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5923", "db_id": "cre_Theme_park", "question": "What are the details of the shops that can be accessed by walk?", "rationale": ["Identify the relevant table for shops, which is the 'Shops' table.", "Determine the relationship between shops and tourist attractions, which is through the 'Tourist_Attraction_ID'.", "Use a JOIN to connect the 'Shops' table with the 'Tourist_Attractions' table based on the 'Shop_ID' and 'Tourist_Attraction_ID'.", "Filter the results to include only those attractions that can be accessed by walking, which is indicated in the 'How_to_Get_There' column of the 'Tourist_Attractions' table.", "Select the necessary columns from the 'Shops' table to get the details of the shops."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "pred_sql": "SELECT Shops.Shop_ID, Shops.Shop_Details \nFROM Shops \nJOIN Tourist_Attractions ON Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Tourist_Attractions.How_to_Get_There LIKE '%walk%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5931", "db_id": "cre_Theme_park", "question": "Which tourist attractions does the visitor with detail 'Vincent' visit?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Visits, and Visitors are needed to find the attractions visited by a specific tourist.", "Join the Visits table with the Tourist_Attractions table on the Tourist_Attraction_ID to link visits to attractions.", "Join the Visits table with the Visitors table on the Tourist_ID to filter visits by the specific tourist's details.", "Use a WHERE clause to filter the results to only include visits by the tourist with the detail 'Vincent'.", "Select the Name of the tourist attractions from the Tourist_Attractions table."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name \nFROM Tourist_Attractions \nJOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID \nJOIN Visitors ON Visits.Tourist_ID = Visitors.Tourist_ID \nWHERE Visitors.Tourist_Details = 'Vincent';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5932", "db_id": "cre_Theme_park", "question": "Show the tourist attractions visited by the tourist whose detail is 'Vincent'.", "rationale": ["Identify the tables involved: Tourist_Attractions, Visits, and Visitors.", "We need to find the names of tourist attractions visited by a specific tourist, so we will join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID.", "Next, we join the Visitors table to filter by the tourist's details, specifically looking for 'Vincent'.", "The final SQL query selects the Name of the tourist attractions from the joined tables where the tourist's details match 'Vincent'."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name \nFROM Tourist_Attractions \nJOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID \nJOIN Visitors ON Visits.Tourist_ID = Visitors.Tourist_ID \nWHERE Visitors.Tourist_Details = 'Vincent';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5941", "db_id": "cre_Theme_park", "question": "Show the details of the top 3 most expensive hotels.", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "To find the most expensive hotels, we need to order the results by the 'price_range' column in descending order.", "We want to limit the results to the top 3 hotels, so we will use the LIMIT clause with a value of 3."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "Determine the relevant column for hotel pricing, which is 'price_range'.", "To find the most expensive hotels, sort the results in descending order based on the 'price_range' column.", "Limit the results to the top three entries to get the three most expensive hotels."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\"\n}\n"}
{"sample_id": "train.5944", "db_id": "cre_Theme_park", "question": "What are the details and star ratings of the three hotels with the lowest price ranges?", "rationale": ["Identify the relevant tables: Hotels and Ref_Hotel_Star_Ratings.", "We need to retrieve hotel details and their star ratings, so we will select columns from both tables: hotel_id and other_hotel_details from Hotels, and star_rating_description from Ref_Hotel_Star_Ratings.", "Join the Hotels table with Ref_Hotel_Star_Ratings on the star_rating_code to get the star rating descriptions for each hotel.", "To find the hotels with the lowest price ranges, we will order the results by the price_range column in ascending order.", "Limit the results to the top 3 hotels to get only the three hotels with the lowest price ranges."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT h.hotel_id, h.other_hotel_details, r.star_rating_description \nFROM Hotels h \nJOIN Ref_Hotel_Star_Ratings r ON h.star_rating_code = r.star_rating_code \nORDER BY h.price_range ASC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\"\n}\n"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Visits are needed to find out how tourists get to attractions and how many times they visited.", "Join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID to link visits to their respective attractions.", "Select the How_to_Get_There column to find out the transportation methods used by tourists.", "Count the number of visits for each transportation method using COUNT(*) and group the results by How_to_Get_There.", "Order the results by the count of visits in descending order to find the most popular transportation method.", "Limit the results to 1 to get only the top transportation method."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Visit_Count\nFROM Tourist_Attractions\nJOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID\nGROUP BY How_to_Get_There\nORDER BY Visit_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders in the SELECT statement represent the name of the attraction and its corresponding visit count.\"\n}\n"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions and Visits are needed to determine how tourists get to attractions and how often they visit them.", "Join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID to link visits to their respective attractions.", "Select the How_to_Get_There column from the Tourist_Attractions table to find out the transportation methods used.", "Count the number of visits for each transportation method using COUNT(*) and group the results by How_to_Get_There.", "Order the results in descending order based on the count of visits to find the most frequently used transportation method.", "Limit the results to 1 to get only the top transportation method."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Visit_Count\nFROM Tourist_Attractions\nJOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID\nGROUP BY How_to_Get_There\nORDER BY Visit_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5955", "db_id": "cre_Theme_park", "question": "Show the names and ids of tourist attractions that are visited at most once.", "rationale": ["We need to find tourist attractions that have been visited at most once.", "To do this, we will join the 'Tourist_Attractions' table with the 'Visits' table on the 'Tourist_Attraction_ID'.", "We will group the results by 'Tourist_Attraction_ID' to count the number of visits for each attraction.", "Using the HAVING clause, we will filter the results to include only those attractions that have a count of visits less than or equal to 1.", "Finally, we will select the 'Name' and 'Tourist_Attraction_ID' of these attractions."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT ta.Name, ta.Tourist_Attraction_ID\nFROM Tourist_Attractions ta\nLEFT JOIN Visits v ON ta.Tourist_Attraction_ID = v.Tourist_Attraction_ID\nGROUP BY ta.Tourist_Attraction_ID\nHAVING COUNT(v.Visit_ID) <= 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5956", "db_id": "cre_Theme_park", "question": "What are the names and ids of the tourist attractions that are visited at most once?", "rationale": ["We need to find tourist attractions that have been visited at most once.", "To do this, we will first create a subquery that counts the number of visits for each tourist attraction by grouping the results based on the 'Tourist_Attraction_ID'.", "In the subquery, we will use the HAVING clause to filter out attractions that have been visited more than once (i.e., COUNT(Tourist_ID) > 1).", "The main query will select the 'Tourist_Attraction_ID' and 'Name' from the 'Tourist_Attractions' table where the 'Tourist_Attraction_ID' is not in the list of attractions returned by the subquery."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attraction_ID, Name \nFROM Tourist_Attractions \nWHERE Tourist_Attraction_ID NOT IN (\n    SELECT Tourist_Attraction_ID \n    FROM Visits \n    GROUP BY Tourist_Attraction_ID \n    HAVING COUNT(Tourist_ID) > 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["Identify the relevant tables: Tourist_Attractions for attraction names, Tourist_Attraction_Features for linking attractions to their features, and Features for feature details.", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table on the Tourist_Attraction_ID to get the features associated with each attraction.", "Join the resulting table with the Features table on Feature_ID to access the feature details.", "Filter the results to include only those attractions that have features with details 'parking' or 'shopping'.", "Select the Name of the tourist attractions that meet the criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT ta.Name \nFROM Tourist_Attractions ta \nJOIN Tourist_Attraction_Features taf ON ta.Tourist_Attraction_ID = taf.Tourist_Attraction_ID \nJOIN Features f ON taf.Feature_ID = f.Feature_ID \nWHERE f.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions for attraction names, Tourist_Attraction_Features for linking attractions to their features, and Features for feature details.", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table on the Tourist_Attraction_ID to get the features associated with each attraction.", "Join the resulting table with the Features table on Feature_ID to access the feature details.", "Filter the results to include only those attractions that have features with details 'parking' or 'shopping'.", "Select the names of the tourist attractions that meet the criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT ta.Name\nFROM Tourist_Attractions ta\nJOIN Tourist_Attraction_Features taf ON ta.Tourist_Attraction_ID = taf.Tourist_Attraction_ID\nJOIN Features f ON taf.Feature_ID = f.Feature_ID\nWHERE f.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"1\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5963", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions Vincent and Marcelle visit?", "rationale": ["Identify the tables involved: 'Tourist_Attractions' for attraction names and 'Visits' for linking tourists to attractions.", "Join the 'Tourist_Attractions' table with the 'Visits' table to get the attractions visited by tourists.", "Use two joins on the 'Visits' table to link both Vincent and Marcelle to the attractions they visited.", "Filter the results to only include attractions visited by both tourists by ensuring both are linked to the same attraction in the 'Visits' table.", "Select the names of the tourist attractions from the resulting joined table."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT ta.Name \nFROM Tourist_Attractions ta \nJOIN Visits v1 ON ta.Tourist_Attraction_ID = v1.Tourist_Attraction_ID \nJOIN Visitors vincent ON v1.Tourist_ID = vincent.Tourist_ID \nJOIN Visits v2 ON ta.Tourist_Attraction_ID = v2.Tourist_Attraction_ID \nJOIN Visitors marcelle ON v2.Tourist_ID = marcelle.Tourist_ID \nWHERE vincent.Tourist_Details = 'Vincent' \nAND marcelle.Tourist_Details = 'Marcelle';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n    \"1\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5985", "db_id": "game_1", "question": "Which game type has most number of games?", "rationale": ["Identify the relevant table: The question asks about game types and the number of games, which relates to the 'Video_Games' table.", "Select the columns needed: We need to select the 'GType' (game type) and count the number of games (GameID) for each type.", "Group the results: To get the count of games per type, we will use GROUP BY on 'GType'.", "Order the results: To find the game type with the most games, we will order the results in descending order based on the count of games.", "Limit the results: Since we only want the game type with the most games, we will limit the results to 1."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType, COUNT(GameID) AS NumberOfGames\nFROM Video_Games\nGROUP BY GType\nORDER BY NumberOfGames DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\",\n    \"1\": \"This virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by the first and last names of the students from the 'Student' table. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.5988", "db_id": "game_1", "question": "What is the type with the fewest games?", "rationale": ["Identify the relevant table: The question asks about the type with the fewest games, which relates to the Video_Games table.", "Select the GType column: We need to group the games by their type, so we will select the GType column.", "Count the number of games: We will use COUNT(GameID) to count how many games exist for each type.", "Group by GType: We will group the results by the GType to aggregate the counts for each type of game.", "Order the results: To find the type with the fewest games, we will order the results in ascending order based on the count of games.", "Limit the results: We will limit the output to 1 to get only the type with the fewest games."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType, COUNT(GameID) AS TotalGames\nFROM Video_Games\nGROUP BY GType\nORDER BY TotalGames ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\",\n    \"1\": \"This virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by the first and last names of the students from the 'Student' table. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.6001", "db_id": "game_1", "question": "How many students play sports?", "rationale": ["The question asks for the number of students who play sports, which implies we need to count unique student identifiers (StuID) from the SportsInfo table.", "We will use the COUNT function to count the distinct StuID values, ensuring that each student is only counted once, even if they participate in multiple sports.", "The query will select from the SportsInfo table, which contains the relevant information about students participating in sports."], "gold_sql": "SELECT count(DISTINCT StuID) FROM Sportsinfo", "source_tables": ["sportsinfo"], "pred_sql": "SELECT COUNT(DISTINCT StuID) AS NumberOfStudents\nFROM SportsInfo;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by the first and last names of the students from the 'Student' table. The placeholders in the WHERE clause represent the student's first and last names.\",\n    \"2\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\"\n}\n"}
{"sample_id": "train.6003", "db_id": "game_1", "question": "List ids for all student who are on scholarship.", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Determine the condition: We need to filter students who are on a sports scholarship, which is indicated by the 'OnScholarship' column.", "Construct the SQL query: We will select the 'StuID' from the SportsInfo table where 'OnScholarship' is 'Yes'."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n    \"1\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6004", "db_id": "game_1", "question": "What are the ids for all sporty students who are on scholarship?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports.", "Determine the condition: We need to find students who are on a sports scholarship, which is indicated by the 'OnScholarship' column.", "Select the unique identifier: We want the 'StuID' of these students.", "Construct the SQL query: Use a SELECT statement to retrieve 'StuID' from the SportsInfo table where 'OnScholarship' is 'Yes'."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n    \"1\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table provides the first and last names of students who participate in sports, along with the count of their participation. The query joins the 'SportsInfo' table with the 'Student' table based on the unique student identifier. The results are grouped by student ID and ordered by the number of sports they participate in, with a limit on the number of results returned, specified by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.6006", "db_id": "game_1", "question": "What are the last names for all scholarship students?", "rationale": ["Identify the relevant tables: We need to look at the Student table for last names and the SportsInfo table to check for scholarship status.", "Join the Student table with the SportsInfo table on the StuID column to combine student information with their sports participation details.", "Filter the results to include only those students who are on a sports scholarship by checking the OnScholarship column in the SportsInfo table.", "Select the LName column from the resulting joined table to get the last names of the scholarship students."], "gold_sql": "SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT LName FROM Student INNER JOIN SportsInfo ON Student.StuID = SportsInfo.StuID WHERE SportsInfo.OnScholarship = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n    \"1\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6010", "db_id": "game_1", "question": "What is the total number of all football games played by scholarship students?", "rationale": ["Identify the relevant table: SportsInfo contains information about sports participation.", "We need to filter for football games, so we will use the condition SportName = 'Football'.", "We also need to consider only those students who are on a scholarship, so we will add the condition OnScholarship = 'Yes'.", "To get the total number of football games played by these students, we will use the SUM function on the GamesPlayed column."], "gold_sql": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  'Football' AND onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SUM(GamesPlayed) AS TotalGamesPlayed\nFROM SportsInfo\nWHERE SportName = 'Football' AND OnScholarship = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\",\n    \"1\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n    \"2\": \"This virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by the first and last names of the students from the 'Student' table. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.6014", "db_id": "game_1", "question": "What are the ids of all students along with how many sports and games did they play?", "rationale": ["We need to retrieve the IDs of all students along with the count of sports and games they play.", "To achieve this, we will select the 'StuID' from the 'Student' table.", "We will count the distinct 'SportName' from the 'SportsInfo' table to get the number of sports each student is involved in.", "We will also count the distinct 'GameID' from the 'Plays_Games' table to get the number of games each student has played.", "We will use LEFT JOIN to include all students even if they have not participated in any sports or games.", "Finally, we will group the results by 'StuID' to aggregate the counts for each student."], "gold_sql": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID", "source_tables": ["sportsinfo"], "pred_sql": "SELECT Student.StuID, COUNT(DISTINCT SportsInfo.SportName) AS SportsCount, COUNT(DISTINCT Plays_Games.GameID) AS GamesCount\nFROM Student\nLEFT JOIN SportsInfo ON Student.StuID = SportsInfo.StuID\nLEFT JOIN Plays_Games ON Student.StuID = Plays_Games.StuID\nGROUP BY Student.StuID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\",\n    \"2\": \"This virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by the first and last names of the students from the 'Student' table. The placeholders in the WHERE clause represent the student's first and last names.\"\n}\n"}
{"sample_id": "train.6019", "db_id": "game_1", "question": "Which sport has most number of students on scholarship?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Filter the records to include only those students who are on a sports scholarship by using the condition 'OnScholarship = 'Yes'.", "Group the results by SportName to count the number of students in each sport.", "Use COUNT(StuID) to count the number of students for each sport.", "Order the results in descending order based on the count of students to find the sport with the most students on scholarship.", "Limit the results to 1 to get only the sport with the highest count."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName, COUNT(StuID) AS NumberOfStudents\nFROM SportsInfo\nWHERE OnScholarship = 'Yes'\nGROUP BY SportName\nORDER BY NumberOfStudents DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n    \"1\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\"\n}\n"}
{"sample_id": "train.6020", "db_id": "game_1", "question": "What is the sport with the most scholarship students?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Filter the records to include only those students who are on a sports scholarship by using the condition 'OnScholarship = 'Yes' in the WHERE clause.", "Group the results by SportName to count how many scholarship students are in each sport using COUNT(*) and GROUP BY.", "Order the results in descending order based on the count of scholarship students to find the sport with the most scholarship students using ORDER BY ScholarshipCount DESC.", "Limit the results to only the top entry using LIMIT 1 to get the sport with the most scholarship students."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName, COUNT(*) AS ScholarshipCount\nFROM SportsInfo\nWHERE OnScholarship = 'Yes'\nGROUP BY SportName\nORDER BY ScholarshipCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n    \"1\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table provides the first and last names of students who participate in sports, along with the count of their participation. The query joins the 'SportsInfo' table with the 'Student' table based on the unique student identifier. The results are grouped by student ID and ordered by the number of sports they participate in, with a limit on the number of results returned, specified by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.6024", "db_id": "game_1", "question": "What are the student ids for those on scholarship in major number 600?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Filter for students on scholarship: We need to check the 'OnScholarship' column for 'Yes'.", "Join with the Student table to filter by major: We need to ensure that the students are majoring in '600'.", "Use a subquery to get the student IDs from the Student table where the Major is '600'.", "Combine the conditions to get the final list of student IDs who are on scholarship and have the specified major."], "gold_sql": "SELECT StuID FROM Student WHERE major  =  600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes' AND StuID IN (SELECT StuID FROM Student WHERE Major = '600');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n    \"1\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6025", "db_id": "game_1", "question": "Show student ids who are female and play football.", "rationale": ["Identify the relevant tables: 'Student' for student information and 'SportsInfo' for sports participation.", "We need to filter students based on gender, specifically females, which is done using the 'Sex' column in the 'Student' table.", "We also need to check for students who play football, which is indicated by the 'SportName' column in the 'SportsInfo' table.", "To get the student IDs, we will select 'StuID' from the 'Student' table.", "We will use a JOIN operation to combine 'Student' and 'SportsInfo' on the 'StuID' column, ensuring we only get students who are in the 'SportsInfo' table.", "Finally, we will apply the WHERE clause to filter for female students and those who play football."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN SportsInfo ON Student.StuID = SportsInfo.StuID \nWHERE Student.Sex = 'Female' AND SportsInfo.SportName = 'Football';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students from the 'Student' table who are of a specific gender and are not participating in a specified sport. The placeholders in the WHERE clause represent the gender and the sport's name.\",\n    \"1\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\"\n}\n"}
{"sample_id": "train.6026", "db_id": "game_1", "question": "What are the ids of all female students who play football?", "rationale": ["Identify the relevant tables: We need to get information from the 'Student' table for female students and the 'SportsInfo' table to check for participation in football.", "Join the 'Student' table with the 'SportsInfo' table on the StuID to link students with their sports participation.", "Filter the results to include only female students by adding a WHERE clause for Student.Sex = 'Female'.", "Further filter the results to include only those who play football by adding another condition in the WHERE clause for SportsInfo.SportName = 'Football'.", "Select the StuID of the students who meet these criteria."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN SportsInfo ON Student.StuID = SportsInfo.StuID \nWHERE Student.Sex = 'Female' AND SportsInfo.SportName = 'Football';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table identifies students from the 'Student' table who are of a specific gender and are not participating in a specified sport. The placeholders in the WHERE clause represent the gender and the sport's name.\",\n    \"2\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\"\n}\n"}
{"sample_id": "train.6028", "db_id": "game_1", "question": "What are the ids of all male students who do not play football?", "rationale": ["Identify the table to query: We need to get data from the 'Student' table.", "Filter for male students: We will add a condition to select only those students where the 'Sex' column is 'Male'.", "Exclude students who play football: We will use a subquery to find students in the 'SportsInfo' table who play 'Football' and exclude them from our main query.", "Combine the conditions: We will use the NOT IN clause to ensure that the selected male students do not appear in the list of students who play football."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male' AND StuID NOT IN (SELECT StuID FROM SportsInfo WHERE SportName = 'Football');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students from the 'Student' table who are of a specific gender and are not participating in a specified sport. The placeholders in the WHERE clause represent the gender and the sport's name.\",\n    \"1\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\"\n}\n"}
{"sample_id": "train.6060", "db_id": "customers_and_addresses", "question": "Find the average order quantity per order.", "rationale": ["Identify the relevant table: The 'Order_Items' table contains the 'order_quantity' that we need to average.", "Use the AVG() function to calculate the average of 'order_quantity'.", "Group the results by 'order_id' to get the average order quantity for each order."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "pred_sql": "SELECT AVG(order_quantity) AS average_order_quantity\nFROM Order_Items\nGROUP BY order_id;", "hint": "\n"}
{"sample_id": "train.6071", "db_id": "customers_and_addresses", "question": "What are the details of all products?", "rationale": ["The user wants to retrieve details of all products.", "To get all details from a table, we use the SELECT statement with a wildcard (*) to select all columns.", "The table we need to query is 'Products'.", "Thus, the SQL query will be 'SELECT * FROM Products;'"], "gold_sql": "SELECT DISTINCT product_details FROM products", "source_tables": ["products"], "pred_sql": "SELECT * FROM Products;", "hint": "\n"}
{"sample_id": "train.6075", "db_id": "customers_and_addresses", "question": "Find the detail of products whose detail contains the word \"Latte\" or the word \"Americano\"", "rationale": ["Identify the table to query: The question asks for product details, so we will query the Products table.", "Determine the condition: We need to find products whose details contain either 'Latte' or 'Americano'.", "Use the SQL LIKE operator: To search for a substring within a text field, we use the LIKE operator with wildcards (%) to match any characters before or after the search term.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter the results based on the specified conditions."], "gold_sql": "SELECT product_details FROM products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'", "source_tables": ["products"], "pred_sql": "SELECT * FROM Products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%';", "hint": "\n"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: We need to find the city with the most customers, so we will use the Customer_Addresses and Addresses tables.", "Join the tables: We will join Customer_Addresses with Addresses on the address_id to get the city information for each customer.", "Count distinct customers: We will count the distinct customer_id for each city to determine how many customers live in each city.", "Group by city: We will group the results by city to aggregate the customer counts.", "Order the results: We will order the results in descending order based on the customer count to find the city with the most customers.", "Limit the results: We will limit the results to 1 to get only the city with the highest customer count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(DISTINCT customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6086", "db_id": "customers_and_addresses", "question": "Find the city where the most customers live.", "rationale": ["To find the city where the most customers live, we need to count the number of customers associated with each city.", "The relevant tables are Customer_Addresses (which links customers to addresses) and Addresses (which contains city information).", "We will join the Customer_Addresses table with the Addresses table on the address_id to get the city for each customer.", "Next, we will group the results by city and count the number of customer_ids for each city to get the total number of customers per city.", "Finally, we will order the results in descending order based on the customer count and limit the results to 1 to get the city with the most customers."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6097", "db_id": "customers_and_addresses", "question": "Which contact channel has been used by the customer with name \"Tillman Ernser\"?", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "Join the Customers table with the Customer_Contact_Channels table using the customer_id as the linking key.", "Filter the results to find the specific customer by name, 'Tillman Ernser'.", "Select the desired fields: customer name, channel code, and contact number."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT c.customer_name, cc.channel_code, cc.contact_number \nFROM Customers c \nJOIN Customer_Contact_Channels cc ON c.customer_id = cc.customer_id \nWHERE c.customer_name = 'Tillman Ernser';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n    \"1\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n    \"2\": \"This virtual table provides the channel codes and contact numbers of customer contact channels that have the longest active duration. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\"\n}\n"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the relevant tables: We need to retrieve the 'active_to_date' from the 'Customer_Contact_Channels' table and link it to the 'Customers' table to filter by customer name.", "Join the 'Customer_Contact_Channels' table with the 'Customers' table on 'customer_id' to access the customer name and their contact channel details.", "Filter the results to only include the customer named 'Tillman Ernser'.", "Order the results by 'active_from_date' in descending order to get the latest contact channel used.", "Limit the results to 1 to get only the latest 'active_to_date' for the specified customer."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT active_to_date \nFROM Customer_Contact_Channels ccc \nJOIN Customers c ON ccc.customer_id = c.customer_id \nWHERE c.customer_name = 'Tillman Ernser' \nORDER BY ccc.active_from_date DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the channel codes and contact numbers of customer contact channels that have the longest active duration. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\",\n    \"1\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n    \"2\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\"\n}\n"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["To find the average time span of contact channels, we need to calculate the duration for each contact channel.", "The duration can be calculated by subtracting the 'active_from_date' from the 'active_to_date'.", "We will use the 'julianday' function to convert the date strings into Julian day numbers for accurate date arithmetic.", "We will select the average of these durations using the AVG function.", "We need to ensure that we only consider contact channels that have an 'active_to_date' (i.e., they have been deactivated) to get valid time spans."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_time_span\nFROM Customer_Contact_Channels\nWHERE active_to_date IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the channel codes and contact numbers of customer contact channels that have the longest active duration. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\",\n    \"1\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n    \"2\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\"\n}\n"}
{"sample_id": "train.6103", "db_id": "customers_and_addresses", "question": "What is the channel code and contact number of the customer contact channel that was active for the longest time?", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the channel codes and contact numbers.", "Determine the columns needed: We need channel_code and contact_number.", "Calculate the duration of activity: Use the difference between active_to_date and active_from_date to determine how long each contact channel was active.", "Sort the results: Order the results by the calculated duration in descending order to get the longest active channel first.", "Limit the results: Use LIMIT 1 to get only the channel that was active for the longest time."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT channel_code, contact_number FROM Customer_Contact_Channels ORDER BY (julianday(active_to_date) - julianday(active_from_date)) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the channel codes and contact numbers of customer contact channels that have the longest active duration. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\",\n    \"1\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n    \"2\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\"\n}\n"}
{"sample_id": "train.6108", "db_id": "customers_and_addresses", "question": "Find the name of the customer who made the order of the largest amount of goods.", "rationale": ["Identify the relevant tables: Customers, Customer_Orders, and Order_Items are needed to find the customer who made the largest order.", "Join the Customers table with Customer_Orders on customer_id to link customers to their orders.", "Join the resulting table with Order_Items on order_id to access the quantities of items ordered.", "Group the results by customer_id to aggregate the total quantity of items ordered by each customer.", "Use SUM(oi.order_quantity) to calculate the total amount of goods ordered by each customer.", "Order the results in descending order based on the total quantity ordered to find the customer with the largest order.", "Limit the results to 1 to get only the top customer."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)", "source_tables": ["customer_orders", "customers", "order_items"], "pred_sql": "SELECT c.customer_name\nFROM Customers c\nJOIN Customer_Orders co ON c.customer_id = co.customer_id\nJOIN Order_Items oi ON co.order_id = oi.order_id\nGROUP BY c.customer_id\nORDER BY SUM(oi.order_quantity) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6123", "db_id": "customers_and_addresses", "question": "What is the total number of products that are in orders with status \"Cancelled\"?", "rationale": ["Identify the tables involved: We need to look at the 'Customer_Orders' table for order status and the 'Order_Items' table for product details.", "We need to count the distinct products that are associated with orders that have a status of 'Cancelled'.", "Join the 'Customer_Orders' table with the 'Order_Items' table on the 'order_id' to link orders with their respective products.", "Filter the results to include only those orders where the 'order_status' is 'Cancelled'.", "Use the COUNT function to get the total number of distinct products from the filtered results."], "gold_sql": "SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_status  =  'Cancelled'", "source_tables": ["customer_orders", "order_items"], "pred_sql": "SELECT COUNT(DISTINCT oi.product_id) AS total_cancelled_products\nFROM Customer_Orders co\nJOIN Order_Items oi ON co.order_id = oi.order_id\nWHERE co.order_status = 'Cancelled';", "hint": "\n"}
{"sample_id": "train.6130", "db_id": "customers_and_addresses", "question": "What is the most frequently ordered product? Tell me the detail of the product", "rationale": ["Identify the relevant tables: We need to find the most frequently ordered product, which involves the Order_Items and Products tables.", "Count the occurrences of each product in the Order_Items table: We will use COUNT() to tally how many times each product has been ordered.", "Join the Order_Items table with the Products table: This will allow us to retrieve product details along with the order counts.", "Group the results by product_id: This is necessary to aggregate the counts for each product.", "Order the results by the count in descending order: This will help us find the product with the highest order count.", "Limit the results to 1: Since we only want the most frequently ordered product."], "gold_sql": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Products.product_id, Products.product_details, COUNT(Order_Items.product_id) AS order_count\nFROM Order_Items\nJOIN Products ON Order_Items.product_id = Products.product_id\nGROUP BY Order_Items.product_id\nORDER BY order_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["Identify the relevant tables: Products and Order_Items.", "We need to find the product with the largest total order quantity, so we will join the Products table with the Order_Items table on the product_id.", "We will group the results by product_id and product_details to aggregate the order quantities for each product.", "Use the SUM function to calculate the total order quantity for each product.", "Order the results in descending order based on the total order quantity.", "Limit the results to 1 to get the product with the largest total order quantity."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT P.product_id, P.product_details\nFROM Products P\nJOIN Order_Items OI ON P.product_id = OI.product_id\nGROUP BY P.product_id, P.product_details\nORDER BY SUM(OI.order_quantity) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6132", "db_id": "customers_and_addresses", "question": "What are the name and ID of the product bought the most.", "rationale": ["Identify the relevant tables: We need to look at the Order_Items table to find out which products were bought and the Products table to get the product details.", "Count the number of times each product was ordered: This can be done using the COUNT() function on the product_id from the Order_Items table.", "Join the Order_Items table with the Products table to get the product details along with the product ID.", "Group the results by product_id to aggregate the counts for each product.", "Order the results by the count of purchases in descending order to find the most bought product.", "Limit the results to 1 to get only the top product."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT oi.product_id, p.product_details, COUNT(oi.product_id) AS purchase_count\nFROM Order_Items oi\nJOIN Products p ON oi.product_id = p.product_id\nGROUP BY oi.product_id\nORDER BY purchase_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The 'Addresses' table contains the address information we need.", "Determine the filtering criteria: We need to filter addresses based on two specific cities and their corresponding states.", "Construct the WHERE clause: We will use an OR condition to combine the two sets of criteria for the cities and states.", "Formulate the SQL query: We will select all columns from the 'Addresses' table where the conditions are met."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the detailed address content from the 'Addresses' table for specific cities and states, allowing for the combination of results from two different queries based on the same criteria. The placeholders in the WHERE clauses represent the city and state names.\"\n}\n"}
{"sample_id": "train.6155", "db_id": "music_4", "question": "What are the category of music festivals with result \"Awarded\"?", "rationale": ["Identify the relevant table: The question pertains to music festivals and their results, so we will focus on the 'music_festival' table.", "Determine the required columns: We need the 'Category' column from the 'music_festival' table.", "Apply the condition: We are interested in categories where the result is 'Awarded'.", "Use DISTINCT to ensure we only get unique categories.", "Construct the SQL query using the SELECT statement with the appropriate WHERE clause."], "gold_sql": "SELECT Category FROM music_festival WHERE RESULT  =  'Awarded'", "source_tables": ["music_festival"], "pred_sql": "SELECT DISTINCT Category FROM music_festival WHERE Result = 'Awarded';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\"\n}\n"}
{"sample_id": "train.6167", "db_id": "music_4", "question": "Please show the songs that have result \"nominated\" at music festivals.", "rationale": ["Identify the relevant tables: volume, artist, and music_festival.", "Determine the columns needed: we need the song identifier and the famous title from the artist table.", "Establish the relationships between the tables using JOINs: volume is linked to artist via Artist_ID, and volume is linked to music_festival via Volume.", "Filter the results to only include those records where the Result in the music_festival table is 'nominated'."], "gold_sql": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  'Nominated'", "source_tables": ["music_festival", "volume"], "pred_sql": "SELECT volume.Song, artist.Famous_Title \nFROM volume \nJOIN artist ON volume.Artist_ID = artist.Artist_ID \nJOIN music_festival ON volume.Volume_ID = music_festival.Volume \nWHERE music_festival.Result = 'nominated';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\"\n}\n"}
{"sample_id": "train.6180", "db_id": "music_4", "question": "Return the famous release date for the oldest artist.", "rationale": ["Identify the table that contains the release date of the famous title, which is the 'artist' table.", "To find the oldest artist, we need to sort the artists by their age in ascending order.", "We will select the 'Famous_Release_date' of the artist who is the oldest.", "Using 'ORDER BY Age ASC' will sort the artists from youngest to oldest, and 'LIMIT 1' will give us the oldest artist's release date."], "gold_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1", "source_tables": ["artist"], "pred_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\"\n}\n"}
{"sample_id": "train.6185", "db_id": "music_4", "question": "Please show the categories of the music festivals with count more than 1.", "rationale": ["Identify the table that contains the categories of music festivals, which is the 'music_festival' table.", "We need to count the occurrences of each category, so we will use the COUNT() function.", "To group the results by category, we will use the GROUP BY clause on the 'Category' column.", "To filter the results to only include categories that have more than one occurrence, we will use the HAVING clause with COUNT(*) > 1."], "gold_sql": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*)  >  1", "source_tables": ["music_festival"], "pred_sql": "SELECT Category, COUNT(*) as Count\nFROM music_festival\nGROUP BY Category\nHAVING COUNT(*) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\"\n}\n"}
{"sample_id": "train.6187", "db_id": "music_4", "question": "What is the song in the volume with the maximum weeks on top?", "rationale": ["Identify the table that contains the relevant information about songs and their weeks on top, which is the 'volume' table.", "Determine that we need to find the song associated with the maximum number of weeks on top.", "Use a subquery to find the maximum value of 'Weeks_on_Top' in the 'volume' table.", "Select the 'Song' from the 'volume' table where the 'Weeks_on_Top' matches the maximum value found in the subquery."], "gold_sql": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT v.Song FROM volume v WHERE v.Weeks_on_Top = (SELECT MAX(Weeks_on_Top) FROM volume);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\"\n}\n"}
{"sample_id": "train.6195", "db_id": "music_4", "question": "What is the issue date of the volume with the minimum weeks on top?", "rationale": ["Identify the table that contains the issue date and weeks on top, which is the 'volume' table.", "To find the issue date of the volume with the minimum weeks on top, we need to first determine the minimum value of 'Weeks_on_Top' in the 'volume' table.", "We can use a subquery to find the minimum 'Weeks_on_Top' value.", "Once we have the minimum weeks on top, we can select the 'Issue_Date' from the 'volume' table where 'Weeks_on_Top' matches this minimum value."], "gold_sql": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT Issue_Date FROM volume WHERE Weeks_on_Top = (SELECT MIN(Weeks_on_Top) FROM volume);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\"\n}\n"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["Identify the table that contains the competition information, which is the 'match' table.", "Determine the column that holds the competition name, which is 'Competition'.", "Construct a subquery to find the Competition ID for '1994 FIFA World Cup qualification'.", "Use the result of the subquery to select the Match_ID from the 'match' table."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "pred_sql": "SELECT Match_ID FROM match WHERE Competition = (SELECT Competition FROM match WHERE Competition = '1994 FIFA World Cup qualification');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6274", "db_id": "city_record", "question": "Which city has hosted the most events?", "rationale": ["Identify the table that contains information about hosting events, which is the 'hosting_city' table.", "To find out which city has hosted the most events, we need to count the number of matches hosted by each city.", "We will use the COUNT function to count the number of Match_IDs for each Host_City.", "We will group the results by Host_City to aggregate the counts for each city.", "Finally, we will order the results in descending order based on the count of events and limit the result to the top city."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "pred_sql": "SELECT Host_City, COUNT(Match_ID) AS Event_Count\nFROM hosting_city\nGROUP BY Host_City\nORDER BY Event_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables: We need data from the 'city' table for city names and the 'temperature' table for February temperatures.", "Join the 'city' table with the 'temperature' table on 'City_ID' to get the temperature data associated with each city.", "Select the city name and the average temperature in February from the joined tables.", "Order the results by the February temperature in descending order to find the highest temperature.", "Limit the results to 1 to get only the city with the highest temperature in February."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT City, Feb FROM city JOIN temperature ON city.City_ID = temperature.City_ID ORDER BY Feb DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6287", "db_id": "city_record", "question": "In February, which city marks the highest temperature?", "rationale": ["We need to find the city with the highest average temperature in February.", "To do this, we will select the city name and the average temperature for February from the 'city' and 'temperature' tables.", "We will join the 'city' table with the 'temperature' table on the 'City_ID' to get the relevant temperature data for each city.", "Next, we will order the results by the February temperature in descending order to get the highest temperature at the top.", "Finally, we will limit the results to just one entry to get the city with the highest temperature."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, t.Feb\nFROM city c\nJOIN temperature t ON c.City_ID = t.City_ID\nORDER BY t.Feb DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables.", "Determine the conditions: We want cities where the average temperature in March is lower than in July or higher than in October.", "Join the tables: We will join the 'city' table with the 'temperature' table on 'City_ID' to access both city names and their temperature data.", "Construct the SQL query: We will select the city name and its related information from the 'city' table where the temperature conditions are met."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, c.Hanzi, c.Hanyu_Pinyin \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE (t.Mar < t.Jul OR t.Mar > t.Oct);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6289", "db_id": "city_record", "question": "Which cities' temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Apply the conditions: We want cities where the average temperature in March is lower than in July or higher than in October.", "Select the city name and the relevant temperature data for March, July, and October."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, t.Mar, t.Jul, t.Oct \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE (t.Mar < t.Jul OR t.Mar > t.Oct);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6292", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in Dec and which have never been host cities.", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Filter the results to include only those cities where the average temperature in March (t.Mar) is lower than in December (t.Dec).", "Additionally, we need to ensure that these cities have never hosted a match, which can be checked by ensuring that the 'City_ID' is not in the list of 'Host_City' from the 'hosting_city' table.", "Construct the SQL query using the SELECT statement to retrieve the city names and IDs that meet these criteria."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City_ID, c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables, and we also need to check against the 'hosting_city' table.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Use a WHERE clause to filter cities where the average temperature in March (t.Mar) is lower than in December (t.Dec).", "Additionally, we need to ensure that these cities have never served as host cities, which can be checked using a NOT IN clause that selects all Host_City from the 'hosting_city' table."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"1\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n    \"2\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6298", "db_id": "city_record", "question": "Please give me a list of cities whose regional population is over 8000000 or under 5000000.", "rationale": ["Identify the relevant table: The 'city' table contains the information about cities and their regional populations.", "Determine the filtering criteria: We need to find cities with a regional population greater than 8000000 or less than 5000000.", "Construct the SQL query: Use a SELECT statement to retrieve the 'City' column from the 'city' table, applying the specified conditions in the WHERE clause."], "gold_sql": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000", "source_tables": ["city"], "pred_sql": "SELECT City FROM city WHERE Regional_Population > 8000000 OR Regional_Population < 5000000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the names of cities from the 'city' table where the regional population is either greater than or less than specified numeric values. The placeholders in the WHERE clauses represent the population thresholds for filtering the cities.\",\n    \"1\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\"\n}\n"}
{"sample_id": "train.6313", "db_id": "e_government", "question": "What is the name of the party form that is most common?", "rationale": ["Identify the relevant tables: Party_Forms and Forms are needed to get the form names.", "Join the Party_Forms table with the Forms table on the form_id to access the form names.", "Group the results by form_name to count how many times each form appears in Party_Forms.", "Use COUNT(*) to count the occurrences of each form name.", "Order the results in descending order based on the count to find the most common form.", "Limit the results to 1 to get only the most common form."], "gold_sql": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["forms", "party_forms"], "pred_sql": "SELECT form_name, COUNT(*) as form_count \nFROM Party_Forms \nJOIN Forms ON Party_Forms.form_id = Forms.form_id \nGROUP BY form_name \nORDER BY form_count DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6329", "db_id": "e_government", "question": "What are the names of the services that have never been used?", "rationale": ["Identify the relevant table: The question asks about services, so we will focus on the Services table.", "Determine the condition: We need to find services that have never been used, which means we need to check for services that do not have any entries in the Party_Services table.", "Construct the subquery: We will create a subquery that selects all service_ids from the Party_Services table, as these represent services that have been used.", "Use the NOT IN clause: In the main query, we will select service_name from the Services table where the service_id is not in the list of used service_ids from the subquery."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "pred_sql": "SELECT service_name FROM Services WHERE service_id NOT IN (SELECT service_id FROM Party_Services);", "hint": "\n"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table: The 'Addresses' table contains the columns for town/city and state/province/county.", "Determine the columns needed: We need 'town_city' and 'state_province_county' from the 'Addresses' table.", "Use UNION to combine results: Since we want a unique list of names from both columns, we will use UNION to combine the results from both SELECT statements.", "Select distinct values: To ensure there are no duplicates in the results, we will use DISTINCT in both SELECT statements."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city AS name FROM Addresses\nUNION\nSELECT DISTINCT state_province_county AS name FROM Addresses;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a combined list of town/city names and state/province/county names from the 'Addresses' table. The use of UNION allows for the retrieval of unique entries from both columns, ensuring that the results do not contain duplicates.\"\n}\n"}
{"sample_id": "train.6342", "db_id": "e_government", "question": "Which state can address \"6862 Kaitlyn Knolls\" possibly be in?", "rationale": ["Identify the relevant table: The 'Addresses' table contains the address information.", "Determine the specific address to search for: The address in question is '6862 Kaitlyn Knolls'.", "Select the state/province/county associated with the specified address: We need to retrieve the 'state_province_county' column.", "Use DISTINCT to ensure that we get unique results, in case there are multiple entries for the same address.", "Construct the SQL query to select the distinct state/province/county for the given address."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT state_province_county FROM Addresses WHERE line_1_number_building = '6862 Kaitlyn Knolls';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a combined list of town/city names and state/province/county names from the 'Addresses' table. The use of UNION allows for the retrieval of unique entries from both columns, ensuring that the results do not contain duplicates.\"\n}\n"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the relevant tables: Organizations, Organization_Contact_Individuals, and Individuals.", "Determine the relationship between these tables: Organization_Contact_Individuals links individuals to organizations.", "Select the last name of individuals from the Individuals table.", "Join the Organizations table to get the organization details and the Organization_Contact_Individuals table to link individuals to organizations.", "Construct the SQL query to retrieve the last names of individuals who have contacted any organization."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "pred_sql": "SELECT i.individual_last_name \nFROM Organizations o \nJOIN Organization_Contact_Individuals oci ON o.organization_id = oci.organization_id \nJOIN Individuals i ON oci.individual_id = i.individual_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the last names of individuals who have contacted the organization with the highest VAT number. The query joins the 'organizations', 'organization_contact_individuals', and 'individuals' tables to filter the results based on the maximum VAT number and orders the results by the contact end date. The placeholder in the LIMIT clause represents the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.6371", "db_id": "flight_company", "question": "What are the names and types of the companies that have ever operated a flight?", "rationale": ["Identify the relevant tables: We need information from the 'operate_company' table for company names and types, and the 'flight' table to find companies that have operated flights.", "Determine the relationship: The 'flight' table has a foreign key 'company_id' that links to the 'id' in the 'operate_company' table.", "Construct the SQL query: We will use a JOIN to combine the 'operate_company' and 'flight' tables based on the matching 'company_id' and 'id'.", "Select the distinct names and types of companies to avoid duplicates, as multiple flights may be operated by the same company."], "gold_sql": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id", "source_tables": ["flight", "operate_company"], "pred_sql": "SELECT DISTINCT operate_company.name, operate_company.Type \nFROM operate_company \nJOIN flight ON operate_company.id = flight.company_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the pilots operating flights from companies that engage in specific principal activities. The query uses an INTERSECT operation to find pilots from two different sets of operating companies that share the same principal activities, represented by placeholders in the WHERE clause.\"\n}\n"}
{"sample_id": "train.6375", "db_id": "flight_company", "question": "What is the id, name and IATA code of the airport that had most number of flights?", "rationale": ["Identify the relevant tables: 'airport' and 'flight'.", "We need to find the airport with the most flights, so we will join the 'airport' table with the 'flight' table using the foreign key relationship (airport.id = flight.airport_id).", "Select the required fields: airport.id, airport.name, and airport.IATA.", "Group the results by airport.id, airport.name, and airport.IATA to aggregate the flight counts for each airport.", "Count the number of flights for each airport using COUNT(flight.id).", "Order the results in descending order based on the flight count to get the airport with the most flights at the top.", "Limit the results to 1 to get only the airport with the highest number of flights."], "gold_sql": "SELECT T1.id ,  T1.name ,  T1.IATA FROM airport AS T1 JOIN flight AS T2 ON T1.id  =  T2.airport_id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airport", "flight"], "pred_sql": "SELECT airport.id, airport.name, airport.IATA\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nGROUP BY airport.id, airport.name, airport.IATA\nORDER BY COUNT(flight.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6381", "db_id": "flight_company", "question": "How many companies operates airlines in each airport?", "rationale": ["Identify the relevant tables: airport, operate_company, and flight.", "We need to count the number of companies that operate airlines at each airport.", "Join the airport table with the flight table on airport.id and flight.airport_id.", "Join the flight table with the operate_company table on flight.company_id and operate_company.id.", "Filter the results to include only those companies that are of type 'airline'.", "Group the results by the airport name to get the count of airlines per airport."], "gold_sql": "SELECT T3.id ,  count(*) FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id JOIN airport AS T3 ON T2.airport_id  =  T3.id GROUP BY T3.id", "source_tables": ["airport", "flight", "operate_company"], "pred_sql": "SELECT airport.name AS Airport_Name, COUNT(operate_company.id) AS Number_of_Airlines\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nJOIN operate_company ON flight.company_id = operate_company.id\nWHERE operate_company.Type = 'airline'\nGROUP BY airport.name;", "hint": "\n"}
{"sample_id": "train.6517", "db_id": "wine_1", "question": "What is the name of the highest rated wine?", "rationale": ["Identify the table that contains the wine names and their scores, which is the 'wine' table.", "To find the highest rated wine, we need to order the results by the 'Score' column in descending order.", "We will limit the results to 1 to get only the highest rated wine.", "The final SQL query selects the 'Name' of the wine from the 'wine' table, orders by 'Score' in descending order, and limits the result to 1."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n    \"1\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"2\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\"\n}\n"}
{"sample_id": "train.6518", "db_id": "wine_1", "question": "Give the name of the wine with the highest score.", "rationale": ["Identify the table that contains the wine names and their scores, which is the 'wine' table.", "To find the wine with the highest score, we need to order the results by the 'Score' column in descending order.", "Using 'LIMIT 1' will ensure that we only get the top result, which is the wine with the highest score."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n    \"1\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"2\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\"\n}\n"}
{"sample_id": "train.6520", "db_id": "wine_1", "question": "What is the winery at which the wine with the highest score was made?", "rationale": ["Identify the table that contains the winery information, which is the 'wine' table.", "Determine that we need to find the wine with the highest score, which requires a subquery to get the maximum score from the 'wine' table.", "Use the MAX function in a subquery to find the highest score.", "Select the winery from the 'wine' table where the score matches the highest score found in the subquery."], "gold_sql": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Winery FROM wine WHERE Score = (SELECT MAX(Score) FROM wine);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n    \"1\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"2\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\"\n}\n"}
{"sample_id": "train.6533", "db_id": "wine_1", "question": "List the names of all distinct wines that are made of red color grape.", "rationale": ["Identify the tables involved: 'wine' and 'grapes'.", "Determine the relationship between the tables: 'wine' table has a foreign key 'Grape' that references 'grapes' table.", "Select the distinct names of wines from the 'wine' table.", "Join the 'wine' table with the 'grapes' table on the 'Grape' column.", "Filter the results to include only those wines made from red color grapes by adding a WHERE clause that checks 'grapes.Color = 'red'."], "gold_sql": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT wine.Name \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'red';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n    \"1\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"2\": \"This virtual table provides a list of counties from the 'appellations' table that are associated with a specific number of wines produced, as indicated by the placeholder. The query joins the 'appellations' and 'wine' tables on the appellation name, groups the results by appellation, and filters the groups to include only those with a count of wines less than or equal to the specified number.\"\n}\n"}
{"sample_id": "train.6544", "db_id": "wine_1", "question": "Give the names and scores of wines made from white grapes.", "rationale": ["Identify the tables involved: 'wine' and 'grapes'.", "Determine the columns needed: 'Name' and 'Score' from the 'wine' table.", "Establish the relationship between the tables: 'wine.Grape' corresponds to 'grapes.Grape'.", "Filter the results to include only wines made from white grapes by adding a WHERE clause that specifies 'grapes.Color = 'white'.", "Construct the SQL query to select the desired columns from the joined tables with the appropriate filtering."], "gold_sql": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT wine.Name, wine.Score \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'white';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"1\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n    \"2\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\"\n}\n"}
{"sample_id": "train.6547", "db_id": "wine_1", "question": "Find the the grape whose white color grapes are used to produce wines with scores higher than 90.", "rationale": ["Identify the relevant tables: 'grapes' and 'wine'.", "We need to find grape varieties that are white in color and are used in wines with scores higher than 90.", "Join the 'grapes' table with the 'wine' table on the grape variety column.", "Filter the results to include only white grapes and wines with a score greater than 90.", "Select distinct grape varieties to avoid duplicates in the results."], "gold_sql": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White' AND T2.score  >  90", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT grapes.Grape \nFROM grapes \nJOIN wine ON grapes.Grape = wine.Grape \nWHERE grapes.Color = 'white' AND wine.Score > 90;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"1\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n    \"2\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\"\n}\n"}
{"sample_id": "train.6550", "db_id": "wine_1", "question": "What are the names of wines made from red grapes and with prices above 50?", "rationale": ["Identify the relevant tables: 'wine' and 'grapes'.", "Determine the columns needed: 'Name' from 'wine' and 'Color' from 'grapes'.", "Establish the relationship between the tables: join 'wine' and 'grapes' on the 'Grape' column.", "Apply the filters: select only red grapes and wines with prices above 50.", "Use DISTINCT to ensure unique wine names are returned."], "gold_sql": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red' AND T2.price  >  50", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT wine.Name \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'red' AND wine.Price > 50;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n    \"1\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"2\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\"\n}\n"}
{"sample_id": "train.6558", "db_id": "wine_1", "question": "What are the distinct names of wines with prices higher than any wine from John Anthony winery.", "rationale": ["Identify the main requirement: distinct names of wines with prices higher than any wine from John Anthony winery.", "To find wines with prices higher than those from John Anthony, we need to compare prices.", "We will use a subquery to find the maximum price of wines from John Anthony winery.", "The outer query will select distinct wine names from the 'wine' table where the price is greater than the result of the subquery."], "gold_sql": "SELECT DISTINCT Name FROM WINE WHERE Price  >  (SELECT min(Price) FROM wine WHERE Winery  =  'John Anthony')", "source_tables": ["wine"], "pred_sql": "SELECT DISTINCT w.Name \nFROM wine w \nWHERE w.Price > (SELECT MAX(w2.Price) \n                  FROM wine w2 \n                  WHERE w2.Winery = 'John Anthony');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n    \"1\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n    \"2\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\"\n}\n"}
{"sample_id": "train.6566", "db_id": "wine_1", "question": "Give the color of the grape whose wine products have the highest average price?", "rationale": ["Identify the tables involved: 'grapes' and 'wine'.", "We need to find the color of the grape whose wine products have the highest average price.", "Join the 'grapes' table with the 'wine' table on the grape variety.", "Group the results by the color of the grape to calculate the average price of wines for each color.", "Order the results by the average price in descending order to get the highest average price at the top.", "Limit the results to 1 to get only the color of the grape with the highest average price."], "gold_sql": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT 1", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT g.Color\nFROM grapes g\nJOIN wine w ON g.Grape = w.Grape\nGROUP BY g.Color\nORDER BY AVG(w.Price) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n    \"1\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"2\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\"\n}\n"}
{"sample_id": "train.6588", "db_id": "wine_1", "question": "Which 3 wineries produce the most wines made from white grapes?", "rationale": ["Identify the relevant tables: 'wine' and 'grapes'.", "Join the 'wine' table with the 'grapes' table on the grape variety to access grape color information.", "Filter the results to include only wines made from white grapes by adding a WHERE clause for grapes.Color = 'white'.", "Group the results by winery name to count the number of wines produced by each winery.", "Count the number of wines for each winery using COUNT(*) and alias it as WineCount.", "Order the results in descending order based on the count of wines produced (WineCount).", "Limit the results to the top 3 wineries using LIMIT 3."], "gold_sql": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  'White' GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT Winery, COUNT(*) AS WineCount\nFROM wine\nJOIN grapes ON wine.Grape = grapes.Grape\nWHERE grapes.Color = 'white'\nGROUP BY Winery\nORDER BY WineCount DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n    \"1\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"2\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\"\n}\n"}
{"sample_id": "train.6597", "db_id": "wine_1", "question": "Find the county where produces the most number of wines with score higher than 90.", "rationale": ["We need to find the county that produces the most wines with a score higher than 90.", "To do this, we will join the 'appellations' table with the 'wine' table on the appellation name.", "We will filter the wines to include only those with a score greater than 90 using a WHERE clause.", "Next, we will group the results by county to count the number of wines per county.", "We will order the results in descending order based on the count of wines to find the county with the highest number.", "Finally, we will limit the results to just one county using the LIMIT clause."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1", "source_tables": ["wine", "appellations"], "pred_sql": "SELECT a.County, COUNT(w.No) AS WineCount\nFROM appellations a\nJOIN wine w ON a.Appelation = w.Appelation\nWHERE w.Score > 90\nGROUP BY a.County\nORDER BY WineCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n    \"1\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n    \"2\": \"This virtual table provides a list of counties from the 'appellations' table that are associated with a specific number of wines produced, as indicated by the placeholder. The query joins the 'appellations' and 'wine' tables on the appellation name, groups the results by appellation, and filters the groups to include only those with a count of wines less than or equal to the specified number.\"\n}\n"}
{"sample_id": "train.6626", "db_id": "driving_school", "question": "Show the detail of vehicle with id 1.", "rationale": ["Identify the table that contains vehicle details, which is the Vehicles table.", "Determine the specific vehicle we want to retrieve details for, which is identified by vehicle_id '1'.", "Construct a SQL SELECT statement to retrieve all columns from the Vehicles table where the vehicle_id matches '1'."], "gold_sql": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;", "source_tables": ["vehicles"], "pred_sql": "SELECT * FROM Vehicles WHERE vehicle_id = '1';", "hint": "\n"}
{"sample_id": "train.6650", "db_id": "driving_school", "question": "How many staff live in state Georgia?", "rationale": ["Identify the relevant tables: Staff and Addresses.", "Determine the relationship between the tables: Staff has a foreign key (staff_address_id) that links to Addresses (address_id).", "We need to count the number of staff members, so we will use the COUNT() function.", "Filter the results to only include staff members who live in the state of Georgia by using a WHERE clause on the state_province_county column in the Addresses table."], "gold_sql": "SELECT count(*) FROM Addresses WHERE state_province_county = 'Georgia';", "source_tables": ["addresses"], "pred_sql": "SELECT COUNT(*) AS staff_count \nFROM Staff \nJOIN Addresses ON Staff.staff_address_id = Addresses.address_id \nWHERE Addresses.state_province_county = 'Georgia';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the number of staff members located in each city, derived from the 'Addresses' and 'Staff' tables. The placeholder in the LIMIT clause allows the user to specify the maximum number of cities to display based on the count of staff members.\"\n}\n"}
{"sample_id": "train.6665", "db_id": "driving_school", "question": "What is the status code, phone number, and email address of the customer whose last name is Kohler or whose first name is Marina?", "rationale": ["Identify the relevant table: Customers, as we need customer details.", "Determine the required fields: status code, phone number, and email address.", "Formulate the WHERE clause to filter customers by last name 'Kohler' or first name 'Marina'.", "Construct the SELECT statement to retrieve the specified fields from the Customers table."], "gold_sql": "SELECT customer_status_code ,  cell_mobile_phone_number ,  email_address FROM Customers WHERE first_name = 'Marina' OR last_name  =  'Kohler'", "source_tables": ["customers"], "pred_sql": "SELECT customer_status_code, phone_number, email_address FROM Customers WHERE last_name = 'Kohler' OR first_name = 'Marina';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of lessons attended by a specific customer identified by their first and last name, along with the status of those lessons. The placeholders in the WHERE clause represent the customer's first name, last name, and the lesson status code.\"\n}\n"}
{"sample_id": "train.6676", "db_id": "driving_school", "question": "How many lessons taken by customer with first name as Rylan and last name as Goodwin were completed?", "rationale": ["Identify the tables involved: Lessons and Customers.", "We need to count the number of lessons, so we will use the COUNT() function.", "We need to join the Lessons table with the Customers table on the customer_id to filter by customer name.", "The WHERE clause will filter for the specific first name 'Rylan' and last name 'Goodwin'.", "Additionally, we need to filter for lessons that have a status of 'completed'.", "Construct the SQL query using the identified tables, join condition, and filters."], "gold_sql": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = 'Rylan' AND T2.last_name = 'Goodwin' AND T1.lesson_status_code = 'Completed';", "source_tables": ["lessons", "customers"], "pred_sql": "SELECT COUNT(*) AS lesson_count \nFROM Lessons \nJOIN Customers ON Lessons.customer_id = Customers.customer_id \nWHERE Customers.first_name = 'Rylan' \nAND Customers.last_name = 'Goodwin' \nAND Lessons.lesson_status_code = 'completed';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of lessons attended by a specific customer identified by their first and last name, along with the status of those lessons. The placeholders in the WHERE clause represent the customer's first name, last name, and the lesson status code.\"\n}\n"}
{"sample_id": "train.6688", "db_id": "driving_school", "question": "Which city does has most number of customers?", "rationale": ["Identify the relevant tables: Customers and Addresses.", "Determine the relationship between Customers and Addresses using the foreign key customer_address_id.", "Count the number of customers grouped by city.", "Order the results by the count of customers in descending order to find the city with the most customers.", "Limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "customers"], "pred_sql": "SELECT city, COUNT(customer_id) AS customer_count \nFROM Customers \nJOIN Addresses ON Customers.customer_address_id = Addresses.address_id \nGROUP BY city \nORDER BY customer_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the number of staff members located in each city, derived from the 'Addresses' and 'Staff' tables. The placeholder in the LIMIT clause allows the user to specify the maximum number of cities to display based on the count of staff members.\"\n}\n"}
{"sample_id": "train.6711", "db_id": "driving_school", "question": "What are the last names that are used by customers and staff?", "rationale": ["Identify the tables that contain last names: Customers and Staff.", "Use the SELECT statement to retrieve last names from both tables.", "Use DISTINCT to ensure that each last name is unique in the results.", "Combine the results from both tables using UNION to get a single list of last names."], "gold_sql": "SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff", "source_tables": ["staff", "customers"], "pred_sql": "SELECT DISTINCT last_name FROM Customers UNION SELECT DISTINCT last_name FROM Staff;", "hint": "\n"}
{"sample_id": "train.6714", "db_id": "driving_school", "question": "What is the id and detail of the vehicle used in lessons for most of the times?", "rationale": ["Identify the relevant tables: Lessons and Vehicles.", "We need to find the vehicle used in lessons, so we will join the Lessons table with the Vehicles table on the vehicle_id.", "We want to count how many times each vehicle has been used in lessons, so we will group the results by vehicle_id.", "To find the vehicle used the most, we will order the results by the count of lesson_id in descending order.", "Finally, we will limit the results to 1 to get the vehicle used in lessons the most times."], "gold_sql": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["lessons", "vehicles"], "pred_sql": "SELECT v.vehicle_id, v.vehicle_details\nFROM Lessons l\nJOIN Vehicles v ON l.vehicle_id = v.vehicle_id\nGROUP BY l.vehicle_id\nORDER BY COUNT(l.lesson_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of lessons attended by a specific customer identified by their first and last name, along with the status of those lessons. The placeholders in the WHERE clause represent the customer's first name, last name, and the lesson status code.\"\n}\n"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the table that contains faculty information, which is the 'Faculty' table.", "Determine the relevant column for faculty identifiers, which is 'FacID'.", "Identify the column that indicates gender, which is 'Sex'.", "Specify the condition to filter for male faculty members by using 'WHERE Sex = 'Male''.", "Combine these elements to form the SQL query that selects the 'FacID' of male faculty members."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "pred_sql": "SELECT FacID FROM Faculty WHERE Sex = 'Male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n    \"2\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\"\n}\n"}
{"sample_id": "train.6734", "db_id": "activity_1", "question": "What are the first name and last name of all the instructors?", "rationale": ["Identify the relevant table: The 'Faculty' table contains the information about instructors.", "Determine the required fields: We need the first name (Fname) and last name (Lname) of the instructors.", "Construct the SQL query: Use a SELECT statement to retrieve Fname and Lname from the Faculty table."], "gold_sql": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  'Instructor'", "source_tables": ["faculty"], "pred_sql": "SELECT Fname, Lname FROM Faculty;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n    \"2\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\"\n}\n"}
{"sample_id": "train.6737", "db_id": "activity_1", "question": "Which building has most faculty members?", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their building.", "Count the number of faculty members in each building: Use COUNT(FacID) to count the faculty members grouped by their building.", "Group the results by building: Use GROUP BY Building to aggregate the counts for each building.", "Order the results to find the building with the most faculty members: Use ORDER BY FacultyCount DESC to sort the counts in descending order.", "Limit the results to the top building: Use LIMIT 1 to return only the building with the highest count of faculty members."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(FacID) AS FacultyCount\nFROM Faculty\nGROUP BY Building\nORDER BY FacultyCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n    \"1\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n    \"2\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their rank and gender.", "Filter for assistant professors: We need to include only those faculty members whose rank is 'Assistant Professor'.", "Group by gender: To count the number of male and female assistant professors, we will group the results by the 'Sex' column.", "Count the number of faculty members: We will use the COUNT() function to count the number of faculty members in each gender group."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) as Count \nFROM Faculty \nWHERE Rank = 'Assistant Professor' \nGROUP BY Sex;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n    \"1\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n    \"2\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6748", "db_id": "activity_1", "question": "How many male and female assistant professors do we have?", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their rank and gender.", "Determine the criteria: We need to filter for assistant professors, which is specified by the Rank column.", "Count the number of faculty members: We will use the COUNT function to count the number of assistant professors, grouped by their gender (Sex).", "Construct the SQL query: We will select the Sex and the count of faculty members, applying the necessary filters and grouping."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) as Count\nFROM Faculty\nWHERE Rank = 'Assistant Professor'\nGROUP BY Sex;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n    \"2\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\"\n}\n"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the tables needed: We need to find the advisor of a student named Linda Smith, so we will use the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that references the 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the JOIN: We will join the Faculty table with the Student table on the condition that Faculty.FacID matches Student.Advisor.", "Filter the results: We need to filter the results to only include the student with the first name 'Linda' and last name 'Smith'.", "Select the required fields: We need to select the first name and last name of the faculty advisor."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Faculty.Fname, Faculty.Lname \nFROM Faculty \nJOIN Student ON Faculty.FacID = Student.Advisor \nWHERE Student.Fname = 'Linda' AND Student.Lname = 'Smith';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\"\n}\n"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["Identify the relevant tables: We need to find students and their advisors, which involves the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that references 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the SQL query: We will select the student IDs from the Student table and join it with the Faculty table on the Advisor and FacID columns to filter students whose advisors are faculty members."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN Faculty ON Student.Advisor = Faculty.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n    \"2\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\"\n}\n"}
{"sample_id": "train.6752", "db_id": "activity_1", "question": "Which students have professors as their advisors? Find their student ids.", "rationale": ["Identify the relevant tables: We need to find students and their advisors, so we will use the 'Student' and 'Faculty' tables.", "Determine the relationship: The 'Advisor' column in the 'Student' table references the 'FacID' in the 'Faculty' table, indicating which faculty member is the advisor for each student.", "Construct the SQL query: We will select the student IDs from the 'Student' table where the advisor matches a faculty member in the 'Faculty' table. We will use a JOIN to connect these two tables based on the advisor relationship."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN Faculty ON Student.Advisor = Faculty.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\"\n}\n"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the tables needed: We need the 'Student' table to get student names and the 'Faculty' table to find the advisor's name.", "Determine the relationship: The 'Student' table has a foreign key 'Advisor' that links to 'FacID' in the 'Faculty' table.", "Select the required columns: We need to select the first name (Fname) and last name (LName) of the students.", "Filter the results: We need to filter the results to only include students whose advisor's first name is 'Michael' and last name is 'Goodrich'.", "Construct the SQL query using JOIN to combine the 'Student' and 'Faculty' tables based on the advisor relationship."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT S.Fname, S.LName \nFROM Student S \nJOIN Faculty F ON S.Advisor = F.FacID \nWHERE F.Fname = 'Michael' AND F.Lname = 'Goodrich';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n    \"2\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\"\n}\n"}
{"sample_id": "train.6756", "db_id": "activity_1", "question": "What are the faculty id and the number of students each faculty has?", "rationale": ["We need to find the faculty ID and the number of students each faculty has.", "To do this, we will join the Faculty table with the Faculty_Participates_in table to get the activities each faculty member participates in.", "Next, we will join the Participates_in table to count the number of students participating in those activities.", "We will group the results by Faculty.FacID to get the count of students for each faculty member."], "gold_sql": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Faculty.FacID, COUNT(Participates_in.stuid) AS student_count\nFROM Faculty\nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID\nJOIN Participates_in ON Faculty_Participates_in.actid = Participates_in.actid\nGROUP BY Faculty.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n    \"2\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\"\n}\n"}
{"sample_id": "train.6758", "db_id": "activity_1", "question": "How many students are advised by each rank of faculty? List the rank and the number of students.", "rationale": ["We need to find out how many students are advised by each rank of faculty.", "The relevant tables for this query are 'Faculty' and 'Student'.", "The 'Faculty' table contains the rank of faculty members, and the 'Student' table contains the advisor information.", "We will join the 'Faculty' table with the 'Student' table on the condition that the faculty's ID matches the advisor ID of the students.", "We will group the results by the faculty rank to count the number of students for each rank.", "Finally, we will select the rank and the count of students advised by that rank."], "gold_sql": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank", "source_tables": ["faculty", "student"], "pred_sql": "SELECT f.Rank, COUNT(s.StuID) AS number_of_students\nFROM Faculty f\nJOIN Student s ON f.FacID = s.Advisor\nGROUP BY f.Rank;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n    \"2\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\"\n}\n"}
{"sample_id": "train.6761", "db_id": "activity_1", "question": "Show the ids for all the faculty members who have at least 2 students.", "rationale": ["Identify the requirement: We need to find faculty members who have at least 2 students.", "Understand the relationship: Faculty members are linked to students through the Advisor field in the Student table.", "Create a subquery to count the number of students for each faculty member (Advisor).", "Use GROUP BY on the Advisor field to aggregate the student counts.", "Use HAVING to filter the results to only include faculty members with 2 or more students.", "Select the FacID from the Faculty table where the FacID matches the Advisors from the subquery."], "gold_sql": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  2", "source_tables": ["faculty", "student"], "pred_sql": "SELECT FacID\nFROM Faculty\nWHERE FacID IN (\n    SELECT Advisor\n    FROM Student\n    GROUP BY Advisor\n    HAVING COUNT(StuID) >= 2\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n    \"2\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\"\n}\n"}
