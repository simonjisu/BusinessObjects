{"sample_id": "train.1109", "db_id": "match_season", "question": "Return the colleges that have players who play the Midfielder position, as well as players who play the Defender position.", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players, including their positions and the colleges they attended.", "Determine the required positions: We need to filter players who play as 'Midfielder' or 'Defender'.", "Use the DISTINCT keyword: Since we want unique colleges, we will use DISTINCT to avoid duplicate entries in the result.", "Construct the SQL query: The query selects the 'College' column from the 'match_season' table where the 'Position' is either 'Midfielder' or 'Defender'."], "gold_sql": "SELECT College FROM match_season WHERE POSITION  =  'Midfielder' INTERSECT SELECT College FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "pred_sql": "SELECT DISTINCT College \nFROM match_season \nWHERE Position IN ('Midfielder', 'Defender');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\",\n    \"1\": \"This virtual table identifies the names of countries represented by players who occupy a specific position in matches. It uses an intersection to find countries where players in that position are participating in matches, ensuring that only countries with players in that position are returned. The placeholders in the query represent the position of the players being filtered.\",\n    \"2\": \"This virtual table provides information about the draft pick number and draft class of players from the 'match_season' table who play in a specific position. The placeholder in the WHERE clause represents the position of the player.\"\n}\n"}
{"sample_id": "train.1222", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with type code \"Duplex\"?", "rationale": ["Identify the relevant tables: Apartments and Apartment_Bookings are needed to get the apartment type and booking dates.", "Join the Apartments table with the Apartment_Bookings table on the apt_id to link apartments with their bookings.", "Filter the results to only include apartments with the type code 'Duplex'.", "Select the booking start and end dates from the joined tables."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  'Duplex'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartments a \nJOIN Apartment_Bookings ab ON a.apt_id = ab.apt_id \nWHERE a.apt_type_code = 'Duplex';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1224", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with more than 2 bedrooms?", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "We need to select the booking start and end dates, which are in the Apartment_Bookings table.", "To filter apartments with more than 2 bedrooms, we will join the Apartments table on the apt_id from Apartment_Bookings and apply a WHERE clause to check for bedroom_count > 2."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartment_Bookings ab \nJOIN Apartments a ON ab.apt_id = a.apt_id \nWHERE a.bedroom_count > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1225", "db_id": "apartment_rentals", "question": "Find the booking start date and end date for the apartments that have more than two bedrooms.", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "Determine the columns needed: booking_start_date and booking_end_date from Apartment_Bookings.", "Filter the apartments based on the condition of having more than two bedrooms, which is found in the Apartments table.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to correlate bookings with their respective apartments.", "Construct the SQL query to select the required columns with the appropriate join and where clause."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartment_Bookings ab \nJOIN Apartments a ON ab.apt_id = a.apt_id \nWHERE a.bedroom_count > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1229", "db_id": "apartment_rentals", "question": "Which apartments have bookings with status code \"Confirmed\"? Return their apartment numbers.", "rationale": ["Identify the relevant tables: Apartments and Apartment_Bookings are needed to find apartments with confirmed bookings.", "Join the Apartments table with the Apartment_Bookings table on the apt_id to link apartments with their bookings.", "Filter the results to include only those bookings where the booking_status_code is 'Confirmed'.", "Select the apt_number from the filtered results to return the apartment numbers that meet the criteria."], "gold_sql": "SELECT DISTINCT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  'Confirmed'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT a.apt_number \nFROM Apartments a \nJOIN Apartment_Bookings ab ON a.apt_id = ab.apt_id \nWHERE ab.booking_status_code = 'Confirmed';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1232", "db_id": "apartment_rentals", "question": "Show the guest first names, start dates, and end dates of all the apartment bookings.", "rationale": ["Identify the required fields: guest first names, booking start dates, and booking end dates.", "Determine the relevant tables: Guests for guest information and Apartment_Bookings for booking details.", "Establish the relationship between the tables: Apartment_Bookings is linked to Guests through guest_id.", "Construct the SQL SELECT statement to retrieve the desired fields from the joined tables."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT Guests.guest_first_name, Apartment_Bookings.booking_start_date, Apartment_Bookings.booking_end_date\nFROM Apartment_Bookings\nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1234", "db_id": "apartment_rentals", "question": "Show the start dates and end dates of all the apartment bookings made by guests with gender code \"Female\".", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Guests for gender information.", "Determine the columns needed: booking_start_date and booking_end_date from Apartment_Bookings.", "Establish the relationship between tables: Join Apartment_Bookings with Guests on guest_id.", "Filter the results to include only those bookings made by guests with gender code 'Female'."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  'Female'", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT Apartment_Bookings.booking_start_date, Apartment_Bookings.booking_end_date \nFROM Apartment_Bookings \nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id \nWHERE Guests.gender_code = 'Female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1238", "db_id": "apartment_rentals", "question": "Show the facility codes of apartments with more than 4 bedrooms.", "rationale": ["Identify the relevant tables: We need to retrieve facility codes from the Apartment_Facilities table and filter apartments based on the number of bedrooms from the Apartments table.", "Join the tables: We will join the Apartment_Facilities table with the Apartments table using the apt_id to link them together.", "Apply the filter: We need to filter the apartments to only include those with more than 4 bedrooms, which is done using a WHERE clause.", "Select distinct facility codes: Since we only want the unique facility codes, we will use SELECT DISTINCT to avoid duplicates."], "gold_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "source_tables": ["apartments", "apartment_facilities"], "pred_sql": "SELECT DISTINCT af.facility_code \nFROM Apartment_Facilities af \nJOIN Apartments a ON af.apt_id = a.apt_id \nWHERE a.bedroom_count > 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1256", "db_id": "apartment_rentals", "question": "Show the top 3 apartment type codes sorted by the average number of rooms in descending order.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of rooms.", "Select the columns needed: We need the apartment type code (apt_type_code) and the average number of rooms (room_count).", "Calculate the average number of rooms: Use the AVG() function to calculate the average of room_count for each apartment type code.", "Group the results: Use GROUP BY to group the results by apt_type_code to get the average for each type.", "Sort the results: Use ORDER BY to sort the results in descending order based on the average number of rooms.", "Limit the results: Use LIMIT to restrict the output to the top 3 apartment type codes."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, AVG(room_count) AS average_rooms\nFROM Apartments\nGROUP BY apt_type_code\nORDER BY average_rooms DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1258", "db_id": "apartment_rentals", "question": "Show the apartment type code that has the largest number of total rooms, together with the number of bathrooms and number of bedrooms.", "rationale": ["Identify the relevant columns needed: apt_type_code, bathroom_count, bedroom_count from the Apartments table.", "To find the apartment type code with the largest number of total rooms, we need to order the results by room_count in descending order.", "We will limit the results to 1 to get only the top result, which will be the apartment type with the largest number of total rooms."], "gold_sql": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, bathroom_count, bedroom_count \nFROM Apartments \nORDER BY room_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1261", "db_id": "apartment_rentals", "question": "Which apartment type code appears the most often?", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes.", "Count occurrences: We need to count how many times each apartment type code appears.", "Group by apartment type code: Use GROUP BY to aggregate the counts for each type code.", "Order by count: To find the most common type, we will order the results by the count in descending order.", "Limit the results: Since we only want the most common type, we will limit the results to 1."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, COUNT(*) as type_count \nFROM Apartments \nGROUP BY apt_type_code \nORDER BY type_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1262", "db_id": "apartment_rentals", "question": "Show the most common apartment type code among apartments with more than 1 bathroom.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of bathrooms.", "Filter the apartments: We need to filter apartments that have more than 1 bathroom, which can be done using a WHERE clause.", "Group the results: To find the most common apartment type code, we will group the results by the apartment type code using GROUP BY.", "Count the apartments: We will count the number of apartments for each type code using COUNT(*) and alias it as apartment_count.", "Order the results: To find the most common type, we will order the results in descending order based on the count of apartments.", "Limit the results: Since we only want the most common type, we will limit the results to 1 using LIMIT 1."], "gold_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, COUNT(*) as apartment_count \nFROM Apartments \nWHERE bathroom_count > 1 \nGROUP BY apt_type_code \nORDER BY apartment_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n    \"1\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\"\n}\n"}
{"sample_id": "train.1272", "db_id": "apartment_rentals", "question": "Show the apartment numbers of apartments with unit status availability of both 0 and 1.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment numbers we want to retrieve.", "Determine the condition for availability: We need to check the availability status from the View_Unit_Status table, which indicates if an apartment is available or not.", "Use a subquery to filter apartments: We will use a subquery to select the apt_id from View_Unit_Status where the available_yn column indicates both 'Yes' (1) and 'No' (0).", "Join the results: The main query will select the apt_number from the Apartments table where the apt_id matches the results from the subquery."], "gold_sql": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1", "source_tables": ["view_unit_status", "apartments"], "pred_sql": "SELECT apt_number FROM Apartments WHERE apt_id IN (SELECT apt_id FROM View_Unit_Status WHERE available_yn IN ('Yes', 'No'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\"\n}\n"}
{"sample_id": "train.1294", "db_id": "soccer_1", "question": "How many leagues are there in England?", "rationale": ["Identify the relevant table: The question pertains to leagues, so we will use the 'League' table.", "Determine the condition: We need to filter the leagues to only those in England.", "Construct the SQL query: We will use the COUNT function to count the number of leagues that match the condition."], "gold_sql": "SELECT count(*) FROM Country AS T1 JOIN League AS T2 ON T1.id  =  T2.country_id WHERE T1.name  =  'England'", "source_tables": ["country", "league"], "pred_sql": "SELECT COUNT(*) AS league_count FROM League WHERE name = 'England';", "hint": "\n"}
{"sample_id": "train.1303", "db_id": "soccer_1", "question": "List all of the player ids with a height of at least 180cm and an overall rating higher than 85.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to select player ids, which are in the Player table.", "We need to filter players based on height (at least 180cm) and overall rating (higher than 85).", "Join the Player table with Player_Attributes table on player_api_id to access both height and overall rating.", "Construct the SQL query to select the player ids with the specified conditions."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE overall_rating  >  85", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT p.id \nFROM Player p \nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id \nWHERE p.height >= 180 AND pa.overall_rating > 85;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of players from the 'Player' table who have a specific preferred foot and whose overall skill rating falls within a defined range. The placeholders in the WHERE clause represent the preferred foot and the minimum and maximum overall ratings.\",\n    \"1\": \"This virtual table lists the distinct names of players from the 'Player' table who have a crossing ability greater than a specified value and have a preferred foot that matches a given specification. The placeholders in the WHERE clause represent the crossing ability threshold and the preferred foot of the players.\"\n}\n"}
{"sample_id": "train.1304", "db_id": "soccer_1", "question": "List all of the ids for left-footed players with a height between 180cm and 190cm.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to select the 'id' from the Player table.", "Join the Player table with Player_Attributes on the player_api_id to access player attributes.", "Filter the results to include only left-footed players by checking 'preferred_foot' column.", "Further filter the results to include only players with height between 180cm and 190cm using the 'height' column."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 AND height  <=  190 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE preferred_foot  =  'left'", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT Player.id FROM Player JOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id WHERE Player_Attributes.preferred_foot = 'left' AND Player.height BETWEEN 180 AND 190;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of players from the 'Player' table who have a specific preferred foot and whose overall skill rating falls within a defined range. The placeholders in the WHERE clause represent the preferred foot and the minimum and maximum overall ratings.\",\n    \"1\": \"This virtual table lists the distinct names of players from the 'Player' table who have a crossing ability greater than a specified value and have a preferred foot that matches a given specification. The placeholders in the WHERE clause represent the crossing ability threshold and the preferred foot of the players.\"\n}\n"}
{"sample_id": "train.1306", "db_id": "soccer_1", "question": "List the names and birthdays of the top five players in terms of potential.", "rationale": ["Identify the relevant tables: Player and Player_Attributes are needed to get player names and birthdays along with their potential.", "Use a JOIN clause to combine Player and Player_Attributes on the player_api_id, which is the common key between these two tables.", "Select the player_name and birthday columns from the Player table.", "Order the results by the potential column in descending order to get the top players.", "Limit the results to the top five players by using the LIMIT clause."], "gold_sql": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT 5", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT player_name, birthday \nFROM Player \nJOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id \nORDER BY potential DESC \nLIMIT 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct names of players from the 'Player' table who have a specific preferred foot and whose overall skill rating falls within a defined range. The placeholders in the WHERE clause represent the preferred foot and the minimum and maximum overall ratings.\",\n    \"1\": \"This virtual table lists the distinct names of players from the 'Player' table who have a crossing ability greater than a specified value and have a preferred foot that matches a given specification. The placeholders in the WHERE clause represent the crossing ability threshold and the preferred foot of the players.\"\n}\n"}
{"sample_id": "train.1511", "db_id": "insurance_and_eClaims", "question": "Which type of policy is most frequently used? Give me the policy type code.", "rationale": ["Identify the table that contains the policy type information, which is the 'Policies' table.", "To find the most frequently used policy type, we need to count the occurrences of each 'Policy_Type_Code'.", "Use the COUNT() function to count the number of policies for each type.", "Group the results by 'Policy_Type_Code' to aggregate the counts for each type.", "Order the results in descending order based on the frequency count to get the most common policy type at the top.", "Limit the results to 1 to get only the most frequently used policy type."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(*) AS Frequency\nFROM Policies\nGROUP BY Policy_Type_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1513", "db_id": "insurance_and_eClaims", "question": "Find all the policy types that are used by more than 2 customers.", "rationale": ["Identify the relevant table: The Policies table contains the Policy_Type_Code and Customer_ID, which are needed to answer the question.", "Determine the condition: We need to find policy types that are used by more than 2 customers. This means we need to count the number of distinct customers for each policy type.", "Use GROUP BY: We will group the results by Policy_Type_Code to count the number of customers associated with each policy type.", "Use HAVING clause: We will use the HAVING clause to filter out policy types that have 2 or fewer customers.", "Construct the SQL query: Combine the SELECT, FROM, WHERE, GROUP BY, and HAVING clauses to form the complete SQL query."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code\nFROM Policies\nWHERE Customer_ID IN (\n    SELECT Customer_ID\n    FROM Policies\n    GROUP BY Customer_ID\n    HAVING COUNT(DISTINCT Customer_ID) > 2\n)\nGROUP BY Policy_Type_Code;", "hint": "\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["Identify the relevant table: Claim_Headers, which contains the Amount_Paid column.", "To find the total amount paid, use the SUM() function on the Amount_Paid column.", "To find the average amount paid, use the AVG() function on the Amount_Paid column.", "Construct the SQL query to select both the total and average amounts from the Claim_Headers table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\"\n}\n"}
{"sample_id": "train.1518", "db_id": "insurance_and_eClaims", "question": "How much amount in total were claimed in the most recently created document?", "rationale": ["Identify the relevant tables: Claim_Headers for the amount claimed and Claims_Documents for the document creation date.", "We need to sum the 'Amount_Claimed' from the Claim_Headers table.", "Join Claim_Headers with Claims_Documents on the Claim_ID to link claims with their documents.", "Filter the results to only include claims that have documents created on the most recent date.", "Use a subquery to find the maximum 'Created_Date' from the Claims_Documents table to get the most recent document creation date."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT SUM(ch.Amount_Claimed) AS Total_Claimed_Amount\nFROM Claim_Headers ch\nJOIN Claims_Documents cd ON ch.Claim_Header_ID = cd.Claim_ID\nWHERE cd.Created_Date = (\n    SELECT MAX(Created_Date)\n    FROM Claims_Documents\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\"\n}\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers are needed to find the customer details and their claims.", "Join the Customers table with the Policies table on Customer_ID to link customers to their policies.", "Join the resulting table with the Claim_Headers table on Policy_ID to access the claims made by each customer.", "Order the results by the Amount_Claimed in descending order to get the claim with the largest amount at the top.", "Limit the results to 1 to get only the customer with the largest claim."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details\nFROM Customers c\nJOIN Policies p ON c.Customer_ID = p.Customer_ID\nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID\nORDER BY ch.Amount_Claimed DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\"\n}\n"}
{"sample_id": "train.1521", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the minimum amount of payment in one claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers.", "We need to find the customer who has made the minimum amount of payment in one claim, which involves the Amount_Paid column in the Claim_Headers table.", "Join the Customers table with the Policies table on Customer_ID to link customers to their policies.", "Then, join the Claim_Headers table on Policy_ID to link policies to their claims.", "Use ORDER BY to sort the claims by Amount_Paid in ascending order to find the minimum payment.", "Limit the results to 1 to get the customer with the minimum payment."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID \nORDER BY ch.Amount_Paid ASC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1531", "db_id": "insurance_and_eClaims", "question": "Find the names of the customers who have an deputy policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Select the Customer_Details from the Customers table.", "Filter the results to include only those policies with a Policy_Type_Code of 'deputy'.", "Use DISTINCT to ensure that each customer's name appears only once in the results."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT DISTINCT Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Policy_Type_Code = 'deputy';", "hint": "\n"}
{"sample_id": "train.1533", "db_id": "insurance_and_eClaims", "question": "Find the names of customers who either have an deputy policy or uniformed policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Select the required fields: We need the Customer_Details from the Customers table.", "Filter the results based on the Policy_Type_Code: We want policies that are either 'deputy' or 'uniformed'.", "Construct the SQL query using JOIN to combine the tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy' OR t1.policy_type_code  =  'Uniform'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT DISTINCT Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Policy_Type_Code IN ('deputy', 'uniformed');", "hint": "\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find the customer who started a policy most recently, so we will join the Customers table with the Policies table on the Customer_ID.", "We will select the Customer_ID and Customer_Details from the Customers table, and the Start_Date from the Policies table.", "To find the most recent policy start date, we will order the results by Start_Date in descending order.", "Finally, we will limit the results to 1 to get only the most recent customer."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details, Policies.Start_Date\nFROM Customers\nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID\nORDER BY Policies.Start_Date DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers are needed to get account details for a specific customer.", "Determine the columns to select: We need account_id, account_name, and other_account_details from the Accounts table.", "Establish the relationship between tables: Use the customer_id to join Accounts and Customers tables.", "Filter the results: We need to filter the results to only include accounts for the customer with the first name 'Meaghan'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT a.account_id, a.account_name, a.other_account_details \nFROM Accounts a \nJOIN Customers c ON a.customer_id = c.customer_id \nWHERE c.customer_first_name = 'Meaghan';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"1\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"2\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\"\n}\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Accounts and Customers are needed to get account details for a specific customer.", "Join the Accounts table with the Customers table on the customer_id to link accounts to the customer.", "Filter the results to only include the customer named Meaghan Keeling by using the WHERE clause with the customer's first and last name.", "Select the desired columns from the Accounts table, which include account_id, account_name, date_account_opened, and other_account_details."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT a.account_id, a.account_name, a.date_account_opened, a.other_account_details \nFROM Accounts a \nJOIN Customers c ON a.customer_id = c.customer_id \nWHERE c.customer_first_name = 'Meaghan' AND c.customer_last_name = 'Keeling';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"1\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"2\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\"\n}\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts are needed to get customer names and account details.", "Join the Customers table with the Accounts table on the customer_id to link customers with their accounts.", "Filter the results to only include accounts with the name '900'.", "Select the full name of the customers by concatenating their first and last names."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name \nFROM Customers \nJOIN Accounts ON Customers.customer_id = Accounts.customer_id \nWHERE Accounts.account_name = '900';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"1\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\"\n}\n"}
{"sample_id": "train.1568", "db_id": "customers_and_invoices", "question": "Return the id and full name of the customer with the most accounts.", "rationale": ["Identify the relevant tables: Customers and Accounts are needed to get customer details and their associated accounts.", "Join the Customers table with the Accounts table on the customer_id to link customers with their accounts.", "Group the results by customer_id to count the number of accounts each customer has.", "Order the results by the count of accounts in descending order to find the customer with the most accounts.", "Limit the results to 1 to get only the customer with the highest account count."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Accounts a\nJOIN Customers c ON a.customer_id = c.customer_id\nGROUP BY c.customer_id\nORDER BY COUNT(a.account_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"1\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"2\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\"\n}\n"}
{"sample_id": "train.1579", "db_id": "customers_and_invoices", "question": "How many transaction does each account have? Show the number and account id.", "rationale": ["We need to count the number of transactions for each account, which involves the 'Accounts' and 'Financial_Transactions' tables.", "We will select the 'account_id' from the 'Accounts' table and count the 'transaction_id' from the 'Financial_Transactions' table.", "To get the count of transactions per account, we will use a LEFT JOIN to ensure we include accounts even if they have no transactions.", "We will group the results by 'account_id' to get the count of transactions for each account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT a.account_id, COUNT(ft.transaction_id) AS transaction_count\nFROM Accounts a\nLEFT JOIN Financial_Transactions ft ON a.account_id = ft.account_id\nGROUP BY a.account_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n    \"1\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"2\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\"\n}\n"}
{"sample_id": "train.1589", "db_id": "customers_and_invoices", "question": "Show the account name, id and the number of transactions for each account.", "rationale": ["We need to retrieve the account name and account ID from the Accounts table.", "We also need to count the number of transactions associated with each account from the Financial_Transactions table.", "To achieve this, we will perform a LEFT JOIN between the Accounts table and the Financial_Transactions table on the account_id.", "We will use COUNT() to count the transaction IDs for each account, which will give us the number of transactions.", "Finally, we will group the results by account_id and account_name to ensure we get the correct counts for each account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "pred_sql": "SELECT a.account_name, a.account_id, COUNT(ft.transaction_id) AS number_of_transactions\nFROM Accounts a\nLEFT JOIN Financial_Transactions ft ON a.account_id = ft.account_id\nGROUP BY a.account_id, a.account_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n    \"1\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"2\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\"\n}\n"}
{"sample_id": "train.1599", "db_id": "customers_and_invoices", "question": "Show the invoice number and the number of transactions for each invoice.", "rationale": ["Identify the tables involved: Invoices and Financial_Transactions.", "We need to retrieve the invoice number from the Invoices table.", "We need to count the number of transactions associated with each invoice from the Financial_Transactions table.", "Join the Invoices table with the Financial_Transactions table on the invoice_number field to associate transactions with their respective invoices.", "Use COUNT() function to count the number of transactions for each invoice.", "Group the results by invoice_number to get the count for each invoice."], "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"], "pred_sql": "SELECT Invoices.invoice_number, COUNT(Financial_Transactions.transaction_id) AS transaction_count\nFROM Invoices\nLEFT JOIN Financial_Transactions ON Invoices.invoice_number = Financial_Transactions.invoice_number\nGROUP BY Invoices.invoice_number;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n    \"1\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n    \"2\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\"\n}\n"}
{"sample_id": "train.1602", "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?", "rationale": ["We need to find the invoice number and invoice date for the invoice with the greatest number of transactions.", "To do this, we will first summarize the total number of transactions associated with each invoice using the Financial_Transactions table.", "We will group the results by invoice_number and count the number of transaction_ids for each invoice.", "Next, we will join this summary with the Invoices table to get the corresponding invoice details.", "Finally, we will order the results by the transaction count in descending order and limit the results to 1 to get the invoice with the greatest number of transactions."], "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"], "pred_sql": "SELECT i.invoice_number, i.invoice_date\nFROM Invoices i\nJOIN (\n    SELECT ft.invoice_number, COUNT(ft.transaction_id) AS transaction_count\n    FROM Financial_Transactions ft\n    GROUP BY ft.invoice_number\n) AS transaction_summary ON i.invoice_number = transaction_summary.invoice_number\nORDER BY transaction_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n    \"1\": \"This virtual table provides a list of order IDs and their corresponding details from the 'Orders' table, specifically for those orders that are associated with invoices. The results are grouped by order ID, and only those orders that have more than a specified number of associated invoices are included. The placeholder in the HAVING clause represents the minimum count of invoices required for an order to be displayed.\"\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["Identify the relevant table: The 'Order_Items' table contains the order details and the items associated with each order.", "Select the order_id: We need to retrieve the order IDs from the 'Order_Items' table.", "Count the number of items: Use the COUNT function to count the distinct order_item_id for each order_id.", "Group the results: Use GROUP BY to group the results by order_id to get the count of items for each order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT oi.order_id, COUNT(oi.order_item_id) AS number_of_items\nFROM Order_Items oi\nGROUP BY oi.order_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of distinct products associated with each order from the 'Order_Items' table. The placeholder in the SELECT clause represents the order identifier, while the count function calculates the unique product count for each order.\",\n    \"1\": \"This virtual table provides a list of order IDs and their corresponding details from the 'Orders' table, specifically for those orders that are associated with invoices. The results are grouped by order ID, and only those orders that have more than a specified number of associated invoices are included. The placeholder in the HAVING clause represents the minimum count of invoices required for an order to be displayed.\",\n    \"2\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\"\n}\n"}
{"sample_id": "train.2049", "db_id": "party_people", "question": "Show all ministers who do not belong to Progress Party.", "rationale": ["Identify the relevant tables: 'party' for political parties and 'member' for members.", "We need to find ministers, which are associated with the 'party' table.", "Join the 'party' table with the 'member' table on the Party_ID to get the members associated with each party.", "Filter the results to exclude members from the 'Progress Party'.", "Also, ensure that we only select members who are currently in office (In_office = 'Yes').", "Select distinct ministers from the resulting joined table."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT DISTINCT minister.* \nFROM party AS p \nJOIN member AS m ON p.Party_ID = m.Party_ID \nWHERE p.Party_name != 'Progress Party' AND m.In_office = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement represents the party's name, and the count function aggregates the total number of members for each party.\",\n    \"1\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT clause represents the party name, while the count function aggregates the total number of events for each party.\"\n}\n"}
{"sample_id": "train.2058", "db_id": "party_people", "question": "How many members are in each party?", "rationale": ["Identify the tables involved: 'member' and 'party'.", "We need to count the number of members in each party, so we will use the COUNT() function.", "Join the 'party' table with the 'member' table on the Party_ID to associate members with their respective parties.", "Group the results by party name to get the count of members for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT party.Party_name, COUNT(member.Member_ID) AS Member_Count\nFROM party\nLEFT JOIN member ON party.Party_ID = member.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement represents the party's name, and the count function aggregates the total number of members for each party.\",\n    \"1\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT clause represents the party name, while the count function aggregates the total number of events for each party.\"\n}\n"}
{"sample_id": "train.2071", "db_id": "party_people", "question": "Show party names and the number of events for each party.", "rationale": ["We need to retrieve the names of the political parties and the number of events they have organized.", "To do this, we will select the 'Party_name' from the 'party' table.", "We will use the COUNT function to count the number of events from the 'party_events' table.", "To link the two tables, we will perform a LEFT JOIN on the 'Party_ID' column, which is common to both tables.", "Finally, we will group the results by 'Party_name' to get the count of events for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT party.Party_name, COUNT(party_events.Event_ID) AS Number_of_Events\nFROM party\nLEFT JOIN party_events ON party.Party_ID = party_events.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT clause represents the party name, while the count function aggregates the total number of events for each party.\",\n    \"1\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement represents the party's name, and the count function aggregates the total number of members for each party.\"\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the relevant tables: 'party_events', 'party', and 'region'.", "We need to count the number of events, so we will use the COUNT() function.", "Join the 'party_events' table with the 'party' table on Party_ID to get the party names associated with the events.", "Join the 'party' table with the 'region' table on Region_ID to filter events by the region name.", "Add a WHERE clause to filter for events specifically named 'Annual Meeting'.", "Add another condition in the WHERE clause to filter for the region name 'United Kingdom'.", "Select the count of events that meet these criteria."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT COUNT(*) AS Annual_Meeting_Count \nFROM party_events pe \nJOIN party p ON pe.Party_ID = p.Party_ID \nJOIN region r ON p.Region_ID = r.Region_ID \nWHERE pe.Event_Name = 'Annual Meeting' \nAND r.Region_name = 'United Kingdom';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT clause represents the party name, while the count function aggregates the total number of events for each party.\"\n}\n"}
{"sample_id": "train.2176", "db_id": "formula_1", "question": "What are the names and years of all races that had a driver with the last name Lewis?", "rationale": ["We need to find the names and years of all races that had a driver with the last name 'Lewis'.", "To do this, we will join the 'races' table with the 'results' table on the raceId, as the results table contains the driverId for each race.", "Next, we will join the 'drivers' table to get the surname of the drivers associated with each result.", "Finally, we will filter the results to only include those where the driver's surname is 'Lewis'.", "We will select the distinct names of the races and their corresponding years to avoid duplicates."], "gold_sql": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = 'Lewis'", "source_tables": ["results", "drivers", "races"], "pred_sql": "SELECT DISTINCT races.name, races.year \nFROM races \nJOIN results ON races.raceId = results.raceId \nJOIN drivers ON results.driverId = drivers.driverId \nWHERE drivers.surname = 'Lewis';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the tables needed: We need the 'drivers' table to get the first and last names, and the 'results' and 'races' tables to filter by race participation.", "Join the 'drivers' table with the 'results' table to link drivers to their race results.", "Join the 'results' table with the 'races' table to filter for the Australian Grand Prix.", "Use a subquery to find drivers who participated in the Chinese Grand Prix and exclude them from the main query results.", "Select the first and last names of drivers who participated in the Australian Grand Prix but not in the Chinese Grand Prix."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.forename, d.surname \nFROM drivers d \nJOIN results r1 ON d.driverId = r1.driverId \nJOIN races ra ON r1.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' \nAND d.driverId NOT IN (\n    SELECT d2.driverId \n    FROM drivers d2 \n    JOIN results r2 ON d2.driverId = r2.driverId \n    JOIN races rb ON r2.raceId = rb.raceId \n    WHERE rb.name = 'Chinese Grand Prix'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2183", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who was in position 1 as standing and won?", "rationale": ["Identify the relevant tables: drivers and driverStandings.", "We need to find distinct drivers who were in position 1 and also won races.", "Join the drivers table with the driverStandings table on driverId to access both driver information and their standings.", "Filter the results where the position in the standings is 1 and the number of wins is greater than 0.", "Select the distinct forenames of the drivers that meet these criteria."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.wins > 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2185", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["We need to find distinct drivers who won in position 1 and had more than 20 points.", "To do this, we will select the 'forename' from the 'drivers' table.", "We will join the 'drivers' table with the 'driverStandings' table on the 'driverId' to get the standings of each driver.", "We will filter the results where the 'position' in the standings is 1 (indicating a win) and the 'points' are greater than 20.", "Using DISTINCT ensures that we only get unique forenames of the drivers."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2186", "db_id": "formula_1", "question": "What are the first names of the different drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["Identify the relevant table: We need to find drivers who won in position 1 and had more than 20 points, which involves the 'drivers' and 'driverStandings' tables.", "Join the 'drivers' table with the 'driverStandings' table on the 'driverId' to access both driver information and their standings.", "Filter the results to include only those drivers who have a position of 1 in the standings and have more than 20 points.", "Select the distinct first names of these drivers to avoid duplicates."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\"\n}\n"}
{"sample_id": "train.2189", "db_id": "formula_1", "question": "What are the numbers of races for each constructor id?", "rationale": ["We need to find the number of races for each constructor id.", "The relevant table for this information is 'constructorResults', which links constructors to races.", "We will use the COUNT function to count the number of races (raceId) for each constructor (constructorId).", "We will group the results by constructorId to get the count for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(raceId) AS number_of_races\nFROM constructorResults\nGROUP BY constructorId;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table counts the distinct number of drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.\"\n}\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the table that contains information about constructors, which is the 'constructors' table.", "We need to filter constructors based on their nationality, specifically 'Japanese'.", "We also need to check if these constructors have earned more than 5 points.", "To do this, we will use a subquery on the 'constructorResults' table to sum the points for each constructor and filter those with a sum greater than 5.", "The final query will select the names of constructors from the 'constructors' table where the nationality is 'Japanese' and the constructorId is in the list of constructorIds that have more than 5 points."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT name FROM constructors WHERE nationality = 'Japanese' AND constructorId IN (SELECT constructorId FROM constructorResults GROUP BY constructorId HAVING SUM(points) > 5);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: lapTimes, races, and circuits are needed to find the average fastest lap speed for a specific race.", "The lapTimes table contains the fastest lap speed, while the races table provides the year and the circuitId for the Monaco Grand Prix in 2008.", "The circuits table is used to filter for the specific race name 'Monaco Grand Prix'.", "Join the lapTimes table with the races table on raceId, and then join the races table with the circuits table on circuitId.", "Filter the results to only include the Monaco Grand Prix in the year 2008.", "Calculate the average of the fastest lap speeds using the AVG() function."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(fastestLapSpeed) AS average_fastest_lap_speed\nFROM lapTimes\nJOIN races ON lapTimes.raceId = races.raceId\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE circuits.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2221", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["Identify the relevant tables: We need to find the fastest lap speed for a specific race, which involves the 'results' and 'races' tables.", "Determine the filtering criteria: The race name is 'Monaco Grand Prix' and the year is 2008.", "Join the 'results' table with the 'races' table on the raceId to access the race details along with the results.", "Use the MAX function to find the maximum fastest lap speed from the results for the specified race."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(fastestLapSpeed) AS max_fastest_lap_speed \nFROM results \nJOIN races ON results.raceId = races.raceId \nWHERE races.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races and lapTimes are needed to find the fastest lap speed for the Monaco Grand Prix in 2008.", "We need to join the races table with the lapTimes table on the raceId to access the fastest lap speed for the specific race.", "Filter the results to only include the Monaco Grand Prix in the year 2008 using the WHERE clause.", "Use the MAX function to find the maximum fastest lap speed from the filtered results."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(lapTimes.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races\nJOIN lapTimes ON races.raceId = lapTimes.raceId\nWHERE races.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["Identify the relevant tables: We need data from the 'races' table for race names and years, and the 'lapTimes' table for fastest lap speeds.", "Join the 'races' table with the 'lapTimes' table on the raceId to correlate races with their lap times.", "Filter the results to include only races that occurred after the year 2004 using the WHERE clause.", "Group the results by race name and year to calculate the maximum fastest lap speed for each race.", "Select the race name and the maximum fastest lap speed, and order the results by year."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races r\nJOIN lapTimes l ON r.raceId = l.raceId\nWHERE r.year > 2004\nGROUP BY r.name, r.year\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2225", "db_id": "formula_1", "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the relevant tables: We need the 'races' table for race names and years, and the 'lapTimes' table for fastest lap speeds.", "Join the 'races' table with the 'lapTimes' table on the raceId to associate each lap time with its corresponding race.", "Filter the results to include only races held after the year 2004 using a WHERE clause.", "Group the results by race name to calculate the average fastest lap speed for each race.", "Use the AVG() function to calculate the average fastest lap speed for each race.", "Order the results by year to see the average fastest lap speeds in chronological order."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name AS race_name, AVG(lap.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races r\nJOIN lapTimes lap ON r.raceId = lap.raceId\nWHERE r.year > 2004\nGROUP BY r.name\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n    \"1\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n    \"2\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2226", "db_id": "formula_1", "question": "What is the average fastest lap speed for races held after 2004, for each race, ordered by year?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to get the race year, results, and fastest lap speed.", "Join the races table with the results table on raceId to link races with their results.", "Join the results table with the lapTimes table on raceId and driverId to get the fastest lap speed for each driver in each race.", "Filter the results to include only races held after the year 2004 using the WHERE clause.", "Group the results by year to calculate the average fastest lap speed for each race year using AVG function.", "Order the final results by year to present the data in chronological order."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.year, AVG(lap.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN lapTimes lap ON res.raceId = lap.raceId AND res.driverId = lap.driverId\nWHERE r.year > 2004\nGROUP BY r.year\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n    \"1\": \"This virtual table counts the distinct number of drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.\",\n    \"2\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\"\n}\n"}
{"sample_id": "train.2243", "db_id": "machine_repair", "question": "What is the starting year of the oldest technicians?", "rationale": ["Identify the relevant table: The 'technician' table contains the information about technicians, including their starting years.", "Determine the required information: We need to find the oldest starting year among all technicians.", "Use the MIN() function: To find the oldest starting year, we can use the MIN() function on the 'Starting_Year' column.", "Construct the SQL query: The query will select the minimum starting year from the technician table."], "gold_sql": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT MIN(Starting_Year) AS oldest_starting_year FROM technician;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the starting years of technicians from the 'technician' table who belong to two specific teams. The placeholders in the WHERE clause represent the identifiers for the teams being compared.\",\n    \"1\": \"This virtual table provides a summary of the number of repair assignments handled by each technician. It joins the 'repair_assignment' table with the 'technician' table to associate each assignment with the technician's name. The result is grouped by the technician's name, allowing for a count of assignments per technician.\"\n}\n"}
{"sample_id": "train.2248", "db_id": "machine_repair", "question": "What are the teams with the most technicians?", "rationale": ["We need to find the teams with the most technicians, which requires counting the number of technicians in each team.", "We will select the 'Team' column from the 'technician' table and count the number of 'technician_id' for each team.", "To get the count of technicians per team, we will use the GROUP BY clause on the 'Team' column.", "Finally, we will order the results in descending order based on the count of technicians to identify the teams with the most technicians."], "gold_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT Team, COUNT(technician_id) AS technician_count\nFROM technician\nGROUP BY Team\nORDER BY technician_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the starting years of technicians from the 'technician' table who belong to two specific teams. The placeholders in the WHERE clause represent the identifiers for the teams being compared.\",\n    \"1\": \"This virtual table provides a summary of the number of repair assignments handled by each technician. It joins the 'repair_assignment' table with the 'technician' table to associate each assignment with the technician's name. The result is grouped by the technician's name, allowing for a count of assignments per technician.\"\n}\n"}
{"sample_id": "train.2258", "db_id": "machine_repair", "question": "What are the names of the technicians  and how many machines are they assigned to repair?", "rationale": ["Identify the tables needed: technician and repair_assignment.", "We need the names of technicians, which are in the technician table.", "We also need to count the number of machines assigned to each technician, which can be found in the repair_assignment table.", "Join the technician table with the repair_assignment table on the technician_id to associate technicians with their repair assignments.", "Use COUNT() to count the number of Machine_IDs for each technician, which represents the number of machines they are assigned to.", "Group the results by technician's name to get the count for each technician."], "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name", "source_tables": ["repair_assignment", "technician"], "pred_sql": "SELECT technician.Name, COUNT(repair_assignment.Machine_ID) AS machine_count\nFROM technician\nLEFT JOIN repair_assignment ON technician.technician_id = repair_assignment.technician_id\nGROUP BY technician.Name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the number of repair assignments handled by each technician. It joins the 'repair_assignment' table with the 'technician' table to associate each assignment with the technician's name. The result is grouped by the technician's name, allowing for a count of assignments per technician.\",\n    \"1\": \"This virtual table retrieves the starting years of technicians from the 'technician' table who belong to two specific teams. The placeholders in the WHERE clause represent the identifiers for the teams being compared.\"\n}\n"}
{"sample_id": "train.2328", "db_id": "csu_1", "question": "Find all the campuses opened in 1958.", "rationale": ["Identify the relevant table: Campuses, as it contains information about the year campuses were opened.", "Focus on the 'Year' column to filter campuses opened in 1958.", "Construct the SQL query to select the 'Campus' from the 'Campuses' table where the 'Year' is '1958'."], "gold_sql": "SELECT campus FROM campuses WHERE YEAR  =  1958", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE Year = '1958';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\"\n}\n"}
{"sample_id": "train.2334", "db_id": "csu_1", "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.", "rationale": ["Identify the relevant table: The 'Campuses' table contains the information about campus names and their locations.", "Determine the conditions: We need to find campuses that are either in 'Northridge, Los Angeles' or in 'San Francisco, San Francisco'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' column from the 'Campuses' table, applying a WHERE clause to filter based on the specified locations and counties. The OR operator is used to combine the two conditions."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE (Location = 'Northridge' AND County = 'Los Angeles') OR (Location = 'San Francisco' AND County = 'San Francisco');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table retrieves the names of campuses from the 'Campuses' table that are located in a specific geographical location and county. The query uses placeholders for the location and county to allow for flexible input.\",\n    \"2\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\"\n}\n"}
{"sample_id": "train.2350", "db_id": "csu_1", "question": "Which campus has the most faculties in year 2003?", "rationale": ["Identify the relevant tables: 'Campuses' and 'faculty' are needed to find the campus with the most faculty members.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier to combine campus names with their respective faculty counts.", "Filter the results to only include records from the year 2003, as specified in the question.", "Order the results by the number of faculty members in descending order to get the campus with the most faculty at the top.", "Limit the results to 1 to get only the campus with the highest number of faculty members."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT c.Campus, f.Faculty \nFROM Campuses c \nJOIN faculty f ON c.Id = f.Campus \nWHERE f.Year = 2003 \nORDER BY f.Faculty DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\"\n}\n"}
{"sample_id": "train.2356", "db_id": "csu_1", "question": "report the total number of degrees granted between 1998 and 2002.", "rationale": ["Identify the relevant table: The 'degrees' table contains information about degrees awarded, including the year and the number of degrees.", "Determine the columns needed: We need to sum the 'Degrees' column to get the total number of degrees awarded.", "Apply the filter: We need to filter the records for the years between 1998 and 2002 using the WHERE clause with the BETWEEN operator.", "Construct the SQL query: Combine the SELECT statement with the SUM function and the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(Degrees) AS TotalDegrees\nFROM degrees\nWHERE Year BETWEEN '1998' AND '2002';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n    \"2\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\"\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: degrees and Campuses.", "We need to count the total number of degrees granted after the year 2000, so we will use the COUNT function on the Degrees column from the degrees table.", "We need to filter the results to only include campuses located in Orange county and degrees awarded after the year 2000.", "To achieve this, we will join the degrees table with the Campuses table on the Campus identifier.", "We will use a WHERE clause to filter for the county 'Orange' and years greater than 2000.", "Finally, we will group the results by the Campus name to get the total degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT Campuses.Campus, COUNT(degrees.Degrees) AS TotalDegrees\nFROM degrees\nJOIN Campuses ON degrees.Campus = Campuses.Id\nWHERE Campuses.County = 'Orange' AND degrees.Year > '2000'\nGROUP BY Campuses.Campus;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"2\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\"\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant tables: Campuses and enrollments.", "We need to find campuses with specific enrollment criteria: total enrollment greater than 400 and full-time equivalent (FTE) enrollment greater than 200.", "Join the Campuses table with the enrollments table on the campus identifier.", "Filter the results based on the specified conditions for total enrollment and FTE enrollment for the year 1956."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT c.Campus \nFROM Campuses c \nJOIN enrollments e ON c.Id = e.Campus \nWHERE e.TotalEnrollment_AY > 400 \nAND e.FTE_AY > 200 \nAND e.Year = '1956';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\"\n}\n"}
{"sample_id": "train.2363", "db_id": "csu_1", "question": "What campus started in year 1956, has more than 200 full time students, and more than 400 students enrolled?", "rationale": ["Identify the relevant tables: Campuses, enrollments, and faculty are needed to answer the question.", "Join the Campuses table with the enrollments and faculty tables using the campus identifier.", "Filter the results to only include campuses that started in the year 1956.", "Add conditions to ensure that the full-time equivalent (FTE) enrollments are greater than 200 and total enrollments are greater than 400."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT c.Campus, e.TotalEnrollment_AY, f.FTE_AY \nFROM Campuses c \nJOIN enrollments e ON c.Id = e.Campus \nJOIN faculty f ON c.Id = f.Campus \nWHERE c.Year = '1956' \nAND f.FTE_AY > '200' \nAND e.TotalEnrollment_AY > '400';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"2\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\"\n}\n"}
{"sample_id": "train.2366", "db_id": "csu_1", "question": "List the campuses in Los Angeles county.", "rationale": ["Identify the relevant table: The 'Campuses' table contains information about campuses, including their location and county.", "Determine the filtering criteria: We need to filter campuses based on the county, specifically 'Los Angeles'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' names from the 'Campuses' table where the 'County' matches 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the names of campuses from the 'Campuses' table that are located in a specific geographical location and county. The query uses placeholders for the location and county to allow for flexible input.\",\n    \"1\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\"\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: degrees and Campuses.", "We need to find the total number of degrees conferred, so we will use the SUM function on the Degrees column from the degrees table.", "We need to filter the results to only include degrees awarded in the year 2000, so we will add a WHERE clause for the Year column.", "We also need to filter by the specific campus, 'San Jose State University', so we will join the degrees table with the Campuses table on the Campus identifier and add another condition in the WHERE clause."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(Degrees) AS TotalDegreesConferred \nFROM degrees \nJOIN Campuses ON degrees.Campus = Campuses.Id \nWHERE Campuses.Campus = 'San Jose State University' AND degrees.Year = '2000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n    \"2\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\"\n}\n"}
{"sample_id": "train.2374", "db_id": "csu_1", "question": "What is the number of faculty lines in campus \"Long Beach State University\" in 2002?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to filter by campus name.", "Filter the results to only include records for 'Long Beach State University' and the year 2002.", "Count the number of faculty lines for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2002 AND T2.campus  =  'Long Beach State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) AS NumberOfFacultyLines \nFROM faculty f \nJOIN Campuses c ON f.Campus = c.Id \nWHERE c.Campus = 'Long Beach State University' AND f.Year = 2002;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\"\n}\n"}
{"sample_id": "train.2376", "db_id": "csu_1", "question": "How many faculty lines are there in \"San Francisco State University\" in year 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to filter by campus name.", "Filter the results to only include records for 'San Francisco State University' and the year 2004.", "Count the number of faculty lines for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) AS FacultyCount \nFROM faculty f \nJOIN Campuses c ON f.Campus = c.Id \nWHERE c.Campus = 'San Francisco State University' AND f.Year = 2004;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\"\n}\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to access the campus name.", "Filter the results to only include records for 'San Francisco State University' and the year 2004.", "Count the number of faculty lines for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) AS FacultyCount \nFROM faculty \nJOIN Campuses ON faculty.Campus = Campuses.Id \nWHERE Campuses.Campus = 'San Francisco State University' AND faculty.Year = 2004;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\"\n}\n"}
{"sample_id": "train.2381", "db_id": "csu_1", "question": "How many faculty members did the university that conferred the most degrees in 2002 have?", "rationale": ["Identify the year of interest, which is 2002, for the degrees awarded.", "Determine which campus conferred the most degrees in 2002 by grouping the degrees table by campus and counting the number of degrees awarded, ordering by the count in descending order, and limiting the result to the top campus.", "Join the faculty table with the degrees table on the campus identifier to get the faculty count for the campus that awarded the most degrees in 2002.", "Select the faculty count for that specific campus."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty f \nJOIN degrees d ON f.Campus = d.Campus \nWHERE d.Year = '2002' \nAND d.Campus = (SELECT d2.Campus \n                FROM degrees d2 \n                WHERE d2.Year = '2002' \n                GROUP BY d2.Campus \n                ORDER BY COUNT(d2.Degrees) DESC \n                LIMIT 1)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\"\n}\n"}
{"sample_id": "train.2382", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the least number of degrees in year 2001?", "rationale": ["Identify the year of interest, which is 2001, to filter the degrees awarded.", "Join the faculty table with the degrees table on the Campus identifier to correlate faculty data with degree data.", "Group the results by campus to count the number of degrees awarded for each campus in 2001.", "Order the campuses by the count of degrees awarded in ascending order to find the campus with the least number of degrees conferred.", "Limit the results to 1 to get only the campus with the least number of degrees awarded.", "Count the number of faculty lines associated with that campus."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(faculty.Campus) AS FacultyCount\nFROM faculty\nJOIN degrees ON faculty.Campus = degrees.Campus\nWHERE degrees.Year = '2001'\nGROUP BY faculty.Campus\nORDER BY COUNT(degrees.Degrees) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\"\n}\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the year of interest, which is 2001, for both degrees and faculty.", "Create a subquery to count the total number of degrees awarded for each campus in 2001.", "Order the results of the subquery by the total number of degrees in ascending order to find the campus with the least degrees awarded.", "Limit the results of the subquery to 1 to get only the campus with the least degrees.", "Join the faculty table with the subquery on the campus identifier to get the faculty count for that campus.", "Select the faculty count for the campus that awarded the least number of degrees in 2001."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty f \nJOIN (\n    SELECT Campus, COUNT(Degrees) AS TotalDegrees \n    FROM degrees \n    WHERE Year = '2001' \n    GROUP BY Campus \n    ORDER BY TotalDegrees ASC \n    LIMIT 1\n) d ON f.Campus = d.Campus \nWHERE f.Year = '2001';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\"\n}\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "Determine the specific campus of interest, which is 'San Jose State'.", "Use a subquery to find the 'Id' of 'San Jose State' from the 'Campuses' table.", "Sum the 'Undergraduate' column from the 'discipline_enrollments' table where the 'Campus' matches the 'Id' of 'San Jose State'."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT SUM(Undergraduate) AS TotalUndergraduates\nFROM discipline_enrollments\nWHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Jose State');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\"\n}\n"}
{"sample_id": "train.2397", "db_id": "candidate_poll", "question": "Return the poll resource associated with the most candidates.", "rationale": ["Identify the relevant table: The 'candidate' table contains the 'Poll_Source' and 'Candidate_ID' columns needed for this query.", "Count the number of candidates associated with each poll source: Use COUNT(Candidate_ID) to count the candidates for each Poll_Source.", "Group the results by Poll_Source: Use GROUP BY Poll_Source to aggregate the counts for each source.", "Order the results by the count of candidates in descending order: Use ORDER BY Candidate_Count DESC to get the poll source with the most candidates at the top.", "Limit the results to the top entry: Use LIMIT 1 to return only the poll source associated with the most candidates."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source, COUNT(Candidate_ID) AS Candidate_Count\nFROM candidate\nGROUP BY Poll_Source\nORDER BY Candidate_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n    \"1\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\"\n}\n"}
{"sample_id": "train.2405", "db_id": "candidate_poll", "question": "Return the poll source corresponding to the candidate who has the oppose rate.", "rationale": ["Identify the relevant table: The 'candidate' table contains the 'Poll_Source' and 'Oppose_rate' columns.", "Determine the condition: We need to find candidates who have an oppose rate, which implies checking for non-null values in the 'Oppose_rate' column.", "Construct the SQL query: We will select the 'Poll_Source' from the 'candidate' table where the 'Oppose_rate' is not null."], "gold_sql": "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source FROM candidate WHERE Oppose_rate IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n    \"1\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\"\n}\n"}
{"sample_id": "train.2417", "db_id": "candidate_poll", "question": "For each sex, what is the name and sex of the candidate with the oppose rate for their sex?", "rationale": ["Identify the relevant tables: 'candidate' for candidate data and 'people' for personal details.", "Join the 'candidate' table with the 'people' table on the 'People_ID' to access both candidate and personal information.", "We need to find the candidate with the highest oppose rate for each sex. This requires a subquery to find the maximum oppose rate for each sex.", "The subquery selects the maximum oppose rate from the 'candidate' table, grouped by the sex of the candidates.", "The main query selects the name and sex of the candidates whose oppose rate matches the maximum oppose rate for their respective sex.", "Finally, order the results by sex to group the candidates accordingly."], "gold_sql": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex", "source_tables": ["candidate", "people"], "pred_sql": "SELECT p.Name, p.Sex, c.Oppose_rate \nFROM candidate c \nJOIN people p ON c.People_ID = p.People_ID \nWHERE c.Oppose_rate = (SELECT MAX(Oppose_rate) \n                       FROM candidate c2 \n                       JOIN people p2 ON c2.People_ID = p2.People_ID \n                       WHERE p2.Sex = p.Sex) \nORDER BY p.Sex;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n    \"1\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\"\n}\n"}
{"sample_id": "train.2434", "db_id": "movie_1", "question": "Find the titles of all movies directed by steven spielberg.", "rationale": ["Identify the relevant table: The 'Movie' table contains the information about movie titles and their directors.", "Determine the required columns: We need the 'title' column from the 'Movie' table.", "Specify the condition: We want movies directed by 'steven spielberg', so we will filter the results where the 'director' column matches 'steven spielberg'.", "Construct the SQL query: Using the SELECT statement to retrieve the titles from the Movie table with the specified condition."], "gold_sql": "SELECT title FROM Movie WHERE director = 'Steven Spielberg'", "source_tables": ["movie"], "pred_sql": "SELECT title FROM Movie WHERE director = 'steven spielberg';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles and directors of movies from the 'Movie' table that have the same director but different titles. The query uses a self-join on the 'Movie' table to compare movies directed by the same person, ensuring that the titles are not the same. The results are ordered by the director's name and the movie title.\",\n    \"1\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"2\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\"\n}\n"}
{"sample_id": "train.2461", "db_id": "movie_1", "question": "What are the different names of all reviewers whose ratings do not have a date field?", "rationale": ["Identify the tables involved: Reviewer and Rating.", "We need to find reviewers whose ratings do not have a date field, which means we need to check for NULL values in the ratingDate column of the Rating table.", "Join the Reviewer table with the Rating table on the reviewer ID (rID) to access the names of the reviewers along with their ratings.", "Use a SELECT DISTINCT statement to ensure we get unique reviewer names.", "Apply a WHERE clause to filter the results where the ratingDate is NULL."], "gold_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  'null'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nWHERE Rating.ratingDate IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"1\": \"This virtual table provides the average star ratings of movies from the 'Rating' table, excluding those rated by a specific reviewer. The placeholder in the subquery represents the reviewer's name whose ratings are to be excluded.\",\n    \"2\": \"This virtual table provides the average star ratings of movies from the 'Rating' table, excluding those rated by a specific reviewer. The placeholder in the subquery represents the reviewer's name whose ratings are to be excluded.\"\n}\n"}
{"sample_id": "train.2476", "db_id": "movie_1", "question": "Find the names of all reviewers who rated Gone with the Wind.", "rationale": ["Identify the tables involved: Movie, Reviewer, and Rating.", "We need to find the names of reviewers, so we will select the 'name' column from the Reviewer table.", "To link reviewers to their ratings, we will use the Rating table, which connects reviewers to movies via rID.", "We also need to filter the results to only include ratings for the movie 'Gone with the Wind', which requires joining the Movie table and using a WHERE clause to specify the title.", "The final SQL query will join these tables and apply the necessary filters to retrieve the desired information."], "gold_sql": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  'Gone with the Wind'", "source_tables": ["rating", "movie", "reviewer"], "pred_sql": "SELECT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nJOIN Movie ON Rating.mID = Movie.mID \nWHERE Movie.title = 'Gone with the Wind';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"1\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"2\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\"\n}\n"}
{"sample_id": "train.2483", "db_id": "movie_1", "question": "What are the names of all the reviewers and movie names?", "rationale": ["We need to retrieve the names of all reviewers and the titles of the movies they rated.", "To do this, we will join the Reviewer table with the Rating table on the reviewer ID (rID).", "Next, we will join the resulting table with the Movie table on the movie ID (mID) to get the movie titles.", "The final SQL query will select the reviewer's name and the movie title from the joined tables."], "gold_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "source_tables": ["movie", "reviewer"], "pred_sql": "SELECT Reviewer.name, Movie.title\nFROM Reviewer\nJOIN Rating ON Reviewer.rID = Rating.rID\nJOIN Movie ON Rating.mID = Movie.mID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"1\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n    \"2\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\"\n}\n"}
{"sample_id": "train.2495", "db_id": "movie_1", "question": "For each director, how many reviews have they received?", "rationale": ["We need to find out how many reviews each director has received.", "To do this, we will join the Movie table with the Rating table on the movie ID (mID).", "We will select the director's name from the Movie table and count the number of ratings (reviews) from the Rating table.", "The COUNT function will be used to count the number of reviews for each director.", "Finally, we will group the results by the director's name to get the total count of reviews for each director."], "gold_sql": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT Movie.director, COUNT(Rating.rID) AS review_count\nFROM Movie\nJOIN Rating ON Movie.mID = Rating.mID\nGROUP BY Movie.director;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"1\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"2\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\"\n}\n"}
{"sample_id": "train.2500", "db_id": "movie_1", "question": "What are the names and years of the movies that has the top 3 highest rating star?", "rationale": ["Identify the main goal: to find the names and years of movies with the top 3 highest ratings.", "The relevant tables are Movie and Rating, as we need movie details and their ratings.", "To get the top 3 highest ratings, we will first query the Rating table, ordering by the stars in descending order and limiting the results to 3.", "We will then use the mID from this subquery to filter the Movie table to get the corresponding titles and years.", "The final SQL query will select the title and year from the Movie table where the mID matches the top 3 ratings from the Rating table."], "gold_sql": "SELECT T2.title ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID ORDER BY T1.stars DESC LIMIT 3", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title, year \nFROM Movie \nWHERE mID IN (\n    SELECT mID \n    FROM Rating \n    ORDER BY stars DESC \n    LIMIT 3\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n    \"1\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"2\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\"\n}\n"}
{"sample_id": "train.2502", "db_id": "movie_1", "question": "For each director, return the director's name together with the title of the movie they directed that received the highest rating among all of their movies, and the value of that rating. Ignore movies whose director is NULL.", "rationale": ["We need to retrieve the director's name, the title of the movie they directed, and the highest rating for that movie.", "We will join the Movie table with the Rating table on the movie ID (mID) to access the ratings for each movie.", "We will filter out any movies where the director is NULL using a WHERE clause.", "To find the highest rating for each director, we will use the MAX function on the stars column from the Rating table.", "We will group the results by director and title to ensure we get the highest rating for each movie directed by the same director.", "Finally, we will use a HAVING clause to ensure that we only return the movie with the highest rating for each director. This involves a subquery that finds the maximum stars for movies directed by the same director."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT m.director, m.title, MAX(r.stars) AS highest_rating\nFROM Movie m\nJOIN Rating r ON m.mID = r.mID\nWHERE m.director IS NOT NULL\nGROUP BY m.director, m.title\nHAVING MAX(r.stars) = (SELECT MAX(stars) FROM Rating WHERE mID IN (SELECT mID FROM Movie WHERE director = m.director))", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"1\": \"This virtual table lists the titles and directors of movies from the 'Movie' table that have the same director but different titles. The query uses a self-join on the 'Movie' table to compare movies directed by the same person, ensuring that the titles are not the same. The results are ordered by the director's name and the movie title.\",\n    \"2\": \"This virtual table provides the unique movie identifiers along with the average star ratings from the 'Rating' table. It groups the results by movie ID and filters to include only those movies that have received a minimum number of ratings, as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.2503", "db_id": "movie_1", "question": "For each director, what are the titles and ratings for all the movies they reviewed?", "rationale": ["We need to retrieve the titles of movies, their ratings, and the names of the directors.", "The relevant tables are Movie, Rating, and Reviewer.", "We will join the Movie table with the Rating table on the movie ID (mID) to get the ratings for each movie.", "Next, we will join the Reviewer table on the reviewer ID (rID) to associate the ratings with the reviewers.", "Finally, we will select the title of the movie, the stars given in the rating, and the director's name.", "To organize the results, we will order the output by director and then by movie title."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT Movie.title, Rating.stars, Movie.director \nFROM Movie \nJOIN Rating ON Movie.mID = Rating.mID \nJOIN Reviewer ON Rating.rID = Reviewer.rID \nORDER BY Movie.director, Movie.title;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"1\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"2\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\"\n}\n"}
{"sample_id": "train.2505", "db_id": "movie_1", "question": "For each reviewer id, what is the title and rating for the movie with the smallest rating?", "rationale": ["We need to find the title and rating for the movie with the smallest rating for each reviewer id.", "To achieve this, we will first identify the minimum rating for each reviewer using a subquery that groups by reviewer id (rID) and selects the minimum stars.", "Next, we will join this result with the Rating table to get the corresponding movie id (mID) and stars for each reviewer.", "Finally, we will join the resulting table with the Movie table to get the title of the movie associated with each rating.", "The final query will select the reviewer id, movie title, and the minimum stars from the joined tables."], "gold_sql": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID", "source_tables": ["rating", "movie"], "pred_sql": "SELECT r.rID, m.title, r.stars \nFROM Rating r \nJOIN Movie m ON r.mID = m.mID \nWHERE (r.rID, r.stars) IN (\n    SELECT r2.rID, MIN(r2.stars) \n    FROM Rating r2 \n    GROUP BY r2.rID\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"1\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"2\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\"\n}\n"}
{"sample_id": "train.2507", "db_id": "movie_1", "question": "For each director, what is the title and score of their most poorly rated movie?", "rationale": ["We need to find the title and score of the most poorly rated movie for each director.", "To do this, we will join the Movie table with the Rating table on the movie ID (mID).", "We will select the title of the movie, the director's name, and the minimum star rating for each movie.", "We will group the results by director and movie title to aggregate the ratings.", "To find the most poorly rated movie for each director, we will use a HAVING clause to filter the results to only include movies that have the minimum star rating for that director."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT m.title, m.director, MIN(r.stars) AS min_stars\nFROM Movie m\nJOIN Rating r ON m.mID = r.mID\nGROUP BY m.director, m.title\nHAVING min_stars = (SELECT MIN(stars) FROM Rating WHERE mID = m.mID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"1\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"2\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\"\n}\n"}
{"sample_id": "train.2508", "db_id": "movie_1", "question": "What is the name of the movie that is rated by most of times?", "rationale": ["Identify the goal: We need to find the name of the movie that has been rated the most times.", "To achieve this, we will use the Rating table to count the number of ratings for each movie.", "We will group the results by movie ID (mID) to aggregate the ratings for each movie.", "Next, we will order the grouped results by the count of ratings in descending order to get the movie with the highest count at the top.", "Finally, we will limit the results to just one movie to get the top-rated movie.", "We will then select the title of that movie from the Movie table using the mID obtained from the previous step."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title FROM Movie WHERE mID IN (SELECT mID FROM Rating GROUP BY mID ORDER BY COUNT(*) DESC LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n    \"1\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n    \"2\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\"\n}\n"}
{"sample_id": "train.2509", "db_id": "movie_1", "question": "What is the name of the movie that has been reviewed the most?", "rationale": ["To find the movie that has been reviewed the most, we need to count the number of reviews for each movie.", "We can achieve this by using the Rating table, where each entry corresponds to a review for a movie.", "We will group the results by the movie ID (mID) to count how many reviews each movie has received.", "Next, we will order these counts in descending order so that the movie with the most reviews comes first.", "Finally, we will limit the results to just one entry to get the top movie with the most reviews.", "We will then select the title of that movie from the Movie table using the mID obtained from the previous query."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title\nFROM Movie\nWHERE mID IN (\n    SELECT mID\n    FROM Rating\n    GROUP BY mID\n    ORDER BY COUNT(rID) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n    \"1\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"2\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\"\n}\n"}
{"sample_id": "train.2517", "db_id": "movie_1", "question": "What are the ids of all moviest hat have not been reviewed by Britanny Harris?", "rationale": ["Identify the movies that have not been reviewed by Britanny Harris.", "To do this, we need to find the IDs of the movies that have ratings from reviewers.", "We will first find the rID of Britanny Harris from the Reviewer table.", "Next, we will find all mIDs from the Rating table where the rID matches Britanny Harris's rID.", "Finally, we will select all mIDs from the Movie table that are not in the list of mIDs found in the previous step."], "gold_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT mID FROM Movie WHERE mID NOT IN (SELECT mID FROM Rating WHERE rID = (SELECT rID FROM Reviewer WHERE name = 'Britanny Harris'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"1\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n    \"2\": \"This virtual table provides the unique movie identifiers along with the average star ratings from the 'Rating' table. It groups the results by movie ID and filters to include only those movies that have received a minimum number of ratings, as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.2518", "db_id": "movie_1", "question": "Find the average rating star for each movie that received at least 2 ratings.", "rationale": ["We need to find the average rating star for each movie that received at least 2 ratings.", "To do this, we will join the 'Movie' table with the 'Rating' table on the movie ID (mID).", "We will select the movie title and calculate the average of the stars given in the ratings using AVG(Rating.stars).", "We will group the results by the movie ID to ensure we get the average rating for each movie.", "Finally, we will use the HAVING clause to filter the results to include only those movies that have received at least 2 ratings, which we can count using COUNT(Rating.rID)."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2", "source_tables": ["rating"], "pred_sql": "SELECT Movie.title, AVG(Rating.stars) AS average_rating\nFROM Movie\nJOIN Rating ON Movie.mID = Rating.mID\nGROUP BY Movie.mID\nHAVING COUNT(Rating.rID) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the unique movie identifiers along with the average star ratings from the 'Rating' table. It groups the results by movie ID and filters to include only those movies that have received a minimum number of ratings, as specified by the placeholder.\",\n    \"1\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n    \"2\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\"\n}\n"}
{"sample_id": "train.2528", "db_id": "movie_1", "question": "What are the names of reviewers who had rated 3 star and 4 star?", "rationale": ["We need to find the names of reviewers who rated movies with 3 stars and 4 stars.", "To do this, we will join the Reviewer table with the Rating table on the reviewer ID (rID).", "We will select the distinct names of reviewers to avoid duplicates.", "In the WHERE clause, we will filter the ratings to include only those that are either 3 or 4 stars."], "gold_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nWHERE Rating.stars IN ('3', '4');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"1\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n    \"2\": \"This virtual table describes the names of reviewers who have given a specific number of stars to movies. The query uses an INTERSECT operation to find reviewers who rated two different movies with the same star rating. The placeholders in the WHERE clause represent the number of stars given in the ratings.\"\n}\n"}
{"sample_id": "train.2530", "db_id": "movie_1", "question": "What are the names of movies that get 3 star and 4 star?", "rationale": ["We need to find the names of movies that received both 3-star and 4-star ratings.", "To do this, we will join the Movie table with the Rating table on the movie ID (mID).", "We will filter the ratings to include only those that are either 3 or 4 stars using the WHERE clause.", "To ensure that we only get movies that have received both ratings, we will group the results by the movie title.", "Finally, we will use the HAVING clause to ensure that the count of distinct star ratings for each movie is 2, meaning it has received both 3 and 4 stars."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "source_tables": ["rating", "movie"], "pred_sql": "SELECT DISTINCT Movie.title \nFROM Movie \nJOIN Rating ON Movie.mID = Rating.mID \nWHERE Rating.stars IN ('3', '4') \nGROUP BY Movie.title \nHAVING COUNT(DISTINCT Rating.stars) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n    \"1\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n    \"2\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\"\n}\n"}
{"sample_id": "train.2576", "db_id": "inn_1", "question": "Find the most popular room in the hotel. The most popular room is the room that had seen the largest number of reservations.", "rationale": ["Identify the tables involved: Rooms and Reservations.", "To find the most popular room, we need to count the number of reservations for each room.", "Join the Rooms table with the Reservations table on the RoomId to get the room names along with their reservation counts.", "Use COUNT() to count the number of reservations for each room, grouping by the RoomId.", "Order the results by the count of reservations in descending order to get the most popular room at the top.", "Limit the results to 1 to get only the most popular room."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT r.roomName, COUNT(res.Code) AS reservation_count\nFROM Rooms r\nJOIN Reservations res ON r.RoomId = res.Room\nGROUP BY r.RoomId\nORDER BY reservation_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"2\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\"\n}\n"}
{"sample_id": "train.2577", "db_id": "inn_1", "question": "Which room has the largest number of reservations?", "rationale": ["Identify the tables involved: Rooms and Reservations.", "We need to count the number of reservations for each room, so we will use a COUNT function on the Reservations table.", "Join the Rooms table with the Reservations table on the RoomId to get the room names along with their reservation counts.", "Group the results by the RoomId to aggregate the reservation counts for each room.", "Order the results by the reservation count in descending order to find the room with the largest number of reservations.", "Limit the results to 1 to get only the room with the highest count."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservation_count\nFROM Rooms\nLEFT JOIN Reservations ON Rooms.RoomId = Reservations.Room\nGROUP BY Rooms.RoomId\nORDER BY reservation_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"2\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\"\n}\n"}
{"sample_id": "train.2578", "db_id": "inn_1", "question": "How many kids stay in the rooms reserved by ROY SWEAZY?", "rationale": ["Identify the relevant table: Reservations contains the information about guests and their kids.", "We need to sum the number of kids from the Reservations table.", "Filter the results to only include reservations made by ROY SWEAZY by using the LastName and FirstName columns.", "Use the SUM function to calculate the total number of kids across all reservations for ROY SWEAZY."], "gold_sql": "SELECT kids FROM Reservations WHERE FirstName = 'ROY' AND LastName  =  'SWEAZY';", "source_tables": ["reservations"], "pred_sql": "SELECT SUM(Kids) AS TotalKids\nFROM Reservations\nWHERE LastName = 'SWEAZY' AND FirstName = 'ROY';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"2\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\"\n}\n"}
{"sample_id": "train.2582", "db_id": "inn_1", "question": "Which room has the highest rate? List the room's full name, rate, check in and check out date.", "rationale": ["Identify the tables involved: Rooms and Reservations.", "Determine the columns needed: roomName from Rooms, Rate, CheckIn, and CheckOut from Reservations.", "Join the Rooms table with the Reservations table on the RoomId and Room columns respectively.", "Order the results by Rate in descending order to find the highest rate.", "Limit the results to 1 to get only the room with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT r.roomName, res.Rate, res.CheckIn, res.CheckOut \nFROM Rooms r \nJOIN Reservations res ON r.RoomId = res.Room \nORDER BY res.Rate DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n    \"1\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"2\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
{"sample_id": "train.2583", "db_id": "inn_1", "question": "Return the name, rate, check in and check out date for the room with the highest rate.", "rationale": ["Identify the required fields: room name, rate, check-in date, and check-out date.", "The data is spread across two tables: Rooms and Reservations. We need to join these tables on the RoomId.", "Use a JOIN clause to combine the Rooms and Reservations tables based on the RoomId and Room fields.", "To find the room with the highest rate, we will order the results by the Rate in descending order.", "Finally, we will limit the results to only one entry to get the room with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT r.roomName, res.Rate, res.CheckIn, res.CheckOut \nFROM Rooms r \nJOIN Reservations res ON r.RoomId = res.Room \nORDER BY res.Rate DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n    \"1\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"2\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
{"sample_id": "train.2589", "db_id": "inn_1", "question": "Find the total number of king beds available.", "rationale": ["Identify the requirement: We need to find the total number of king beds available.", "Refer to the schema: The 'Rooms' table contains a column 'bedType' which indicates the type of beds in each room.", "Use the COUNT function to count the number of rooms that have 'king' as their bed type.", "Construct the SQL query to select the count from the 'Rooms' table where 'bedType' is 'king'."], "gold_sql": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT COUNT(*) AS TotalKingBeds FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n    \"2\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\"\n}\n"}
{"sample_id": "train.2590", "db_id": "inn_1", "question": "List the names and decor of rooms that have a king bed. Sort the list by their price.", "rationale": ["Identify the relevant table: Rooms.", "Determine the columns needed: roomName and decor.", "Filter the results to include only rooms with a king bed by using a WHERE clause: bedType = 'king'.", "Sort the results by the base price of the rooms using ORDER BY basePrice."], "gold_sql": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName, decor FROM Rooms WHERE bedType = 'king' ORDER BY basePrice;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"2\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\"\n}\n"}
{"sample_id": "train.2594", "db_id": "inn_1", "question": "What is the decor of room Recluse and defiance?", "rationale": ["Identify the relevant table: The question pertains to the decor of specific rooms, which are stored in the 'Rooms' table.", "Determine the columns needed: We need the 'decor' column to answer the question.", "Filter the results: We need to filter the rooms by their names, which are 'Recluse' and 'defiance'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'decor' from the 'Rooms' table where the 'roomName' matches the specified names."], "gold_sql": "SELECT decor FROM Rooms WHERE roomName  =  'Recluse and defiance';", "source_tables": ["rooms"], "pred_sql": "SELECT decor FROM Rooms WHERE roomName IN ('Recluse', 'defiance');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n    \"2\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
{"sample_id": "train.2604", "db_id": "inn_1", "question": "Find the first and last names of people who payed more than the rooms' base prices.", "rationale": ["Identify the tables involved: Reservations and Rooms.", "We need to retrieve the first and last names of guests, which are in the Reservations table.", "We also need to compare the Rate from the Reservations table with the basePrice from the Rooms table.", "To do this, we will join the Reservations table with the Rooms table on the RoomId.", "The condition for the query is that the Rate in Reservations must be greater than the basePrice in Rooms.", "Finally, we select the FirstName and LastName from the Reservations table where the condition is met."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Reservations.FirstName, Reservations.LastName\nFROM Reservations\nJOIN Rooms ON Reservations.Room = Rooms.RoomId\nWHERE Reservations.Rate > Rooms.basePrice;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
{"sample_id": "train.2609", "db_id": "inn_1", "question": "How many rooms have a king bed?", "rationale": ["Identify the table to query: The question is about rooms, so we will use the 'Rooms' table.", "Determine the relevant column: We need to filter rooms based on the type of bed, which is in the 'bedType' column.", "Count the rooms: We need to count how many rooms have a king bed, so we will use the COUNT() function.", "Construct the SQL query: We will select the count of rooms from the 'Rooms' table where the 'bedType' is 'king'."], "gold_sql": "SELECT count(*) FROM Rooms WHERE bedType  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT COUNT(*) AS RoomCount FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n    \"1\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n    \"2\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\"\n}\n"}
