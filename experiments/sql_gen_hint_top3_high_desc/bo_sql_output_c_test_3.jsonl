{"sample_id": "train.3672", "db_id": "baseball_1", "question": "For each year, return the year and the number of times the team Boston Red Stockings won in the postseasons.", "rationale": ["We need to retrieve the year and the number of postseason wins for the Boston Red Stockings.", "The relevant table for postseason results is the 'postseason' table, which contains the winning team IDs and the year of the postseason.", "We will join the 'postseason' table with the 'team' table to get the team names corresponding to the winning team IDs.", "We will filter the results to only include wins by the 'Boston Red Stockings'.", "Finally, we will group the results by year and count the number of wins for each year."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "pred_sql": "SELECT p.year, COUNT(p.team_id_winner) AS wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings'\nGROUP BY p.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n    \"1\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\"\n}\n"}
{"sample_id": "train.3677", "db_id": "baseball_1", "question": "What is the total salary paid by team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant tables: We need the 'salary' table to get salary information and the 'team' table to filter by team name.", "Join the 'salary' table with the 'team' table on 'team_id' to associate salaries with the correct team.", "Filter the results to only include records for the 'Boston Red Stockings' team in the year 2010.", "Use the SUM function to calculate the total salary paid by the team for that year."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT SUM(salary) AS total_salary \nFROM salary \nJOIN team ON salary.team_id = team.team_id \nWHERE team.name = 'Boston Red Stockings' AND salary.year = 2010;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n    \"1\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\"\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant table: The 'salary' table contains the salary records for players.", "Specify the year: We need to filter the records for the year 2001.", "Select the required columns: We want to retrieve the 'player_id' and 'salary' columns.", "Order the results: To find the highest salaries, we will order the results by 'salary' in descending order.", "Limit the results: We only need the top 3 highest salaries, so we will limit the results to 3."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n    \"1\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n    \"2\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\"\n}\n"}
{"sample_id": "train.3682", "db_id": "baseball_1", "question": "How much salary did the top 3 well-paid players get in 2001?", "rationale": ["Identify the relevant table: The 'salary' table contains the salary records for players.", "Specify the year: We need to filter the records for the year 2001.", "Order the results: To find the top 3 well-paid players, we need to order the results by salary in descending order.", "Limit the results: We only want the top 3 players, so we will use the LIMIT clause."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n    \"1\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n    \"2\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\"\n}\n"}
{"sample_id": "train.3683", "db_id": "baseball_1", "question": "What were all the salary values of players in 2010 and 2001?", "rationale": ["Identify the relevant table: The 'salary' table contains the salary records for players.", "Determine the years of interest: The user wants salary values for the years 2010 and 2001.", "Construct the SQL query: Use a SELECT statement to retrieve the 'player_id' and 'salary' columns from the 'salary' table where the 'year' is either 2010 or 2001."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year IN (2010, 2001);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n    \"1\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n    \"2\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\"\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "The relevant table for this information is the 'hall_of_fame' table, which contains the 'yearid' and 'inducted' columns.", "We will count the number of players inducted (where 'inducted' is 'Y') for each year using COUNT(*) and group the results by 'yearid'.", "To find the year with the least inductees, we will order the results in ascending order based on the count of inducted players.", "Finally, we will limit the results to 1 to get the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) AS num_inducted\nFROM hall_of_fame\nWHERE inducted = 'Y'\nGROUP BY yearid\nORDER BY num_inducted ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n    \"1\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n    \"2\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["To find the year with the least number of people entering the Hall of Fame, we need to count the number of inductees for each year.", "The 'hall_of_fame' table contains the relevant data, specifically the 'yearid' and 'inducted' columns.", "We will filter the results to only include those who were inducted (indicated by 'inducted = 'Y'').", "Next, we will group the results by 'yearid' to count the number of inductees for each year.", "Finally, we will order the results in ascending order based on the count of inductees and limit the output to the first result, which will give us the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) AS num_inducted FROM hall_of_fame WHERE inducted = 'Y' GROUP BY yearid ORDER BY num_inducted ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n    \"1\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n    \"2\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\"\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant table: The 'home_game' table contains information about games played in different parks.", "Determine the columns needed: We need to sum the 'games' column to get the total number of games played.", "Filter by year: We need to specify the year 1907 in the WHERE clause.", "Filter by park: We need to find the park ID for 'Columbia Park' using a subquery on the 'park' table, which will allow us to filter the results to only include games played in that park."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nWHERE year = 1907 AND park_id = (SELECT park_id FROM park WHERE park_name = 'Columbia Park');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n    \"1\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\"\n}\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: We need to count the number of games, which can be found in the 'home_game' table, and we need to filter by the park name, which is in the 'park' table.", "Join the 'home_game' table with the 'park' table on the park_id to access the park name.", "Use a WHERE clause to filter for the specific park name 'Columbia Park' and the year 1907.", "Count the total number of games using COUNT(*) and alias it as total_games."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT COUNT(*) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.park_name = 'Columbia Park' AND home_game.year = 1907;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n    \"1\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\"\n}\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant tables: We need to find the total number of games played in Atlanta in 2000, which involves the 'home_game' table for game counts and the 'team' table for city information.", "Join the 'home_game' table with the 'team' table on 'team_id' to access the city information for the teams that hosted games.", "Filter the results for the year 2000 and for teams located in Atlanta.", "Use the SUM function to calculate the total number of games played in Atlanta in that year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(home_game.games) AS total_games\nFROM home_game\nJOIN team ON home_game.team_id = team.team_id\nWHERE home_game.year = 2000 AND home_game.league_id = team.league_id AND team.city = 'Atlanta';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n    \"1\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n    \"2\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: We need to find the number of games in Atlanta in 2000, so we will use the 'home_game' table for game data and the 'park' table for city information.", "Join the tables: We will join 'home_game' with 'park' on the park_id to access the city information related to the games.", "Filter the results: We will filter the results to only include games that took place in Atlanta and in the year 2000.", "Count the games: We will sum the 'games' column from the 'home_game' table to get the total number of games played in Atlanta in 2000."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.city = 'Atlanta' AND home_game.year = 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n    \"1\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n    \"2\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.3693", "db_id": "baseball_1", "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'team' for team identification.", "Join the 'home_game' table with the 'team' table on 'team_id' to associate attendance with the correct team.", "Filter the results to include only the 'Boston Red Stockings' team by using the team name in the WHERE clause.", "Limit the results to the years between 2000 and 2010 using the BETWEEN clause in the WHERE condition.", "Use the SUM function to calculate the total attendance for the specified team and years."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT SUM(attendance) AS total_attendance \nFROM home_game \nJOIN team ON home_game.team_id = team.team_id \nWHERE team.name = 'Boston Red Stockings' \nAND home_game.year BETWEEN 2000 AND 2010;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n    \"1\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n    \"2\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.3698", "db_id": "baseball_1", "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?", "rationale": ["Identify the team ID for 'Washington Nationals' from the 'team' table.", "Select the first and last names of players from the 'player' table who have salary records in the 'salary' table.", "Filter the salary records to include only those from the years 2005 and 2007 for the identified team ID.", "Use a subquery to ensure that the player has salary records for both years (2005 and 2007)."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT p.name_first, p.name_last \nFROM salary s1 \nJOIN player p ON s1.player_id = p.player_id \nWHERE s1.team_id = (SELECT team_id FROM team WHERE name = 'Washington Nationals') \nAND s1.year = 2005 \nAND s1.player_id IN (\n    SELECT player_id \n    FROM salary s2 \n    WHERE s2.team_id = (SELECT team_id FROM team WHERE name = 'Washington Nationals') \n    AND s2.year = 2007\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n    \"1\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n    \"2\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\"\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games played by teams, including the year and team ID.", "Filter the data: We need to focus on the year 1980, so we will filter the results to include only records from that year.", "Group the results: We will group the results by 'team_id' to count the number of home games each team hosted in 1980.", "Count the home games: Use COUNT(*) to count the number of home games for each team.", "Order the results: We will order the results in ascending order based on the count of home games to find the team with the least number.", "Limit the results: Since we only want the team with the least number of home games, we will limit the results to 1."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, COUNT(*) AS home_games_count \nFROM home_game \nWHERE year = 1980 \nGROUP BY team_id \nORDER BY home_games_count ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n    \"1\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.3709", "db_id": "baseball_1", "question": "Which park had most attendances in 2008?", "rationale": ["Identify the relevant tables: home_game and park.", "We need to find the park with the highest attendance in 2008, so we will filter the home_game table for the year 2008.", "Join the home_game table with the park table to get the park names associated with the attendance records.", "Order the results by attendance in descending order to get the park with the highest attendance at the top.", "Limit the results to 1 to get only the park with the most attendance."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT park.park_name, home_game.attendance \nFROM home_game \nJOIN park ON home_game.park_id = park.park_id \nWHERE home_game.year = 2008 \nORDER BY home_game.attendance DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\"\n}\n"}
{"sample_id": "train.3857", "db_id": "insurance_policies", "question": "Find the settlement amount of the claim with the largest claim amount. Show both the settlement amount and claim amount.", "rationale": ["Identify the relevant tables: Claims and Settlements, since we need information about claim amounts and their corresponding settlement amounts.", "We need to find the claim with the largest claim amount, which requires a subquery to get the maximum claim amount from the Claims table.", "Join the Claims table with the Settlements table on the Claim_ID to access both the claim amount and the settlement amount.", "Select the Amount_Claimed from the Claims table and the Amount_Settled from the Settlements table where the Amount_Claimed matches the maximum claim amount found in the subquery."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"], "pred_sql": "SELECT c.Amount_Claimed, s.Amount_Settled\nFROM Claims c\nJOIN Settlements s ON c.Claim_ID = s.Claim_ID\nWHERE c.Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claims);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n    \"1\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\"\n}\n"}
{"sample_id": "train.3862", "db_id": "insurance_policies", "question": "Among all the claims, which settlements have a claimed amount that is no more than the average? List the claim start date.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find settlements where the claimed amount is no more than the average claimed amount across all claims.", "To do this, we will join the Claims table with the Settlements table on the Claim_ID.", "We will select the Date_Claim_Made from the Claims table and the Amount_Claimed from the Settlements table.", "We will use a subquery to calculate the average claimed amount from the Claims table and filter the results based on this average."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT Claims.Date_Claim_Made, Settlements.Amount_Claimed \nFROM Claims \nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID \nWHERE Settlements.Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Claims);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n    \"1\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\"\n}\n"}
{"sample_id": "train.3863", "db_id": "insurance_policies", "question": "Return the claim start date for the claims whose claimed amount is no more than the average", "rationale": ["Identify the relevant table: Claims, which contains the claim details including the claimed amount and the date the claim was made.", "Determine the condition: We need to find claims where the claimed amount is no more than the average claimed amount across all claims.", "Use a subquery to calculate the average claimed amount: (SELECT AVG(Amount_Claimed) FROM Claims).", "Construct the SQL query to select the Date_Claim_Made from the Claims table where the Amount_Claimed is less than or equal to the average amount calculated."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT Date_Claim_Made \nFROM Claims \nWHERE Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Claims);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n    \"1\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\"\n}\n"}
{"sample_id": "train.3868", "db_id": "insurance_policies", "question": "How many settlements were made on the claim with the most recent claim settlement date? List the number and the claim id.", "rationale": ["Identify the need to count settlements related to claims with the most recent settlement date.", "Join the Claims table with the Settlements table to link claims to their settlements.", "Use a subquery to find the maximum settlement date from the Claims table.", "Filter the results to only include settlements related to claims that have this maximum settlement date.", "Group the results by Claim_ID to get the count of settlements for each claim."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT COUNT(Settlements.Settlement_ID) AS Number_of_Settlements, Claims.Claim_ID\nFROM Claims\nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID\nWHERE Claims.Date_Claim_Settled = (\n    SELECT MAX(Date_Claim_Settled)\n    FROM Claims\n)\nGROUP BY Claims.Claim_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n    \"1\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\"\n}\n"}
{"sample_id": "train.3869", "db_id": "insurance_policies", "question": "Find the claim id and the number of settlements made for the claim with the most recent settlement date.", "rationale": ["Identify the relevant tables: Claims and Settlements are needed to find the claim ID and the number of settlements.", "Join the Claims table with the Settlements table on Claim_ID to link claims with their settlements.", "Use a subquery to find the maximum settlement date from the Settlements table.", "Filter the results to only include settlements that match this maximum date.", "Group the results by Claim_ID to count the number of settlements for each claim."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT Claims.Claim_ID, COUNT(Settlements.Settlement_ID) AS Number_of_Settlements\nFROM Claims\nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID\nWHERE Settlements.Date_Claim_Settled = (\n    SELECT MAX(Date_Claim_Settled)\n    FROM Settlements\n)\nGROUP BY Claims.Claim_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n    \"1\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\"\n}\n"}
{"sample_id": "train.3878", "db_id": "insurance_policies", "question": "What is the most popular payment method?", "rationale": ["Identify the relevant table: The Payments table contains information about payment transactions, including the payment method.", "Determine the required information: We need to find the most popular payment method, which implies counting the occurrences of each payment method.", "Use the COUNT function: To find out how many times each payment method was used, we will use the COUNT function on the Payment_Method_Code column.", "Group the results: We will group the results by Payment_Method_Code to aggregate the counts for each method.", "Order the results: To find the most popular method, we will order the results in descending order based on the count of each payment method.", "Limit the results: Since we only want the most popular payment method, we will limit the results to 1."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Method_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Method_Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3879", "db_id": "insurance_policies", "question": "Which payment method is used the most often?", "rationale": ["Identify the relevant table: The question is about payment methods, so we will focus on the Payments table.", "Determine the required information: We need to find out which payment method is used the most often, which implies counting the occurrences of each payment method.", "Use the COUNT function: We will count the number of times each Payment_Method_Code appears in the Payments table.", "Group the results: We will group the results by Payment_Method_Code to aggregate the counts for each method.", "Order the results: To find the most used payment method, we will order the results in descending order based on the count.", "Limit the results: Since we only need the most frequently used payment method, we will limit the results to 1."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Method_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Method_Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3880", "db_id": "insurance_policies", "question": "With which kind of payment method were the least number of payments processed?", "rationale": ["We need to find the payment method with the least number of payments processed.", "To do this, we will select the 'Payment_Method_Code' from the 'Payments' table.", "We will count the number of payments for each payment method using COUNT(Payment_ID).", "We will group the results by 'Payment_Method_Code' to aggregate the counts for each method.", "Next, we will order the results in ascending order based on the count of payments to get the least processed method at the top.", "Finally, we will limit the results to 1 to get only the payment method with the least number of payments."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(Payment_ID) AS Payment_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Payment_Count ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3886", "db_id": "insurance_policies", "question": "Which kind of policy type was chosen by the most customers?", "rationale": ["Identify the relevant table: The question pertains to the types of policies chosen by customers, so we will focus on the 'Customer_Policies' table.", "Count distinct customers: We need to count how many distinct customers chose each policy type, which requires using COUNT(DISTINCT Customer_ID).", "Group by policy type: To get the count of customers for each policy type, we will use GROUP BY Policy_Type_Code.", "Order the results: To find the policy type chosen by the most customers, we will order the results in descending order based on the customer count.", "Limit the results: Since we only want the policy type with the highest count, we will limit the results to 1."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(DISTINCT Customer_ID) AS Customer_Count\nFROM Customer_Policies\nGROUP BY Policy_Type_Code\nORDER BY Customer_Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3893", "db_id": "insurance_policies", "question": "Which customers do not have any policies? Find the details of these customers.", "rationale": ["Identify the Customers table as the primary source of customer information.", "To find customers without policies, we need to check which Customer_IDs are present in the Customer_Policies table.", "Use a subquery to select all Customer_IDs from the Customer_Policies table.", "Use the NOT IN clause to filter out those Customer_IDs from the Customers table, thus identifying customers without any policies."], "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"], "pred_sql": "SELECT * FROM Customers WHERE Customer_ID NOT IN (SELECT Customer_ID FROM Customer_Policies);", "hint": "\n"}
{"sample_id": "train.3895", "db_id": "insurance_policies", "question": "Which claims had exactly one settlement? For each, tell me the the date the claim was made, the date it was settled and the amount settled.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to select the date the claim was made, the date it was settled, and the amount settled.", "Join the Claims table with the Settlements table on the Claim_ID to access settlement details for each claim.", "Group the results by Claim_ID to aggregate the settlements for each claim.", "Use the HAVING clause to filter the groups to only those claims that have exactly one settlement."], "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT c.Date_Claim_Made, c.Date_Claim_Settled, s.Amount_Settled\nFROM Claims c\nJOIN Settlements s ON c.Claim_ID = s.Claim_ID\nGROUP BY c.Claim_ID\nHAVING COUNT(s.Settlement_ID) = 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n    \"1\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\"\n}\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to count the number of employees in each department, which involves joining the Department table with the Physician table.", "Use a LEFT JOIN to include all departments even if they have no physicians.", "Group the results by department name to count the number of employees in each department.", "Order the results by the count of employees in descending order to find the department with the largest number of employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT d.Name, COUNT(p.EmployeeID) AS EmployeeCount\nFROM Department d\nLEFT JOIN Physician p ON d.Head = p.EmployeeID\nGROUP BY d.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["Identify the relevant tables: Department and Affiliated_With.", "We need to count the number of physicians affiliated with each department, so we will join the Department table with the Affiliated_With table on the DepartmentID.", "Use COUNT() to count the number of physicians in each department.", "Group the results by department name to get the count per department.", "Order the results by the count of employees in descending order to find the department with the most employees.", "Limit the results to 1 to get only the department with the highest count."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Affiliated_With.Physician) AS EmployeeCount\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3901", "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["We need to find the head of the department with the least employees.", "To do this, we will join the Department table with the Affiliated_With table to count the number of physicians in each department.", "We will group the results by DepartmentID to get the count of physicians per department.", "Next, we will order the results by the count of physicians in ascending order to find the department with the least employees.", "Finally, we will limit the results to 1 to get only the head of that department."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Head\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.DepartmentID\nORDER BY COUNT(Affiliated_With.Physician) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["We need to find the name and position of the head of the department with the least number of employees.", "The head of a department is identified by the 'Head' column in the Department table, which corresponds to the 'EmployeeID' in the Physician table.", "To find the department with the least number of employees, we can use the Affiliated_With table to count the number of physicians affiliated with each department.", "We will group the results by department and order them by the count of physicians in ascending order, limiting the result to the first one to get the department with the least employees.", "Finally, we will join the Physician and Department tables to get the name and position of the head of that department."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Physician \nJOIN Department ON Physician.EmployeeID = Department.Head \nWHERE Department.DepartmentID = \n  (SELECT Affiliated_With.Department \n   FROM Affiliated_With \n   GROUP BY Affiliated_With.Department \n   ORDER BY COUNT(Affiliated_With.Physician) ASC \n   LIMIT 1);", "hint": "\n"}
{"sample_id": "train.3903", "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["Identify the head of the department by joining the Physician and Department tables on the EmployeeID and Head columns respectively.", "To find the department with the least employees, we need to count the number of physicians affiliated with each department. This can be done using the Affiliated_With table.", "We will group the results by department and order them by the count of physicians in ascending order to get the department with the least employees.", "We will limit the results to 1 to get only the department with the least employees.", "Finally, we will use the department ID from the subquery to filter the main query to get the name and position of the head of that department."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Physician \nJOIN Department ON Physician.EmployeeID = Department.Head \nWHERE Department.DepartmentID = \n    (SELECT Affiliated_With.Department \n     FROM Affiliated_With \n     GROUP BY Affiliated_With.Department \n     ORDER BY COUNT(Affiliated_With.Physician) ASC \n     LIMIT 1);", "hint": "\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["Identify the relevant tables: Patient and Appointment.", "We need to find the names of patients who have made an appointment, which means we need to join the Patient table with the Appointment table on the Patient's SSN and the Appointment's Patient identifier.", "Use SELECT DISTINCT to ensure we get unique patient names, as a patient may have multiple appointments.", "Construct the SQL query to select the names from the Patient table, joining with the Appointment table."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT Patient.Name\nFROM Patient\nJOIN Appointment ON Patient.SSN = Appointment.Patient;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n    \"1\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n    \"2\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\"\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["Identify the tables needed: Physician, Department, and Affiliated_With.", "We need to retrieve the names of physicians and their affiliated departments, so we will select the 'Name' columns from both the Physician and Department tables.", "To link the Physician and Department tables, we will use the Affiliated_With table, which contains the relationships between physicians and departments.", "We will perform a JOIN operation between the Physician and Affiliated_With tables on the EmployeeID and Physician columns, respectively.", "Next, we will join the Department table on the DepartmentID from the Affiliated_With table to get the department names.", "Finally, we need to filter the results to include only those affiliations that are marked as primary, which is indicated by the 'PrimaryAffiliation' column in the Affiliated_With table."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name, Department.Name \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nJOIN Department ON Affiliated_With.Department = Department.DepartmentID \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\",\n    \"1\": \"This virtual table provides a list of physicians along with their associated departments from the 'Affiliated_With' table, filtered by whether the affiliation is marked as primary. The placeholder in the WHERE clause represents the primary affiliation status.\",\n    \"2\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\"\n}\n"}
{"sample_id": "train.3928", "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["Identify the tables needed: Physician and Patient.", "Join the Physician table with the Patient table on the condition that the Physician's EmployeeID matches the Patient's PCP.", "Count the number of patients for each physician using COUNT(Patient.SSN).", "Select the Physician's Name and the count of patients, aliasing the count as NumberOfPatients.", "Group the results by Physician's EmployeeID to aggregate the patient counts."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name, COUNT(Patient.SSN) AS NumberOfPatients\nFROM Physician\nLEFT JOIN Patient ON Physician.EmployeeID = Patient.PCP\nGROUP BY Physician.EmployeeID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n    \"1\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n    \"2\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\"\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["We need to find physicians who are in charge of more than one patient, which means we are looking for primary care physicians (PCP).", "To do this, we will join the 'Physician' table with the 'Patient' table on the condition that the physician's EmployeeID matches the patient's PCP identifier.", "Next, we will group the results by the physician's EmployeeID to count how many patients each physician is responsible for.", "Finally, we will use the HAVING clause to filter the results to only include physicians who have more than one patient (i.e., COUNT(Patient.SSN) > 1).", "We will select the names of these physicians in the final output."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Patient ON Physician.EmployeeID = Patient.PCP\nGROUP BY Physician.EmployeeID\nHAVING COUNT(Patient.SSN) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n    \"1\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n    \"2\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\"\n}\n"}
{"sample_id": "train.3940", "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication are needed to find the names of physicians who prescribe a specific medication.", "Join the Physician table with the Prescribes table on the EmployeeID and Physician columns to link physicians with their prescriptions.", "Next, join the Prescribes table with the Medication table on the Medication code to access the medication details.", "Use a WHERE clause to filter the results to only include prescriptions for the medication named 'Thesisin'.", "Select the Name column from the Physician table to get the names of the physicians who prescribed the medication."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT Physician.Name \nFROM Physician \nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician \nJOIN Medication ON Prescribes.Medication = Medication.Code \nWHERE Medication.Name = 'Thesisin';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n    \"1\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n    \"2\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\"\n}\n"}
{"sample_id": "train.3941", "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["Identify the tables involved: Physician, Prescribes, and Medication.", "We need to find the names of physicians who prescribe a specific medication, which is 'Thesisin'.", "Join the Physician table with the Prescribes table on the Physician's EmployeeID and the Prescribes table's Physician field.", "Join the Prescribes table with the Medication table on the Medication's Code and the Prescribes table's Medication field.", "Filter the results to only include records where the Medication's Name is 'Thesisin'.", "Select the Name field from the Physician table to get the desired output."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT Physician.Name \nFROM Physician \nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician \nJOIN Medication ON Prescribes.Medication = Medication.Code \nWHERE Medication.Name = 'Thesisin';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n    \"1\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n    \"2\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\"\n}\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["We need to find the number of medications prescribed for each brand.", "To do this, we will join the 'Medication' table with the 'Prescribes' table on the medication code.", "We will select the brand from the 'Medication' table and count the number of prescriptions from the 'Prescribes' table.", "Finally, we will group the results by the brand to get the count for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT m.Brand, COUNT(p.Medication) AS MedicationCount\nFROM Medication m\nJOIN Prescribes p ON m.Code = p.Medication\nGROUP BY m.Brand;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n    \"1\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\"\n}\n"}
{"sample_id": "train.3948", "db_id": "hospital_1", "question": "Find the patient who has the most recent undergoing treatment?", "rationale": ["To find the patient who has the most recent undergoing treatment, we need to look at the 'Undergoes' table which contains information about patients undergoing procedures.", "We will join the 'Undergoes' table with the 'Patient' table to get the patient's name along with the date of the procedure.", "We will order the results by the 'DateUndergoes' in descending order to get the most recent treatment at the top.", "Finally, we will limit the results to 1 to get only the most recent patient."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT Patient.Name, Undergoes.DateUndergoes \nFROM Undergoes \nJOIN Patient ON Undergoes.Patient = Patient.SSN \nORDER BY Undergoes.DateUndergoes DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n    \"1\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n    \"2\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\"\n}\n"}
{"sample_id": "train.3949", "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["Identify the relevant tables: We need to find patients undergoing treatments, which involves the 'Undergoes', 'Patient', and 'Procedures' tables.", "Join the 'Undergoes' table with the 'Patient' table to get patient names, using the SSN as the linking key.", "Join the 'Undergoes' table with the 'Procedures' table to get the names of the procedures being undergone, using the procedure code as the linking key.", "Order the results by the date of the procedures in descending order to get the most recent treatment at the top.", "Limit the results to 1 to get only the most recent treatment."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT Patient.Name, Procedures.Name, Undergoes.DateUndergoes \nFROM Undergoes \nJOIN Patient ON Undergoes.Patient = Patient.SSN \nJOIN Procedures ON Undergoes.Procedures = Procedures.Code \nORDER BY Undergoes.DateUndergoes DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n    \"1\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n    \"2\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\"\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: 'Physician' for physician names and 'Prescribes' for prescription details.", "Join the 'Prescribes' table with the 'Physician' table on the physician's identifier to access physician names along with their prescribed doses.", "Order the results by the 'Dose' column in descending order to get the highest dose at the top.", "Limit the results to 1 to get only the physician who prescribed the highest dose."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT Physician.Name\nFROM Prescribes\nJOIN Physician ON Prescribes.Physician = Physician.EmployeeID\nORDER BY Prescribes.Dose DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n    \"1\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n    \"2\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\"\n}\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["Identify the tables needed: Physician and Affiliated_With.", "We need to retrieve the EmployeeID from the Physician table and the Department from the Affiliated_With table.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician identifiers respectively.", "Filter the results to include only those records where the affiliation is marked as primary (i.e., PrimaryAffiliation = 'Yes').", "Select the required columns: EmployeeID and Department."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of physicians along with their associated departments from the 'Affiliated_With' table, filtered by whether the affiliation is marked as primary. The placeholder in the WHERE clause represents the primary affiliation status.\",\n    \"1\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\",\n    \"2\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\"\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["Identify the relevant table: Procedures, which contains the cost of each procedure.", "Select the columns needed: Name (for the procedure name) and Cost (for the cost of the procedure).", "Order the results by Cost in descending order to get the most expensive procedures first.", "Limit the results to 3 to get only the top three most costly procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n    \"1\": \"This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.\",\n    \"2\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\"\n}\n"}
{"sample_id": "train.3972", "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find physicians who are trained in procedures that cost more than 5000.", "Join the Physician table with the Trained_In table on the Physician's EmployeeID and the Trained_In's Physician.", "Then, join the resulting table with the Procedures table on the Trained_In's Treatment and Procedures' Code.", "Filter the results where the cost of the procedure is greater than 5000.", "Select the distinct names of the physicians from the final result."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT DISTINCT Physician.Name\nFROM Physician\nJOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician\nJOIN Procedures ON Trained_In.Treatment = Procedures.Code\nWHERE Procedures.Cost > 5000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n    \"1\": \"This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.\",\n    \"2\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\"\n}\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the tables involved: Physician, Trained_In, and Procedures.", "We need to find the physician who is trained in the most expensive procedure.", "Join the Physician table with the Trained_In table to get the treatments each physician is certified to perform.", "Then, join the Procedures table to get the details of those treatments, including their costs.", "To find the most expensive procedure, we can use a subquery to get the maximum cost from the Procedures table.", "Finally, filter the results to only include the procedure(s) that match this maximum cost."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT p.Name, pr.Name AS ProcedureName, pr.Cost\nFROM Physician p\nJOIN Trained_In ti ON p.EmployeeID = ti.Physician\nJOIN Procedures pr ON ti.Treatment = pr.Code\nWHERE pr.Cost = (SELECT MAX(Cost) FROM Procedures)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n    \"1\": \"This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.\",\n    \"2\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\"\n}\n"}
{"sample_id": "train.3980", "db_id": "hospital_1", "question": "Find all procedures which cost more than 1000 or which physician John Wen was trained in.", "rationale": ["Identify the tables involved: Procedures, Trained_In, and Physician.", "We need to find procedures with a cost greater than 1000, which can be done by filtering the Procedures table.", "We also need to find procedures that John Wen is trained in, which requires joining the Trained_In and Physician tables to get the relevant procedures for that physician.", "Use a LEFT JOIN to connect Procedures with Trained_In on the procedure code and then with Physician on the physician's EmployeeID.", "The WHERE clause will filter for procedures that either have a cost greater than 1000 or are associated with John Wen.", "Use DISTINCT to ensure that we do not have duplicate procedure names in the result."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT DISTINCT Procedures.Name \nFROM Procedures \nLEFT JOIN Trained_In ON Procedures.Code = Trained_In.Treatment \nLEFT JOIN Physician ON Trained_In.Physician = Physician.EmployeeID \nWHERE Procedures.Cost > 1000 OR Physician.Name = 'John Wen';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.\",\n    \"1\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n    \"2\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\"\n}\n"}
{"sample_id": "train.3993", "db_id": "hospital_1", "question": "How many patients are not using Procrastin-X as medication?", "rationale": ["We need to count the number of patients who are not using a specific medication, Procrastin-X.", "First, we identify the medication code for Procrastin-X from the Medication table.", "Next, we find all patients who have been prescribed Procrastin-X by checking the Prescribes table.", "We then use this list of patients to filter out those who are using Procrastin-X from the total list of patients in the Patient table.", "Finally, we count the remaining patients who are not in the list of those using Procrastin-X."], "gold_sql": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )", "source_tables": ["patient", "prescribes", "medication"], "pred_sql": "SELECT COUNT(*) AS PatientCount\nFROM Patient\nWHERE SSN NOT IN (\n    SELECT Patient\n    FROM Prescribes\n    WHERE Medication IN (\n        SELECT Code\n        FROM Medication\n        WHERE Brand = 'Procrastin-X'\n    )\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n    \"1\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n    \"2\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\"\n}\n"}
{"sample_id": "train.4256", "db_id": "club_1", "question": "What are the first names of all the students?", "rationale": ["Identify the table that contains the required information, which is the 'Student' table.", "Determine the specific column needed, which is 'Fname' for the first names of students.", "Construct the SQL query to select the 'Fname' column from the 'Student' table."], "gold_sql": "SELECT DISTINCT fname FROM student", "source_tables": ["student"], "pred_sql": "SELECT Fname FROM Student;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\"\n}\n"}
{"sample_id": "train.4271", "db_id": "club_1", "question": "Give me the first name and last name for all the female members of the club \"Bootup Baltimore\".", "rationale": ["Identify the tables needed: Student, Member_of_club, and Club.", "Determine the columns to select: first name (Fname) and last name (LName) of female members.", "Establish the relationships between the tables: Student is linked to Member_of_club via StuID, and Member_of_club is linked to Club via ClubID.", "Filter the results to include only those members who are female and belong to the club named 'Bootup Baltimore'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses to retrieve the desired information."], "gold_sql": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  'Bootup Baltimore' AND t3.sex  =  'F'", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Fname, LName \nFROM Student \nJOIN Member_of_club ON Student.StuID = Member_of_club.StuID \nJOIN Club ON Member_of_club.ClubID = Club.ClubID \nWHERE Club.ClubName = 'Bootup Baltimore' AND Student.Sex = 'Female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n    \"1\": \"This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.4277", "db_id": "club_1", "question": "Find the club which has the largest number of members majoring in \"600\".", "rationale": ["Identify the tables involved: We need to find clubs and their members, so we will use the 'Club', 'Member_of_club', and 'Student' tables.", "Join the tables: We will join 'Club' with 'Member_of_club' on 'ClubID' and 'Member_of_club' with 'Student' on 'StuID' to get the necessary information about clubs and their members.", "Filter by major: We need to filter the results to only include students majoring in '600'.", "Group the results: We will group the results by club name to count the number of members in each club.", "Count members: We will use COUNT() to count the number of members for each club.", "Order the results: We will order the results by the count of members in descending order to find the club with the most members.", "Limit the results: We will limit the results to 1 to get only the club with the largest number of members."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  '600' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Club.ClubName, COUNT(Member_of_club.StuID) AS MemberCount\nFROM Club\nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID\nJOIN Student ON Member_of_club.StuID = Student.StuID\nWHERE Student.Major = '600'\nGROUP BY Club.ClubName\nORDER BY MemberCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of clubs that students with a specific major are members of. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of clubs returned. The placeholders in the WHERE clause and LIMIT clause represent the major of the students and the maximum number of clubs to display, respectively.\",\n    \"1\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n    \"2\": \"This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.4278", "db_id": "club_1", "question": "Find the name of the club that has the most female students.", "rationale": ["We need to find the name of the club with the most female students.", "To do this, we will join the 'Club', 'Member_of_club', and 'Student' tables to access the necessary information about clubs and their members.", "We will filter the results to include only female students by using a WHERE clause that checks for 'Student.Sex = 'Female'.", "Next, we will group the results by club name to count the number of female members in each club.", "We will order the results in descending order based on the count of female students to get the club with the most female members at the top.", "Finally, we will limit the results to 1 to get only the top club."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Club.ClubName\nFROM Club\nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID\nJOIN Student ON Member_of_club.StuID = Student.StuID\nWHERE Student.Sex = 'Female'\nGROUP BY Club.ClubName\nORDER BY COUNT(Student.StuID) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n    \"1\": \"This virtual table lists the names of clubs that students with a specific major are members of. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of clubs returned. The placeholders in the WHERE clause and LIMIT clause represent the major of the students and the maximum number of clubs to display, respectively.\",\n    \"2\": \"This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.4312", "db_id": "club_1", "question": "List the clubs that have at least a member with advisor \"1121\".", "rationale": ["We need to list clubs that have at least one member with a specific advisor, which is '1121'.", "To achieve this, we will join the 'Club', 'Member_of_club', and 'Student' tables.", "The 'Club' table contains the club names, while the 'Member_of_club' table links students to clubs, and the 'Student' table contains advisor information.", "We will use a JOIN operation to connect these tables based on their relationships: 'Member_of_club.ClubID' with 'Club.ClubID' and 'Member_of_club.StuID' with 'Student.StuID'.", "We will filter the results using a WHERE clause to only include students whose advisor is '1121'.", "Finally, we will select distinct club names to avoid duplicates in the results."], "gold_sql": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  1121", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT DISTINCT Club.ClubName \nFROM Club \nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID \nJOIN Student ON Member_of_club.StuID = Student.StuID \nWHERE Student.Advisor = '1121';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of clubs that students with a specific major are members of. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of clubs returned. The placeholders in the WHERE clause and LIMIT clause represent the major of the students and the maximum number of clubs to display, respectively.\",\n    \"1\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n    \"2\": \"This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: Grants, Organisations, and Organisation_Types.", "We need to sum the grant amounts, so we will use the SUM function on the grant_amount column from the Grants table.", "To filter the organisations described as research, we will join the Organisations table with the Organisation_Types table using the organisation_type foreign key.", "We will filter the results where the organisation_type_description in Organisation_Types is 'research'.", "Finally, we will select the total grant amount by summing the grant_amount from the Grants table."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT SUM(g.grant_amount) AS total_grant_amount\nFROM Grants g\nJOIN Organisations o ON g.organisation_id = o.organisation_id\nJOIN Organisation_Types ot ON o.organisation_type = ot.organisation_type\nWHERE ot.organisation_type_description = 'research';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n    \"1\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the role code for the leader role from the Staff_Roles table.", "Use the role code to filter the Project_Staff table to find projects that have staff in a leader role.", "Group the results by project_id and count the number of staff members for each project.", "Order the projects by the count of staff members in descending order to find the project with the most staff.", "Limit the results to 1 to get the project_id of the project with the most staff in a leader role.", "Use the project_id obtained to select the date_from and date_to from the Project_Staff table."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to \nFROM Project_Staff \nWHERE project_id = (SELECT project_id \n                    FROM Project_Staff \n                    WHERE role_code = (SELECT role_code \n                                      FROM Staff_Roles \n                                      WHERE role_description = 'leader') \n                    GROUP BY project_id \n                    ORDER BY COUNT(staff_id) DESC \n                    LIMIT 1)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4328", "db_id": "tracking_grants_for_research", "question": "Find the organisation ids and details of the organisations which are involved in", "rationale": ["The user wants to find the organisation ids and details of the organisations involved in projects.", "To get the organisation ids and details, we need to select the relevant columns from the Organisations table.", "The relevant columns are 'organisation_id' and 'organisation_details'.", "The query will be a simple SELECT statement from the Organisations table."], "gold_sql": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  6000", "source_tables": ["grants", "organisations"], "pred_sql": "SELECT organisation_id, organisation_details FROM Organisations;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields.", "Group the results by organisation_id and organisation_type to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most research staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type \nFROM Organisations o \nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id \nGROUP BY o.organisation_id, o.organisation_type \nORDER BY COUNT(rs.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4331", "db_id": "tracking_grants_for_research", "question": "What is the type and id of the organization that has the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id.", "Group the results by organisation_id and organisation_type to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most research staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_type, Organisations.organisation_id\nFROM Organisations\nJOIN Research_Staff ON Organisations.organisation_id = Research_Staff.employer_organisation_id\nGROUP BY Organisations.organisation_id, Organisations.organisation_type\nORDER BY COUNT(Research_Staff.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4333", "db_id": "tracking_grants_for_research", "question": "What is the type of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations, Research_Staff, and Organisation_Types are needed to find the type of organization with the most research staff.", "Join the Organisations table with the Research_Staff table on the organisation_id to link research staff to their respective organizations.", "Join the Organisation_Types table to get the description of the organization type.", "Group the results by organisation_id to count the number of research staff per organization.", "Order the results by the count of research staff in descending order to get the organization with the most staff at the top.", "Limit the results to 1 to get only the top organization."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT ot.organisation_type_description \nFROM Organisations o \nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id \nJOIN Organisation_Types ot ON o.organisation_type = ot.organisation_type \nGROUP BY o.organisation_id \nORDER BY COUNT(rs.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the relevant tables: Documents, Grants, Organisations, and Organisation_Types.", "Determine the relationships between these tables: Documents are linked to Grants via grant_id, Grants are linked to Organisations via organisation_id, and Organisations are linked to Organisation_Types via organisation_type.", "Select the 'sent_date' from the Documents table as the main output.", "Join the Grants table to filter documents based on the grant amount, specifically those greater than 5000.", "Join the Organisations table to ensure we can access the organisation type, although it is not directly used in the WHERE clause for filtering.", "Construct the SQL query to retrieve the desired information."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT Documents.sent_date \nFROM Documents \nJOIN Grants ON Documents.grant_id = Grants.grant_id \nJOIN Organisations ON Grants.organisation_id = Organisations.organisation_id \nJOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type \nWHERE Grants.grant_amount > 5000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n    \"1\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4335", "db_id": "tracking_grants_for_research", "question": "What are the send dates for all documents that have a grant amount of more than 5000 and are involved in research?", "rationale": ["Identify the relevant tables: Documents and Grants.", "Determine the relationship between the tables: Documents are linked to Grants via grant_id.", "Filter the Grants table for grant amounts greater than 5000.", "Select the sent_date from the Documents table for the filtered grants."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT Documents.sent_date \nFROM Documents \nJOIN Grants ON Documents.grant_id = Grants.grant_id \nWHERE Grants.grant_amount > 5000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n    \"1\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4343", "db_id": "tracking_grants_for_research", "question": "When did researchers start and stop working?", "rationale": ["Identify the relevant table: Project_Staff contains the start and end dates of staff involvement in projects.", "Select the columns needed: date_from (start date) and date_to (end date) are the relevant columns for the question.", "Construct the SQL query: Use SELECT to retrieve date_from and date_to from Project_Staff."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to FROM Project_Staff;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4349", "db_id": "tracking_grants_for_research", "question": "What are the details for the project whose research has been published?", "rationale": ["Identify the main table to query: Projects, as we need details for the project.", "Determine the relationship between Projects and Research outcomes: Projects are linked to outcomes through Project_Outcomes.", "Filter the Project_Outcomes table to find projects with published research outcomes by checking the Research_Outcomes table for relevant outcome descriptions.", "Use a subquery to find project_ids from Project_Outcomes that match the outcome codes from Research_Outcomes where the description indicates publication.", "Combine the results to select all details from the Projects table for the identified project_ids."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE '%Published%'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT * FROM Projects WHERE project_id IN (SELECT project_id FROM Project_Outcomes WHERE outcome_code IN (SELECT outcome_code FROM Research_Outcomes WHERE outcome_description LIKE '%published%'))", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n    \"1\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n    \"2\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\"\n}\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes are needed to get project details and their outcomes.", "Join the Projects table with the Project_Outcomes table on the project_id to link projects with their outcomes.", "Group the results by project_id and project_details to aggregate the outcomes for each project.", "Count the number of outcomes for each project using COUNT(po.outcome_code).", "Order the results in descending order to get the project with the most outcomes at the top.", "Limit the results to 1 to get only the project with the highest number of outcomes."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT p.project_id, p.project_details\nFROM Projects p\nJOIN Project_Outcomes po ON p.project_id = po.project_id\nGROUP BY p.project_id, p.project_details\nORDER BY COUNT(po.outcome_code) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n    \"1\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\",\n    \"2\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id.", "Group the results by organisation_id, organisation_type, and organisation_details to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id, o.organisation_type, o.organisation_details\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4361", "db_id": "tracking_grants_for_research", "question": "What are the ids, types, and details of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "We need to join these tables on the organisation_id to get the details of the organizations that employ research staff.", "We will group the results by organisation_id to count the number of research staff for each organization.", "To find the organization with the most research staff, we will order the results by the count of staff in descending order.", "Finally, we will limit the results to 1 to get only the organization with the highest count of research staff."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff for staff involvement in projects and Staff_Roles for role descriptions.", "We need to find the role involved with the most number of projects for each staff id.", "To do this, we will first create a subquery that counts the number of staff members associated with each project and orders them in descending order, limiting the result to the top project.", "Next, we will join the Project_Staff table with the Staff_Roles table to get the role descriptions for the staff members involved in that project.", "Finally, we will select the staff_id and the corresponding role_description from the joined tables."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT ps.staff_id, sr.role_description\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nWHERE ps.project_id IN (\n    SELECT project_id\n    FROM Project_Staff\n    GROUP BY project_id\n    ORDER BY COUNT(staff_id) DESC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n    \"1\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\",\n    \"2\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\"\n}\n"}
{"sample_id": "train.4367", "db_id": "tracking_grants_for_research", "question": "For grants that have descriptions of Regular and Initial Applications, what are their start dates?", "rationale": ["Identify the relevant tables: Grants, Documents, and Document_Types.", "We need to retrieve the start dates of grants, so we will select 'grant_start_date' from the Grants table.", "To filter the grants based on document descriptions, we will join the Documents table with the Grants table using 'grant_id'.", "Next, we will join the Document_Types table with the Documents table using 'document_type_code' to access the document descriptions.", "We will filter the results where the document descriptions are either 'Regular Applications' or 'Initial Applications'."], "gold_sql": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Regular' INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Initial Application'", "source_tables": ["grants", "document_types", "documents"], "pred_sql": "SELECT g.grant_start_date \nFROM Grants g \nJOIN Documents d ON g.grant_id = d.grant_id \nJOIN Document_Types dt ON d.document_type_code = dt.document_type_code \nWHERE dt.document_description IN ('Regular Applications', 'Initial Applications');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n    \"1\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["Identify the relevant tables: Grants and Documents.", "We need to count the number of documents associated with each grant, so we will use a LEFT JOIN between Grants and Documents on the grant_id.", "Use COUNT() to count the number of documents for each grant.", "Group the results by grant_id to get the count for each grant.", "To find the grant with the most documents, we will order the results by the document count in descending order and limit the results to 1."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT g.grant_id, COUNT(d.document_id) AS document_count, d.document_id AS most_documents\nFROM Grants g\nLEFT JOIN Documents d ON g.grant_id = d.grant_id\nGROUP BY g.grant_id\nORDER BY document_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\"\n}\n"}
{"sample_id": "train.4372", "db_id": "tracking_grants_for_research", "question": "What are all the details of the organisations described as 'Sponsor'? Sort the result in an ascending order.", "rationale": ["Identify the relevant table: Organisations.", "Determine the condition to filter organisations: organisation_type should match the type described as 'Sponsor'.", "To find the organisation_type corresponding to 'Sponsor', a subquery is needed to select the organisation_type from Organisation_Types where organisation_type_description is 'Sponsor'.", "Combine the main query and the subquery to filter the Organisations table based on the result of the subquery.", "Sort the results in ascending order by organisation_id."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "pred_sql": "SELECT * FROM Organisations WHERE organisation_type = (SELECT organisation_type FROM Organisation_Types WHERE organisation_type_description = 'Sponsor') ORDER BY organisation_id ASC;", "hint": "\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant table: The question asks for project details, which are stored in the 'Projects' table.", "Determine the specific column: The 'project_details' column contains the descriptions of the projects.", "Formulate the SQL query: We need to select the 'project_id' and 'project_details' from the 'Projects' table where the 'project_details' match the specified value 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT project_id, project_details FROM Projects WHERE project_details = 'sint';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n    \"1\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\"\n}\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes are needed to get project details and their associated outcomes.", "Determine the relationship between the tables: Projects is linked to Project_Outcomes through project_id, and Project_Outcomes is linked to Research_Outcomes through outcome_code.", "Formulate the SELECT statement: We need to select project_details from Projects and outcome_description from Research_Outcomes.", "Add the JOIN clauses to connect the tables based on their relationships.", "Include a WHERE clause to filter the results for projects with the specific detail 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT p.project_details, ro.outcome_description \nFROM Projects p \nJOIN Project_Outcomes po ON p.project_id = po.project_id \nJOIN Research_Outcomes ro ON po.outcome_code = ro.outcome_code \nWHERE p.project_details = 'sint';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n    \"1\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\",\n    \"2\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\"\n}\n"}
{"sample_id": "train.4383", "db_id": "tracking_grants_for_research", "question": "What is the id of the organization with the maximum number of outcomes and how many outcomes are there?", "rationale": ["We need to find the organization with the maximum number of outcomes.", "First, we will join the Project_Outcomes table with the Projects table using the project_id.", "Next, we will join the Projects table with the Organisations table using the organisation_id.", "We will then group the results by organisation_id and count the number of outcomes for each organization using COUNT(outcome_code).", "To find the organization with the maximum outcomes, we will order the results in descending order based on the count of outcomes.", "Finally, we will limit the results to 1 to get the organization with the maximum number of outcomes."], "gold_sql": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT organisation_id, COUNT(outcome_code) AS outcome_count\nFROM Project_Outcomes\nJOIN Projects ON Project_Outcomes.project_id = Projects.project_id\nJOIN Organisations ON Projects.organisation_id = Organisations.organisation_id\nGROUP BY organisation_id\nORDER BY outcome_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4384", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects launched by the organisation", "rationale": ["Identify the relevant table: Projects contains the project details we need.", "Determine the relationship: Projects are linked to Organisations through organisation_id.", "We need to filter projects based on the organisation that launched them, which requires a subquery to find the organisation_id from the Organisations table.", "Construct the SQL query to select project_details from the Projects table where the organisation_id matches the one from the Organisations table."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT project_details FROM Projects WHERE organisation_id = (SELECT organisation_id FROM Organisations WHERE organisation_id = ?)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n    \"1\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\",\n    \"2\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\"\n}\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["Identify the relevant tables: Project_Staff and Staff_Roles.", "We need to retrieve the role descriptions of staff members, which are stored in the Staff_Roles table.", "Join the Project_Staff table with the Staff_Roles table on the role_code to get the role descriptions.", "Filter the results to ensure we only include staff members who have valid start and end dates for their involvement in projects."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT sr.role_description \nFROM Project_Staff ps \nJOIN Staff_Roles sr ON ps.role_code = sr.role_code \nWHERE ps.date_from IS NOT NULL AND ps.date_to IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4394", "db_id": "tracking_grants_for_research", "question": "What are the descriptions of all the project outcomes?", "rationale": ["The user wants to retrieve descriptions of all project outcomes, which are stored in the Project_Outcomes table.", "To get the descriptions, we need to select the relevant columns from the Project_Outcomes table, specifically 'outcome_code' and 'outcome_details'.", "The SQL query will be a simple SELECT statement that fetches these columns from the Project_Outcomes table."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code", "source_tables": ["project_outcomes", "research_outcomes"], "pred_sql": "SELECT outcome_code, outcome_details FROM Project_Outcomes;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\",\n    \"1\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n    \"2\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["To find the most common role for the staff, we need to count the occurrences of each role in the Project_Staff table.", "We will use the COUNT function to count the number of staff members for each role_code.", "We will group the results by role_code to aggregate the counts for each role.", "To determine the most common role, we will order the results in descending order based on the count of staff members.", "Finally, we will limit the results to 1 to get only the most common role."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count \nFROM Project_Staff \nGROUP BY role_code \nORDER BY role_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\"\n}\n"}
{"sample_id": "train.4410", "db_id": "network_2", "question": "Who is the oldest person whose job is student?", "rationale": ["Identify the table to query: The relevant table is 'Person' as it contains information about individuals including their age and job.", "Filter the results: We need to filter the results to only include those whose job is 'student'.", "Sort the results: To find the oldest person, we will sort the results by age in descending order.", "Limit the results: Since we only want the oldest person, we will limit the results to 1."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "pred_sql": "SELECT name, age FROM Person WHERE job = 'student' ORDER BY age DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4439", "db_id": "network_2", "question": "What is the name and age of every male? Order the results by age.", "rationale": ["Identify the relevant table: The 'Person' table contains the information we need (name and age).", "Filter the results: We need to select only male individuals, so we add a WHERE clause to filter by gender.", "Select the required columns: We need to retrieve the 'name' and 'age' columns from the 'Person' table.", "Order the results: We need to order the results by age, so we add an ORDER BY clause for the 'age' column."], "gold_sql": "SELECT name FROM Person WHERE gender  =  'male' ORDER BY age", "source_tables": ["person"], "pred_sql": "SELECT name, age FROM Person WHERE gender = 'male' ORDER BY age;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\"\n}\n"}
{"sample_id": "train.4441", "db_id": "network_2", "question": "What are the names and ages of every person who is a friend of both Dan and Alice?", "rationale": ["We need to find the names and ages of persons who are friends with both Dan and Alice.", "To achieve this, we will join the Person table with the PersonFriend table twice: once for Dan and once for Alice.", "The first join (PF1) will find friends of Dan, and the second join (PF2) will find friends of Alice.", "We will select the name and age from the Person table where the friend matches in both joins.", "The WHERE clause will filter the results to ensure that we only get friends of both Dan and Alice."], "gold_sql": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, P.age \nFROM Person P \nJOIN PersonFriend PF1 ON P.name = PF1.friend \nJOIN PersonFriend PF2 ON P.name = PF2.friend \nWHERE PF1.name = 'Dan' AND PF2.name = 'Alice';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"2\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\"\n}\n"}
{"sample_id": "train.4444", "db_id": "network_2", "question": "Find the name of the person who has friends with age above 40 and under age 30?", "rationale": ["We need to find the names of persons who have friends with specific age criteria: above 40 or under 30.", "To achieve this, we will join the 'Person' table with the 'PersonFriend' table to link persons with their friends.", "We will also join the 'Person' table again to access the age of the friends.", "The WHERE clause will filter friends based on the age conditions: greater than 40 or less than 30.", "Finally, we will use DISTINCT to ensure that we only get unique names of persons who meet the criteria."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT P.name \nFROM Person P \nJOIN PersonFriend PF ON P.name = PF.name \nJOIN Person F ON PF.friend = F.name \nWHERE F.age > 40 OR F.age < 30;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"2\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4445", "db_id": "network_2", "question": "What are the names of every person who has a friend over 40 and under 30?", "rationale": ["We need to find the names of persons who have friends that are either over 40 or under 30.", "To do this, we will join the 'Person' table with the 'PersonFriend' table to link persons with their friends.", "We will then join again with the 'Person' table to access the age of the friends.", "The WHERE clause will filter friends based on the age criteria: friends older than 40 or younger than 30.", "Finally, we will select distinct names to avoid duplicates."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT p1.name \nFROM Person p1 \nJOIN PersonFriend pf1 ON p1.name = pf1.name \nJOIN Person p2 ON pf1.friend = p2.name \nWHERE p2.age > 40 OR p2.age < 30;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"2\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4449", "db_id": "network_2", "question": "What are the names of the people who have no friends who are students?", "rationale": ["Identify the main requirement: we need the names of people who have no friends that are students.", "To find friends who are students, we can query the 'Person' table for names where the job is 'student'.", "Next, we need to find all names in the 'PersonFriend' table where the friend is in the list of students identified in the previous step.", "Finally, we select names from the 'Person' table that are not in the list of names from the 'PersonFriend' table that have friends who are students."], "gold_sql": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  'student'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT name FROM Person WHERE name NOT IN (SELECT name FROM PersonFriend WHERE friend IN (SELECT name FROM Person WHERE job = 'student'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of individuals from the 'Person' table who do not have any friends that work in a specific occupation. The placeholder in the query allows for the specification of the job title to filter out those individuals accordingly.\",\n    \"1\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4454", "db_id": "network_2", "question": "Find the name of persons who are friends with Bob.", "rationale": ["Identify the main goal: to find the names of persons who are friends with Bob.", "Understand the relationship between the tables: 'Person' contains personal details, while 'PersonFriend' contains friendship details.", "Use a JOIN operation to connect 'Person' and 'PersonFriend' based on the name of the person.", "Filter the results to include only those records where the friend is 'Bob'.", "Select the distinct names from the resulting dataset to avoid duplicates."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT P.name \nFROM Person P \nJOIN PersonFriend PF ON P.name = PF.name \nWHERE PF.friend = 'Bob';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n    \"1\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n    \"2\": \"This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4455", "db_id": "network_2", "question": "What are the names of all of Bob's friends?", "rationale": ["Identify the table that contains friendship information, which is 'PersonFriend'.", "Determine that we need to find friends of a specific person, in this case, 'Bob'.", "Construct a SQL query that selects the 'friend' column from the 'PersonFriend' table where the 'name' column matches 'Bob'."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Bob';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n    \"1\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n    \"2\": \"This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4456", "db_id": "network_2", "question": "Find the names of females who are friends with Zach", "rationale": ["Identify the relevant tables: 'Person' for personal details and 'PersonFriend' for friendship details.", "We need to find females who are friends with Zach, so we will join the 'Person' table with the 'PersonFriend' table on the name column.", "In the WHERE clause, we specify that the friend must be 'Zach' and the gender must be 'female'.", "Select the name of the individuals who meet these criteria."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Zach' AND T1.gender  =  'female'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name \nFROM Person P \nJOIN PersonFriend PF ON P.name = PF.name \nWHERE PF.friend = 'Zach' AND P.gender = 'female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n    \"1\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n    \"2\": \"This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4465", "db_id": "network_2", "question": "What are the different names of friends who are younger than the average age for a friend?", "rationale": ["Identify the need to find friends who are younger than the average age.", "Use the PersonFriend table to access the friends of individuals.", "Join the Person table to get the ages of these friends.", "Calculate the average age from the Person table using a subquery.", "Filter the friends based on the condition that their age is less than the calculated average age.", "Select distinct names of friends to avoid duplicates."], "gold_sql": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT pf.friend\nFROM PersonFriend pf\nJOIN Person p ON pf.friend = p.name\nWHERE p.age < (SELECT AVG(age) FROM Person)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"2\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4466", "db_id": "network_2", "question": "Who has friends that are older than the average age? Print their friends and their ages as well", "rationale": ["Identify the need to find friends who are older than the average age.", "Calculate the average age from the Person table using AVG(age).", "Join the PersonFriend table with the Person table to access the ages of friends.", "Filter the results to include only those friends whose age is greater than the calculated average age."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT pf.friend, p.age \nFROM PersonFriend pf \nJOIN Person p ON pf.friend = p.name \nWHERE p.age > (SELECT AVG(age) FROM Person);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"2\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4467", "db_id": "network_2", "question": "Whare the names, friends, and ages of all people who are older than the average age of a person?", "rationale": ["Identify the required fields: names, friends, and ages of people.", "We need to join the 'Person' table with the 'PersonFriend' table to get the friends of each person.", "The condition specifies that we want people who are older than the average age.", "To find the average age, we can use a subquery that calculates the average from the 'Person' table.", "The final SQL query selects the name, friend, and age from the joined tables where the age is greater than the average age."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name, pf.friend, p.age \nFROM Person p \nJOIN PersonFriend pf ON p.name = pf.name \nWHERE p.age > (SELECT AVG(age) FROM Person);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"2\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4473", "db_id": "network_2", "question": "What are the names of all people who are friends with Alice for the shortest amount of time?", "rationale": ["Identify the table that contains friendship information, which is 'PersonFriend'.", "We need to find friends of 'Alice', so we will filter the 'PersonFriend' table where the 'name' column is 'Alice'.", "To find the friends with the shortest friendship duration, we will order the results by the 'year' column in ascending order.", "Finally, we will limit the results to only one friend, as we are interested in the friend with the shortest amount of time."], "gold_sql": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Alice' ORDER BY year ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n    \"1\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n    \"2\": \"This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.\"\n}\n"}
{"sample_id": "train.4475", "db_id": "network_2", "question": "What are the names, ages, and jobs of all people who are friends with Alice for the longest amount of time?", "rationale": ["Identify the required information: names, ages, and jobs of people who are friends with Alice.", "Use the Person table to get the names, ages, and jobs.", "Join the Person table with the PersonFriend table on the name column to find friends of Alice.", "Filter the results to only include those who are friends with Alice by using a WHERE clause.", "To find the friends who have been friends with Alice for the longest time, order the results by the year the friendship was established in ascending order.", "Limit the results to the top entry to get the friend with the longest friendship."], "gold_sql": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, P.age, P.job \nFROM Person P \nJOIN PersonFriend PF ON P.name = PF.name \nWHERE PF.friend = 'Alice' \nORDER BY PF.year ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n    \"1\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n    \"2\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\"\n}\n"}
{"sample_id": "train.4478", "db_id": "network_2", "question": "Which person whose friends have the oldest average age?", "rationale": ["Identify the main goal: Find the person whose friends have the oldest average age.", "To achieve this, we need to calculate the average age of friends for each person.", "Join the 'PersonFriend' table with the 'Person' table to get the ages of friends.", "Group the results by the person's name to calculate the average age of their friends.", "Order the results by the average age in descending order to find the oldest average age.", "Limit the results to 1 to get the person with the oldest average age of friends."], "gold_sql": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT 1", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name\nFROM Person p\nJOIN (\n    SELECT pf.name, AVG(CAST(p.age AS INTEGER)) AS avg_age\n    FROM PersonFriend pf\n    JOIN Person p ON pf.friend = p.name\n    GROUP BY pf.name\n) AS avg_ages ON p.name = avg_ages.name\nORDER BY avg_ages.avg_age DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n    \"2\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\"\n}\n"}
{"sample_id": "train.4480", "db_id": "network_2", "question": "What is the total number of people who has no friend living in the city of Austin.", "rationale": ["We need to count the total number of people who have no friends living in Austin.", "To achieve this, we will use a LEFT JOIN to connect the Person table with the PersonFriend table to find all friends of each person.", "We will also LEFT JOIN the Person table again to get the city of each friend.", "We will filter the results to include only those persons whose friends either do not exist (NULL) or do not live in Austin.", "Finally, we will use COUNT(DISTINCT p.name) to count the unique persons who meet the criteria."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT COUNT(DISTINCT p.name) AS total_no_friends\nFROM Person p\nLEFT JOIN PersonFriend pf ON p.name = pf.name\nLEFT JOIN Person pf_friends ON pf.friend = pf_friends.name\nWHERE pf_friends.city IS NULL OR pf_friends.city != 'Austin';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of distinct persons from the 'PersonFriend' table who have friends that do not reside in a specified city. The placeholder in the WHERE clause represents the name of the city to filter out friends.\",\n    \"1\": \"This virtual table identifies the names of individuals from the 'Person' table who do not have any friends that work in a specific occupation. The placeholder in the query allows for the specification of the job title to filter out those individuals accordingly.\",\n    \"2\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\"\n}\n"}
{"sample_id": "train.4503", "db_id": "document_management", "question": "Find the types of documents with more than 4 documents.", "rationale": ["Identify the table that contains the document types, which is the 'Documents' table.", "We need to count the number of documents for each type, so we will use the COUNT() function.", "To group the results by document type, we will use the GROUP BY clause on 'document_type_code'.", "We want to filter the results to only include document types that have more than 4 documents, so we will use the HAVING clause with COUNT(*) > 4."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code, COUNT(*) as document_count \nFROM Documents \nGROUP BY document_type_code \nHAVING COUNT(*) > 4;", "hint": "\n"}
{"sample_id": "train.4504", "db_id": "document_management", "question": "What are the codes of types of documents of which there are for or more?", "rationale": ["Identify the table that contains the document types, which is the 'Documents' table.", "We need to select the 'document_type_code' from the 'Documents' table.", "To find the document types that have four or more documents, we will group the results by 'document_type_code'.", "We will use the HAVING clause to filter the groups to only include those with a count of 'document_code' that is 4 or more."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code\nFROM Documents\nGROUP BY document_type_code\nHAVING COUNT(document_code) >= 4;", "hint": "\n"}
{"sample_id": "train.4505", "db_id": "document_management", "question": "Find the total access count of all documents in the most popular document type.", "rationale": ["We need to find the total access count of all documents in the most popular document type.", "First, we need to identify the most popular document type. This can be done by grouping the documents by their document_type_code and summing their access counts.", "We will order the results by the summed access count in descending order to get the most popular document type at the top.", "To get only the most popular document type, we will limit the results to 1.", "Once we have the most popular document type, we can then sum the access counts of all documents that match this type."], "gold_sql": "SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT SUM(access_count) AS total_access_count\nFROM Documents\nWHERE document_type_code = (\n    SELECT document_type_code\n    FROM Documents\n    GROUP BY document_type_code\n    ORDER BY SUM(access_count) DESC\n    LIMIT 1\n);", "hint": "\n"}
{"sample_id": "train.4525", "db_id": "document_management", "question": "Find names of the document without any images.", "rationale": ["We need to find documents that do not have any associated images.", "To do this, we will use a LEFT JOIN to connect the Documents table with the Document_Sections table, as each document can have multiple sections.", "Next, we will perform another LEFT JOIN with the Document_Sections_Images table to check for images associated with those sections.", "In the WHERE clause, we will filter for cases where the image_id from Document_Sections_Images is NULL, indicating that there are no images associated with the document's sections."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "pred_sql": "SELECT d.document_name \nFROM Documents d \nLEFT JOIN Document_Sections ds ON d.document_code = ds.document_code \nLEFT JOIN Document_Sections_Images dsi ON ds.section_id = dsi.section_id \nWHERE dsi.image_id IS NULL;", "hint": "\n"}
{"sample_id": "train.4532", "db_id": "document_management", "question": "Count the number of users that are logged in.", "rationale": ["The task is to count the number of users that are logged in.", "To achieve this, we need to select the count of unique user IDs from the Users table.", "The SQL function COUNT() will be used to count the number of user_id entries in the Users table, which represents the logged-in users."], "gold_sql": "SELECT count(*) FROM users WHERE user_login  =  1", "source_tables": ["users"], "pred_sql": "SELECT COUNT(user_id) AS logged_in_users FROM Users;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of user names and their corresponding passwords from the 'Users' table, grouped by their role codes. The results are ordered by the number of users in each role, showing the top roles based on user count, with a limit specified by a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of user names and their corresponding passwords from the 'Users' table, grouped by their role codes. The results are ordered by the number of users in each role, showing the most populated roles first, with a limit on the number of results returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.4733", "db_id": "department_store", "question": "Return the distinct name of customers whose order status is Pending, in the order of customer id.", "rationale": ["Identify the relevant tables: Customers and Customer_Orders are needed to get customer names and their order statuses.", "Use a JOIN to connect Customers and Customer_Orders on the customer_id field, as this is the common identifier between the two tables.", "Filter the results to include only those orders with a status of 'Pending' using a WHERE clause.", "Select distinct customer names to avoid duplicates in the results.", "Order the final results by customer_id to meet the requirement of ordering the output."], "gold_sql": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending' ORDER BY T2.customer_id", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT c.customer_name \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nWHERE co.order_status_code = 'Pending' \nORDER BY c.customer_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\",\n    \"1\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\"\n}\n"}
{"sample_id": "train.4736", "db_id": "department_store", "question": "What are the names and addressed of customers who have both New and Pending orders?", "rationale": ["Identify the relevant tables: Customers and Customer_Orders.", "We need to retrieve customer names and addresses, so we will select 'customer_name' and 'customer_address' from the Customers table.", "To find customers with both 'New' and 'Pending' orders, we will join the Customers table with the Customer_Orders table on 'customer_id'.", "We will filter the results based on the 'order_status_code' to include only 'New' and 'Pending' statuses.", "To ensure we only get customers with both statuses, we will group the results by 'customer_id' and use the HAVING clause to count distinct order statuses, ensuring it equals 2."], "gold_sql": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'New' INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending'", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT c.customer_name, c.customer_address \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nWHERE co.order_status_code IN ('New', 'Pending') \nGROUP BY c.customer_id \nHAVING COUNT(DISTINCT co.order_status_code) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\",\n    \"1\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\"\n}\n"}
{"sample_id": "train.4749", "db_id": "department_store", "question": "Find the id and name of the staff who has been assigned for the shortest period.", "rationale": ["Identify the relevant table: Staff_Department_Assignments contains the staff assignments and their duration.", "To find the shortest assignment period, calculate the difference between date_assigned_to and date_assigned_from.", "Sort the results by the calculated duration in ascending order to get the shortest period first.", "Select the staff_id and staff_name from the sorted results.", "Limit the output to 1 to get only the staff with the shortest assignment period."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name\nFROM Staff_Department_Assignments\nORDER BY (date_assigned_to - date_assigned_from) ASC\nLIMIT 1;", "hint": "\n"}
