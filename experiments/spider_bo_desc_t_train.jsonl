{"sample_id": "train.6800", "db_id": "activity_1", "question": "What are the first names of the faculty members playing both Canoeing and Kayaking?", "rationale": ["The query identifies the relevant tables, which are 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "It selects the 'lname' column from the 'Faculty' table.", "The JOIN operations link faculty members to their participation in activities through the 'Faculty_Participates_in' table and the 'Activity' table.", "The WHERE clause filters the results based on the specified activity name using a placeholder for string values.", "The INTERSECT operation ensures that only faculty members participating in the same activity are returned."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.", "virtual_table": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6799", "db_id": "activity_1", "question": "Find the first names of the faculty members who participate in Canoeing and Kayaking.", "rationale": ["The query identifies the relevant tables, which are 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "It selects the 'lname' column from the 'Faculty' table.", "The JOIN operations link faculty members to their participation in activities through the 'Faculty_Participates_in' table and the 'Activity' table.", "The WHERE clause filters the results based on the specified activity name using a placeholder for string values.", "The INTERSECT operation ensures that only faculty members participating in the same activity are returned."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.", "virtual_table": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6797", "db_id": "activity_1", "question": "Find the first names of professors who are not playing Canoeing or Kayaking.", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'lname' column to display the last names of faculty members.", "A condition is added to filter faculty by their 'rank' using a placeholder for string values.", "The EXCEPT clause is used to exclude faculty members who participate in activities, which is determined by joining the 'Faculty' table with 'Faculty_Participates_in' and 'Activity' tables.", "The activities to be excluded are specified using placeholders for their names."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.", "virtual_table": "SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6777", "db_id": "activity_1", "question": "Show the names of all the activities Mark Giuliano participates in.", "rationale": ["The query identifies the relevant tables: 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "It selects the 'activity_name' from the 'Activity' table.", "The JOIN operations link the 'Faculty' table to the 'Faculty_Participates_in' table using the faculty ID, and then to the 'Activity' table using the activity ID.", "Conditions are added to filter the results based on the specified first and last names of the faculty member using placeholders for string values."], "gold_sql": "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  'Mark' AND T1.lname  =  'Giuliano'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.", "virtual_table": "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6761", "db_id": "activity_1", "question": "Show the ids for all the faculty members who have at least 2 students.", "rationale": ["The query identifies the relevant tables, 'Faculty' and 'Student'.", "It selects the 'FacID' from the 'Faculty' table, which represents the unique identifier for each faculty member.", "A JOIN operation is performed between 'Faculty' and 'Student' on the condition that the faculty member's ID matches the advisor ID of the student.", "The results are grouped by 'FacID' to aggregate the data based on faculty members.", "The HAVING clause filters the results to include only those faculty members who have advised a specified number of students, using a placeholder for numeric values."], "gold_sql": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  2", "source_tables": ["faculty", "student"], "description": "This virtual table identifies faculty members who serve as advisors to students. It retrieves the unique identifiers of faculty members from the 'Faculty' table, joining it with the 'Student' table based on the advisor relationship. The results are grouped by faculty ID, and only those faculty members who have advised a specified number of students are included, as indicated by the placeholder in the HAVING clause.", "virtual_table": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6758", "db_id": "activity_1", "question": "How many students are advised by each rank of faculty? List the rank and the number of students.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the 'rank' column from the 'Faculty' table and counts the number of students associated with each faculty member.", "The join condition links faculty members to their students through the advisor relationship.", "The results are grouped by the faculty rank to provide a count of students for each rank."], "gold_sql": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank", "source_tables": ["faculty", "student"], "description": "This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.", "virtual_table": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank"}
{"sample_id": "train.6755", "db_id": "activity_1", "question": "Show the faculty id of each faculty member, along with the number of students he or she advises.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the 'FacID' from the 'Faculty' table and counts the number of students associated with each faculty member.", "A JOIN operation is performed between 'Faculty' and 'Student' on the advisor relationship, where 'FacID' matches the 'advisor' field in the 'Student' table.", "The results are grouped by 'FacID' to aggregate the count of students for each faculty member."], "gold_sql": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID", "source_tables": ["faculty", "student"], "description": "This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier, and the count reflects the number of students associated with each advisor.", "virtual_table": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID"}
{"sample_id": "train.6802", "db_id": "activity_1", "question": "Which students participate in both Canoeing and Kayaking as their activities? Tell me their student ids.", "rationale": ["The query is identifying the relevant tables, which are 'Participates_in' and 'Activity'.", "It selects the 'stuid' column from the 'Participates_in' table.", "The query uses a JOIN to connect 'Participates_in' with 'Activity' based on the 'actid'.", "It filters the results based on the 'activity_name' for the first activity using a placeholder.", "The INTERSECT operator is used to find students who participate in both activities, requiring a second selection with a similar structure and another placeholder for the second activity's name."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "description": "This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities being compared.", "virtual_table": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6757", "db_id": "activity_1", "question": "Show all the faculty ranks and the number of students advised by each rank.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the 'rank' column from the 'Faculty' table and counts the number of students associated with each faculty member.", "The join condition links faculty members to their students through the advisor relationship.", "The results are grouped by the faculty rank to provide a count of students for each rank."], "gold_sql": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank", "source_tables": ["faculty", "student"], "description": "This virtual table summarizes the number of students assigned to each academic rank of faculty advisors. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students for each rank.", "virtual_table": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank"}
{"sample_id": "train.6756", "db_id": "activity_1", "question": "What are the faculty id and the number of students each faculty has?", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the 'FacID' from the 'Faculty' table and counts the number of students associated with each faculty member.", "The JOIN operation links the 'Faculty' table with the 'Student' table based on the advisor relationship, where 'FacID' matches the 'advisor' field in the 'Student' table.", "The GROUP BY clause is used to aggregate the results by 'FacID', providing a count of students for each faculty member."], "gold_sql": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID", "source_tables": ["faculty", "student"], "description": "This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.", "virtual_table": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID"}
{"sample_id": "train.6776", "db_id": "activity_1", "question": "Find the number of activities Mark Giuliano is involved in.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Faculty_Participates_in'.", "It uses a JOIN operation to connect the two tables based on the faculty member's ID.", "The SELECT statement counts the number of records that match the specified first and last names of the faculty member using placeholders for string values."], "gold_sql": "SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  'Mark' AND T1.lname  =  'Giuliano'", "source_tables": ["faculty", "faculty_participates_in"], "description": "This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.", "virtual_table": "SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6752", "db_id": "activity_1", "question": "Which students have professors as their advisors? Find their student ids.", "rationale": ["The query is identifying the relevant tables, which are 'Faculty' and 'Student'.", "A JOIN operation is performed to connect the 'Faculty' table with the 'Student' table based on the advisor relationship.", "The SELECT statement specifies that we want to retrieve the 'StuID' from the 'Student' table.", "A condition is added to filter faculty members based on their rank using a placeholder for string values."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "description": "This virtual table identifies the unique identifiers of students who are advised by faculty members of a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.", "virtual_table": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6779", "db_id": "activity_1", "question": "Show the first and last name of all the faculty members who participated in some activity, together with the number of activities they participated in.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Faculty_Participates_in'.", "It selects the first name and last name of faculty members, along with a count of their participation in activities.", "The join condition links faculty members to their activities based on the unique faculty identifier.", "The results are grouped by the faculty identifier to aggregate the count of activities for each faculty member."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "description": "This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.", "virtual_table": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID"}
{"sample_id": "train.6748", "db_id": "activity_1", "question": "How many male and female assistant professors do we have?", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'sex' column and counts the number of occurrences for each gender.", "A condition is added to filter the results based on the specified 'rank' using a placeholder for string values.", "The results are grouped by the 'sex' column to provide a count for each gender."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "description": "This virtual table summarizes the count of faculty members by gender from the 'Faculty' table, filtered by a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty members.", "virtual_table": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sex"}
{"sample_id": "train.6737", "db_id": "activity_1", "question": "Which building has most faculty members?", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'building' column to display the names of the buildings.", "The results are grouped by 'building' to aggregate the data based on the building name.", "The query orders the results by the count of faculty members in each building in descending order to show the most populated buildings first.", "The LIMIT clause uses a placeholder to allow users to specify how many buildings they want to retrieve."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "description": "This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The results are ordered by the number of faculty members in each building, allowing users to see which buildings have the most faculty presence. The placeholder in the LIMIT clause represents the maximum number of buildings to return.", "virtual_table": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6726", "db_id": "activity_1", "question": "What are the faculty ids of all the male faculty members?", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the column to display, 'FacID'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "description": "This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.", "virtual_table": "SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6739", "db_id": "activity_1", "question": "Show all the buildings that have at least 10 professors.", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "Select the 'building' column to display the locations of faculty offices.", "Add a condition to filter the 'rank' column for the specified academic rank using a placeholder for string values.", "Group the results by 'building' to aggregate the data based on the location.", "Use the HAVING clause to filter the grouped results to include only those buildings with a count of faculty members greater than or equal to a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT building FROM Faculty WHERE rank  =  'Professor' GROUP BY building HAVING count(*)  >=  10", "source_tables": ["faculty"], "description": "This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.", "virtual_table": "SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6733", "db_id": "activity_1", "question": "Show the first name and last name for all the instructors.", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the columns to display, 'fname' and 'lname'.", "Add a condition to filter the 'Rank' column for the specified rank using a placeholder for string values."], "gold_sql": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  'Instructor'", "source_tables": ["faculty"], "description": "This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.", "virtual_table": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6724", "db_id": "activity_1", "question": "What are the first name, last name, and phone number of all the female faculty members?", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the columns to display, 'Fname', 'Lname', and 'phone'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'", "source_tables": ["faculty"], "description": "This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.", "virtual_table": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6734", "db_id": "activity_1", "question": "What are the first name and last name of all the instructors?", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the columns to display, 'fname' and 'lname'.", "Add a condition to filter the 'Rank' column for the specified rank using a placeholder for string values."], "gold_sql": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  'Instructor'", "source_tables": ["faculty"], "description": "This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.", "virtual_table": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It counts the total number of students that meet certain criteria.", "The first condition filters students based on their gender using a placeholder for string values.", "The second condition checks if the student's ID is in a subquery that joins 'Has_Allergy' and 'Allergy_Type' to filter by a specific allergy type, using another placeholder for string values."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.", "virtual_table": "SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'lname'.", "Add a condition to filter out students whose IDs are in a subquery.", "The subquery selects student IDs from 'Has_Allergy' joined with 'Allergy_Type' where the allergy type matches the specified placeholder."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.", "virtual_table": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.534", "db_id": "allergy_1", "question": "How many students are over 18 and do not have allergy to food type or animal type?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It counts the total number of students that meet the specified age condition.", "A subquery is used to filter out students who have allergies of certain types by joining 'Has_Allergy' and 'Allergy_Type' tables.", "The placeholders in the WHERE clause represent the age limit and the allergy types to be excluded."], "gold_sql": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' OR T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.", "virtual_table": "SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.526", "db_id": "allergy_1", "question": "How old are the students with allergies to food and animal types on average?", "rationale": ["The query identifies the relevant table, which is 'Student', to calculate the average age.", "It uses a subquery to find students who have allergies of a specific type by joining 'Has_Allergy' and 'Allergy_Type'.", "The INTERSECT operator is used to ensure that only students with both specified allergy types are considered.", "The placeholders in the WHERE clause represent the allergy types to filter the students accordingly."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.", "virtual_table": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'lname' and 'age'.", "Add a condition to filter students based on their allergies using a subquery that checks for students with both specified allergies using the INTERSECT operator. The placeholders represent the names of the allergies."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.", "virtual_table": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.536", "db_id": "allergy_1", "question": "What are the first name and major of the students who are able to consume soy?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'major'.", "Add a condition to filter students who do not have a specific allergy by using a subquery that checks the 'StuID' in the 'Has_Allergy' table for the specified allergy, using a placeholder for string values."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy being checked against the 'Has_Allergy' table.", "virtual_table": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.512", "db_id": "allergy_1", "question": "How many students are affected by food related allergies?", "rationale": ["The query identifies the relevant tables, 'Has_Allergy' and 'Allergy_Type'.", "It uses a JOIN operation to connect these tables based on the allergy name.", "The SELECT statement counts the number of records that match the specified allergy type, using a placeholder for the allergy type in the WHERE clause."], "gold_sql": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  'food'", "source_tables": ["has_allergy", "allergy_type"], "description": "This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.", "virtual_table": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["The query identifies the relevant tables, which are 'Student' and 'Has_Allergy'.", "It selects distinct first names and city codes from the 'Student' table.", "A JOIN operation is performed between 'Student' and 'Has_Allergy' on the student ID to link students with their allergies.", "The WHERE clause filters the results to include only those students who have one of the specified allergies, using placeholders for the allergy names."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.", "virtual_table": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.524", "db_id": "allergy_1", "question": "What are the first name and gender of the students who have allergy to milk but can put up with cats?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'sex'.", "Use a subquery to filter students based on their allergies from the 'Has_Allergy' table.", "The first part of the subquery selects students with a specific allergy, while the EXCEPT clause excludes those with another specified allergy, both using placeholders for the allergy names."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.", "virtual_table": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.523", "db_id": "allergy_1", "question": "Find the first name and gender of the student who has allergy to milk but not cat.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'sex'.", "Use a subquery to filter students based on their allergies from the 'Has_Allergy' table.", "The first part of the subquery selects students with a specific allergy using a placeholder for string values.", "The second part of the subquery excludes students with another specified allergy using another placeholder for string values."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.", "virtual_table": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.511", "db_id": "allergy_1", "question": "How many students have a food allergy?", "rationale": ["The query identifies the relevant tables, 'Has_Allergy' and 'Allergy_Type'.", "It uses a JOIN operation to connect these tables based on the allergy name.", "The SELECT statement counts the number of records that match the specified allergy type.", "A placeholder is included in the WHERE clause to filter results based on the allergy type."], "gold_sql": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  'food'", "source_tables": ["has_allergy", "allergy_type"], "description": "This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.", "virtual_table": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.442", "db_id": "allergy_1", "question": "How many distinct allergies are there?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects the distinct values of the 'AllergyType' column to ensure that only unique allergy types are counted.", "The use of the COUNT function allows for the aggregation of these distinct values, providing a total count."], "gold_sql": "SELECT count(DISTINCT allergytype) FROM Allergy_type", "source_tables": ["allergy_type"], "description": "This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.", "virtual_table": "SELECT count(DISTINCT allergytype) FROM Allergy_type"}
{"sample_id": "train.452", "db_id": "allergy_1", "question": "How many animal type allergies exist?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects the count of records to determine how many allergies fall under a specific type.", "A condition is added to filter the 'AllergyType' column for the specified allergy type using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  'animal'", "source_tables": ["allergy_type"], "description": "This virtual table provides the count of different allergies categorized under a specific type from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the allergy type being queried.", "virtual_table": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects the 'allergytype' column to display the types of allergies.", "The query groups the results by 'allergytype' to aggregate the data.", "It orders the results by the count of occurrences in descending order to show the most common types first.", "The LIMIT clause uses a placeholder for numeric values to specify how many types to return."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "description": "This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.", "virtual_table": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.491", "db_id": "allergy_1", "question": "Which major has most number of students?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the column to display, 'major'.", "Group the results by the 'major' column to aggregate the data.", "Order the results by the count of students in each major in descending order to show the most popular majors first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of academic majors from the 'Student' table, grouped by the major and ordered by the number of students in each major in descending order. The placeholder in the LIMIT clause represents the maximum number of majors to return.", "virtual_table": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["The query identifies the relevant table, which is 'Has_Allergy'.", "It selects the count of records to determine how many students have a specific allergy.", "A condition is added to filter the 'Allergy' column for the specified allergy using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "description": "This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.", "virtual_table": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.471", "db_id": "allergy_1", "question": "Show student ids for all male students.", "rationale": ["The query is identifying the relevant table, which is 'Student'.", "Select the column to display, 'StuID'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "description": "This virtual table lists the unique identifiers of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT StuID FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.514", "db_id": "allergy_1", "question": "Which allergy is the most common?", "rationale": ["The query identifies the relevant table, which is 'Has_Allergy'.", "It selects the 'Allergy' column to display the names of allergies.", "The GROUP BY clause is used to group the results by the 'Allergy' name.", "The ORDER BY clause sorts the results based on the count of occurrences in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "description": "This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.", "virtual_table": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.470", "db_id": "allergy_1", "question": "What are the full names and ages for all female students whose sex is F?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display: 'Fname', 'Lname', and 'Age'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT Fname ,  Lname ,  Age FROM Student WHERE Sex  =  'F'", "source_tables": ["student"], "description": "This virtual table provides the first name, last name, and age of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT Fname ,  Lname ,  Age FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.450", "db_id": "allergy_1", "question": "What is allergy type of a cat allergy?", "rationale": ["The query is identifying the relevant table, which is 'Allergy_Type'.", "Select the column to display, 'AllergyType'.", "Add a condition to filter the 'Allergy' column for the specified allergy using a placeholder for string values."], "gold_sql": "SELECT allergytype FROM Allergy_type WHERE allergy  =  'Cat'", "source_tables": ["allergy_type"], "description": "This virtual table describes the type or category of a specific allergy from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the name of the allergy being queried.", "virtual_table": "SELECT allergytype FROM Allergy_type WHERE allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.502", "db_id": "allergy_1", "question": "Give the advisor with the most students.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the column to display, 'advisor'.", "Group the results by the 'advisor' column to aggregate the data.", "Order the results by the count of students associated with each advisor in descending order.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of academic advisors from the 'Student' table, grouped by the advisor's name. The results are ordered by the number of students assigned to each advisor in descending order, with a limit on the number of advisors returned, specified by a placeholder for numeric values.", "virtual_table": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3126", "db_id": "assets_maintenance", "question": "Which assets have 2 parts and have less than 2 fault logs? List the asset id and detail.", "rationale": ["The query identifies the relevant tables, which are 'Assets', 'Asset_Parts', and 'Fault_Log'.", "It selects the 'asset_id' and 'asset_details' from the 'Assets' table.", "The first part of the query counts the number of parts associated with each asset and filters those with a specific count using a placeholder.", "The second part of the query counts the number of faults associated with each asset and filters those with a lesser count using another placeholder.", "The INTERSECT operator is used to find assets that meet both conditions."], "gold_sql": "SELECT T1.asset_id ,  T1.asset_details FROM Assets AS T1 JOIN Asset_Parts AS T2 ON T1.asset_id  =  T2.asset_id GROUP BY T1.asset_id HAVING count(*)  =  2 INTERSECT SELECT T1.asset_id ,  T1.asset_details FROM Assets AS T1 JOIN Fault_Log AS T2 ON T1.asset_id  =  T2.asset_id GROUP BY T1.asset_id HAVING count(*)  <  2", "source_tables": ["assets", "asset_parts", "fault_log"], "description": "This virtual table describes assets that have a specific number of associated parts and a lesser number of recorded faults. The placeholders in the HAVING clauses represent the numeric values for the counts of parts and faults.", "virtual_table": "SELECT T1.asset_id ,  T1.asset_details FROM Assets AS T1 JOIN Asset_Parts AS T2 ON T1.asset_id  =  T2.asset_id GROUP BY T1.asset_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.asset_id ,  T1.asset_details FROM Assets AS T1 JOIN Fault_Log AS T2 ON T1.asset_id  =  T2.asset_id GROUP BY T1.asset_id HAVING count(*)  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3134", "db_id": "assets_maintenance", "question": "For all the faults of different parts, what are all the decriptions of the skills required to fix them? List the name of the faults and the skill description.", "rationale": ["The query identifies the relevant tables: 'Part_Faults', 'Skills_Required_To_Fix', and 'Skills'.", "It selects the 'fault_short_name' from 'Part_Faults' and 'skill_description' from 'Skills'.", "The join between 'Part_Faults' and 'Skills_Required_To_Fix' is established using the 'part_fault_id'.", "Another join is made between 'Skills_Required_To_Fix' and 'Skills' using the 'skill_id' to retrieve the skill descriptions."], "gold_sql": "SELECT T1.fault_short_name ,  T3.skill_description FROM Part_Faults AS T1 JOIN Skills_Required_To_Fix AS T2 ON T1.part_fault_id  =  T2.part_fault_id JOIN Skills AS T3 ON T2.skill_id  =  T3.skill_id", "source_tables": ["part_faults", "skills", "skills_required_to_fix"], "description": "This virtual table provides a list of fault short names along with their corresponding skill descriptions required to fix those faults. The data is sourced from the 'Part_Faults' table, which contains information about faults related to parts, and is joined with the 'Skills_Required_To_Fix' table to identify the necessary skills, and the 'Skills' table to get detailed descriptions of those skills.", "virtual_table": "SELECT T1.fault_short_name ,  T3.skill_description FROM Part_Faults AS T1 JOIN Skills_Required_To_Fix AS T2 ON T1.part_fault_id  =  T2.part_fault_id JOIN Skills AS T3 ON T2.skill_id  =  T3.skill_id"}
{"sample_id": "train.3136", "db_id": "assets_maintenance", "question": "What are all the fault descriptions and the fault status of all the faults recoreded in the logs?", "rationale": ["The query identifies the relevant tables, which are 'Fault_Log' and 'Fault_Log_Parts'.", "It selects the 'fault_description' from 'Fault_Log' and 'fault_status' from 'Fault_Log_Parts'.", "A JOIN operation is performed on the 'fault_log_entry_id' to connect the fault log entries with the parts related to those faults."], "gold_sql": "SELECT T1.fault_description ,  T2.fault_status FROM Fault_Log AS T1 JOIN Fault_Log_Parts AS T2 ON T1.fault_log_entry_id  =  T2.fault_log_entry_id", "source_tables": ["fault_log_parts", "fault_log"], "description": "This virtual table provides a view of fault descriptions and their corresponding statuses from the 'Fault_Log' and 'Fault_Log_Parts' tables. The join operation links the fault log entries with the parts associated with those faults, allowing users to see the details of each fault alongside its current status.", "virtual_table": "SELECT T1.fault_description ,  T2.fault_status FROM Fault_Log AS T1 JOIN Fault_Log_Parts AS T2 ON T1.fault_log_entry_id  =  T2.fault_log_entry_id"}
{"sample_id": "train.3154", "db_id": "assets_maintenance", "question": "Which gender makes up the majority of the staff?", "rationale": ["The query identifies the relevant table, which is 'Staff'.", "It selects the 'gender' column to analyze the distribution of genders.", "The GROUP BY clause is used to group the results by gender, allowing for counting occurrences of each gender.", "The ORDER BY clause sorts the results based on the count of each gender in descending order, ensuring the most common genders appear first.", "The LIMIT clause uses a placeholder to allow the user to specify how many gender categories they want to see."], "gold_sql": "SELECT gender FROM staff GROUP BY gender ORDER BY count(*) DESC LIMIT 1", "source_tables": ["staff"], "description": "This virtual table provides a summary of the gender distribution among staff members in the 'Staff' table. The placeholder in the LIMIT clause allows the user to specify the maximum number of gender categories to return, sorted by the most common gender first.", "virtual_table": "SELECT gender FROM staff GROUP BY gender ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3698", "db_id": "baseball_1", "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?", "rationale": ["The query identifies the relevant tables: 'salary', 'player', and 'team'.", "It selects the 'name_first' and 'name_last' columns from the 'player' table.", "The 'salary' table is joined with the 'player' table using the 'player_id' to link salary records to players.", "The 'team' table is joined using the 'team_id_br' to connect salary records to the respective team.", "The WHERE clause filters the results based on the specified year and team name using placeholders for user input.", "The INTERSECT operator is used to ensure that the results from both queries are the same, which is somewhat redundant in this case."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "description": "This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.", "virtual_table": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3672", "db_id": "baseball_1", "question": "For each year, return the year and the number of times the team Boston Red Stockings won in the postseasons.", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the count of wins and the year from the 'postseason' table.", "A JOIN is performed between 'postseason' and 'team' on the winning team identifier to filter results based on the team name.", "The WHERE clause uses a placeholder to specify the team name, allowing for dynamic querying.", "The results are grouped by year to provide a count of wins for each year."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "description": "This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.", "virtual_table": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year"}
{"sample_id": "train.3693", "db_id": "baseball_1", "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the sum of the 'attendance' column from the 'home_game' table.", "A join is performed between 'home_game' and 'team' on the 'team_id' to link attendance data with the team information.", "A condition is added to filter the results based on the specified team name using a placeholder for string values.", "Another condition is included to filter the years of the home games using placeholders for numeric values."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "description": "This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.", "virtual_table": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3670", "db_id": "baseball_1", "question": "Find the name and id of the team that won the most times in 2008 postseason.", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the team name from the 'team' table and the winning team ID from the 'postseason' table.", "A JOIN operation is performed to link the winning team ID with the corresponding team name using the team ID.", "A condition is added to filter the results for a specific year using a placeholder for numeric values.", "The results are grouped by the winning team ID to aggregate the data and ordered by the count of wins in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"], "description": "This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.", "virtual_table": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["The query identifies the relevant tables, 'team' and 'salary'.", "It selects the 'name' and 'team_id' from the 'team' table (aliased as T1).", "It joins the 'team' table with the 'salary' table (aliased as T2) on the 'team_id' to correlate teams with their players' salaries.", "The results are grouped by 'team_id' to calculate the average salary for each team.", "The results are ordered by the average salary in ascending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "description": "This virtual table provides a list of team names and their corresponding team IDs from the 'team' table, along with the average salary of players from each team. The results are ordered by the average salary in ascending order, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3694", "db_id": "baseball_1", "question": "How many games in total did team Boston Red Stockings attend from 2000 to 2010?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the sum of the 'attendance' column from the 'home_game' table.", "A join is performed between 'home_game' and 'team' on the 'team_id' to link the attendance data with the team information.", "A condition is added to filter the results based on the specified team name using a placeholder for string values.", "Another condition is included to filter the years of the home games using placeholders for numeric values."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "description": "This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.", "virtual_table": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3632", "db_id": "baseball_1", "question": "Compute the average salary of the players in the team called 'Boston Red Stockings'.", "rationale": ["The query identifies the relevant tables, which are 'salary' and 'team'.", "It selects the average salary from the 'salary' table.", "A JOIN is performed between 'salary' and 'team' on the team_id to link player salaries to their respective teams.", "A condition is added to filter the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "description": "This virtual table calculates the average salary of players from a specific team in the 'salary' table. The placeholder in the WHERE clause represents the name of the team for which the average salary is being calculated.", "virtual_table": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3658", "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["The query identifies the relevant tables, which are 'team' and 'salary'.", "It selects the 'name' and 'team_id' from the 'team' table and the maximum salary from the 'salary' table.", "A JOIN operation is performed on the 'team_id' to link the two tables based on the team identifier.", "The results are grouped by 'team_id' to ensure that each team appears only once with its maximum salary."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "description": "This virtual table provides the names and identifiers of teams along with their highest recorded salary from the 'salary' table. The data is grouped by team identifiers to ensure that each team is represented only once with its maximum salary.", "virtual_table": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;"}
{"sample_id": "train.3677", "db_id": "baseball_1", "question": "What is the total salary paid by team Boston Red Stockings in 2010?", "rationale": ["The query identifies the relevant tables, 'salary' and 'team'.", "It selects the sum of salaries from the 'salary' table, which is aliased as T1.", "A join is performed between the 'salary' table and the 'team' table on the team_id to link salary records to the respective teams.", "Conditions are added to filter the results based on the specified team name and year using placeholders for string and numeric values."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "description": "This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.", "virtual_table": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3671", "db_id": "baseball_1", "question": "What is the number of wins the team Boston Red Stockings got in the postseasons each year in history?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the count of wins and the year from the 'postseason' table.", "A JOIN is performed between 'postseason' and 'team' on the winning team identifier.", "A condition is added to filter results based on the specified team name using a placeholder for string values.", "The results are grouped by year to provide a count of wins per year."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "description": "This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.", "virtual_table": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["The query selects the first and last names of players from the 'player' table.", "It joins the 'player' table with the 'player_award' table to filter players based on the year they received awards.", "The INTERSECT operator is used to find players who received awards in both specified years, indicated by placeholders for numeric values."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "description": "This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.", "virtual_table": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3680", "db_id": "baseball_1", "question": "How many players did Boston Red Stockings have in 2000?", "rationale": ["The query identifies the relevant tables, 'salary' and 'team'.", "It uses a JOIN operation to connect the salary records with the corresponding team based on the team identifier.", "The SELECT statement counts the total number of salary records for the specified team name and year, using placeholders for user input."], "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"], "description": "This virtual table counts the number of salary records for a specific team in a given year. The placeholders represent the team's name and the year for which the salary records are being queried.", "virtual_table": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["The query identifies the relevant tables, which are 'salary' and 'team'.", "It selects the average salary from the 'salary' table.", "A JOIN is performed between the 'salary' table and the 'team' table based on the team identifier.", "A condition is added to filter the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "description": "This virtual table calculates the average salary of players from a specific team in the 'salary' table. The placeholder in the WHERE clause represents the name of the team for which the average salary is being calculated.", "virtual_table": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3709", "db_id": "baseball_1", "question": "Which park had most attendances in 2008?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It selects the 'park_name' from the 'park' table.", "A JOIN operation is performed to connect 'home_game' and 'park' based on the 'park_id'.", "A condition is added to filter results for a specific year using a placeholder for numeric values.", "The results are ordered by attendance in descending order and limited to a specified number using placeholders."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "description": "This virtual table provides a list of park names where home games were played in a specific year, ordered by the total attendance of those games. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.", "virtual_table": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3674", "db_id": "baseball_1", "question": "How many times in total did the team Boston Red Stockings participate in postseason games?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It uses a UNION to combine results from two SELECT statements: one for winning teams and one for losing teams.", "Each SELECT statement joins the 'postseason' table with the 'team' table based on the winning and losing team identifiers.", "The WHERE clause filters the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"], "description": "This virtual table counts the total number of postseason appearances for a specific team, including both wins and losses. It combines data from the 'postseason' table and the 'team' table, filtering by the team's name provided as a placeholder.", "virtual_table": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );"}
{"sample_id": "train.3701", "db_id": "baseball_1", "question": "Which team had the least number of attendances in home games in 1980?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the 'name' column from the 'team' table, which contains the names of the teams.", "A JOIN operation is performed between 'home_game' and 'team' on the 'team_id' to link home games with their respective teams.", "A condition is added to filter the results based on the specified year using a placeholder for numeric values.", "The results are ordered by the 'attendance' column in ascending order and limited to a specified number of results using placeholders."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "description": "This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.", "virtual_table": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3668", "db_id": "baseball_1", "question": "Count the number of times the team \"Boston Red Stockings\" lost in 2009 postseason.", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It joins these tables on the condition that the losing team's ID matches the team's ID in the 'team' table.", "The SELECT statement counts the number of losses for the specified team in the specified year, using placeholders for the team name and year."], "gold_sql": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year = 2009;", "source_tables": ["postseason", "team"], "description": "This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.", "virtual_table": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3700", "db_id": "baseball_1", "question": "Count the total number of games the team Boston Red Stockings attended from 1990 to 2000.", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the sum of the 'games' column from the 'home_game' table.", "A join is performed between 'home_game' and 'team' on the 'team_id' to link the games to the specific team.", "A condition is added to filter by the team's name using a placeholder for string values.", "Another condition is added to filter the years using placeholders for numeric values."], "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"], "description": "This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.", "virtual_table": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3667", "db_id": "baseball_1", "question": "How many times did Boston Red Stockings lose in 2009 postseason?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It joins these tables on the condition that the losing team's identifier matches the team's identifier in the 'team' table.", "The SELECT statement counts the number of records that meet the specified conditions.", "The WHERE clause filters the results based on the team's name and the year, using placeholders for user input."], "gold_sql": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year = 2009;", "source_tables": ["postseason", "team"], "description": "This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.", "virtual_table": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3682", "db_id": "baseball_1", "question": "How much salary did the top 3 well-paid players get in 2001?", "rationale": ["The query identifies the relevant table, which is 'salary'.", "It selects the 'salary' column to display the salary amounts.", "A condition is added to filter the records for a specific year using a placeholder for numeric values.", "The results are ordered by salary in descending order to show the highest salaries first.", "A limit is applied to restrict the number of records returned, using a placeholder for numeric values."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "description": "This virtual table provides the salary records from the 'salary' table for a specific year, sorted in descending order. The placeholders represent the year for which the salary data is requested and the limit on the number of records to return.", "virtual_table": "SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY salary DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3652", "db_id": "baseball_1", "question": "What are the first name and last name of the players whose death record is empty?", "rationale": ["The query identifies the relevant table, which is 'player'.", "Select the columns to display, 'name_first' and 'name_last'.", "Add a condition to filter the 'death_year' column for the specified year using a placeholder for string values."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE death_year = '';", "source_tables": ["player"], "description": "This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.", "virtual_table": "SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3638", "db_id": "baseball_1", "question": "Count the number of players who enter hall of fame for each year.", "rationale": ["The query identifies the relevant table, which is 'hall_of_fame'.", "It selects the 'yearid' to group the results by year.", "The count function is used to aggregate the number of players inducted for each year, and the results are grouped by 'yearid' to provide a count for each distinct year."], "gold_sql": "SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;", "source_tables": ["hall_of_fame"], "description": "This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.", "virtual_table": "SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;"}
{"sample_id": "train.3663", "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["The query identifies the relevant table, which is 'player'.", "Select the columns to display, 'name_first' and 'name_last'.", "Add a condition to filter the 'weight' column for values greater than a specified number and the 'height' column for values less than a specified number using placeholders for numeric values."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "description": "This virtual table lists the first and last names of players from the 'player' table who either weigh more than a specified amount or are shorter than a specified height. The placeholders in the WHERE clause represent the weight and height criteria for filtering the players.", "virtual_table": "SELECT name_first ,  name_last FROM player WHERE weight  >  [PLACEHOLDER-TYPE:NUMBER] OR height  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3683", "db_id": "baseball_1", "question": "What were all the salary values of players in 2010 and 2001?", "rationale": ["The query identifies the relevant table, which is 'salary'.", "It selects the 'salary' column to display the salary amounts.", "The UNION operator is used to combine results from two different years, with placeholders for the specific years in the WHERE clause."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "description": "This virtual table retrieves the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.", "virtual_table": "SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3664", "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["The query identifies the relevant table, which is 'player'.", "Select the columns to display, 'name_first' and 'name_last'.", "Add a condition to filter the 'weight' column for values greater than a specified number and the 'height' column for values less than a specified number using placeholders for numeric values."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "description": "This virtual table lists the first and last names of players from the 'player' table who either weigh more than a specified amount or are shorter than a specified height. The placeholders in the WHERE clause represent the weight and height criteria for filtering the players.", "virtual_table": "SELECT name_first ,  name_last FROM player WHERE weight  >  [PLACEHOLDER-TYPE:NUMBER] OR height  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3707", "db_id": "baseball_1", "question": "Which cities have 2 to 4 parks?", "rationale": ["The query identifies the relevant table, which is 'park'.", "It selects the 'city' column to display the cities where parks are located.", "The GROUP BY clause is used to group the results by city.", "The HAVING clause filters the grouped results to include only those cities that have a count of parks within a specified range, using placeholders for the minimum and maximum counts."], "gold_sql": "SELECT city FROM park GROUP BY city HAVING count(*) BETWEEN 2 AND 4;", "source_tables": ["park"], "description": "This virtual table lists the cities where parks are located, specifically those that have a number of parks within a specified range. The placeholders in the HAVING clause represent the minimum and maximum number of parks that should be present in those cities.", "virtual_table": "SELECT city FROM park GROUP BY city HAVING count(*) BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.115", "db_id": "car_1", "question": "How many car models are produced in the usa?", "rationale": ["The query identifies the relevant tables: 'model_list', 'car_makers', and 'countries'.", "It uses a JOIN operation to connect 'model_list' with 'car_makers' based on the 'Maker' identifier.", "Another JOIN is performed to connect 'car_makers' with 'countries' using the 'Country' identifier.", "The query counts the number of car models that belong to car makers from a specified country, using a placeholder for the country name in the WHERE clause."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "description": "This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.", "virtual_table": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.104", "db_id": "car_1", "question": "What are the different models for the cards produced after 1980?", "rationale": ["The query identifies the relevant tables: 'model_list', 'car_names', and 'cars_data'.", "It selects distinct car models from the 'model_list' table.", "The join operation connects 'model_list' with 'car_names' based on the model name.", "Another join connects 'car_names' with 'cars_data' using the MakeId to filter by the manufacturing year.", "The WHERE clause includes a condition to filter results for models manufactured after a specified year using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "description": "This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.", "virtual_table": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.116", "db_id": "car_1", "question": "What is the count of the car models produced in the United States?", "rationale": ["The query identifies the relevant tables: 'model_list', 'car_makers', and 'countries'.", "It uses a JOIN operation to connect 'model_list' with 'car_makers' based on the 'Maker' identifier.", "Another JOIN is performed to connect 'car_makers' with 'countries' using the 'Country' identifier.", "The query counts the number of car models that match the specified country name, using a placeholder for the country name in the WHERE clause."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "description": "This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.", "virtual_table": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.103", "db_id": "car_1", "question": "Which distinct car models are the produced after 1980?", "rationale": ["The query identifies the relevant tables: 'model_list', 'car_names', and 'cars_data'.", "It selects distinct car models from the 'model_list' table.", "The JOIN operation connects 'model_list' with 'car_names' based on the model name.", "Another JOIN connects 'car_names' with 'cars_data' using the MakeId to filter by the manufacturing year.", "The WHERE clause includes a condition to filter results for models manufactured after a specified year using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "description": "This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.", "virtual_table": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.106", "db_id": "car_1", "question": "What is the name of each continent and how many car makers are there in each one?", "rationale": ["The query identifies the relevant tables: 'continents', 'countries', and 'car_makers'.", "It selects the 'Continent' from the 'continents' table and counts the number of car makers associated with each continent.", "The JOIN operations link the 'countries' table to the 'continents' table using the continent identifier, and the 'car_makers' table to the 'countries' table using the country identifier.", "The GROUP BY clause groups the results by continent to provide a count of car makers for each continent."], "gold_sql": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;", "source_tables": ["countries", "car_makers", "continents"], "description": "This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.", "virtual_table": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;"}
{"sample_id": "dev.96", "db_id": "car_1", "question": "What is the model of the car with the smallest amount of horsepower?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'Model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the condition that 'MakeId' from 'car_names' matches 'Id' from 'cars_data'.", "The results are ordered by the 'horsepower' column from 'cars_data' in ascending order.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.162", "db_id": "car_1", "question": "What is the number of countries with more than 2 car makers ?", "rationale": ["The query identifies the relevant tables, which are 'countries' and 'car_makers'.", "It performs a join operation on the 'countryid' from 'countries' and 'country' from 'car_makers' to associate car makers with their respective countries.", "The count of car makers is calculated for each country using the COUNT function.", "The results are grouped by 'countryid' to aggregate the counts for each country.", "A HAVING clause is added to filter the results, ensuring only countries with a count of car makers greater than a specified numeric threshold are included."], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "source_tables": ["car_makers", "countries"], "description": "This virtual table provides a count of car makers grouped by their respective countries from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents a numeric threshold for the minimum number of car makers that must be associated with a country.", "virtual_table": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.133", "db_id": "car_1", "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.", "rationale": ["The query identifies the relevant tables, which are 'car_names' and 'cars_data'.", "It selects the 'Model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the condition that 'MakeId' from 'car_names' matches 'Id' from 'cars_data'.", "The results are ordered by the 'MPG' column from 'cars_data' in descending order to prioritize the most fuel-efficient models.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "The virtual table describes the car models from the 'car_names' table, ordered by their fuel efficiency (MPG) in descending order. The placeholder in the LIMIT clause represents the maximum number of car models to return.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.102", "db_id": "car_1", "question": "What is the maker of the carr produced in the earliest year and what year was it?", "rationale": ["The query identifies the relevant tables, which are 'cars_data' and 'car_names'.", "It selects the 'Make' from 'car_names' and 'Year' from 'cars_data'.", "A JOIN operation is performed on 'cars_data' and 'car_names' using the 'Id' and 'MakeId' columns to link the car data with their respective makes.", "A subquery is used to find the minimum year from the 'cars_data' table, ensuring that only the earliest manufactured cars are included in the results."], "gold_sql": "SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);", "source_tables": ["cars_data", "car_names"], "description": "This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.", "virtual_table": "SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);"}
{"sample_id": "dev.168", "db_id": "car_1", "question": "Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?", "rationale": ["The query identifies the relevant tables, 'cars_data' and 'car_names'.", "It selects the 'makeid' and 'make' columns from the 'car_names' table.", "A join is performed between 'cars_data' and 'car_names' on the condition that the 'id' from 'cars_data' matches the 'makeid' from 'car_names'.", "A condition is added to filter cars with horsepower greater than the minimum horsepower from 'cars_data'.", "Another condition is added to filter cars with a cylinder count less than a specified number using a placeholder for numeric values."], "gold_sql": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  4;", "source_tables": ["cars_data", "car_names"], "description": "This virtual table provides a list of car makes and their identifiers from the 'car_names' table, specifically for cars that have a horsepower greater than the minimum horsepower recorded in the 'cars_data' table and have a cylinder count less than a specified number. The placeholder in the WHERE clause represents the maximum number of cylinders allowed.", "virtual_table": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.158", "db_id": "car_1", "question": "For a volvo model, how many cylinders does the version with least accelerate have?", "rationale": ["The query identifies the relevant tables, 'cars_data' and 'car_names'.", "It selects the 'cylinders' column from the 'cars_data' table.", "A JOIN operation is performed between 'cars_data' and 'car_names' on the condition that the 'Id' from 'cars_data' matches the 'MakeId' from 'car_names'.", "A WHERE clause is added to filter results based on the specified model name using a placeholder for string values.", "The results are ordered by the 'accelerate' column in ascending order.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "description": "This virtual table provides the number of cylinders for car models from the 'cars_data' table, specifically for a given model name. The query joins the 'cars_data' table with the 'car_names' table to filter results based on the specified model. The results are ordered by the acceleration time in ascending order, and a limit is applied to restrict the number of returned records.", "virtual_table": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.166", "db_id": "car_1", "question": "For all of the 4 cylinder cars, which model has the most horsepower?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'Model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the 'MakeId' and 'Id' columns respectively to combine relevant data.", "A condition is added to filter the results based on the number of cylinders in the 'cars_data' table using a placeholder for numeric values.", "The results are ordered by the 'horsepower' column in descending order to show the most powerful cars first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table provides a list of car models from the 'car_names' table that have a specific number of cylinders. The results are filtered based on the cylinder count in the 'cars_data' table, and the output is ordered by horsepower in descending order. The placeholders in the query represent the number of cylinders and the limit for the number of results to return.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.157", "db_id": "car_1", "question": "For model volvo, how many cylinders does the car with the least accelerate have?", "rationale": ["The query identifies the relevant tables, 'cars_data' and 'car_names'.", "It selects the 'cylinders' column from the 'cars_data' table.", "A JOIN operation is performed between 'cars_data' and 'car_names' on the 'Id' and 'MakeId' columns to link car models with their respective data.", "A WHERE clause is added to filter results based on the specified model name using a placeholder for string values.", "The results are ordered by the 'accelerate' column in ascending order to show the fastest accelerating cars first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "description": "This virtual table provides the number of cylinders for car models from the 'cars_data' table, specifically for a given model name. The query joins the 'cars_data' table with the 'car_names' table to filter results based on the specified model. The results are ordered by the acceleration time in ascending order, and a limit is applied to restrict the number of returned records.", "virtual_table": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.114", "db_id": "car_1", "question": "What is the number of makers of care in France?", "rationale": ["The query identifies the relevant tables, which are 'car_makers' and 'countries'.", "It uses a JOIN operation to connect these tables based on the country identifier.", "The SELECT statement counts the number of car makers that match the specified country name, using a placeholder for the country name in the WHERE clause."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "description": "This virtual table provides the count of car makers based in a specific country. It joins the 'car_makers' table with the 'countries' table using the country identifier, and filters the results based on the specified country name.", "virtual_table": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.134", "db_id": "car_1", "question": "What is the car model with the highest mpg ?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'model' column from the 'car_names' table, which contains the names of the car models.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the condition that 'makeid' from 'car_names' matches 'id' from 'cars_data'.", "The results are ordered by the 'mpg' column from 'cars_data' in descending order to show the most fuel-efficient models first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.", "virtual_table": "select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.122", "db_id": "car_1", "question": "What are the makers and models?", "rationale": ["The query identifies the relevant table, which is 'model_list'.", "Select the columns to display, 'Maker' and 'Model'.", "This query provides a list of car makers along with their corresponding car models without any filtering conditions."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "description": "The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.", "virtual_table": "SELECT Maker ,  Model FROM MODEL_LIST;"}
{"sample_id": "dev.160", "db_id": "car_1", "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?", "rationale": ["The query identifies the relevant table, which is 'cars_data'.", "It uses a subquery to find the acceleration time of the top specified number of cars ordered by horsepower.", "The outer query counts the number of cars that have an acceleration time greater than the value returned by the subquery."], "gold_sql": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "source_tables": ["cars_data"], "description": "This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars sorted by horsepower. The placeholder in the subquery represents the number of top cars to consider for the comparison.", "virtual_table": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] );"}
{"sample_id": "train.6291", "db_id": "city_record", "question": "Which cities have lower temperature in March than in July and have been once host cities?", "rationale": ["The query is identifying the relevant tables, which are 'city', 'temperature', and 'hosting_city'.", "It selects the 'city' from the 'city' table where the average temperature in March is less than in July by joining with the 'temperature' table.", "The INTERSECT clause is used to find cities that also appear in the 'hosting_city' table, indicating they have hosted a match."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6292", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in Dec and which have never been host cities.", "rationale": ["The query starts by selecting the 'city' from the 'city' table, aliased as T1.", "It joins the 'temperature' table, aliased as T2, on the 'city_id' to access temperature data.", "A condition is applied to filter cities where the average temperature in March is less than that in December.", "The EXCEPT clause is used to exclude cities that are found in the 'hosting_city' table, which indicates they have hosted a match."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6276", "db_id": "city_record", "question": "What is the venue of the competition \"1994 FIFA World Cup qualification\" hosted by \"Nanjing ( Jiangsu )\"?", "rationale": ["The query identifies the relevant tables: 'city', 'hosting_city', and 'match'.", "It selects the 'venue' column from the 'match' table.", "The JOIN operations link the 'city' table to the 'hosting_city' table using the 'city_id' and 'host_city' columns, and then link the 'hosting_city' table to the 'match' table using the 'match_id'.", "Conditions are added to filter results based on the specified city name and competition using placeholders for string values."], "gold_sql": "SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = 'Nanjing ( Jiangsu )' AND T3.competition = '1994 FIFA World Cup qualification'", "source_tables": ["hosting_city", "city", "match"], "description": "This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.", "virtual_table": "SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6274", "db_id": "city_record", "question": "Which city has hosted the most events?", "rationale": ["The query identifies the relevant tables, 'city' and 'hosting_city'.", "It selects the 'city' from the 'city' table, using an alias T1 for clarity.", "A JOIN operation is performed between 'city' and 'hosting_city' on the condition that the city ID matches the host city ID.", "The results are grouped by the host city to count the number of matches hosted in each city.", "The results are ordered in descending order based on the count of matches, allowing the most frequently hosting cities to appear first.", "A LIMIT clause is included to restrict the number of results returned, with a placeholder for the user to specify the desired number."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "description": "This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6287", "db_id": "city_record", "question": "In February, which city marks the highest temperature?", "rationale": ["The query identifies the relevant tables, which are 'city' and 'temperature'.", "It selects the 'city' column from the 'city' table, aliased as T1.", "A JOIN operation is performed between 'city' and 'temperature' on the 'city_id' to combine data from both tables.", "The results are ordered by the 'Feb' column from the 'temperature' table in descending order to show the warmest cities first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "description": "This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6289", "db_id": "city_record", "question": "Which cities' temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["The query identifies the relevant tables, which are 'city' and 'temperature'.", "It selects the 'city' column from the 'city' table, aliased as T1.", "The query performs a JOIN operation between 'city' (T1) and 'temperature' (T2) on the city identifier to access temperature data.", "A condition is added to filter cities where the average temperature in March is less than that in July or greater than that in October, using placeholders for the temperature values."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "description": "This virtual table lists the names of cities from the 'city' table that have a March average temperature lower than July or higher than October. The query joins the 'city' table with the 'temperature' table based on the city identifier, allowing for the comparison of temperature data across different months.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct"}
{"sample_id": "train.6299", "db_id": "city_record", "question": "Which cities have regional population above 8000000 or below 5000000?", "rationale": ["The query identifies the relevant table, which is 'city'.", "It selects the 'city' column to display the names of the cities.", "The first condition filters cities with a regional population greater than a specified number using a placeholder for numeric values.", "The second condition filters cities with a regional population less than a specified number using another placeholder for numeric values.", "The UNION operator combines the results of both conditions to provide a comprehensive list of cities that meet either criterion."], "gold_sql": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000", "source_tables": ["city"], "description": "This virtual table retrieves the names of cities from the 'city' table where the regional population is either greater than or less than specified numeric values. The placeholders in the WHERE clauses represent the population thresholds for filtering the cities.", "virtual_table": "SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6298", "db_id": "city_record", "question": "Please give me a list of cities whose regional population is over 8000000 or under 5000000.", "rationale": ["The query identifies the relevant table, which is 'city'.", "It selects the 'city' column to display the names of the cities.", "The first part of the query filters cities with a regional population greater than a specified number using a placeholder for numeric values.", "The second part of the query filters cities with a regional population less than another specified number using another placeholder for numeric values.", "The UNION operator combines the results of both queries to provide a comprehensive list of cities that meet either condition."], "gold_sql": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000", "source_tables": ["city"], "description": "This virtual table describes the names of cities from the 'city' table that have a regional population greater than a specified number and also those that have a regional population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds.", "virtual_table": "SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3323", "db_id": "college_1", "question": "Find the first names and degree of all professors who are teaching some class in Computer Info. Systems department.", "rationale": ["The query identifies the relevant tables: 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT'.", "It selects distinct first names of employees and their highest degrees.", "The JOIN operations link the tables based on their foreign key relationships, ensuring that the correct employee and professor data is associated with the classes.", "A WHERE clause is added to filter results by the specified department name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "description": "This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.", "virtual_table": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3308", "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["The query identifies the relevant tables: 'employee', 'professor', and 'department'.", "It selects the 'emp_fname' from the 'employee' table and 'prof_office' from the 'professor' table.", "The join condition links the 'employee' and 'professor' tables through the 'emp_num' field, ensuring we get the correct professor for each employee.", "Another join is made with the 'department' table to filter based on the department name.", "The WHERE clause includes conditions to filter by the specified department name and the highest degree of the professors, both using placeholders for string values."], "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"], "description": "This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.", "virtual_table": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["The query identifies the relevant tables: 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT'.", "It selects distinct first names of employees and their highest degrees.", "The JOIN operations link the tables based on their foreign key relationships, ensuring that the correct data is retrieved.", "A condition is added to filter results based on the specified department name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "description": "This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The placeholder in the WHERE clause represents the name of the department to filter the results accordingly.", "virtual_table": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["The query identifies the relevant tables: 'CLASS', 'ENROLL', and 'STUDENT'.", "It selects the 'stu_fname' column from the 'STUDENT' table to display the first names of students.", "The JOIN operations link the 'CLASS' table to the 'ENROLL' table using 'class_code', and the 'ENROLL' table to the 'STUDENT' table using 'stu_num'.", "Conditions are added to filter results based on the specified course code and the grade received, using placeholders for string values."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "description": "This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.", "virtual_table": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3294", "db_id": "college_1", "question": "What are the first names of all students taking accoutning and Computer Information Systems classes?", "rationale": ["The query identifies the relevant tables: 'student', 'enroll', 'class', 'course', and 'department'.", "It selects the 'stu_fname' column from the 'student' table.", "The JOIN operations link the tables based on their foreign key relationships to ensure that only students enrolled in the specified classes are considered.", "The WHERE clause filters the results based on the department name, using a placeholder for the string value.", "The INTERSECT operation is used to find students who are enrolled in classes from the same department in two separate queries, ensuring that only those students who meet both conditions are included."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "description": "This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.", "virtual_table": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["The query identifies the relevant tables: 'COURSE', 'CLASS', and 'DEPARTMENT'.", "It joins the 'COURSE' table with the 'CLASS' table on the course code to associate classes with their respective courses.", "Then, it joins the resulting table with the 'DEPARTMENT' table on the department code to retrieve department names.", "The results are grouped by the department code to aggregate the data correctly.", "The ordering is done based on the sum of credit hours for the courses in descending order to prioritize departments with more credit hours.", "Finally, a limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "description": "This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.", "virtual_table": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3309", "db_id": "college_1", "question": "Find the first names of all instructors who have taught some course and the course code.", "rationale": ["The query identifies the relevant tables, which are 'CLASS' and 'EMPLOYEE'.", "It selects the 'emp_fname' column from the 'EMPLOYEE' table and the 'crs_code' column from the 'CLASS' table.", "A JOIN operation is performed on the 'prof_num' column from the 'CLASS' table and the 'emp_num' column from the 'EMPLOYEE' table to associate professors with their respective classes."], "gold_sql": "SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num", "source_tables": ["employee", "class"], "description": "This virtual table provides the first names of professors along with the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.", "virtual_table": "SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num"}
{"sample_id": "train.3272", "db_id": "college_1", "question": "Which department has the most professors with a Ph.D.?", "rationale": ["The query identifies the relevant tables, 'professor' and 'department', and establishes a join between them based on the department code.", "It selects the department name and department code to display in the results.", "A condition is added to filter professors based on their highest degree using a placeholder for string values.", "The results are grouped by department code to aggregate the data appropriately.", "The results are ordered by the count of professors in each department in descending order, and a limit is set on the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  'Ph.D.' GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["department", "professor"], "description": "This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.", "virtual_table": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3241", "db_id": "college_1", "question": "How many students enrolled in class ACCT-211?", "rationale": ["The query identifies the relevant tables, which are 'CLASS' and 'ENROLL'.", "It uses a JOIN operation to connect these tables based on the 'class_code'.", "The SELECT statement counts the number of enrollments for classes that match the specified course code, using a placeholder for the course code in the WHERE clause."], "gold_sql": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["class", "enroll"], "description": "This virtual table provides the count of students enrolled in classes associated with a specific course code from the 'CLASS' and 'ENROLL' tables. The placeholder in the WHERE clause represents the course code for which the enrollment count is being queried.", "virtual_table": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3205", "db_id": "college_1", "question": "Find the number of classes in each department.", "rationale": ["The query identifies the relevant tables, which are 'CLASS' and 'COURSE'.", "It performs a JOIN operation on the 'CRS_CODE' to link classes with their respective courses.", "The SELECT statement counts the number of classes and groups the results by 'dept_code', which represents the department associated with each course."], "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"], "description": "This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.", "virtual_table": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code"}
{"sample_id": "train.3299", "db_id": "college_1", "question": "What is the department name of the students with lowest gpa belongs to?", "rationale": ["The query identifies the relevant tables, 'student' and 'department'.", "It selects the 'dept_name' from the 'department' table.", "A JOIN operation is performed on the 'dept_code' to link students with their respective departments.", "The results are ordered by the students' GPA to prioritize higher-performing students.", "The LIMIT clause includes a placeholder for the maximum number of results to return."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "description": "This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.", "virtual_table": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3237", "db_id": "college_1", "question": "Find the total credits of all classes offered by each department.", "rationale": ["The query identifies the relevant tables, which are 'COURSE' and 'CLASS'.", "It selects the sum of credit hours from the 'COURSE' table and groups the results by department code.", "The JOIN operation connects the 'COURSE' and 'CLASS' tables based on the course code, allowing for aggregation of credit hours by department."], "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"], "description": "This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping.", "virtual_table": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code"}
{"sample_id": "train.3319", "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["The query identifies the relevant tables, which are 'student' and 'enroll'.", "It selects the columns to display, 'stu_fname' and 'stu_lname' from the 'student' table.", "A JOIN operation is performed between 'student' and 'enroll' on the 'stu_num' column to link students with their enrollment records.", "Conditions are added to filter the results based on the 'enroll_grade' column for the specified grades using placeholders for string values."], "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"], "description": "This virtual table describes the first and last names of students from the 'student' table who have received specific grades in their enrolled classes. The placeholders in the WHERE clause represent the grades being queried.", "virtual_table": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING] OR T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3214", "db_id": "college_1", "question": "Which school has the fewest professors?", "rationale": ["The query identifies the relevant tables, which are 'department' and 'professor'.", "It selects the 'school_code' from the 'department' table.", "A JOIN operation is performed between 'department' and 'professor' on the 'dept_code' to associate professors with their respective departments.", "The results are grouped by 'school_code' to aggregate the data based on the number of professors per school.", "The results are ordered by the count of professors in descending order to prioritize schools with more professors.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "description": "This virtual table provides a list of school codes from the 'department' table, grouped by school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows for specifying the maximum number of school codes to return.", "virtual_table": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["The query identifies the relevant tables, which are 'employee' and 'class'.", "It selects the columns to display, which are the first name and date of birth of the professors.", "A JOIN operation is performed between the 'employee' table and the 'class' table based on the professor's identifier.", "A condition is added to filter the results based on the specified course code using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "description": "This virtual table provides a distinct list of first names and dates of birth of professors who teach a specific course. The data is retrieved from the 'employee' table, which contains information about professors, and is joined with the 'class' table to filter by the course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.", "virtual_table": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["The query identifies the relevant tables, which are 'employee' and 'class'.", "It selects the 'emp_fname' column from the 'employee' table, which represents the first names of professors.", "The JOIN operation connects the 'employee' table with the 'class' table based on the professor's identifier.", "The WHERE clause filters the results based on the specified course code using a placeholder for string values.", "The INTERSECT operation is used to find common professors teaching the same course in two different instances, requiring the same course code in both SELECT statements."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "description": "This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.", "virtual_table": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["The query identifies the relevant table, which is 'department', and uses an alias 'T1' for clarity.", "It joins the 'professor' table (aliased as 'T2') on the department code to associate professors with their respective departments.", "The GROUP BY clause is used to group the results by 'school_code', allowing for aggregation of data.", "The ORDER BY clause sorts the results based on the count of professors in each school code, ensuring the most populated schools are listed first.", "The LIMIT clause includes a placeholder for a numeric value, allowing the user to specify how many school codes they want to retrieve."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "description": "This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows for specifying the maximum number of school codes to return.", "virtual_table": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3271", "db_id": "college_1", "question": "What is the name of department where has the largest number of professors with a Ph.D. degree?", "rationale": ["The query identifies the relevant tables, 'professor' and 'department', to retrieve the necessary information.", "It selects the 'dept_name' from the 'department' table and 'dept_code' from the 'professor' table.", "A JOIN operation is performed on the 'dept_code' to link professors to their respective departments.", "A condition is added to filter professors based on their highest degree using a placeholder for string values.", "The results are grouped by 'dept_code' to aggregate the data by department.", "The results are ordered by the count of professors in each department in descending order, and a limit is set on the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  'Ph.D.' GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["department", "professor"], "description": "This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.", "virtual_table": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["The query identifies the relevant table, which is 'COURSE'.", "It selects the sum of 'crs_credit' to calculate the total credit hours for each department.", "The 'dept_code' is included to group the results by department, allowing for a summary of credit hours per department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "description": "This virtual table summarizes the total credit hours for courses grouped by department code from the 'COURSE' table. The placeholder in the SELECT clause represents the credit hours for each course, while the GROUP BY clause organizes the results by department code.", "virtual_table": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code"}
{"sample_id": "train.3221", "db_id": "college_1", "question": "Find the max, average, and minimum gpa of all students in each department.", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the maximum, average, and minimum GPA from the 'stu_gpa' column.", "The results are grouped by the 'dept_code' to provide a summary for each department."], "gold_sql": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.", "virtual_table": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3202", "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["The query identifies the relevant table, which is 'COURSE'.", "It selects the sum of 'crs_credit' to calculate the total credit hours for each department.", "The query groups the results by 'dept_code' to provide a summary for each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "description": "This virtual table summarizes the total credit hours for courses grouped by department code from the 'COURSE' table. The placeholder in the SELECT clause represents the credit hours for each course, while the GROUP BY clause organizes the results by department code.", "virtual_table": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code"}
{"sample_id": "train.3257", "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["The query identifies the relevant table, which is 'CLASS'.", "Select the column to display, 'class_code'.", "Add a condition to filter the 'class_room' column for the specified room using a placeholder for string values."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "description": "This virtual table describes the unique class codes from the 'CLASS' table that are held in a specific classroom. The placeholder in the WHERE clause represents the room where the class is conducted.", "virtual_table": "SELECT class_code FROM CLASS WHERE class_room  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3175", "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["The query identifies the relevant table, which is 'CLASS'.", "It counts the distinct 'PROF_NUM' to determine the number of unique professors.", "A condition is added to filter the results based on the 'CRS_CODE' using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "description": "This virtual table provides the count of distinct professors teaching classes associated with a specific course code from the 'CLASS' table. The placeholder in the WHERE clause represents the course code being queried.", "virtual_table": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3216", "db_id": "college_1", "question": "How many professors have a Ph.D. in each department?", "rationale": ["The query identifies the relevant table, which is 'professor'.", "It selects a count of professors and groups the results by 'dept_code'.", "A condition is added to filter the results based on the 'prof_high_degree' column using a placeholder for string values."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "description": "This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.", "virtual_table": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code"}
{"sample_id": "train.3188", "db_id": "college_1", "question": "Where is the history department?", "rationale": ["The query identifies the relevant table, which is 'DEPARTMENT'.", "Select the column to display, 'dept_address'.", "Add a condition to filter the 'dept_name' column for the specified department using a placeholder for string values."], "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"], "description": "This virtual table provides the physical address of a department from the 'DEPARTMENT' table based on the specified department name. The placeholder in the WHERE clause represents the name of the department being queried.", "virtual_table": "SELECT dept_address FROM department WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3215", "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["The query identifies the relevant table, which is 'professor'.", "It selects a count of professors and groups the results by 'dept_code'.", "A condition is added to filter the results based on the 'prof_high_degree' column using a placeholder for string values."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "description": "This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree type being queried.", "virtual_table": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the sum of 'stu_hrs' to calculate the total credit hours for each department.", "The GROUP BY clause is used to aggregate the results based on 'dept_code', allowing for a summary of credit hours per department."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.", "virtual_table": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.1454", "db_id": "college_2", "question": "Find the total number of students and total number of instructors for each department.", "rationale": ["The query identifies the relevant tables: 'department', 'student', and 'instructor'.", "It counts the distinct IDs of students and instructors to avoid duplicates.", "The join condition is established on the department name to link students and instructors to their respective departments.", "The results are grouped by the department name to aggregate the counts for each department."], "gold_sql": "SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name", "source_tables": ["instructor", "department", "student"], "description": "This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.", "virtual_table": "SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name"}
{"sample_id": "train.1438", "db_id": "college_2", "question": "Find the name of instructor who is the advisor of the student who has the highest number of total credits.", "rationale": ["The query identifies the relevant tables: 'advisor', 'instructor', and 'student'.", "It selects the 'name' column from the 'instructor' table (aliased as T2).", "The JOIN operations link the 'advisor' table (T1) to the 'instructor' table (T2) using the instructor ID, and to the 'student' table (T3) using the student ID.", "The results are ordered by the 'tot_cred' column from the 'student' table in descending order to prioritize students with the most credits.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT 1", "source_tables": ["instructor", "student", "advisor"], "description": "This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.", "virtual_table": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1455", "db_id": "college_2", "question": "How many students and instructors are in each department?", "rationale": ["The query identifies the relevant tables: 'department', 'student', and 'instructor'.", "It counts the distinct IDs of students and instructors to avoid duplicates.", "The join condition is based on the department name, ensuring that only students and instructors from the same department are counted.", "The results are grouped by the department name to provide a summary for each department."], "gold_sql": "SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name", "source_tables": ["instructor", "department", "student"], "description": "This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.", "virtual_table": "SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name"}
{"sample_id": "train.1453", "db_id": "college_2", "question": "What are the names of students who haven't taken any Biology courses?", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the 'name' column to display the names of students.", "The condition filters out students whose IDs are found in a subquery that checks for courses in a specific department.", "The subquery joins the 'takes' table with the 'course' table to find students enrolled in courses from the specified department, using a placeholder for the department's name."], "gold_sql": "SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  'Biology')", "source_tables": ["course", "student", "takes"], "description": "This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.", "virtual_table": "SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.1422", "db_id": "college_2", "question": "What is the title of the prerequisite class of International Finance course?", "rationale": ["The query identifies the relevant table, which is 'course'.", "It selects the 'title' column to display the names of the courses.", "A subquery is used to find the prerequisite course IDs by joining the 'prereq' table with the 'course' table based on the course ID.", "The outer query filters the courses based on the prerequisite IDs obtained from the subquery, using a placeholder for the course title."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  'International Finance')", "source_tables": ["course", "prereq"], "description": "This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.", "virtual_table": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.1427", "db_id": "college_2", "question": "What are the names of students who took a course in the Fall of 2003?", "rationale": ["The query identifies the relevant table, which is 'student'.", "Select the column to display, 'name'.", "Add a condition to filter the 'id' of students based on their enrollment in courses during a specified semester and year using a subquery.", "The subquery selects 'id' from the 'takes' table where the semester and year match the provided placeholders."], "gold_sql": "SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  'Fall' AND YEAR  =  2003)", "source_tables": ["student", "takes"], "description": "This virtual table describes the names of students who are enrolled in courses during a specific semester and year. The placeholders in the WHERE clause represent the semester and year for which the student enrollment is being queried.", "virtual_table": "SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.1425", "db_id": "college_2", "question": "What is the title of the course with Differential Geometry as a prerequisite?", "rationale": ["The query identifies the relevant table, which is 'course'.", "It selects the 'title' column to display the names of the courses.", "A subquery is used to find the 'course_id' of courses that have prerequisites, joining the 'prereq' table with the 'course' table on the prerequisite course ID.", "The condition in the subquery filters the prerequisite courses based on their title using a placeholder for string values."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  =  'Differential Geometry')", "source_tables": ["course", "prereq"], "description": "This virtual table lists the titles of courses from the 'course' table that have prerequisites. The prerequisite courses are identified by their titles, which are specified using a placeholder in the subquery.", "virtual_table": "SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.1437", "db_id": "college_2", "question": "What is the title of the course that is a prerequisite for Mobile Computing?", "rationale": ["The query identifies the relevant table, which is 'course'.", "It selects the 'title' column to display the names of the courses.", "A subquery is used to find the prerequisite course IDs by joining the 'prereq' table with the 'course' table based on the course ID.", "The outer query filters the results based on the specified course title using a placeholder for string values."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  'Mobile Computing')", "source_tables": ["course", "prereq"], "description": "This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.", "virtual_table": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.1375", "db_id": "college_2", "question": "Given the titles of all courses, in order of titles and credits.", "rationale": ["The query identifies the relevant table, which is 'course'.", "Select the column to display, 'title'.", "Add an ORDER BY clause to sort the results first by 'title' and then by 'credits'."], "gold_sql": "SELECT title FROM course ORDER BY title ,  credits", "source_tables": ["course"], "description": "This virtual table lists the titles of courses from the 'course' table, sorted alphabetically by title and then by the number of credits awarded for each course. The sorting allows for an organized view of the available courses based on their titles and credits.", "virtual_table": "SELECT title FROM course ORDER BY title ,  credits"}
{"sample_id": "train.1478", "db_id": "college_2", "question": "Find courses that ran in Fall 2009 and in Spring 2010.", "rationale": ["The query is identifying the relevant table, which is 'SECTION'.", "Select the 'course_id' column to display the course identifiers.", "Add conditions to filter the results for two different semesters and years using placeholders for string and numeric values.", "Use the INTERSECT operator to find common course IDs between the two sets of results."], "gold_sql": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 INTERSECT SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010", "source_tables": ["section"], "description": "This virtual table identifies the course IDs from the 'SECTION' table that are offered in two different semesters and years. The placeholders in the WHERE clauses represent the specific semesters and years for which the course IDs are being queried.", "virtual_table": "SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1364", "db_id": "college_2", "question": "Find the title of course that is provided by Statistics but not Psychology departments.", "rationale": ["The query identifies the relevant table, which is 'course'.", "It selects the 'title' column to display the names of the courses.", "The first WHERE clause filters the courses by the first specified department using a placeholder for string values.", "The EXCEPT clause is used to exclude the titles of courses from the second specified department, also using a placeholder for string values."], "gold_sql": "SELECT title FROM course WHERE dept_name  =  'Statistics' EXCEPT SELECT title FROM course WHERE dept_name  =  'Psychology'", "source_tables": ["course"], "description": "This virtual table lists the titles of courses offered by one academic department that are not offered by another department. The placeholders in the WHERE clause represent the names of the departments being compared.", "virtual_table": "SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1400", "db_id": "college_2", "question": "Find the minimum salary for the departments whose average salary is above the average payment of all instructors.", "rationale": ["The query identifies the relevant table, which is 'instructor'.", "It selects the minimum salary and groups the results by department name.", "The HAVING clause filters the groups to include only those where the average salary exceeds the overall average salary of instructors, which is calculated using a subquery."], "gold_sql": "SELECT min(salary) ,  dept_name FROM instructor GROUP BY dept_name HAVING avg(salary)  >  (SELECT avg(salary) FROM instructor)", "source_tables": ["instructor"], "description": "This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.", "virtual_table": "SELECT min(salary) ,  dept_name FROM instructor GROUP BY dept_name HAVING avg(salary)  >  (SELECT avg(salary) FROM instructor)"}
{"sample_id": "train.1476", "db_id": "college_2", "question": "Find courses that ran in Fall 2009 or in Spring 2010.", "rationale": ["The query identifies the relevant table, which is 'section'.", "It selects the 'course_id' column to display the identifiers of the courses.", "The query includes two separate SELECT statements combined with a UNION to retrieve course IDs for two instances of the same semester and year, using placeholders for the semester and year values."], "gold_sql": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 UNION SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010", "source_tables": ["section"], "description": "This virtual table provides a list of course identifiers from the 'section' table for two different instances of the same semester and year. The placeholders in the WHERE clauses represent the semester and year values that can be specified by the user.", "virtual_table": "SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1401", "db_id": "college_2", "question": "What is the lowest salary in departments with average salary greater than the overall average.", "rationale": ["The query identifies the relevant table, which is 'instructor'.", "It selects the minimum salary and groups the results by 'dept_name'.", "The HAVING clause filters the groups to include only those where the average salary exceeds the overall average salary of instructors, which is calculated using a subquery."], "gold_sql": "SELECT min(salary) ,  dept_name FROM instructor GROUP BY dept_name HAVING avg(salary)  >  (SELECT avg(salary) FROM instructor)", "source_tables": ["instructor"], "description": "This virtual table provides the minimum salary of instructors grouped by their respective departments, but only for those departments where the average salary of instructors exceeds the overall average salary of all instructors. The placeholders in the query represent the necessary values for filtering and aggregating the data.", "virtual_table": "SELECT min(salary) ,  dept_name FROM instructor GROUP BY dept_name HAVING avg(salary)  >  (SELECT avg(salary) FROM instructor)"}
{"sample_id": "train.5963", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions Vincent and Marcelle visit?", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Visitors', and 'Visits'.", "It selects the 'Name' of the tourist attractions from 'Tourist_Attractions'.", "The JOIN operations link the tables based on the identifiers for tourist attractions and tourists.", "The WHERE clause filters the results based on the details of the tourists using placeholders for string values.", "The INTERSECT operator is used to find common attractions visited by both tourists."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5931", "db_id": "cre_Theme_park", "question": "Which tourist attractions does the visitor with detail 'Vincent' visit?", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Visits', and 'Visitors'.", "It selects the 'Name' column from the 'Tourist_Attractions' table.", "The query uses JOINs to connect 'Tourist_Attractions' with 'Visits' based on the 'Tourist_Attraction_ID', and 'Visits' with 'Visitors' based on the 'Tourist_ID'.", "A condition is added to filter the results based on the specified tourist's details using a placeholder for string values."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5932", "db_id": "cre_Theme_park", "question": "Show the tourist attractions visited by the tourist whose detail is 'Vincent'.", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Visits', and 'Visitors'.", "It selects the 'Name' column from the 'Tourist_Attractions' table.", "It joins 'Tourist_Attractions' with 'Visits' on the 'Tourist_Attraction_ID' to connect attractions with their visits.", "It further joins 'Visits' with 'Visitors' on 'Tourist_ID' to link visits to specific tourists.", "A condition is added to filter the results based on the specified tourist's details using a placeholder for string values."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5965", "db_id": "cre_Theme_park", "question": "What are the names of tourist attraction that Alison visited but Rosalind did not visit?", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Visitors', and 'Visits'.", "It selects the 'Name' column from the 'Tourist_Attractions' table.", "The JOIN operations link the tables based on the relationships defined by the foreign keys.", "The WHERE clause filters the results to include only the attractions visited by the first specified tourist using a placeholder for their details.", "The EXCEPT clause is used to exclude the attractions visited by the second specified tourist, again using a placeholder for their details."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Alison' EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Rosalind'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5921", "db_id": "cre_Theme_park", "question": "What are the details and ways to get to tourist attractions related to royal family?", "rationale": ["The query identifies the relevant tables, which are 'Royal_Family' and 'Tourist_Attractions'.", "It selects the 'Royal_Family_Details' from the 'Royal_Family' table and 'How_to_Get_There' from the 'Tourist_Attractions' table.", "A JOIN operation is performed on the 'Royal_Family_ID' from the 'Royal_Family' table and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table to link the two tables based on their relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "description": "This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The data is retrieved by joining the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for the royal family that corresponds to the tourist attraction.", "virtual_table": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.5956", "db_id": "cre_Theme_park", "question": "What are the names and ids of the tourist attractions that are visited at most once?", "rationale": ["The query identifies the relevant tables, 'Tourist_Attractions' and 'Visits'.", "It selects the 'Name' and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table.", "A JOIN operation is performed between 'Tourist_Attractions' and 'Visits' on the 'Tourist_Attraction_ID' to link attractions with their visit records.", "The results are grouped by 'Tourist_Attraction_ID' to aggregate visit counts.", "The HAVING clause filters the results to include only those attractions with a visit count less than or equal to the specified numeric placeholder."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "description": "This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table, ensuring that only attractions with visit counts below or equal to the specified threshold are included.", "virtual_table": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5952", "db_id": "cre_Theme_park", "question": "What are the name, id and the corresponding number of visits for each  tourist attraction?", "rationale": ["The query identifies the relevant tables, which are 'Tourist_Attractions' and 'Visits'.", "It selects the 'Name' of the tourist attraction from 'Tourist_Attractions' and the 'Tourist_Attraction_ID' from 'Visits'.", "The COUNT function is used to count the number of visits for each attraction.", "The JOIN operation links the two tables on the 'Tourist_Attraction_ID' to associate visits with their respective attractions.", "The results are grouped by 'Tourist_Attraction_ID' to aggregate the visit counts for each attraction."], "gold_sql": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID", "source_tables": ["visits", "tourist_attractions"], "description": "This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.", "virtual_table": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID"}
{"sample_id": "train.5955", "db_id": "cre_Theme_park", "question": "Show the names and ids of tourist attractions that are visited at most once.", "rationale": ["The query identifies the relevant tables, 'Tourist_Attractions' and 'Visits'.", "It selects the 'Name' and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table.", "A JOIN operation is performed between 'Tourist_Attractions' and 'Visits' on the 'Tourist_Attraction_ID' to link attractions with their visit records.", "The results are grouped by 'Tourist_Attraction_ID' to aggregate visit counts.", "A HAVING clause is used to filter attractions based on the count of visits, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "description": "This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.", "virtual_table": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5916", "db_id": "cre_Theme_park", "question": "Give me the detail and opening hour for each museum.", "rationale": ["The query identifies the relevant tables, which are 'Museums' and 'Tourist_Attractions'.", "It selects the 'Museum_Details' from the 'Museums' table and 'Opening_Hours' from the 'Tourist_Attractions' table.", "A JOIN operation is performed on the 'Museum_ID' from the 'Museums' table and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table to link the two tables based on their relationship."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "description": "This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.", "virtual_table": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.5923", "db_id": "cre_Theme_park", "question": "What are the details of the shops that can be accessed by walk?", "rationale": ["The query identifies the relevant tables, which are 'SHOPS' and 'TOURIST_ATTRACTIONS'.", "It selects the 'Shop_Details' column from the 'SHOPS' table.", "A JOIN operation is performed to link 'SHOPS' with 'TOURIST_ATTRACTIONS' based on the matching 'Shop_ID' and 'Tourist_Attraction_ID'.", "A condition is added to filter the results based on the 'How_to_Get_There' column from the 'TOURIST_ATTRACTIONS' table, using a placeholder for string values."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "description": "This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.", "virtual_table": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5888", "db_id": "cre_Theme_park", "question": "Tell me the price ranges for all the hotels.", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Select the column to display, 'price_range'.", "The query is structured to retrieve the price range of hotels without any filtering conditions, allowing for flexibility in future modifications."], "gold_sql": "SELECT price_range FROM HOTELS", "source_tables": ["hotels"], "description": "The virtual table provides the price range of hotels from the 'Hotels' table. The placeholder in the SELECT statement allows for the retrieval of the price range for hotels based on specific criteria that can be defined later.", "virtual_table": "SELECT price_range FROM HOTELS"}
{"sample_id": "train.5898", "db_id": "cre_Theme_park", "question": "What is the average price range of five star hotels that allow pets?", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "It selects the average of the 'price_range' column to calculate the average price.", "Conditions are added to filter the results based on the specified 'star_rating_code' and whether pets are allowed, using placeholders for string and numeric values."], "gold_sql": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  '5' AND pets_allowed_yn  =  1", "source_tables": ["hotels"], "description": "This virtual table calculates the average price range of hotels from the 'Hotels' table that have a specific star rating and indicate whether pets are allowed. The placeholders in the WHERE clause represent the star rating code and the pets allowed status.", "virtual_table": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5887", "db_id": "cre_Theme_park", "question": "What are the price ranges of hotels?", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Select the column to display, 'price_range'.", "The query is structured to retrieve the price range of hotels without any filtering conditions, allowing for flexibility in future modifications."], "gold_sql": "SELECT price_range FROM HOTELS", "source_tables": ["hotels"], "description": "The virtual table provides the price range of hotels from the 'Hotels' table. The placeholder in the SELECT statement allows for the retrieval of the price range for hotels based on specific criteria that can be defined later.", "virtual_table": "SELECT price_range FROM HOTELS"}
{"sample_id": "train.5904", "db_id": "cre_Theme_park", "question": "Find all the locations whose names contain the word \"film\".", "rationale": ["The query identifies the relevant table, which is 'Locations'.", "Select the column to display, 'Location_Name'.", "Add a condition to filter the 'Location_Name' column using a LIKE operator with a placeholder for string values."], "gold_sql": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE '%film%'", "source_tables": ["locations"], "description": "This virtual table provides a list of location names from the 'Locations' table that match a specific pattern. The placeholder in the WHERE clause allows for flexible searching of location names based on user input.", "virtual_table": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5941", "db_id": "cre_Theme_park", "question": "Show the details of the top 3 most expensive hotels.", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Select the column to display, 'other_hotel_details'.", "Order the results by 'price_range' in descending order to show the most expensive hotels first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "description": "This virtual table provides additional details about hotels from the 'Hotels' table, sorted by their price range in descending order. The placeholder in the LIMIT clause represents the maximum number of hotel details to retrieve.", "virtual_table": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5944", "db_id": "cre_Theme_park", "question": "What are the details and star ratings of the three hotels with the lowest price ranges?", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Selects the columns 'other_hotel_details' and 'star_rating_code' to display.", "Orders the results by 'price_range' in ascending order to show cheaper hotels first.", "Limits the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "description": "This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5894", "db_id": "cre_Theme_park", "question": "What is the detail of each visitor?", "rationale": ["The query identifies the relevant table, which is 'Visitors'.", "Select the column to display, 'Tourist_Details'."], "gold_sql": "SELECT Tourist_Details FROM VISITORS", "source_tables": ["visitors"], "description": "This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.", "virtual_table": "SELECT Tourist_Details FROM VISITORS"}
{"sample_id": "train.5897", "db_id": "cre_Theme_park", "question": "Show the average price range of hotels that have 5 star ratings and allow pets.", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "It selects the average of the 'price_range' column to calculate the average price.", "Conditions are added to filter the results based on the specified 'star_rating_code' and whether pets are allowed, using placeholders for string and numeric values."], "gold_sql": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  '5' AND pets_allowed_yn  =  1", "source_tables": ["hotels"], "description": "This virtual table calculates the average price range of hotels from the 'Hotels' table that have a specific star rating and indicate whether pets are allowed. The placeholders in the WHERE clause represent the star rating code and the pets allowed status.", "virtual_table": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2381", "db_id": "csu_1", "question": "How many faculty members did the university that conferred the most degrees in 2002 have?", "rationale": ["The query identifies the relevant tables: 'campuses', 'faculty', and 'degrees'.", "It selects the 'faculty' column from the 'faculty' table.", "The query joins the 'campuses' table with the 'faculty' table on the campus identifier, and also joins with the 'degrees' table to ensure the year matches.", "A condition is added to filter the results based on a specific year using a placeholder for numeric values.", "The results are ordered by the number of degrees awarded in descending order and limited to a specified number using placeholders."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.", "virtual_table": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2382", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the least number of degrees in year 2001?", "rationale": ["The query identifies the relevant tables: 'campuses', 'faculty', and 'degrees'.", "It selects the 'faculty' column from the 'faculty' table.", "The query joins the 'campuses' table with the 'faculty' table on the campus identifier and also joins with the 'degrees' table to ensure that the faculty data corresponds to the year when degrees were awarded.", "A condition is added to filter the results based on a specific year using a placeholder for numeric values.", "The results are ordered by the 'degrees' column and limited to a specified number using placeholders."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.", "virtual_table": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2350", "db_id": "csu_1", "question": "Which campus has the most faculties in year 2003?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'faculty'.", "It selects the 'campus' column from the 'Campuses' table.", "A JOIN operation is performed between 'Campuses' and 'faculty' on the campus identifier to combine data from both tables.", "A condition is added to filter the results based on the specified year using a placeholder for numeric values.", "The results are ordered by the number of faculty members in descending order.", "A limit is applied to restrict the number of campuses returned, using another placeholder for numeric values."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "description": "This virtual table lists the campuses from the 'Campuses' table that have faculty data for a specific year. The campuses are ordered by the number of faculty members in descending order, and the result is limited to a specified number of campuses. The placeholders in the WHERE clause represent the year of the faculty data and the limit on the number of campuses to return.", "virtual_table": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2376", "db_id": "csu_1", "question": "How many faculty lines are there in \"San Francisco State University\" in year 2004?", "rationale": ["The query identifies the relevant tables, 'faculty' and 'campuses'.", "It selects the 'faculty' column to display the number of faculty members.", "A JOIN operation is performed to link the 'faculty' table with the 'campuses' table based on the campus identifier.", "Conditions are added to filter the results by the specified year and campus name using placeholders for numeric and string values."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.", "virtual_table": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2363", "db_id": "csu_1", "question": "What campus started in year 1956, has more than 200 full time students, and more than 400 students enrolled?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'enrollments'.", "It selects the 'campus' column from the 'Campuses' table.", "A JOIN operation is performed between 'Campuses' and 'enrollments' on the campus identifier.", "Conditions are added to filter the results based on the specified year and the thresholds for total and full-time equivalent enrollments using placeholders for numeric values."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "description": "This virtual table lists the campuses from the 'Campuses' table that have total enrollments exceeding a specified number and full-time equivalent enrollments exceeding another specified number for a given academic year. The placeholders in the WHERE clause represent the year and the enrollment thresholds.", "virtual_table": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] AND totalenrollment_ay  >  [PLACEHOLDER-TYPE:NUMBER] AND FTE_AY  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2374", "db_id": "csu_1", "question": "What is the number of faculty lines in campus \"Long Beach State University\" in 2002?", "rationale": ["The query identifies the relevant tables, 'faculty' and 'campuses'.", "It selects the 'faculty' column to display the number of faculty members.", "A JOIN operation is performed to link the 'faculty' table with the 'campuses' table based on the campus identifier.", "Conditions are added to filter the results by a specific year and campus name using placeholders for numeric and string values."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2002 AND T2.campus  =  'Long Beach State University'", "source_tables": ["faculty", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.", "virtual_table": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2369", "db_id": "csu_1", "question": "How many degrees were conferred at San Jose State University in 2000?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'Degrees' column from the 'degrees' table.", "A JOIN operation is performed to link 'Campuses' and 'degrees' based on the campus identifier.", "Conditions are added to filter results for a specific campus and year using placeholders for string and numeric values."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "description": "This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.", "virtual_table": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2357", "db_id": "csu_1", "question": "how many degrees were conferred between 1998 and 2002?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'campus' from the 'Campuses' table and sums the 'degrees' from the 'degrees' table.", "A JOIN operation is performed on the 'Campus' identifier to link the two tables.", "The WHERE clause filters the results based on a specified range of years using placeholders for numeric values.", "The results are grouped by 'campus' to provide a total count of degrees awarded per campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "description": "This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.", "virtual_table": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus"}
{"sample_id": "train.2356", "db_id": "csu_1", "question": "report the total number of degrees granted between 1998 and 2002.", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'campus' from the 'Campuses' table and sums the 'degrees' from the 'degrees' table.", "A JOIN operation is performed on the 'Campus' identifier to link the two tables.", "The WHERE clause filters the results based on a specified range of years using placeholders for numeric values.", "The results are grouped by 'campus' to provide a total count of degrees awarded per campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "description": "This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.", "virtual_table": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus"}
{"sample_id": "train.2387", "db_id": "csu_1", "question": "How many people graduated from San Francisco State University in 2004?", "rationale": ["The query identifies the relevant tables, 'discipline_enrollments' and 'Campuses'.", "It uses a JOIN operation to connect the two tables based on the campus identifier.", "The SUM function is applied to the 'graduate' column to calculate the total number of graduate enrollments.", "Conditions are added to filter the results by the specified year and campus name using placeholders for numeric and string values."], "gold_sql": "SELECT sum(t1.graduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Francisco State University'", "source_tables": ["discipline_enrollments", "campuses"], "description": "This virtual table calculates the total number of graduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the WHERE clause represent the year of enrollment and the name of the campus.", "virtual_table": "SELECT sum(t1.graduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND t2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2328", "db_id": "csu_1", "question": "Find all the campuses opened in 1958.", "rationale": ["The query is identifying the relevant table, which is 'Campuses'.", "Select the column to display, 'Campus'.", "Add a condition to filter the 'Year' column for the specified year using a placeholder for numeric values."], "gold_sql": "SELECT campus FROM campuses WHERE YEAR  =  1958", "source_tables": ["campuses"], "description": "This virtual table describes the names of campuses from the 'Campuses' table that have records for a specific year. The placeholder in the WHERE clause represents the year for which the campus data is being queried.", "virtual_table": "SELECT campus FROM campuses WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2366", "db_id": "csu_1", "question": "List the campuses in Los Angeles county.", "rationale": ["The query is identifying the relevant table, which is 'Campuses'.", "Select the column to display, 'campus'.", "Add a condition to filter the 'county' column for the specified county using a placeholder for string values."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "description": "This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.", "virtual_table": "SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2327", "db_id": "csu_1", "question": "What campuses are located in Chico?", "rationale": ["The query is identifying the relevant table, which is 'Campuses'.", "Select the column to display, 'Campus'.", "Add a condition to filter the 'Location' column for the specified location using a placeholder for string values."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Chico'", "source_tables": ["campuses"], "description": "This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of the campus.", "virtual_table": "SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2335", "db_id": "csu_1", "question": "What campuses are located in Northridge, Los Angeles or in San Francisco, San Francisco?", "rationale": ["The query identifies the relevant table, which is 'Campuses'.", "It selects the 'Campus' column to display the names of the campuses.", "The query includes conditions to filter the 'Location' and 'County' columns for specified values using placeholders for string values.", "The UNION operator is used to combine results from two identical selections, allowing for flexibility in filtering by location and county."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "description": "This virtual table retrieves the names of campuses located in a specific geographical location and county. The query combines results from two identical selections, allowing for the possibility of filtering by different criteria for the same location and county. The placeholders in the WHERE clauses represent the location and county names.", "virtual_table": "SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2334", "db_id": "csu_1", "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.", "rationale": ["The query identifies the relevant table, which is 'Campuses'.", "It selects the 'Campus' column to display the names of the campuses.", "The query includes conditions to filter the 'Location' and 'County' columns for the specified values using placeholders for string values.", "The UNION operator is used to combine results from two identical selections, allowing for flexibility in filtering by two different criteria."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "description": "This virtual table retrieves the names of campuses located in a specific geographical location and county. The query combines results from two identical selections, allowing for the possibility of filtering by two different sets of location and county criteria. The placeholders in the WHERE clauses represent the specific location and county names to be provided by the user.", "virtual_table": "SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2365", "db_id": "csu_1", "question": "How many campuses exist are in the county of LA?", "rationale": ["The query identifies the relevant table, which is 'Campuses'.", "It selects a count of all records to determine the number of campuses.", "A condition is added to filter the results based on the 'county' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "description": "This virtual table provides the total count of campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.", "virtual_table": "SELECT count(*) FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["The query identifies the relevant tables: 'Products', 'Complaints', and 'Customers'.", "It selects distinct product names from the 'Products' table.", "The query joins the 'Products' table with the 'Complaints' table on the product identifier to link complaints to products.", "It groups the results by customer identifiers from the 'Customers' table to aggregate the data based on customers.", "The results are ordered by the count of complaints for each customer to prioritize the most complained products.", "A limit is applied to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "description": "This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.", "virtual_table": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5794", "db_id": "customer_complaints", "question": "Find the last name of the staff member who processed the complaint of the cheapest product.", "rationale": ["The query identifies the relevant tables: 'staff', 'complaints', and 'products'.", "It selects the 'last_name' column from the 'staff' table.", "The query joins the 'staff' table with the 'complaints' table on the 'staff_id' to link staff members to the complaints they handle.", "It further joins the 'complaints' table with the 'products' table on the 'product_id' to associate complaints with the respective products.", "The results are ordered by the 'product_price' from the 'products' table, allowing for a sorted list based on product pricing.", "The LIMIT clause uses a placeholder for a numeric value to specify how many last names to return."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "description": "This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["The query identifies the relevant tables, 'Staff' and 'Complaints'.", "It selects the 'first_name' column from the 'Staff' table.", "A JOIN operation is performed between 'Staff' and 'Complaints' on the 'staff_id' column to link staff members with the complaints they handle.", "The results are grouped by 'staff_id' to aggregate the data based on each staff member.", "The ORDER BY clause is used to sort the results by the count of complaints handled in descending order.", "The LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "description": "This virtual table provides the first names of staff members from the 'Staff' table who are associated with complaints in the 'Complaints' table. The results are grouped by staff member, and the number of complaints handled by each staff member is counted. The placeholder in the LIMIT clause allows for specifying the maximum number of staff members to return based on the count of complaints they have handled.", "virtual_table": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5802", "db_id": "customer_complaints", "question": "What is the last name of the staff who has handled the first ever complaint?", "rationale": ["The query identifies the relevant tables, which are 'staff' and 'complaints'.", "It selects the 'last_name' column from the 'staff' table.", "A JOIN operation is performed between 'staff' and 'complaints' on the 'staff_id' to link staff members to the complaints they are handling.", "The results are ordered by the 'date_complaint_raised' from the 'complaints' table to show the most recent complaints first.", "The LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT 1", "source_tables": ["complaints", "staff"], "description": "This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["The query identifies the relevant table, which is 'Complaints'.", "It selects the 'complaint_status_code' to display.", "The GROUP BY clause is used to group the results by 'complaint_status_code'.", "The HAVING clause filters the groups to include only those with a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "description": "The virtual table summarizes the different complaint status codes from the 'Complaints' table, specifically focusing on those status codes that have a count exceeding a specified number. The placeholder in the HAVING clause represents the minimum count of complaints required for a status code to be included in the results.", "virtual_table": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5772", "db_id": "customer_complaints", "question": "Which city has the least number of customers whose type code is \"Good Credit Rating\"?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "Select the column to display, 'town_city'.", "Add a condition to filter the 'customer_type_code' column for the specified customer type using a placeholder for string values.", "Group the results by 'town_city' to ensure unique entries.", "Order the results by the count of occurrences to prioritize the most common towns or cities.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT town_city FROM customers WHERE customer_type_code  =  'Good Credit Rating' GROUP BY town_city ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "description": "This virtual table provides a list of unique town or city names from the 'Customers' table, filtered by a specific customer type code. The results are grouped by town or city and ordered by the number of occurrences, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the customer type code and the maximum number of results to display.", "virtual_table": "SELECT town_city FROM customers WHERE customer_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY town_city ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It uses the COUNT function to count the number of customers for each type, grouping the results by 'customer_type_code'.", "The results are ordered in descending order based on the count, allowing the most common customer types to appear first.", "A LIMIT clause is included to restrict the number of results returned, with a placeholder for the user to specify the desired number."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.", "virtual_table": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6108", "db_id": "customers_and_addresses", "question": "Find the name of the customer who made the order of the largest amount of goods.", "rationale": ["The query identifies the relevant tables: 'Customers', 'Customer_Orders', and 'Order_Items'.", "It selects the 'customer_name' from the 'Customers' table.", "The JOIN operations link customers to their orders and the items in those orders.", "The WHERE clause filters the results to only include customers whose order quantity matches the maximum order quantity found in the 'Order_Items' table."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)", "source_tables": ["customer_orders", "customers", "order_items"], "description": "This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.", "virtual_table": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)"}
{"sample_id": "train.6086", "db_id": "customers_and_addresses", "question": "Find the city where the most customers live.", "rationale": ["The query identifies the relevant tables: 'Customers', 'Customer_Addresses', and 'Addresses'.", "It selects the 'city' column from the 'Addresses' table.", "The query joins the 'Customers' table with 'Customer_Addresses' on 'customer_id' and then joins 'Customer_Addresses' with 'Addresses' on 'address_id'.", "The results are grouped by 'city' to aggregate the number of customers in each city.", "The results are ordered by the count of customers in descending order to show the most populated cities first.", "A limit is applied to restrict the number of cities returned, using a placeholder for numeric values."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "description": "This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.", "virtual_table": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6129", "db_id": "customers_and_addresses", "question": "Which product has been ordered most number of times?", "rationale": ["The query identifies the relevant tables, 'Order_Items' and 'Products'.", "It selects the 'product_details' column from the 'Products' table.", "The query joins 'Order_Items' with 'Products' on the 'product_id' to link ordered items with their details.", "It groups the results by 'product_id' to aggregate the order counts for each product.", "The results are ordered by the count of orders in descending order to show the most ordered products first.", "A placeholder is included in the LIMIT clause to allow the user to specify how many product details to return."], "gold_sql": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "order_items"], "description": "This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.", "virtual_table": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6123", "db_id": "customers_and_addresses", "question": "What is the total number of products that are in orders with status \"Cancelled\"?", "rationale": ["The query identifies the relevant tables, which are 'Customer_Orders' and 'Order_Items'.", "It uses a JOIN operation to link 'Customer_Orders' with 'Order_Items' based on the 'order_id'.", "The SELECT statement sums the 'order_quantity' from 'Order_Items'.", "A condition is added to filter the results based on the 'order_status' from 'Customer_Orders', using a placeholder for string values."], "gold_sql": "SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_status  =  'Cancelled'", "source_tables": ["customer_orders", "order_items"], "description": "This virtual table calculates the total quantity of products ordered from the 'Customer_Orders' table, filtered by a specific order status. The placeholder in the WHERE clause represents the order status to filter the results accordingly.", "virtual_table": "SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_status  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6097", "db_id": "customers_and_addresses", "question": "Which contact channel has been used by the customer with name \"Tillman Ernser\"?", "rationale": ["The query identifies the relevant tables, 'Customers' and 'Customer_Contact_Channels'.", "It selects distinct values from the 'channel_code' column to avoid duplicates.", "A JOIN operation is performed to link the 'Customers' table with the 'Customer_Contact_Channels' table using the 'customer_id'.", "A condition is added to filter the results based on the specified customer's name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.", "virtual_table": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6130", "db_id": "customers_and_addresses", "question": "What is the most frequently ordered product? Tell me the detail of the product", "rationale": ["The query identifies the relevant tables, 'Order_Items' and 'Products'.", "It selects the 'product_details' from the 'Products' table.", "The join condition links 'Order_Items' and 'Products' on 'product_id'.", "The results are grouped by 'product_id' to aggregate the order quantities.", "The results are ordered by the count of orders in descending order to show the most ordered products first.", "A placeholder is included in the LIMIT clause to allow the user to specify how many product details to return."], "gold_sql": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "order_items"], "description": "This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.", "virtual_table": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6106", "db_id": "customers_and_addresses", "question": "What are the name and active date of the customers whose contact channel code is email?", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It selects the 'customer_name' from the 'Customers' table and 'active_from_date' from the 'Customer_Contact_Channels' table.", "A JOIN operation is performed on the 'customer_id' to link the two tables based on the customer.", "A condition is added to filter the results based on the 'channel_code' using a placeholder for string values."], "gold_sql": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table provides the names of customers along with the activation dates of their preferred contact channels from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the specific contact channel code being queried.", "virtual_table": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6132", "db_id": "customers_and_addresses", "question": "What are the name and ID of the product bought the most.", "rationale": ["The query identifies the relevant tables, 'Order_Items' and 'Products'.", "It selects the 'product_details' and 'product_id' from the 'Products' table.", "A JOIN operation is performed between 'Order_Items' and 'Products' on the 'product_id' to link the ordered items with their details.", "The results are grouped by 'product_id' to aggregate the order quantities for each product.", "The results are ordered by the sum of 'order_quantity' to show the most ordered products first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "description": "This virtual table provides a summary of product details and their identifiers from the 'Products' table, based on the quantities ordered from the 'Order_Items' table. The results are grouped by product ID and ordered by the total quantity ordered, with a limit specified by a placeholder for numeric values.", "virtual_table": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6103", "db_id": "customers_and_addresses", "question": "What is the channel code and contact number of the customer contact channel that was active for the longest time?", "rationale": ["The query identifies the relevant table, which is 'Customer_Contact_Channels'.", "Selects the columns to display, 'channel_code' and 'contact_number'.", "Adds a condition to filter the results based on the duration of activity, comparing the difference between 'active_to_date' and 'active_from_date'.", "Utilizes a subquery to find the maximum duration of activity and limits the results based on a placeholder for numeric values."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "description": "This virtual table provides the channel codes and associated contact numbers from the 'Customer_Contact_Channels' table for the most recently active contact channel based on the duration of activity. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.", "virtual_table": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.6065", "db_id": "customers_and_addresses", "question": "Which payment method is used by most customers?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'payment_method' column to display the different payment methods used by customers.", "The results are grouped by 'payment_method' to aggregate the data based on unique payment methods.", "The query orders the results by the count of each payment method in descending order to show the most popular methods first.", "A limit is applied to restrict the number of payment methods returned, using a placeholder for numeric values."], "gold_sql": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "This virtual table summarizes the preferred payment methods used by customers from the 'Customers' table. It groups the results by payment method and orders them by the frequency of each method, allowing the user to specify a limit on the number of payment methods returned.", "virtual_table": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6072", "db_id": "customers_and_addresses", "question": "Return the the details of all products.", "rationale": ["The query is identifying the relevant table, which is 'Products'.", "Select the column to display, 'product_details'.", "Use DISTINCT to ensure that only unique product specifications are returned."], "gold_sql": "SELECT DISTINCT product_details FROM products", "source_tables": ["products"], "description": "The virtual table provides a unique list of product specifications from the 'Products' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be added later.", "virtual_table": "SELECT DISTINCT product_details FROM products"}
{"sample_id": "train.6075", "db_id": "customers_and_addresses", "question": "Find the detail of products whose detail contains the word \"Latte\" or the word \"Americano\"", "rationale": ["The query identifies the relevant table, which is 'Products'.", "Select the column to display, 'product_details'.", "Add a condition to filter the 'product_details' column for specified patterns using placeholders for string values. The use of 'LIKE' allows for partial matches."], "gold_sql": "SELECT product_details FROM products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'", "source_tables": ["products"], "description": "This virtual table retrieves the product details from the 'Products' table that match specific criteria. The placeholders in the WHERE clause represent the patterns to search for in the product details.", "virtual_table": "SELECT product_details FROM products WHERE product_details LIKE [PLACEHOLDER-TYPE:STRING] OR product_details LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6071", "db_id": "customers_and_addresses", "question": "What are the details of all products?", "rationale": ["The query is identifying the relevant table, which is 'Products'.", "Select the column to display, 'product_details'.", "Use DISTINCT to ensure that only unique product specifications are returned."], "gold_sql": "SELECT DISTINCT product_details FROM products", "source_tables": ["products"], "description": "This virtual table provides a unique list of product specifications from the 'Products' table. The placeholder in the SELECT clause represents the product details that can be filtered or modified as needed.", "virtual_table": "SELECT DISTINCT product_details FROM products"}
{"sample_id": "train.6060", "db_id": "customers_and_addresses", "question": "Find the average order quantity per order.", "rationale": ["The query identifies the relevant table, which is 'Order_Items'.", "It selects the average of the 'order_quantity' column to determine the typical quantity of products ordered."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "description": "This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.", "virtual_table": "SELECT avg(order_quantity) FROM order_items"}
{"sample_id": "train.1621", "db_id": "customers_and_invoices", "question": "Show all product names and the number of customers having an order on each product.", "rationale": ["The query identifies the relevant tables: 'Order_Items', 'Products', and 'Orders'.", "It selects the 'product_name' from the 'Products' table and counts the occurrences of each product ordered.", "The JOIN operations link 'Order_Items' to 'Products' using 'product_id' and to 'Orders' using 'order_id'.", "The GROUP BY clause groups the results by 'product_name' to provide a count for each unique product."], "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"], "description": "This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.", "virtual_table": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name"}
{"sample_id": "train.1610", "db_id": "customers_and_invoices", "question": "Return the order ids and details for orderes with two or more invoices.", "rationale": ["The query identifies the relevant tables, which are 'Invoices' and 'Orders'.", "It selects the columns 'order_id' and 'order_details' from the 'Orders' table.", "A JOIN operation is performed between 'Invoices' and 'Orders' on the 'order_id' to link the two tables.", "The results are grouped by 'order_id' to aggregate the data.", "The HAVING clause filters the results to include only those orders that have more than a specified number of associated invoices, using a placeholder for the numeric value."], "gold_sql": "SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  2", "source_tables": ["orders", "invoices"], "description": "This virtual table provides a list of order IDs and their corresponding details from the 'Orders' table, specifically for those orders that are associated with invoices. The results are grouped by order ID, and only those orders that have more than a specified number of associated invoices are included. The placeholder in the HAVING clause represents the minimum count of invoices required for an order to be displayed.", "virtual_table": "SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1568", "db_id": "customers_and_invoices", "question": "Return the id and full name of the customer with the most accounts.", "rationale": ["The query identifies the relevant tables, 'Accounts' and 'Customers'.", "It selects the 'customer_id', 'customer_first_name', and 'customer_last_name' columns to display.", "A JOIN operation is performed between 'Accounts' and 'Customers' on the 'customer_id' to link accounts to their respective customers.", "The results are grouped by 'customer_id' to aggregate the data for each customer.", "The results are ordered by the count of accounts in descending order to show the customers with the most accounts first.", "A LIMIT clause is included to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["accounts", "customers"], "description": "This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1589", "db_id": "customers_and_invoices", "question": "Show the account name, id and the number of transactions for each account.", "rationale": ["The query identifies the relevant tables, which are 'Financial_Transactions' and 'Accounts'.", "It selects the 'account_name' from the 'Accounts' table and 'account_id' from the 'Financial_Transactions' table.", "The count function is used to aggregate the number of transactions for each account.", "A JOIN operation is performed on the 'account_id' to link transactions to their respective accounts.", "Finally, the results are grouped by 'account_id' to provide a count of transactions per account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "description": "This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.", "virtual_table": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id"}
{"sample_id": "train.1602", "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?", "rationale": ["The query identifies the relevant tables, 'Financial_Transactions' and 'Invoices'.", "It selects the columns 'invoice_number' and 'invoice_date' from the 'Invoices' table.", "A JOIN operation is performed on the 'invoice_number' to link financial transactions with invoices.", "The results are grouped by 'invoice_number' to aggregate the count of transactions for each invoice.", "The results are ordered by the count of transactions in descending order to show the most frequently transacted invoices first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"], "description": "This virtual table provides a list of invoice numbers and their corresponding invoice dates from the 'Invoices' table, filtered by the number of financial transactions associated with each invoice. The placeholder in the LIMIT clause represents the maximum number of records to return.", "virtual_table": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1590", "db_id": "customers_and_invoices", "question": "Return the names and ids of each account, as well as the number of transactions.", "rationale": ["The query identifies the relevant tables, which are 'Financial_Transactions' and 'Accounts'.", "It selects the 'account_name' and 'account_id' from the 'Accounts' table.", "It counts the number of transactions for each account from the 'Financial_Transactions' table.", "The JOIN operation links the two tables based on the 'account_id' to ensure that the account details correspond to the transactions.", "Finally, the results are grouped by 'account_id' to aggregate the transaction counts for each account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "description": "This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.", "virtual_table": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id"}
{"sample_id": "train.1599", "db_id": "customers_and_invoices", "question": "Show the invoice number and the number of transactions for each invoice.", "rationale": ["The query identifies the relevant table, which is 'Financial_Transactions'.", "Select the column 'invoice_number' to display the invoice identifier.", "Use the count function to aggregate the number of transactions for each invoice.", "Group the results by 'invoice_number' to get the count of transactions per invoice."], "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"], "description": "This virtual table summarizes the total number of financial transactions associated with each invoice from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the invoice number, while the count function aggregates the number of transactions for each invoice.", "virtual_table": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number"}
{"sample_id": "train.1623", "db_id": "customers_and_invoices", "question": "Show order ids and the number of products in each order.", "rationale": ["The query identifies the relevant table, which is 'Order_Items'.", "It selects the 'order_id' to group the results by each order.", "The count function is used to count the distinct 'product_id' for each order, ensuring that only unique products are counted."], "gold_sql": "SELECT order_id ,  count(DISTINCT product_id) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "description": "This virtual table summarizes the total number of distinct products associated with each order from the 'Order_Items' table. The placeholder in the SELECT clause represents the unique order identifier, while the count function calculates the number of different products for each order.", "virtual_table": "SELECT order_id ,  count(DISTINCT product_id) FROM Order_items GROUP BY order_id"}
{"sample_id": "train.1579", "db_id": "customers_and_invoices", "question": "How many transaction does each account have? Show the number and account id.", "rationale": ["The query identifies the relevant table, which is 'Financial_Transactions'.", "It selects a count of all transactions and groups them by 'account_id'.", "The use of count(*) allows for the aggregation of transaction records per account, providing a summary of transactions associated with each account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "description": "This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.", "virtual_table": "SELECT count(*) ,  account_id FROM Financial_transactions"}
{"sample_id": "train.1549", "db_id": "customers_and_invoices", "question": "How many customers have opened an account?", "rationale": ["The query is identifying the relevant table, which is 'Accounts'.", "The goal is to count the distinct 'customer_id' values to determine the number of unique customers with accounts.", "Using the COUNT function with DISTINCT ensures that only unique customer IDs are counted."], "gold_sql": "SELECT count(DISTINCT customer_id) FROM Accounts", "source_tables": ["accounts"], "description": "This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.", "virtual_table": "SELECT count(DISTINCT customer_id) FROM Accounts"}
{"sample_id": "dev.937", "db_id": "dog_kennels", "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.", "rationale": ["The query identifies the relevant tables: 'Owners', 'Dogs', and 'Treatments'.", "It selects the 'owner_id' and 'last_name' from the 'Owners' table, using an alias for clarity.", "The JOIN operation links 'Owners' to 'Dogs' based on the 'owner_id', and then links 'Dogs' to 'Treatments' based on 'dog_id'.", "The GROUP BY clause groups the results by 'owner_id' to aggregate the treatment counts for each owner.", "The ORDER BY clause sorts the results by the count of treatments in descending order, ensuring that owners with the most treatments appear first.", "The LIMIT clause uses a placeholder to allow the user to specify how many owners to return."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "description": "This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.", "virtual_table": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.998", "db_id": "dog_kennels", "question": "List the first name of all the professionals along with the description of the treatment they have done.", "rationale": ["The query identifies the relevant tables: 'Professionals', 'Treatments', and 'Treatment_Types'.", "It selects the 'first_name' from the 'Professionals' table and 'treatment_type_description' from the 'Treatment_Types' table.", "The JOIN operations link the 'Treatments' table to both the 'Professionals' and 'Treatment_Types' tables based on their respective foreign keys.", "The DISTINCT keyword ensures that only unique combinations of professional names and treatment descriptions are returned."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "description": "This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code"}
{"sample_id": "dev.954", "db_id": "dog_kennels", "question": "List the names of the dogs of the rarest breed and the treatment dates of them.", "rationale": ["The query identifies the relevant tables, 'Dogs' and 'Treatments', and establishes a join between them based on the dog_id.", "It selects the 'name' of the dog from the 'Dogs' table and the 'date_of_treatment' from the 'Treatments' table.", "A subquery is used to find the breed_code of the least common breed by grouping the dogs by breed_code, counting them, and ordering the results in ascending order, limiting to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )", "source_tables": ["dogs", "treatments"], "description": "This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.", "virtual_table": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "dev.943", "db_id": "dog_kennels", "question": "Find the id and cell phone of the professionals who operate two or more types of treatments.", "rationale": ["The query identifies the relevant tables, 'Professionals' and 'Treatments'.", "It selects the 'professional_id' and 'cell_number' from the 'Professionals' table.", "A JOIN operation is performed between 'Professionals' and 'Treatments' on the 'professional_id' to link treatments to the professionals who administered them.", "The results are grouped by 'professional_id' to aggregate the treatment counts for each professional.", "The HAVING clause filters the results to include only those professionals who have administered a specified minimum number of treatments, using a placeholder for numeric values."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "description": "This virtual table provides a list of professionals along with their cell numbers from the 'Professionals' table who have administered a specified number of treatments. The placeholder in the HAVING clause represents the minimum count of treatments that a professional must have administered.", "virtual_table": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.945", "db_id": "dog_kennels", "question": "Which professionals have operated a treatment that costs less than the average? Give me theor first names and last names.", "rationale": ["The query identifies the relevant tables, 'Professionals' and 'Treatments'.", "It selects distinct first and last names from the 'Professionals' table.", "A join is performed between 'Professionals' and 'Treatments' to link professionals with the treatments they administered.", "A condition is added to filter treatments based on their cost being less than the average cost of treatments, which is calculated using a subquery."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "description": "This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )"}
{"sample_id": "dev.924", "db_id": "dog_kennels", "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects the 'name' column to display the names of the dogs.", "The subquery filters out dogs that have received treatments by checking the 'treatments' table, grouping by 'dog_id', and summing the 'cost_of_treatment'.", "A condition is added to exclude dogs whose total treatment cost exceeds a specified amount using a placeholder for numeric values."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "description": "This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum allowable total cost for treatments.", "virtual_table": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "dev.925", "db_id": "dog_kennels", "question": "What are the names of the dogs for which the owner has not spend more than 1000 for treatment ?", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects the 'name' column to display the names of the dogs.", "The subquery filters out dogs that have received treatments by summing the 'cost_of_treatment' from the 'Treatments' table, grouping by 'dog_id'.", "A condition is added to exclude dogs whose total treatment cost exceeds a specified amount using a placeholder for numeric values."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "description": "This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum allowable total treatment cost.", "virtual_table": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "dev.921", "db_id": "dog_kennels", "question": "Find the average age of the dogs who went through treatments.", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects the average age of dogs using the AVG function.", "The WHERE clause filters the dogs to include only those that have treatment records, which is determined by a subquery that selects dog_ids from the 'Treatments' table."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "description": "This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers if needed.", "virtual_table": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )"}
{"sample_id": "dev.960", "db_id": "dog_kennels", "question": "List the last name of the owner owning the youngest dog.", "rationale": ["The query identifies the relevant tables, which are 'Owners' and 'Dogs'.", "It selects the 'last_name' column from the 'Owners' table.", "A join is performed between 'Owners' and 'Dogs' on the 'owner_id' to link owners to their dogs.", "A condition is added to filter the results to only include the dog(s) with the maximum age, which is determined by a subquery that selects the maximum age from the 'Dogs' table."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "description": "This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.", "virtual_table": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )"}
{"sample_id": "dev.996", "db_id": "dog_kennels", "question": "What are all the possible breed type and size type combinations?", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects distinct values for 'breed_code' and 'size_code' to ensure that each combination is unique.", "The use of DISTINCT ensures that duplicate entries are not included in the results."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "description": "This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.", "virtual_table": "SELECT DISTINCT breed_code ,  size_code FROM dogs"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["The query identifies the relevant tables, 'Student', 'Lives_in', and 'Has_amenity'.", "It selects the columns 'fname' and 'age' from the 'Student' table, aliased as T1.", "It joins the 'Lives_in' table, aliased as T2, to link students with their respective dormitories based on the student ID.", "A subquery is used to filter out dormitories that have a specific amenity by checking against the 'Has_amenity' and 'Dorm_amenity' tables.", "The placeholder in the subquery represents the amenity name that is being excluded from the results."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "description": "This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.", "virtual_table": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["The query identifies the relevant tables, which are 'Student', 'Lives_in', 'Dorm', 'Has_amenity', and 'Dorm_amenity'.", "It selects the 'fname' column from the 'Student' table.", "The query joins 'Student' with 'Lives_in' to find which students live in which dorms.", "A subquery is used to find dorms with the most amenities by joining 'Dorm', 'Has_amenity', and 'Dorm_amenity', counting the amenities for each dorm, and ordering them.", "The LIMIT clause uses a placeholder for the maximum number of dormitories to return."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "description": "This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.", "virtual_table": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.5739", "db_id": "dorm_1", "question": "For each dorm, how many amenities does it have?", "rationale": ["The query identifies the relevant tables, 'dorm' and 'has_amenity'.", "It selects the count of amenities and the dormitory ID from the 'dorm' table.", "A JOIN operation is performed between 'dorm' and 'has_amenity' on the dormitory ID to link dormitories with their amenities.", "A condition is added to filter dormitories based on their student capacity using a placeholder for numeric values.", "The results are grouped by the dormitory ID to provide a count of amenities for each qualifying dormitory."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "description": "This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.", "virtual_table": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["The query identifies the relevant tables, 'dorm' and 'has_amenity'.", "It selects the count of amenities and the dormitory ID from the 'dorm' table.", "A JOIN operation is performed between 'dorm' and 'has_amenity' on the dormitory ID to link dormitories with their amenities.", "A condition is added to filter dormitories based on their student capacity using a placeholder for numeric values.", "The results are grouped by the dormitory ID to provide a count of amenities for each dormitory."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "description": "This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.", "virtual_table": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the 'LName' column to display the last names of students.", "The first part of the query filters students by 'sex' and 'city_code' using placeholders for string values.", "The second part of the query filters students by 'sex' and 'age' using a placeholder for numeric values, and combines the results using UNION."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "description": "This virtual table provides a list of last names of students from the 'Student' table based on specific criteria. It includes students of a certain gender residing in a specific city, as well as students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age criteria.", "virtual_table": "SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND city_code  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5729", "db_id": "dorm_1", "question": "What is the average age and how many male students are there in each city?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the count of students and the average age, along with the city code.", "A condition is added to filter the results based on the 'Sex' column using a placeholder for string values.", "The results are grouped by 'city_code' to provide a summary for each city."], "gold_sql": "SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  'M' GROUP BY city_code", "source_tables": ["student"], "description": "This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.", "virtual_table": "SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city_code"}
{"sample_id": "train.5706", "db_id": "dorm_1", "question": "Find the last name of students who is either female (sex is F) and living in the city of code BAL or male (sex is M) and in age of below 20.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the 'LName' column to display the last names of students.", "The first part of the query filters students by 'sex' and 'city_code' using placeholders for string values.", "The second part of the query filters students by 'sex' and 'age' using a placeholder for numeric values, and combines the results using UNION."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "description": "This virtual table provides a list of last names of students from the 'Student' table based on specific criteria. It includes students of a certain gender residing in a specific city, as well as students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age criteria.", "virtual_table": "SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND city_code  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6323", "db_id": "e_government", "question": "What is the last name of the contact individual from the Labour party organization who was contacted most recently?", "rationale": ["The query identifies the relevant tables: 'Organizations', 'Organization_Contact_Individuals', and 'Individuals'.", "It selects the 'individual_last_name' from the 'Individuals' table.", "The join conditions link the organization to its contact individuals through the 'Organization_Contact_Individuals' table.", "A filter is applied to the 'organization_name' column to specify which organization to query.", "The results are ordered by 'date_contact_to' in descending order to show the most recent contacts first.", "A limit is set to control the number of results returned."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  'Labour Party' ORDER BY t2.date_contact_to DESC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "description": "This virtual table provides the last names of individuals who have contacted a specific organization. It retrieves data from the 'Organizations', 'Organization_Contact_Individuals', and 'Individuals' tables, filtering based on the organization's name. The results are ordered by the end date of the contact period, and a limit is applied to the number of results returned.", "virtual_table": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY t2.date_contact_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6329", "db_id": "e_government", "question": "What are the names of the services that have never been used?", "rationale": ["The query identifies the relevant table, which is 'Services'.", "It selects the 'service_name' column to display the names of the services.", "The EXCEPT clause is used to filter out service names that are present in the 'Party_Services' table, indicating those services have been booked."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "description": "This virtual table lists the names of services from the 'Services' table that have not been booked by any party. The query uses an EXCEPT clause to exclude service names that are present in the 'Party_Services' table, indicating that those services have been booked. The placeholder in the query represents the service names that are being filtered out based on their booking status.", "virtual_table": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id"}
{"sample_id": "train.6313", "db_id": "e_government", "question": "What is the name of the party form that is most common?", "rationale": ["The query identifies the relevant tables, 'Forms' and 'Party_Forms'.", "It selects the 'form_name' from the 'Forms' table.", "A JOIN operation is performed between 'Forms' and 'Party_Forms' on the 'form_id' to link forms with their associated parties.", "The results are grouped by 'form_id' to aggregate the counts of each form's usage.", "The results are ordered by the count of associations in descending order to prioritize the most frequently used forms.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["forms", "party_forms"], "description": "This virtual table provides a list of form names from the 'Forms' table that are associated with parties through the 'Party_Forms' table. The results are grouped by form ID and ordered by the count of associations in descending order, allowing users to see the most frequently used forms. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6343", "db_id": "e_government", "question": "Give the state corresponding to the line number building \"6862 Kaitlyn Knolls\".", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "Select the column to display, 'state_province_county'.", "Add a condition to filter the 'line_1_number_building' column using a LIKE clause with a placeholder for string values."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "description": "This virtual table retrieves the state, province, or county information from the 'Addresses' table based on a specific address line that matches a given pattern. The placeholder in the LIKE clause allows for flexible searching of address lines.", "virtual_table": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6342", "db_id": "e_government", "question": "Which state can address \"6862 Kaitlyn Knolls\" possibly be in?", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "Select the column to display, 'state_province_county'.", "Add a condition to filter the 'line_1_number_building' column using the LIKE operator with a placeholder for string values."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "description": "This virtual table retrieves the state, province, or county information from the 'Addresses' table based on a specific address line that matches a given pattern. The placeholder in the LIKE clause allows for flexible searching of address lines.", "virtual_table": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["The query identifies the relevant tables: 'Employee', 'Certificate', and 'Aircraft'.", "It selects the 'name' column from the 'Employee' table.", "The query joins the 'Employee' table with the 'Certificate' table on the employee ID, and then joins the 'Certificate' table with the 'Aircraft' table on the aircraft ID.", "A condition is added to filter aircraft based on their maximum travel distance using a placeholder for numeric values.", "The results are grouped by employee ID to count the number of certificates held by each employee.", "The results are ordered in descending order based on the count of certificates, and a limit is applied to restrict the number of results returned."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "description": "This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.", "virtual_table": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["The query identifies the relevant table, which is 'Employee'.", "It selects the 'name' column from the 'Employee' table.", "The EXCEPT clause is used to exclude employees who hold a certificate for a specific aircraft model.", "To find employees with certificates, a JOIN is performed between 'Employee', 'Certificate', and 'Aircraft' tables based on their foreign key relationships.", "A condition is added to filter the aircraft model using a placeholder for string values."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "description": "This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.", "virtual_table": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["The query identifies the relevant tables, which are 'Certificate' and 'Aircraft'.", "It selects the 'name' column from the 'Aircraft' table.", "The query performs a JOIN operation between 'Certificate' and 'Aircraft' on the aircraft ID to link certificates to their respective aircraft.", "It groups the results by the aircraft ID to aggregate the count of certificates for each aircraft.", "The results are ordered by the count of certificates in descending order to prioritize aircraft with the most certifications.", "A placeholder is included in the LIMIT clause to allow the user to specify how many aircraft names to return."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "description": "This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' table with the 'Aircraft' table based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of aircraft names to retrieve.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["The query identifies the relevant tables, which are 'Flight' and 'Aircraft'.", "It selects the 'name' column from the 'Aircraft' table and counts the number of flights associated with each aircraft.", "A JOIN operation is performed on the 'aid' column to link flights with their respective aircraft.", "The results are grouped by the 'aid' to aggregate the flight counts for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "description": "This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.", "virtual_table": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid"}
{"sample_id": "train.432", "db_id": "flight_1", "question": "What are the names of the aircraft that the least people are certified to fly?", "rationale": ["The query identifies the relevant tables, which are 'Certificate' and 'Aircraft'.", "It selects the 'name' column from the 'Aircraft' table.", "The query performs a JOIN operation between 'Certificate' and 'Aircraft' on the aircraft ID to link certificates to their respective aircraft.", "It groups the results by the aircraft ID to aggregate the count of certificates for each aircraft.", "The results are ordered by the count of certificates in descending order to prioritize aircraft with the most certifications.", "A placeholder is included in the LIMIT clause to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "description": "This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.407", "db_id": "flight_1", "question": "Which origin has most number of flights?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "It selects the 'origin' column to display the starting locations of flights.", "The results are grouped by the 'origin' to aggregate the data based on unique starting locations.", "The query orders the results by the count of flights from each origin in descending order to show the most popular origins first.", "A limit is applied to restrict the number of origins returned, using a placeholder for numeric values."], "gold_sql": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "description": "This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.", "virtual_table": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "It selects the average of the 'price' column to calculate the average ticket price.", "Conditions are added to filter the results based on the specified 'origin' and 'destination' using placeholders for string values."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "description": "This virtual table calculates the average ticket price for flights originating from a specific location and heading to a specific destination. The placeholders in the WHERE clause represent the origin and destination of the flights.", "virtual_table": "SELECT avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING] AND destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.402", "db_id": "flight_1", "question": "What is the average distance and price for all flights from LA?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "It selects the average values of 'distance' and 'price' columns.", "A condition is added to filter the results based on the 'origin' column using a placeholder for string values."], "gold_sql": "SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  'Los Angeles'", "source_tables": ["flight"], "description": "This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.", "virtual_table": "SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "Select the column to display, 'origin'.", "Add a condition to filter the 'destination' column for the specified destination using a placeholder for string values."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "description": "This virtual table provides the starting locations of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.", "virtual_table": "SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2181", "db_id": "formula_1", "question": "What are the forenames and surnames of drivers who participated in the races named Australian Grand Prix but not the races named Chinese Grand Prix?", "rationale": ["The query identifies the relevant tables: 'races', 'results', and 'drivers'.", "It selects the 'forename' and 'surname' columns from the 'drivers' table.", "The query uses JOINs to connect the 'races' table with the 'results' and 'drivers' tables based on their relationships.", "It filters the results to include drivers from a specific race using a placeholder for the race name.", "The EXCEPT clause is used to exclude drivers from another specified race, again using a placeholder for the race name."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.", "virtual_table": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2176", "db_id": "formula_1", "question": "What are the names and years of all races that had a driver with the last name Lewis?", "rationale": ["The query identifies the relevant tables: 'results', 'races', and 'drivers'.", "It selects the 'name' from the 'races' table and 'year' from the 'races' table to display the race details.", "The JOIN operations link the 'results' table to the 'races' table using 'raceId' and to the 'drivers' table using 'driverId'.", "A condition is added to filter results based on the driver's first name using a placeholder for string values."], "gold_sql": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = 'Lewis'", "source_tables": ["results", "drivers", "races"], "description": "This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.", "virtual_table": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2186", "db_id": "formula_1", "question": "What are the first names of the different drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'driverStandings'.", "It selects distinct first names from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'driverStandings' on the driver ID to combine relevant data.", "Conditions are added to filter the results based on the driver's position, number of wins, and points using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "description": "This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the driver standings, a certain number of wins, and more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2221", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It selects the maximum value of 'fastestLapSpeed' from the 'results' table.", "A JOIN operation is performed between 'races' and 'results' on the 'raceId' to correlate race details with their results.", "Conditions are added to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "This virtual table provides the maximum fastest lap speed recorded during races in a specific year and for a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.", "virtual_table": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2168", "db_id": "formula_1", "question": "What is the id and last name of the driver with the longest laptime?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'lapTimes'.", "It selects the 'driverId' and 'surname' from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'lapTimes' on the 'driverId' to associate drivers with their lap times.", "The results are ordered by the 'milliseconds' column from the 'lapTimes' table in descending order to get the fastest times first.", "The LIMIT clause is included to allow the user to specify how many top results they want to retrieve."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "description": "This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.", "virtual_table": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2183", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who was in position 1 as standing and won?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'driverStandings'.", "It selects distinct first names from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'driverStandings' on the driver ID to correlate driver information with their standings.", "Conditions are added to filter the results based on the specified position and number of wins using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "description": "This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2184", "db_id": "formula_1", "question": "What are all the different first names of the drivers who are in position as standing and won?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'driverStandings'.", "It selects distinct first names from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'driverStandings' on the driver ID to combine relevant data.", "Conditions are added to filter the results based on the specified position and number of wins using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "description": "This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2225", "db_id": "formula_1", "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["The query identifies the relevant tables, 'races' and 'results', and establishes a join between them based on the race ID.", "It selects the average fastest lap speed from the 'results' table, the name of the race, and the year from the 'races' table.", "A condition is added to filter the results to only include races that occurred after a specified year using a placeholder for numeric values.", "The results are grouped by the race name to calculate the average speed for each race and ordered by the year of the race."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "description": "This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.", "virtual_table": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year"}
{"sample_id": "train.2173", "db_id": "formula_1", "question": "How many drivers did not participate in the races held in 2009?", "rationale": ["The query identifies the relevant table, which is 'results', to count distinct drivers.", "It uses a subquery to filter out race IDs from the 'races' table based on the specified year using a placeholder for numeric values.", "The final output is the count of distinct driver IDs from the 'results' table for races that are not in the specified year."], "gold_sql": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )", "source_tables": ["results", "races"], "description": "This virtual table provides the count of distinct drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.", "virtual_table": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.2185", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'driverStandings'.", "It selects distinct first names from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'driverStandings' on the driver ID to combine relevant data.", "Conditions are added to filter the results based on the driver's position, number of wins, and points using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "description": "This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the driver standings, a certain number of wins, and more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria for filtering the results.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2219", "db_id": "formula_1", "question": "What is the average fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It joins the 'races' table with the 'results' table on the race ID to correlate race data with results.", "The SELECT statement calculates the average of the 'fastestLapSpeed' from the 'results' table.", "A condition is added to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.", "virtual_table": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2226", "db_id": "formula_1", "question": "What is the average fastest lap speed for races held after 2004, for each race, ordered by year?", "rationale": ["The query identifies the relevant tables, 'races' and 'results', and uses a JOIN to combine them based on the race ID.", "It selects the average fastest lap speed from the 'results' table, the name of the race, and the year from the 'races' table.", "A condition is added to filter the results to only include races that occurred after a specified year using a placeholder for numeric values.", "The results are grouped by the race name to calculate the average speed for each race and ordered by the year of the race."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "description": "This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.", "virtual_table": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year"}
{"sample_id": "train.2189", "db_id": "formula_1", "question": "What are the numbers of races for each constructor id?", "rationale": ["The query identifies the relevant table, which is 'constructorStandings'.", "It selects a count of records and groups them by 'constructorId' to aggregate the standings for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "description": "This virtual table provides a count of the total number of constructor standings for each constructor from the 'constructorStandings' table. The placeholder in the SELECT statement represents the constructor's identifier, which is grouped to show the total standings for each constructor.", "virtual_table": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid"}
{"sample_id": "train.2202", "db_id": "formula_1", "question": "What are the different names of all the races in reverse alphabetical order?", "rationale": ["The query is identifying the relevant table, which is 'races'.", "Select the distinct column to display, 'name', to ensure unique race names are retrieved.", "Add an ORDER BY clause to sort the results in descending order based on the race names."], "gold_sql": "SELECT DISTINCT name FROM races ORDER BY name DESC", "source_tables": ["races"], "description": "This virtual table provides a distinct list of race names from the 'races' table, sorted in descending order. The placeholder in the ORDER BY clause indicates that the results will be organized based on the race names.", "virtual_table": "SELECT DISTINCT name FROM races ORDER BY name DESC"}
{"sample_id": "train.3940", "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["The query identifies the relevant tables: 'Physician', 'Prescribes', and 'Medication'.", "It selects distinct names from the 'Physician' table (aliased as T1).", "The query joins the 'Prescribes' table (aliased as T2) on the physician's identifier to link physicians with their prescriptions.", "It further joins the 'Medication' table (aliased as T3) to filter the results based on the medication's name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "description": "This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.", "virtual_table": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3981", "db_id": "hospital_1", "question": "What are the procedures that cost more than 1000 or are specialized in by physician John Wen?", "rationale": ["The query identifies the relevant tables, which are 'Procedures' and 'Physician' along with 'Trained_In'.", "The first part of the query selects procedure names from the 'Procedures' table where the cost exceeds a specified number using a placeholder.", "The second part of the query uses a JOIN to connect 'Physician' and 'Trained_In' tables to find procedures that a specific physician is trained in, filtering by the physician's name with a placeholder.", "The UNION operator combines the results of both queries to provide a comprehensive list of procedures based on the specified criteria."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "description": "This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.", "virtual_table": "SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3972", "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["The query identifies the relevant tables: 'Physician', 'Trained_In', and 'Procedures'.", "It selects the 'Name' column from the 'Physician' table.", "The query joins 'Physician' with 'Trained_In' on the 'EmployeeID' and 'Physician' identifiers to link physicians with their training.", "It further joins 'Trained_In' with 'Procedures' on the 'Code' and 'Treatment' identifiers to associate procedures with their costs.", "A condition is added to filter the results based on the cost of the procedures using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "description": "This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3980", "db_id": "hospital_1", "question": "Find all procedures which cost more than 1000 or which physician John Wen was trained in.", "rationale": ["The query identifies the relevant tables, which are 'Procedures', 'Physician', and 'Trained_In'.", "The first part of the query selects procedure names from the 'Procedures' table where the cost exceeds a specified number using a placeholder.", "The second part of the query uses a JOIN to connect 'Physician' and 'Trained_In' tables to find procedures that a specific physician is trained in, filtering by the physician's name with a placeholder."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "description": "This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.", "virtual_table": "SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3993", "db_id": "hospital_1", "question": "How many patients are not using Procrastin-X as medication?", "rationale": ["The query identifies the relevant table, which is 'Patient'.", "It uses a subquery to find patients who have been prescribed a specific medication by joining 'Prescribes' and 'Medication'.", "The main query counts the patients whose SSN is not in the list of patients returned by the subquery, indicating they have not received the medication."], "gold_sql": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )", "source_tables": ["patient", "prescribes", "medication"], "description": "This virtual table counts the number of patients who have not been prescribed a specific medication. It filters the patients based on their Social Security Number (SSN) and checks against a subquery that retrieves patients who have received the specified medication by joining the 'Prescribes' and 'Medication' tables. The placeholder in the query represents the name of the medication.", "virtual_table": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3941", "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["The query identifies the relevant tables: 'Physician', 'Prescribes', and 'Medication'.", "It selects distinct names from the 'Physician' table (aliased as T1).", "It joins the 'Prescribes' table (aliased as T2) on the physician's identifier to link prescriptions to physicians.", "It further joins the 'Medication' table (aliased as T3) on the medication code to filter by a specific medication name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "description": "This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.", "virtual_table": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3903", "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["The query identifies the relevant tables, which are 'Department' and 'Physician'.", "It selects the 'name' and 'position' columns from the 'Physician' table (aliased as T2).", "A JOIN operation is performed between the 'Department' table (aliased as T1) and the 'Physician' table based on the condition that the head of the department matches the physician's EmployeeID.", "The results are grouped by 'departmentID' to aggregate the data appropriately.", "The results are ordered by the count of 'departmentID' to prioritize departments with more heads, and a limit is applied to restrict the number of results returned."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "description": "This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results based on the count of departments, with a limit on the number of results returned as specified by the placeholder.", "virtual_table": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3911", "db_id": "hospital_1", "question": "What are the names of all the physicians who took appointments.", "rationale": ["The query identifies the relevant tables, which are 'Appointment' and 'Physician'.", "It selects the 'Name' column from the 'Physician' table, which contains the names of the physicians.", "The join condition links the 'Physician' column in the 'Appointment' table to the 'EmployeeID' column in the 'Physician' table, ensuring that only the names of physicians conducting appointments are retrieved."], "gold_sql": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID", "source_tables": ["physician", "appointment"], "description": "This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.", "virtual_table": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID"}
{"sample_id": "train.3962", "db_id": "hospital_1", "question": "List the names of departments where some physicians are primarily affiliated with.", "rationale": ["The query identifies the relevant tables, 'Affiliated_With' and 'Department'.", "It selects distinct department names from the 'Department' table.", "A JOIN operation is performed between 'Affiliated_With' and 'Department' on the department identifier.", "A condition is added to filter the results based on the primary affiliation status using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1", "source_tables": ["department", "affiliated_with"], "description": "This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.", "virtual_table": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3945", "db_id": "hospital_1", "question": "How many medications are prescribed for each brand?", "rationale": ["The query identifies the relevant tables, which are 'medication' and 'prescribes'.", "It selects a count of prescriptions and the name of the medication from the 'medication' table.", "The JOIN operation links the two tables based on the medication code, ensuring that only prescribed medications are counted.", "The GROUP BY clause organizes the results by the brand of the medication, allowing for a summary count per brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "description": "This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.", "virtual_table": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand"}
{"sample_id": "train.3910", "db_id": "hospital_1", "question": "List the name of physicians who took some appointment.", "rationale": ["The query identifies the relevant tables, which are 'Appointment' and 'Physician'.", "It selects the 'Name' column from the 'Physician' table, which contains the names of the physicians.", "The join condition links the 'Physician' column in the 'Appointment' table to the 'EmployeeID' column in the 'Physician' table, ensuring that only the names of physicians conducting appointments are retrieved."], "gold_sql": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID", "source_tables": ["physician", "appointment"], "description": "This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.", "virtual_table": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID"}
{"sample_id": "train.3963", "db_id": "hospital_1", "question": "What are the names of departments that have primarily affiliated physicians.", "rationale": ["The query identifies the relevant tables, 'Affiliated_With' and 'Department'.", "It selects distinct department names from the 'Department' table.", "A JOIN operation is performed between 'Affiliated_With' and 'Department' on the department identifier.", "A condition is added to filter the results based on the primary affiliation status using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1", "source_tables": ["department", "affiliated_with"], "description": "This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.", "virtual_table": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3958", "db_id": "hospital_1", "question": "What are the names of the physician who prescribed the highest dose?", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Prescribes'.", "It selects the 'Name' column from the 'Physician' table, aliased as T1.", "A JOIN operation is performed between 'Physician' and 'Prescribes' on the condition that the 'EmployeeID' from 'Physician' matches the 'Physician' identifier in 'Prescribes'.", "The results are ordered by the 'Dose' column from the 'Prescribes' table in descending order to show the highest dosages first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "description": "This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3928", "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Patient'.", "It selects the 'Name' column from the 'Physician' table and counts the number of patients associated with each physician.", "A join is performed between the 'Physician' table and the 'Patient' table using the physician's employee ID and the patient's PCP identifier.", "The results are grouped by the physician's employee ID to provide a count of patients for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "description": "This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.", "virtual_table": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid"}
{"sample_id": "train.3964", "db_id": "hospital_1", "question": "What nurses are on call with block floor 1 and block code 1? Tell me their names.", "rationale": ["The query identifies the relevant table, which is 'On_Call'.", "Select the column to display, 'nurse'.", "Add conditions to filter the 'blockfloor' and 'blockcode' columns using placeholders for numeric values."], "gold_sql": "SELECT nurse FROM on_call WHERE blockfloor  =  1 AND blockcode  =  1", "source_tables": ["on_call"], "description": "This virtual table provides a list of nurses who are on call, filtered by specific conditions related to blocked floors and blocked codes. The placeholders in the WHERE clause represent the identifiers for the blocked floor and blocked code statuses.", "virtual_table": "SELECT nurse FROM on_call WHERE blockfloor  =  [PLACEHOLDER-TYPE:NUMBER] AND blockcode  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3901", "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["The query identifies the relevant table, which is 'Department'.", "It selects the 'head' column to display the heads of the departments.", "The results are grouped by 'DepartmentID' to aggregate the data appropriately.", "The results are ordered by the count of 'DepartmentID' to prioritize departments with more occurrences.", "A placeholder is included to limit the number of results returned."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "description": "This virtual table provides a list of department heads from the 'Department' table, grouped by department ID. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.", "virtual_table": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3924", "db_id": "hospital_1", "question": "Find the patient who most recently stayed in room 111.", "rationale": ["The query identifies the relevant table, which is 'Stay'.", "It selects the 'patient' column to display the patients staying in the specified room.", "A condition is added to filter the 'room' column for the specified room number using a placeholder for numeric values.", "The results are ordered by 'StayStart' in descending order to show the most recent stays first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT patient FROM stay WHERE room  =  111 ORDER BY staystart DESC LIMIT 1", "source_tables": ["stay"], "description": "This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.", "virtual_table": "SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3949", "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["The query identifies the relevant table, which is 'Undergoes'.", "Select the 'patient' column to display the patients who have undergone procedures.", "Order the results by 'dateundergoes' to sort the patients based on when they underwent the procedures.", "Use a placeholder in the LIMIT clause to allow the user to specify how many patient records to return."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "description": "This virtual table provides a list of patients who have undergone medical procedures, sorted by the date of the procedures. The placeholder in the LIMIT clause allows for specifying the maximum number of patients to retrieve.", "virtual_table": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3900", "db_id": "hospital_1", "question": "What is the employee id of the head whose department has the least number of employees?", "rationale": ["The query identifies the relevant table, which is 'Department'.", "It selects the 'head' column to display the heads of the departments.", "The results are grouped by 'DepartmentID' to ensure unique department heads are listed.", "The results are ordered by the count of 'DepartmentID' to prioritize departments with more occurrences.", "A placeholder is included to limit the number of results returned."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "description": "This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.", "virtual_table": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3948", "db_id": "hospital_1", "question": "Find the patient who has the most recent undergoing treatment?", "rationale": ["The query identifies the relevant table, which is 'Undergoes'.", "Select the 'patient' column to display the patients who have undergone procedures.", "Order the results by 'dateundergoes' to show the most recent procedures first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "description": "This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.", "virtual_table": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3518", "db_id": "hr_1", "question": "What are the full names, departments, cities, and state provinces for each employee?", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', and 'locations'.", "It selects the columns to display: 'first_name' and 'last_name' from 'employees', 'department_name' from 'departments', and 'city' and 'state_province' from 'locations'.", "The JOIN operations link the 'employees' table to the 'departments' table using 'department_id', and then link the 'departments' table to the 'locations' table using 'location_id'."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id", "source_tables": ["employees", "departments", "locations"], "description": "The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.", "virtual_table": "SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id"}
{"sample_id": "train.3524", "db_id": "hr_1", "question": "What the full names, ids of each employee and the name of the country they are in?", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', 'locations', and 'countries'.", "It selects the 'first_name', 'last_name', and 'employee_id' from the 'employees' table (aliased as T1).", "It joins the 'departments' table (T2) on the 'department_id' to associate employees with their departments.", "It further joins the 'locations' table (T3) on 'location_id' to link departments to their locations.", "Finally, it joins the 'countries' table (T4) on 'country_id' to retrieve the country names associated with the locations."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "description": "This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.", "virtual_table": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', and 'locations'.", "It selects the columns to display: 'first_name', 'last_name', and 'salary'.", "The JOIN operations link the 'employees' table to the 'departments' table using 'department_id', and then to the 'locations' table using 'location_id'.", "A condition is added to filter the results based on the 'city' column from the 'locations' table, using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "description": "This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["The query identifies the relevant tables, which are 'job_history' and 'employees'.", "It selects all columns from the joined tables using the wildcard '*'.", "The JOIN condition links the 'employee_id' from 'job_history' to 'employee_id' in 'employees'.", "A condition is added to filter employees based on their salary, using a placeholder for numeric values."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "description": "This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.", "virtual_table": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3498", "db_id": "hr_1", "question": "What are the ids for employees who do not work in departments with managers that have ids between 100 and 200?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects all columns from the 'employees' table.", "A condition is added to filter out department IDs that are linked to manager IDs within a specified numeric range using placeholders."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "description": "This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs.", "virtual_table": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.3481", "db_id": "hr_1", "question": "get the details of employees who manage a department.", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It performs a JOIN operation on the 'department_id' to link employees with their respective departments.", "The WHERE clause filters the results to include only those employees whose 'employee_id' matches the 'manager_id' in the departments table."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "description": "This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that each employee-manager pair is unique.", "virtual_table": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id"}
{"sample_id": "train.3464", "db_id": "hr_1", "question": "Give the name of each department and the number of employees in each.", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It selects the 'department_name' from the 'departments' table and counts the number of employees from the 'employees' table.", "A JOIN operation is performed on the 'department_id' to link employees to their respective departments.", "The results are grouped by 'department_name' to provide a count of employees in each department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "description": "This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.", "virtual_table": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name"}
{"sample_id": "train.3466", "db_id": "hr_1", "question": "What is all the job history info done by employees earning a salary greater than or equal to 12000?", "rationale": ["The query identifies the relevant tables, which are 'job_history' and 'employees'.", "It selects all columns from the joined tables using the wildcard '*'.", "The JOIN condition links the 'employee_id' from 'job_history' to 'employee_id' from 'employees'.", "A condition is added to filter employees based on their salary, using a placeholder for numeric values."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "description": "This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.", "virtual_table": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3509", "db_id": "hr_1", "question": "display the employee number, name( first name and last name ) and job title for all employees whose salary is more than any salary of those employees whose job title is PU_MAN.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', 'last_name', and 'job_id'.", "Add a condition to filter employees based on their salary being greater than a maximum salary from a subquery.", "The subquery selects the maximum salary from the 'employees' table where the job identifier matches the specified job, using a placeholder for string values."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "description": "This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the 'department_id' and calculates the average salary using the AVG function.", "A condition is added to filter out employees with a null commission percentage using a placeholder for string values.", "The results are grouped by 'department_id' to provide the average salary for each department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table provides the average salary of employees grouped by their department. The placeholder in the WHERE clause indicates that only employees with a non-null commission percentage are included in the calculation.", "virtual_table": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', and 'last_name'.", "Add a condition to filter the 'department_id' based on a subquery that selects 'department_id' from the 'employees' table where the 'first_name' matches a specified pattern using a placeholder for string values."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "description": "This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["The query identifies the relevant table, which is 'locations'.", "Select the 'country_id' column to group the results by country.", "Use the COUNT function to count the number of locations for each country, grouping the results by 'country_id' to get the total count per country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "description": "This virtual table summarizes the number of locations associated with each country from the 'locations' table. The placeholder in the SELECT clause represents the unique identifier for each country, while the COUNT function aggregates the total number of locations per country.", "virtual_table": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id"}
{"sample_id": "train.3473", "db_id": "hr_1", "question": "Find the first name and last name and department id for those employees who earn such amount of salary which is the smallest salary of any of the departments.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'department_id'.", "Add a condition to filter employees whose salary is in the set of minimum salaries for each department, using a subquery that groups by 'department_id' to find the minimum salary for each department."], "gold_sql": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)", "source_tables": ["employees"], "description": "This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table. It specifically filters for employees who earn the minimum salary within their respective departments. The placeholder in the WHERE clause represents the salary criteria based on the minimum salary grouped by department.", "virtual_table": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)"}
{"sample_id": "train.3428", "db_id": "hr_1", "question": "Return the full names and salaries for employees with first names that end with the letter m.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'salary'.", "Add a condition to filter the 'first_name' column using a LIKE operator with a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE '%m'", "source_tables": ["employees"], "description": "This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the 'department_id' and calculates the average salary using the AVG() function.", "A condition is added to exclude employees with a specific commission percentage using a placeholder for string values.", "The results are grouped by 'department_id' to provide the average salary per department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table provides the average salary of employees grouped by their department. It filters out employees who have a specific commission percentage, represented by a placeholder for string values.", "virtual_table": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id"}
{"sample_id": "train.3432", "db_id": "hr_1", "question": "What are the full names of employees who with in department 70 or 90?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display, 'first_name' and 'last_name'.", "Adds a condition to filter the 'department_id' column for the specified department identifiers using placeholders for numeric values."], "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE department_id  =  70 OR department_id  =  90", "source_tables": ["employees"], "description": "This virtual table provides the first and last names of employees from the 'employees' table who belong to specific departments. The placeholders in the WHERE clause represent the identifiers of the departments being queried.", "virtual_table": "SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'hire_date'.", "Add a condition to filter the 'department_id' using a subquery that retrieves the 'department_id' based on the specified 'first_name' using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "description": "This virtual table provides the first and last names, along with the hire date of employees from the 'employees' table who belong to a specific department. The department is identified by the first name of an employee, which is used as a filter in a subquery to find the corresponding department ID.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["The query is identifying the relevant table, which is 'employees'.", "Select the columns to display, 'first_name', 'last_name', and 'salary'.", "Add a condition to filter the 'salary' column for employees earning less than the specified salary using a placeholder for numeric values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "description": "This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3449", "db_id": "hr_1", "question": "display those departments where more than ten employees work who got a commission percentage.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the 'department_id' to group the results by department.", "The HAVING clause is used to filter groups based on the count of employees with a commission percentage, using a placeholder for numeric values."], "gold_sql": "SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > 10", "source_tables": ["employees"], "description": "This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.", "virtual_table": "SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects all columns from the 'employees' table.", "A condition is added to filter employees based on their salary, using a subquery to find the minimum salary and a placeholder for the upper limit of the salary range."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "description": "This virtual table retrieves all employee records from the 'employees' table whose salary falls within a specified range. The lower limit of the salary range is dynamically determined by selecting the minimum salary from the same table, while the upper limit is represented by a placeholder for numeric values.", "virtual_table": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3474", "db_id": "hr_1", "question": "What are the full names and department ids for the lowest paid employees across all departments.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'department_id'.", "Add a condition to filter employees whose salary matches the minimum salary in their department using a subquery that groups by 'department_id' and selects the minimum salary."], "gold_sql": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)", "source_tables": ["employees"], "description": "This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.", "virtual_table": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display: 'first_name', 'last_name', 'hire_date', 'salary', and 'department_id'.", "Adds a condition to filter out employees whose first names match a specified pattern using a placeholder for string values.", "Orders the results by 'department_id' to group employees by their respective departments."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "description": "This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY department_id"}
{"sample_id": "train.3508", "db_id": "hr_1", "question": "What are the employee ids and job ids for employees who make less than the lowest earning employee with title MK_MAN?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display, 'employee_id' and 'job_id'.", "Add a condition to filter employees whose salary is less than a certain value.", "The subquery retrieves the minimum salary for a specific job using a placeholder for the job identifier."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "description": "This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.", "virtual_table": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3504", "db_id": "hr_1", "question": "What are the ids and full names for employees who work in a department that has someone with a first name that contains the letter T?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', and 'last_name'.", "Add a condition to filter the 'department_id' based on a subquery that selects 'department_id' from the 'employees' table where the 'first_name' matches a specified pattern using a placeholder for string values."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "description": "This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3447", "db_id": "hr_1", "question": "display the employee ID for each employee and the date on which he ended his previous job.", "rationale": ["The query identifies the relevant table, which is 'job_history'.", "Select the column 'employee_id' to display the unique identifier for each employee.", "Use the MAX function to find the latest 'end_date' for each employee's job history.", "Group the results by 'employee_id' to ensure that we get the most recent end date for each employee."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "description": "This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the employee's unique identifier, while the MAX function is used to retrieve the latest end date for each employee's job history.", "virtual_table": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id"}
{"sample_id": "train.3408", "db_id": "hr_1", "question": "What are the full names and salaries for any employees earning less than 6000?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'salary'.", "Add a condition to filter the 'salary' column for employees earning less than the specified amount using a placeholder for numeric values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "description": "This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["The query identifies the relevant table, which is 'locations'.", "It selects the 'country_id' to group the results by each country.", "The COUNT function is used to count the number of locations for each country, and the results are grouped by 'country_id' to provide a summary count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "description": "This virtual table summarizes the number of locations associated with each country in the 'locations' table. The placeholder in the SELECT clause represents the unique identifier for each country, while the COUNT function aggregates the total number of locations per country.", "virtual_table": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects distinct 'department_id' to ensure unique entries.", "The results are grouped by 'department_id' and 'manager_id' to aggregate data based on these identifiers.", "A HAVING clause is used to filter groups that have a count of 'employee_id' greater than or equal to a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "description": "This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.", "virtual_table": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1522", "db_id": "insurance_and_eClaims", "question": "Which customer made the smallest amount of claim in one claim? Return the customer details.", "rationale": ["The query identifies the relevant tables: 'Claim_Headers', 'Policies', and 'Customers'.", "It selects the 'Customer_Details' from the 'Customers' table.", "The query uses JOINs to connect 'Claim_Headers' to 'Policies' and 'Policies' to 'Customers' based on their foreign key relationships.", "A subquery is used to find the minimum 'Amount_Piad' from the 'Claim_Headers' table, which is used as a condition in the WHERE clause."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "description": "This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.", "virtual_table": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)"}
{"sample_id": "train.1521", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the minimum amount of payment in one claim?", "rationale": ["The query identifies the relevant tables: 'Claim_Headers', 'Policies', and 'Customers'.", "It selects the 'customer_details' from the 'Customers' table.", "The query uses JOINs to connect 'Claim_Headers' to 'Policies' via 'policy_id', and 'Policies' to 'Customers' via 'customer_id'.", "A subquery is used to find the minimum 'amount_paid' from 'Claim_Headers', which is used as a condition in the WHERE clause."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "description": "This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.", "virtual_table": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)"}
{"sample_id": "train.1533", "db_id": "insurance_and_eClaims", "question": "Find the names of customers who either have an deputy policy or uniformed policy.", "rationale": ["The query identifies the relevant tables, which are 'Policies' and 'Customers'.", "It selects the 'customer_details' column from the 'Customers' table, ensuring that only distinct entries are returned.", "A JOIN operation is performed on the 'customer_id' to link the two tables based on the relationship defined in the foreign keys.", "The WHERE clause filters the results based on the 'policy_type_code', allowing for multiple policy types to be specified using placeholders."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy' OR t1.policy_type_code  =  'Uniform'", "source_tables": ["policies", "customers"], "description": "This virtual table provides a distinct list of customer details from the 'Customers' table for those customers who have specific types of insurance policies. The placeholders in the WHERE clause represent the policy type codes that the user can specify.", "virtual_table": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING] OR t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1536", "db_id": "insurance_and_eClaims", "question": "What are the names of the customers and staff members?", "rationale": ["The query is identifying the relevant tables, which are 'Customers' and 'Staff'.", "Using the UNION operator to combine results from both tables.", "Selecting the 'Customer_Details' from the 'Customers' table and 'Staff_Details' from the 'Staff' table to provide a unified view of details from both entities."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "description": "This virtual table combines detailed information about customers and staff members from the 'Customers' and 'Staff' tables. The placeholder in the SELECT statement allows for the retrieval of customer details and staff details, providing a comprehensive view of both entities.", "virtual_table": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff"}
{"sample_id": "train.1531", "db_id": "insurance_and_eClaims", "question": "Find the names of the customers who have an deputy policy.", "rationale": ["The query identifies the relevant tables, which are 'Policies' and 'Customers'.", "It uses a JOIN operation to link the 'Policies' table with the 'Customers' table based on the 'Customer_ID'.", "The SELECT DISTINCT statement is used to ensure that only unique customer details are returned.", "A condition is added to filter the results based on the 'Policy_Type_Code' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy'", "source_tables": ["policies", "customers"], "description": "This virtual table provides a distinct list of customer details from the 'Customers' table for those customers who hold a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code that is being queried.", "virtual_table": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1518", "db_id": "insurance_and_eClaims", "question": "How much amount in total were claimed in the most recently created document?", "rationale": ["The query identifies the relevant tables, 'Claim_Headers' and 'Claims_Documents'.", "It uses a JOIN to link the claims with their corresponding documents based on the claim ID.", "The SUM function is applied to the 'amount_claimed' column to calculate the total amount claimed.", "A subquery is used to filter the documents based on their creation date, with a placeholder indicating the limit for the selection."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "description": "This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.", "virtual_table": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.1528", "db_id": "insurance_and_eClaims", "question": "Which claim processing stage has the most claims? Show the claim status name.", "rationale": ["The query identifies the relevant tables, which are 'claims_processing' and 'claims_processing_stages'.", "It selects the 'claim_status_name' from the 'claims_processing_stages' table.", "A JOIN operation is performed on the 'claim_stage_id' to link the two tables together.", "The results are grouped by 'claim_stage_id' to aggregate the data appropriately.", "The results are ordered by the count of occurrences in descending order to prioritize the most common statuses.", "A placeholder is included to allow the user to specify the limit on the number of statuses returned."], "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"], "description": "This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.", "virtual_table": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1513", "db_id": "insurance_and_eClaims", "question": "Find all the policy types that are used by more than 2 customers.", "rationale": ["The query identifies the relevant table, which is 'Policies'.", "It selects the 'policy_type_code' to display unique policy types.", "The GROUP BY clause is used to group the results by 'policy_type_code'.", "The HAVING clause filters the groups to include only those with a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"], "description": "This virtual table provides a list of unique insurance policy types from the 'Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.", "virtual_table": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1511", "db_id": "insurance_and_eClaims", "question": "Which type of policy is most frequently used? Give me the policy type code.", "rationale": ["The query identifies the relevant table, which is 'Policies'.", "It selects the 'policy_type_code' column to display the types of insurance policies.", "The GROUP BY clause is used to group the results by 'policy_type_code'.", "The ORDER BY clause sorts the grouped results by their count in descending order, allowing the user to see the most common policy types first.", "The LIMIT clause includes a placeholder for the user to specify how many policy types they want to retrieve."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"], "description": "This virtual table summarizes the different types of insurance policies from the 'Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.", "virtual_table": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.969", "db_id": "medicine_enzyme_interaction", "question": "Show the medicine names and trade names that cannot interact with the enzyme with product 'Heme'.", "rationale": ["The query identifies the relevant table, which is 'medicine'.", "Select the columns to display, 'name' and 'trade_name'.", "Use the EXCEPT clause to filter out medicines that interact with a specific enzyme product.", "Join the 'medicine' table with 'medicine_enzyme_interaction' and 'enzyme' tables to find the medicines that interact with the specified enzyme product using a placeholder for string values."], "gold_sql": "SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  'Protoporphyrinogen IX'", "source_tables": ["enzyme", "medicine", "medicine_enzyme_interaction"], "description": "This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.", "virtual_table": "SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.967", "db_id": "medicine_enzyme_interaction", "question": "List the medicine name and trade name which can both interact as 'inhibitor' and 'activitor' with enzymes.", "rationale": ["The query identifies the relevant tables, which are 'medicine' and 'medicine_enzyme_interaction'.", "It selects the columns to display, 'name' and 'trade_name' from the 'medicine' table.", "The query uses a JOIN to connect 'medicine' and 'medicine_enzyme_interaction' based on the medicine's ID.", "It adds a condition to filter the 'interaction_type' column for the specified interaction type using placeholders for string values.", "The INTERSECT operator is used to find common medicines that have the same interaction type in two separate queries."], "gold_sql": "SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'inhibitor' INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'activitor'", "source_tables": ["medicine", "medicine_enzyme_interaction"], "description": "This virtual table describes the names and trade names of medicines that have specific types of interactions with enzymes. The placeholders in the WHERE clause represent the types of interactions being queried.", "virtual_table": "SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.952", "db_id": "medicine_enzyme_interaction", "question": "What are the ids, names, and FDA approval status for medicines ordered by descending number of possible enzyme interactions?", "rationale": ["The query identifies the relevant tables, 'medicine' and 'medicine_enzyme_interaction'.", "It selects the columns 'id', 'name', and 'FDA_approved' from the 'medicine' table, aliased as T1.", "The JOIN operation connects 'medicine' with 'medicine_enzyme_interaction' based on the matching 'medicine_id'.", "The results are grouped by the medicine's unique identifier to aggregate the interaction counts.", "Finally, the results are ordered by the count of interactions in descending order to highlight the most interacted medicines."], "gold_sql": "SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC", "source_tables": ["medicine", "medicine_enzyme_interaction"], "description": "This virtual table provides a list of medicines along with their unique identifiers and FDA approval status, sorted by the number of interactions they have with enzymes. The placeholder in the query allows for dynamic filtering based on the specific criteria of interest.", "virtual_table": "SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC"}
{"sample_id": "train.954", "db_id": "medicine_enzyme_interaction", "question": "What is the id and name of the enzyme that can interact with the most medicines as an activator?", "rationale": ["The query identifies the relevant tables, 'enzyme' and 'medicine_enzyme_interaction'.", "It selects the columns 'id' and 'name' from the 'enzyme' table, aliased as T1.", "A JOIN operation is performed between 'enzyme' (T1) and 'medicine_enzyme_interaction' (T2) on the enzyme ID to link the two tables.", "A condition is added to filter the results based on the specified 'interaction_type' using a placeholder for string values.", "The results are grouped by the enzyme ID to aggregate the data, and ordered by the count of interactions in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  'activitor' GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["enzyme", "medicine_enzyme_interaction"], "description": "This virtual table provides a list of enzyme identifiers and their names from the 'enzyme' table that are involved in a specific type of interaction with medicines. The interaction type is specified by a placeholder, and the results are grouped by enzyme ID, ordered by the frequency of interactions in descending order, with a limit on the number of results returned, specified by another placeholder.", "virtual_table": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.966", "db_id": "medicine_enzyme_interaction", "question": "What are the different names, locations, and products of the enzymes that are capable inhibitor interactions?", "rationale": ["The query identifies the relevant tables, which are 'enzyme' and 'medicine_enzyme_interaction'.", "It selects distinct columns to display: 'name', 'location', and 'product' from the 'enzyme' table.", "A JOIN operation is performed between 'enzyme' and 'medicine_enzyme_interaction' on the enzyme ID to link the two tables.", "A condition is added to filter the results based on the 'interaction_type' column using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.name ,  T1.location ,  T1.product FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.enzyme_id  =  T1.id WHERE T2.interaction_type  =  'inhibitor'", "source_tables": ["enzyme", "medicine_enzyme_interaction"], "description": "This virtual table provides a distinct list of enzyme names, their geographical locations, and the products they produce, specifically for those enzymes that interact with medicines in a certain way. The placeholder in the WHERE clause represents the type of interaction being queried.", "virtual_table": "SELECT DISTINCT T1.name ,  T1.location ,  T1.product FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.enzyme_id  =  T1.id WHERE T2.interaction_type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.958", "db_id": "medicine_enzyme_interaction", "question": "What are the most common types of interactions between enzymes and medicine, and how many types are there?", "rationale": ["The query identifies the relevant table, which is 'medicine_enzyme_interaction'.", "It selects the 'interaction_type' column and counts the number of occurrences for each type.", "The results are grouped by 'interaction_type' to aggregate the counts.", "The results are ordered in descending order based on the count of interactions.", "A placeholder is included to allow the user to specify the limit on the number of results returned."], "gold_sql": "SELECT interaction_type ,  count(*) FROM medicine_enzyme_interaction GROUP BY interaction_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["medicine_enzyme_interaction"], "description": "This virtual table summarizes the types of interactions between medicines and enzymes from the 'medicine_enzyme_interaction' table. It counts the occurrences of each interaction type and orders them in descending order, allowing the user to specify a limit on the number of results returned.", "virtual_table": "SELECT interaction_type ,  count(*) FROM medicine_enzyme_interaction GROUP BY interaction_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2082", "db_id": "party_people", "question": "Count the number of Annual Meeting events that took place in the region of the United Kingdom.", "rationale": ["The query identifies the relevant tables: 'region', 'party', and 'party_events'.", "It uses JOIN operations to connect these tables based on their foreign key relationships: 'region_id' from 'party' and 'party_id' from 'party_events'.", "The SELECT statement counts the number of events that match the specified criteria.", "The WHERE clause filters the results based on the specified 'region_name' and 'Event_Name', using placeholders for user input."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "description": "This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.", "virtual_table": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2071", "db_id": "party_people", "question": "Show party names and the number of events for each party.", "rationale": ["The query identifies the relevant tables, which are 'party_events' and 'party'.", "It uses a JOIN operation to connect 'party_events' with 'party' based on the 'party_id'.", "The SELECT statement retrieves the 'party_name' from the 'party' table and counts the number of events from the 'party_events' table.", "The GROUP BY clause is used to group the results by 'party_id' to get the count of events for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "description": "This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT statement represents the party names, while the count function aggregates the total number of events for each party.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2058", "db_id": "party_people", "question": "How many members are in each party?", "rationale": ["The query identifies the relevant tables, which are 'Member' and 'Party'.", "It selects the 'party_name' from the 'Party' table and counts the number of members from the 'Member' table.", "A JOIN operation is performed on the 'party_id' to link members to their respective parties.", "The results are grouped by 'party_id' to aggregate the count of members for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "description": "This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement allows for the retrieval of the party name and the count of members belonging to that party.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2049", "db_id": "party_people", "question": "Show all ministers who do not belong to Progress Party.", "rationale": ["The query identifies the relevant table, which is 'party'.", "Select the column to display, 'minister'.", "Add a condition to filter the 'party_name' column to exclude a specific party using a placeholder for string values."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "description": "This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.", "virtual_table": "SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', and 'Characteristics'.", "It uses JOIN operations to link these tables based on their foreign key relationships.", "The SELECT statement counts the distinct characteristic names from the 'Characteristics' table.", "A condition is added to filter the results based on the specified product name using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "description": "This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.", "virtual_table": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors'.", "It uses JOIN operations to connect these tables based on their foreign key relationships.", "The SELECT statement counts the total number of products that meet the specified conditions.", "The WHERE clause filters the results based on either the color description or the characteristic name, using placeholders for user-defined values."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "description": "This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using joins based on their relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.", "virtual_table": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5557", "db_id": "products_gen_characteristics", "question": "Count the number of different characteristic names the product 'cumin' has.", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', and 'Characteristics'.", "It uses JOIN operations to link these tables based on their relationships: 'Products' to 'Product_Characteristics' via 'product_id', and 'Product_Characteristics' to 'Characteristics' via 'characteristic_id'.", "The SELECT statement counts the distinct 'characteristic_name' from the 'Characteristics' table.", "A condition is added to filter the results based on the specified product name using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "description": "This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.", "virtual_table": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5562", "db_id": "products_gen_characteristics", "question": "List all characteristics of product named \"sesame\" with type code \"Grade\".", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', and 'Characteristics'.", "It selects the 'characteristic_name' from the 'Characteristics' table.", "The JOIN operations link the 'Products' table to the 'Product_Characteristics' table and then to the 'Characteristics' table based on their respective IDs.", "The WHERE clause filters the results by the specified product name and characteristic type code, using placeholders for these string values."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame' AND t3.characteristic_type_code  =  'Grade'", "source_tables": ["products", "characteristics", "product_characteristics"], "description": "This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query filters the results based on the product's name and the type of characteristic, using placeholders for both values.", "virtual_table": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5542", "db_id": "products_gen_characteristics", "question": "Find the category descriptions of the products whose descriptions include letter 't'.", "rationale": ["The query identifies the relevant tables, which are 'Ref_Product_Categories' and 'Products'.", "It selects the 'product_category_description' from 'Ref_Product_Categories'.", "A JOIN is performed between 'Ref_Product_Categories' and 'Products' on the 'product_category_code' to link the product categories with their respective products.", "A condition is added to filter the results based on the 'product_description' using a placeholder for string values."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "description": "This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.", "virtual_table": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5593", "db_id": "products_gen_characteristics", "question": "Give the color description that is least common across products.", "rationale": ["The query identifies the relevant tables, which are 'Products' and 'Ref_Colors'.", "It selects the 'color_description' from the 'Ref_Colors' table.", "A JOIN operation is performed on the 'color_code' to link the two tables based on the color of the products.", "The results are grouped by 'color_description' to aggregate the data based on color.", "The results are ordered by the count of products for each color in ascending order.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "description": "The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color in ascending order. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.", "virtual_table": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["The query identifies the relevant tables, 'Products' and 'Ref_Colors'.", "It selects the 'color_description' from the 'Ref_Colors' table.", "A JOIN operation is performed on the 'color_code' to link products with their respective colors.", "The results are grouped by 'color_description' to aggregate the data based on color.", "The ORDER BY clause sorts the results by the count of products associated with each color in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many color descriptions to return."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "description": "This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the frequency of products associated with each color. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.", "virtual_table": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5535", "db_id": "products_gen_characteristics", "question": "How many products are in the 'Spices' category and have a typical price of over 1000?", "rationale": ["The query identifies the relevant table, which is 'Products'.", "It uses the COUNT function to count the number of products that meet specific criteria.", "The WHERE clause filters products based on the 'product_category_code' and checks if the 'typical_buying_price' is greater than a specified value, using placeholders for both the category code and the price."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "description": "This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.", "virtual_table": "SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5526", "db_id": "products_gen_characteristics", "question": "Find the names of all the product characteristics.", "rationale": ["The query is identifying the relevant table, which is 'Characteristics'.", "Select the column to display, 'characteristic_name'.", "Use DISTINCT to ensure that only unique characteristic names are returned."], "gold_sql": "SELECT DISTINCT characteristic_name FROM CHARACTERISTICS", "source_tables": ["characteristics"], "description": "This virtual table provides a list of unique characteristic names from the 'Characteristics' table. The use of DISTINCT ensures that each characteristic name appears only once in the result set.", "virtual_table": "SELECT DISTINCT characteristic_name FROM CHARACTERISTICS"}
{"sample_id": "train.630", "db_id": "store_1", "question": "What are the names of all Rock tracks that are stored on MPEG audio files?", "rationale": ["The query identifies the relevant tables: 'genres', 'tracks', and 'media_types'.", "It selects the 'name' column from the 'tracks' table (aliased as T2).", "It joins the 'genres' table (aliased as T1) on the genre ID to filter tracks by a specific genre.", "It also joins the 'media_types' table (aliased as T3) on the media type ID to filter tracks by a specific media type.", "The WHERE clause includes placeholders for the genre name and media type name to allow for dynamic filtering."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "description": "This virtual table describes the names of tracks from the 'tracks' table that belong to a specific genre and media type. The placeholders in the WHERE clause represent the genre's name and the media type's name.", "virtual_table": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = [PLACEHOLDER-TYPE:STRING] AND T3.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["The query identifies the relevant tables: 'tracks', 'invoice_lines', 'invoices', and 'customers'.", "It selects the 'name' column from the 'tracks' table, which contains the track names.", "The query joins the 'tracks' table with 'invoice_lines' to link tracks to their respective invoices.", "It further joins 'invoices' with 'customers' to associate invoices with the customers who made the purchases.", "A condition is added to filter the results based on the specified first and last names of the customer using placeholders for string values."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "description": "This virtual table describes the names of tracks from the 'tracks' table that have been purchased by customers with a specific first and last name. The placeholders in the WHERE clause represent the customer's first and last names.", "virtual_table": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = [PLACEHOLDER-TYPE:STRING] AND T4.last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.625", "db_id": "store_1", "question": "List name of all tracks in Balls to the Wall.", "rationale": ["The query identifies the relevant tables, which are 'albums' and 'tracks'.", "It selects the 'name' column from the 'tracks' table.", "A JOIN operation is performed on the 'albums' and 'tracks' tables using the album's ID and the genre ID.", "A condition is added to filter the results based on the specified album title using a placeholder for string values."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "description": "This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.", "virtual_table": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.626", "db_id": "store_1", "question": "What is the name of all tracks in the album named Balls to the Wall?", "rationale": ["The query identifies the relevant tables, which are 'albums' and 'tracks'.", "It selects the 'name' column from the 'tracks' table.", "A JOIN operation is performed on the 'albums' and 'tracks' tables using the album's ID and the genre ID.", "A condition is added to filter the results based on the specified album title using a placeholder for string values."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "description": "This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.", "virtual_table": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["The query identifies the relevant tables, which are 'albums' and 'tracks'.", "It selects the 'title' column from the 'albums' table.", "A JOIN is performed between 'albums' and 'tracks' on the condition that the album's ID matches the genre ID of the track, which is likely a mistake since it should match the album ID instead.", "A condition is added to filter the tracks by their name using a placeholder for string values."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "description": "This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.", "virtual_table": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["The query identifies the relevant tables, which are 'customers' and 'invoices'.", "It uses a JOIN operation to link the 'customers' table with the 'invoices' table based on the customer ID.", "The SELECT statement counts the total number of invoices for the specified customer.", "The WHERE clause filters the results based on the customer's first and last name using placeholders for string values."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "description": "This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.", "virtual_table": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.611", "db_id": "store_1", "question": "List all media types.", "rationale": ["The query identifies the relevant table, which is 'media_types'.", "Select the column to display, 'name', which represents the name of each media type."], "gold_sql": "SELECT name FROM media_types;", "source_tables": ["media_types"], "description": "This virtual table describes the names of different media types from the 'media_types' table. The query retrieves all media type names without any filtering conditions.", "virtual_table": "SELECT name FROM media_types;"}
{"sample_id": "train.555", "db_id": "store_1", "question": "List every album whose title starts with A in alphabetical order.", "rationale": ["The query identifies the relevant table, which is 'albums'.", "Select the column to display, 'title'.", "Add a condition to filter the 'title' column using a LIKE clause for pattern matching with a placeholder for string values.", "Order the results by 'title' to ensure they are presented in a sorted manner."], "gold_sql": "SELECT title FROM albums WHERE title LIKE 'A%' ORDER BY title;", "source_tables": ["albums"], "description": "This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for, allowing for flexible querying of album titles.", "virtual_table": "SELECT title FROM albums WHERE title LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY title;"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["The query identifies the relevant table, which is 'customers'.", "It counts the total number of entries using count(*).", "A condition is added to filter the results based on the 'state' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "description": "This virtual table provides the total number of customers from the 'customers' table who reside in a specific state. The placeholder in the WHERE clause represents the state name.", "virtual_table": "SELECT count(*) FROM customers WHERE state = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.589", "db_id": "store_1", "question": "find the full name of employees who report to Nancy Edwards?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It uses a self-join to connect employees with their managers by matching the 'id' of the manager (T1) with the 'reports_to' field of the employee (T2).", "The SELECT statement specifies the columns to display, which are 'first_name' and 'last_name' of the employees reporting to the specified manager.", "Conditions are added to filter the results based on the first and last names of the manager using placeholders for string values."], "gold_sql": "SELECT T2.first_name , T2.last_name FROM employees AS T1 JOIN employees AS T2 ON T1.id = T2.reports_to WHERE T1.first_name = 'Nancy' AND T1.last_name = 'Edwards';", "source_tables": ["employees"], "description": "This virtual table describes the first and last names of employees who report to a specific manager from the 'employees' table. The placeholders in the WHERE clause represent the first and last names of the manager.", "virtual_table": "SELECT T2.first_name , T2.last_name FROM employees AS T1 JOIN employees AS T2 ON T1.id = T2.reports_to WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.606", "db_id": "store_1", "question": "What are the first and last names of all the employees and how many people report to them?", "rationale": ["The query identifies the relevant table, which is 'employees', and uses a self-join to relate employees to their managers.", "Selects the first and last names of the managers (T2) and counts the number of employees (T1) reporting to each manager.", "Groups the results by the manager's identifier to aggregate the count of reports.", "Orders the results by the count of reports in descending order to show the most reported managers first.", "Limits the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T2.first_name , T2.last_name ,  count(T1.reports_to) FROM employees AS T1 JOIN employees AS T2 ON T1.reports_to = T2.id GROUP BY T1.reports_to ORDER BY count(T1.reports_to) DESC LIMIT 1;", "source_tables": ["employees"], "description": "This virtual table provides a summary of employees and their managers from the 'employees' table. It lists the first and last names of managers along with the count of employees reporting to each manager. The results are grouped by the manager's identifier and ordered by the number of reports in descending order, with a limit on the number of results specified by a placeholder for numeric values.", "virtual_table": "SELECT T2.first_name , T2.last_name ,  count(T1.reports_to) FROM employees AS T1 JOIN employees AS T2 ON T1.reports_to = T2.id GROUP BY T1.reports_to ORDER BY count(T1.reports_to) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.587", "db_id": "store_1", "question": "What is the title, phone and hire date of Nancy Edwards?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'title', 'phone', and 'hire_date'.", "Add conditions to filter the 'first_name' and 'last_name' columns for the specified employee using placeholders for string values."], "gold_sql": "SELECT title ,  phone ,  hire_date FROM employees WHERE first_name = 'Nancy' AND last_name = 'Edwards';", "source_tables": ["employees"], "description": "This virtual table describes the titles, phone numbers, and hire dates of employees from the 'employees' table who have a specific first and last name. The placeholders in the WHERE clause represent the first and last names of the employee.", "virtual_table": "SELECT title ,  phone ,  hire_date FROM employees WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.592", "db_id": "store_1", "question": "What is Nancy Edwards's address?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the column to display, 'address'.", "Add conditions to filter the 'first_name' and 'last_name' columns for the specified employee using placeholders for string values."], "gold_sql": "SELECT address FROM employees WHERE first_name = 'Nancy' AND last_name = 'Edwards';", "source_tables": ["employees"], "description": "This virtual table provides the addresses of employees from the 'employees' table based on their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the employees being queried.", "virtual_table": "SELECT address FROM employees WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.568", "db_id": "store_1", "question": "What is the number of invoices and total money billed in them from CA?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' column, counts the number of invoices, and sums the total amount for those invoices.", "A condition is added to filter the results based on the specified 'billing_state' using a placeholder for string values."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "description": "This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.", "virtual_table": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.81", "db_id": "student_assessment", "question": "How many registed students do each course have? List course name and the number of their registered students?", "rationale": ["The query identifies the relevant tables: 'Students', 'Student_Course_Registrations', and 'Courses'.", "It selects the 'course_name' from the 'Courses' table and counts the number of registrations.", "The join between 'Students' and 'Student_Course_Registrations' links students to their course registrations.", "The join between 'Student_Course_Registrations' and 'Courses' retrieves the course names associated with each registration.", "The results are grouped by 'course_id' to aggregate the count of students for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "description": "This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.", "virtual_table": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["The query identifies the relevant tables: 'Addresses', 'People_Addresses', and 'Students'.", "It selects distinct cities from the 'Addresses' table to ensure no duplicates are included.", "The join conditions link the 'Addresses' table to the 'People_Addresses' table using the address_id, and then link the 'People_Addresses' table to the 'Students' table using the person_id, allowing us to filter the addresses specifically for students."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "description": "This virtual table provides a list of unique cities where students are located, by joining the 'Addresses', 'People_Addresses', and 'Students' tables. The placeholders in the query represent the necessary identifiers for the relationships between these tables.", "virtual_table": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id"}
{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Course_Registrations'.", "It selects the 'course_name' from the 'Courses' table.", "A JOIN operation is performed to link courses with their registrations based on the course ID.", "The results are grouped by 'course_id' to aggregate the data for each course.", "The results are ordered by the count of registrations in descending order to highlight the most popular courses.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "description": "This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.", "virtual_table": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.103", "db_id": "student_assessment", "question": "What are all info of students who registered courses but not attended courses?", "rationale": ["The query identifies the relevant table, which is 'student_course_registrations'.", "It selects all columns from this table.", "A subquery is used to filter out students who have attended any courses by checking the 'student_id' in the 'student_course_attendance' table, ensuring only those who have not attended are included."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "description": "This virtual table provides a list of all course registrations made by students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.", "virtual_table": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["The query identifies the relevant table, which is 'student_course_registrations'.", "It selects all columns from this table.", "A subquery is used to filter out students who have attended any courses by checking the 'student_id' in the 'student_course_attendance' table, ensuring only those who have not attended are included."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "description": "This virtual table provides a list of all course registrations made by students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.", "virtual_table": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)"}
{"sample_id": "train.77", "db_id": "student_assessment", "question": "What is detail of the student who registered the most number of courses?", "rationale": ["The query identifies the relevant tables, 'Students' and 'Student_Course_Registrations'.", "It selects the 'student_details' column from the 'Students' table.", "A JOIN operation is performed to link students with their course registrations based on the 'student_id'.", "The results are grouped by 'student_id' to avoid duplicates and to count the number of registrations per student.", "The results are ordered by the count of registrations in descending order to prioritize students with the most registrations.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.", "virtual_table": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.67", "db_id": "student_assessment", "question": "What is detail of the student who most recently registered course?", "rationale": ["The query identifies the relevant tables, 'Student_Course_Registrations' and 'Students'.", "It selects the 'student_details' column from the 'Students' table.", "A JOIN operation is performed to link the 'Student_Course_Registrations' table with the 'Students' table using the 'student_id'.", "The results are ordered by 'registration_date' in descending order to show the most recent registrations first.", "A placeholder is included to limit the number of results returned."], "gold_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.", "virtual_table": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.59", "db_id": "student_assessment", "question": "What are the ids of the students who registered for some courses but had the least number of courses for all students?", "rationale": ["The query identifies the relevant table, which is 'Student_Course_Registrations'.", "It selects the 'student_id' column to display unique student identifiers.", "The results are grouped by 'student_id' to ensure each student appears only once in the output.", "The results are ordered by the count of registrations for each student to prioritize those with more courses registered.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT 1", "source_tables": ["student_course_registrations"], "description": "This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.", "virtual_table": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["The query is identifying the relevant table, which is 'Student_Course_Attendance'.", "Select the column to display, 'student_id'.", "This column represents the unique identifier for each student who has attended a course."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "description": "This virtual table describes the identifiers of students who have attended courses from the 'Student_Course_Attendance' table. The placeholder in the SELECT clause represents the unique identifier for each student.", "virtual_table": "SELECT student_id FROM student_course_attendance"}
{"sample_id": "train.90", "db_id": "student_assessment", "question": "What are the ids of the students who registered for course 301 most recently?", "rationale": ["The query identifies the relevant table, which is 'Student_Course_Attendance'.", "It selects the 'student_id' column to display the identifiers of students who attended a specific course.", "A condition is added to filter the results based on the 'course_id' using a placeholder for numeric values.", "The results are ordered by 'date_of_attendance' in descending order to show the most recent attendance first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "description": "This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.58", "db_id": "student_assessment", "question": "what is id of students who registered some courses but the least number of courses in these students?", "rationale": ["The query identifies the relevant table, which is 'Student_Course_Registrations'.", "It selects the 'student_id' column to display unique student identifiers.", "The results are grouped by 'student_id' to ensure each student appears only once in the output.", "The results are ordered by the count of registrations for each student to show the most active students first.", "A limit is applied to the number of results returned, which can be specified using a placeholder for numeric values."], "gold_sql": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT 1", "source_tables": ["student_course_registrations"], "description": "This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.", "virtual_table": "SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.536", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?", "rationale": ["The query identifies the relevant tables: 'Students', 'Student_Enrolment', and 'Degree_Programs'.", "It selects distinct names (first, middle, last) from the 'Students' table.", "The JOIN operations link students to their enrolment records and the corresponding degree programs.", "A condition is added to filter the results based on the specified degree program name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "description": "This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.549", "db_id": "student_transcripts_tracking", "question": "Find the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.", "rationale": ["The query identifies the relevant tables, 'Students' and 'Addresses', to retrieve the last names of students.", "It joins the 'Students' table with the 'Addresses' table on the current address ID to filter students based on their current state.", "The WHERE clause specifies the condition for the state using a placeholder for string values.", "The EXCEPT clause is used to exclude students who are enrolled in any degree program by joining the 'Students' table with the 'Student_Enrolment' table."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "description": "This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.", "virtual_table": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id"}
{"sample_id": "dev.576", "db_id": "student_transcripts_tracking", "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?", "rationale": ["The query starts by selecting distinct semester IDs from the 'Student_Enrolment' table, which is joined with the 'Degree_Programs' table to filter by the degree program.", "The first part of the query filters the degree program by its name using a placeholder for string values.", "The INTERSECT operator is used to find common semester IDs from another similar query, ensuring that the semesters returned are those where students are enrolled in the specified degree program."], "gold_sql": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs"], "description": "This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. It uses an intersection of two queries to ensure that the semesters returned are common to two instances of the same degree program, represented by a placeholder for the degree program's name.", "virtual_table": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.584", "db_id": "student_transcripts_tracking", "question": "What are the first names of the students who live in Haiti permanently or have the cell phone number 09700166582 ?", "rationale": ["The query identifies the relevant tables, which are 'Students' and 'Addresses'.", "It selects the 'first_name' column from the 'Students' table.", "A JOIN operation is performed between 'Students' and 'Addresses' on the 'permanent_address_id' and 'address_id' columns to link students with their permanent addresses.", "The WHERE clause includes conditions to filter students based on the specified country from the 'Addresses' table or their mobile phone number from the 'Students' table, using placeholders for both string values."], "gold_sql": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'", "source_tables": ["addresses", "students"], "description": "This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.", "virtual_table": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.537", "db_id": "student_transcripts_tracking", "question": "Find the kind of program which most number of students are enrolled in?", "rationale": ["The query identifies the relevant tables, 'Degree_Programs' and 'Student_Enrolment'.", "It selects the 'degree_summary_name' from the 'Degree_Programs' table.", "A JOIN operation is performed to link 'Degree_Programs' with 'Student_Enrolment' based on the 'degree_program_id'.", "The results are grouped by 'degree_summary_name' to aggregate enrolment counts.", "The results are ordered by the count of enrolments in descending order to highlight the most popular programs.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "description": "This virtual table provides a list of degree program names from the 'Degree_Programs' table, which are associated with student enrolments. The results are grouped by the degree program name and ordered by the number of enrolments in descending order, allowing users to see the most popular degree programs. The placeholder in the LIMIT clause represents the maximum number of degree programs to return.", "virtual_table": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.542", "db_id": "student_transcripts_tracking", "question": "What is the first, middle, and last name, along with the id and number of enrollments, for the student who enrolled the most in any program?", "rationale": ["The query identifies the relevant table, which is 'Students', and uses an alias 'T1' for clarity.", "It selects the 'student_id', 'first_name', 'middle_name', and 'last_name' from the 'Students' table.", "It counts the number of courses each student is enrolled in by joining the 'Student_Enrolment' table (aliased as 'T2') on the 'student_id'.", "The results are grouped by 'student_id' to aggregate the count of courses for each student.", "The results are ordered by the count of courses in descending order to show the most enrolled students first.", "The LIMIT clause uses a placeholder to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "description": "This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.", "virtual_table": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.533", "db_id": "student_transcripts_tracking", "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.", "rationale": ["The query identifies the relevant tables, 'Students' and 'Student_Enrolment'.", "It selects the columns to display: 'first_name', 'middle_name', 'last_name', and 'student_id' from the 'Students' table.", "The JOIN operation is used to link 'Students' with 'Student_Enrolment' based on the 'student_id'.", "The GROUP BY clause is applied to group the results by 'student_id'.", "The HAVING clause filters the results to include only those students who are enrolled in a specific number of courses, represented by a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "description": "This virtual table provides the first name, middle name, last name, and student ID of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.", "virtual_table": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.575", "db_id": "student_transcripts_tracking", "question": "Find the semester when both Master students and Bachelor students got enrolled in.", "rationale": ["The query is identifying the relevant tables, which are 'Degree_Programs' and 'Student_Enrolment'.", "It selects distinct semester IDs from the 'Student_Enrolment' table joined with 'Degree_Programs' based on the degree program ID.", "The WHERE clause filters the results based on the degree program's name using a placeholder for string values.", "The INTERSECT operator is used to find common semester IDs from two identical queries, ensuring that the semesters returned are those where students are enrolled in the specified degree program."], "gold_sql": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs"], "description": "This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. It uses an intersection of two queries to ensure that the semesters returned are common to two instances of the same degree program, represented by a placeholder for the degree program's name.", "virtual_table": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.583", "db_id": "student_transcripts_tracking", "question": "Find the first name of the students who permanently live in the country Haiti or have the cell phone number 09700166582 .", "rationale": ["The query identifies the relevant tables, which are 'Students' and 'Addresses'.", "It selects the 'first_name' column from the 'Students' table.", "A JOIN operation is performed between 'Students' and 'Addresses' on the 'permanent_address_id' and 'address_id' columns to link students with their permanent addresses.", "The WHERE clause includes conditions to filter students based on the specified country from the 'Addresses' table or their mobile number from the 'Students' table, using placeholders for string values."], "gold_sql": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582'", "source_tables": ["addresses", "students"], "description": "This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile number.", "virtual_table": "select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.572", "db_id": "student_transcripts_tracking", "question": "What is the maximum number of times that a course shows up in different transcripts and what is that course's enrollment id?", "rationale": ["The query identifies the relevant table, which is 'Transcript_Contents'.", "It selects the count of occurrences and the 'student_course_id' to show how many times each course is recorded.", "The results are grouped by 'student_course_id' to aggregate the counts for each course.", "The results are ordered by the count in descending order to prioritize the most frequent courses.", "A placeholder is used in the LIMIT clause to specify the maximum number of results to return."], "gold_sql": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["transcript_contents"], "description": "This virtual table provides a count of how many times each student course appears in the 'Transcript_Contents' table, grouped by the course identifier. The results are ordered by the count in descending order, allowing users to see the most frequently recorded courses. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.580", "db_id": "student_transcripts_tracking", "question": "What other details can you tell me about students in reverse alphabetical order?", "rationale": ["The query identifies the relevant table, which is 'Students'.", "Selects the column 'other_student_details' to display additional information about students.", "Orders the results in descending order based on the 'other_student_details' column."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "description": "This virtual table provides a list of additional details related to students from the 'Students' table, sorted in descending order. The placeholder in the ORDER BY clause represents the specific details to be sorted.", "virtual_table": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC"}
{"sample_id": "dev.579", "db_id": "student_transcripts_tracking", "question": "List all the student details in reversed lexicographical order.", "rationale": ["The query identifies the relevant table, which is 'Students'.", "Selects the column 'other_student_details' to display additional information about students.", "Orders the results in descending order based on the 'other_student_details' column."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "description": "This virtual table provides a list of additional details related to students from the 'Students' table, sorted in descending order. The placeholder in the ORDER BY clause represents the specific details to be sorted.", "virtual_table": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC"}
{"sample_id": "train.4325", "db_id": "tracking_grants_for_research", "question": "What is the total amount of grant money for research?", "rationale": ["The query identifies the relevant tables: 'Grants', 'Organisations', and 'Organisation_Types'.", "It selects the sum of the 'grant_amount' from the 'Grants' table.", "Joins are made between 'Grants' and 'Organisations' on 'organisation_id', and between 'Organisations' and 'Organisation_Types' on 'organisation_type'.", "A condition is added to filter the results based on the 'organisation_type_description' using a placeholder for string values."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "description": "This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter based on the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.", "virtual_table": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4335", "db_id": "tracking_grants_for_research", "question": "What are the send dates for all documents that have a grant amount of more than 5000 and are involved in research?", "rationale": ["The query identifies the relevant tables: 'Documents', 'Grants', 'Organisations', and 'Organisation_Types'.", "It selects the 'sent_date' from the 'Documents' table.", "Joins are established between 'Documents' and 'Grants' on 'grant_id', then between 'Grants' and 'Organisations' on 'organisation_id', and finally between 'Organisations' and 'Organisation_Types' on 'organisation_type'.", "A condition is added to filter grants based on the specified grant amount using a placeholder for numeric values.", "Another condition is added to filter organisations based on their type description using a placeholder for string values."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "description": "This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.", "virtual_table": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER] AND T4.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4349", "db_id": "tracking_grants_for_research", "question": "What are the details for the project whose research has been published?", "rationale": ["The query identifies the relevant tables: 'Projects', 'Project_Outcomes', and 'Research_Outcomes'.", "It selects the 'project_details' column from the 'Projects' table.", "The query uses JOIN operations to connect 'Projects' with 'Project_Outcomes' on 'project_id' and 'Project_Outcomes' with 'Research_Outcomes' on 'outcome_code'.", "A condition is added to filter the results based on the 'outcome_description' using a placeholder for string values."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE '%Published%'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "description": "This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.", "virtual_table": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4367", "db_id": "tracking_grants_for_research", "question": "For grants that have descriptions of Regular and Initial Applications, what are their start dates?", "rationale": ["The query identifies the relevant tables: 'Grants', 'Documents', and 'Document_Types'.", "It selects the 'grant_start_date' from the 'Grants' table.", "Joins are used to connect 'Grants' with 'Documents' and 'Document_Types' based on their foreign key relationships.", "The WHERE clause filters results based on the 'document_description' from the 'Document_Types' table using a placeholder for string values.", "The INTERSECT operation is used to find common 'grant_start_date' values from two identical queries, ensuring that only those dates that appear in both sets are returned."], "gold_sql": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Regular' INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Initial Application'", "source_tables": ["grants", "document_types", "documents"], "description": "This virtual table retrieves the start dates of grants from the 'Grants' table that are associated with documents of a specific type. It uses joins to connect the 'Grants', 'Documents', and 'Document_Types' tables based on their foreign key relationships. The placeholder in the WHERE clause represents the description of the document type, allowing users to specify which document type they are interested in. The INTERSECT operation ensures that only the start dates of grants that meet the criteria in both queries are returned.", "virtual_table": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4337", "db_id": "tracking_grants_for_research", "question": "What is the response received date for the document described as Regular that was granted more than 100 dollars?", "rationale": ["The query identifies the relevant tables: 'Documents', 'Document_Types', and 'Grants'.", "It selects the 'response_received_date' from the 'Documents' table.", "The JOIN operations link 'Documents' with 'Document_Types' and 'Grants' based on their respective foreign keys.", "The WHERE clause includes conditions to filter results based on a specific document description and a minimum grant amount, using placeholders for user-defined values."], "gold_sql": "SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  'Regular' OR T3.grant_amount  >  100", "source_tables": ["grants", "document_types", "documents"], "description": "This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.", "virtual_table": "SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4328", "db_id": "tracking_grants_for_research", "question": "Find the organisation ids and details of the organisations which are involved in", "rationale": ["The query identifies the relevant tables, 'Grants' and 'Organisations'.", "It selects the columns 'organisation_id' and 'organisation_details' from the 'Organisations' table.", "A JOIN operation is performed to link 'Grants' and 'Organisations' based on the 'organisation_id'.", "The results are grouped by 'organisation_id' to aggregate the grant amounts.", "The HAVING clause filters the results to include only those organisations with a total grant amount greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  6000", "source_tables": ["grants", "organisations"], "description": "This virtual table provides a list of organisation IDs and their corresponding details from the 'Organisations' table, which are associated with grants from the 'Grants' table. The results are grouped by organisation ID, and only those organisations that have a total grant amount exceeding a specified threshold are included, as indicated by the placeholder in the HAVING clause.", "virtual_table": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4361", "db_id": "tracking_grants_for_research", "question": "What are the ids, types, and details of the organization with the most research staff?", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the columns 'organisation_id', 'organisation_type', and 'organisation_details' from the 'Organisations' table.", "A JOIN operation is performed between 'Organisations' and 'Research_Staff' on the condition that the organisation ID matches the employer organisation ID.", "The results are grouped by 'organisation_id' to aggregate the data for each organisation.", "The results are ordered by the count of research staff in descending order to prioritize organisations with more staff.", "A LIMIT clause is included to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.", "virtual_table": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4333", "db_id": "tracking_grants_for_research", "question": "What is the type of the organization with the most research staff?", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff', and establishes a join condition based on the organisation ID.", "It selects the 'organisation_type' from the 'Organisations' table.", "The results are grouped by 'organisation_type' to aggregate the data accordingly.", "The results are ordered by the count of research staff in each organisation type in descending order.", "A placeholder is included in the LIMIT clause to allow the user to specify how many organisation types to return."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.", "virtual_table": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4394", "db_id": "tracking_grants_for_research", "question": "What are the descriptions of all the project outcomes?", "rationale": ["The query identifies the relevant tables, which are 'Research_Outcomes' and 'Project_Outcomes'.", "It selects the 'outcome_description' from the 'Research_Outcomes' table.", "A JOIN operation is performed on the 'outcome_code' to link the two tables, ensuring that only related outcomes are retrieved."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code", "source_tables": ["project_outcomes", "research_outcomes"], "description": "This virtual table describes the outcome descriptions of research outcomes associated with specific project outcomes. The join between the 'Research_Outcomes' and 'Project_Outcomes' tables is based on the matching outcome codes, allowing users to retrieve detailed descriptions of research outcomes linked to projects.", "virtual_table": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code"}
{"sample_id": "train.4331", "db_id": "tracking_grants_for_research", "question": "What is the type and id of the organization that has the most research staff?", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the 'organisation_type' and 'organisation_id' from the 'Organisations' table.", "A JOIN operation is performed to connect 'Organisations' with 'Research_Staff' based on the employer organisation ID.", "The results are grouped by 'organisation_id' to aggregate the data.", "The results are ordered by the count of research staff in descending order to prioritize organisations with more staff.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.", "virtual_table": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4372", "db_id": "tracking_grants_for_research", "question": "What are all the details of the organisations described as 'Sponsor'? Sort the result in an ascending order.", "rationale": ["The query identifies the relevant tables, which are 'Organisations' and 'Organisation_Types'.", "It selects the 'organisation_details' column from the 'Organisations' table.", "A JOIN operation is performed to connect 'Organisations' with 'Organisation_Types' based on the organisation type.", "A condition is added to filter the results based on the organisation type description using a placeholder for string values.", "The results are ordered by 'organisation_details' to present them in a sorted manner."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "description": "This virtual table provides the details of organisations from the 'Organisations' table that are associated with a specific type of organisation. It joins the 'Organisations' table with the 'Organisation_Types' table to filter organisations based on their type description. The placeholder in the WHERE clause represents the description of the organisation type, and the results are ordered by the organisation details.", "virtual_table": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING] ORDER BY organisation_details"}
{"sample_id": "train.4383", "db_id": "tracking_grants_for_research", "question": "What is the id of the organization with the maximum number of outcomes and how many outcomes are there?", "rationale": ["The query identifies the relevant tables, 'Projects' and 'Project_Outcomes'.", "It selects the 'organisation_id' from the 'Projects' table and counts the number of associated project outcomes from the 'Project_Outcomes' table.", "A JOIN operation is performed on the 'project_id' to link projects with their outcomes.", "The results are grouped by 'organisation_id' to aggregate the counts for each organisation.", "The results are ordered in descending order based on the count of project outcomes, and a LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.", "virtual_table": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4373", "db_id": "tracking_grants_for_research", "question": "What are the details of all organizations that are described as Sponsors and sort the results in ascending order?", "rationale": ["The query identifies the relevant tables, which are 'Organisations' and 'Organisation_Types'.", "It selects the 'organisation_details' column from the 'Organisations' table.", "A JOIN operation is performed to connect 'Organisations' with 'Organisation_Types' based on the organisation type.", "A condition is added to filter the results based on the 'organisation_type_description' using a placeholder for string values.", "The results are ordered by 'organisation_details' to provide a structured output."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "description": "This virtual table provides the details of organisations that are associated with a specific type of organisation. It retrieves the organisation details from the 'Organisations' table and joins it with the 'Organisation_Types' table to filter based on the organisation type description. The placeholder in the WHERE clause represents the specific type of organisation being queried.", "virtual_table": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING] ORDER BY organisation_details"}
{"sample_id": "train.4332", "db_id": "tracking_grants_for_research", "question": "Which organisation type hires most research staff?", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the 'organisation_type' from the 'Organisations' table.", "A JOIN operation is performed to link 'Organisations' with 'Research_Staff' based on the organisation ID.", "The results are grouped by 'organisation_type' to aggregate the data accordingly.", "The results are ordered by the count of research staff in each organisation type in descending order.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.", "virtual_table": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4357", "db_id": "tracking_grants_for_research", "question": "What are the details and id of the project with the most outcomes?", "rationale": ["The query identifies the relevant tables, 'Projects' and 'Project_Outcomes'.", "It selects the 'project_details' and 'project_id' from the 'Projects' table.", "A JOIN operation is performed between 'Projects' and 'Project_Outcomes' on the 'project_id' to link projects with their outcomes.", "The results are grouped by 'project_id' to aggregate the outcomes for each project.", "The results are ordered by the count of outcomes in descending order to prioritize projects with more outcomes.", "A LIMIT clause is included to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.", "virtual_table": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4323", "db_id": "tracking_grants_for_research", "question": "What are the details of the project that is producing both patents and papers as outcomes?", "rationale": ["The query identifies the relevant table, which is 'Projects', and aliases it as T1.", "It joins the 'Project_Outcomes' table, aliased as T2, on the project_id to link projects with their outcomes.", "The WHERE clause filters the results based on the first outcome_code using a placeholder for string values.", "The INTERSECT operation is used to find projects that also meet a second outcome_code condition, again using a placeholder for string values."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.", "virtual_table": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4326", "db_id": "tracking_grants_for_research", "question": "List from which date and to which date these staff work: project staff of the project which hires the most staffs", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects the columns 'date_from' and 'date_to' to display the involvement dates of staff members.", "The first part of the query filters projects based on the count of staff members, using a subquery to get the top N projects.", "The second part of the query filters staff members by a specific role code, using a placeholder for string values."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "description": "This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4353", "db_id": "tracking_grants_for_research", "question": "What is the complete description of the job of a researcher?", "rationale": ["The query identifies the relevant table, which is 'Staff_Roles'.", "Select the column to display, 'role_description'.", "Add a condition to filter the 'role_code' column for the specified role code using a placeholder for string values."], "gold_sql": "SELECT role_description FROM Staff_Roles WHERE role_code  =  'researcher'", "source_tables": ["staff_roles"], "description": "This virtual table describes the role descriptions of staff members from the 'Staff_Roles' table based on a specific role code. The placeholder in the WHERE clause represents the role code being queried.", "virtual_table": "SELECT role_description FROM Staff_Roles WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4343", "db_id": "tracking_grants_for_research", "question": "When did researchers start and stop working?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "Select the columns to display, 'date_from' and 'date_to', which represent the involvement period of staff members.", "Add a condition to filter the 'role_code' column for the specified role using a placeholder for string values."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "description": "This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4384", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects launched by the organisation", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "It selects the 'project_details' column to display information about the projects.", "The WHERE clause filters the results to include only those organisations that have the highest number of projects, using a subquery that groups by 'organisation_id' and orders by the count of projects in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many top organisations to include in the results."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "description": "This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.", "virtual_table": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.4393", "db_id": "tracking_grants_for_research", "question": "What roles did staff members play between '2003-04-19 15:06:20' and '2016-03-15 00:33:18'?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "Select the column to display, 'role_code'.", "Add conditions to filter the 'date_from' and 'date_to' columns for the specified date range using placeholders for string values."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "description": "This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.", "virtual_table": "SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4396", "db_id": "tracking_grants_for_research", "question": "Which role is most common for the staff?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects the 'role_code' column to display unique role codes.", "The results are grouped by 'role_code' to aggregate the data based on the role.", "The results are ordered by the count of occurrences of each role code in descending order to show the most common roles first.", "A placeholder is included in the LIMIT clause to allow the user to specify how many role codes they want to retrieve."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "description": "This virtual table provides a list of unique role codes from the 'Project_Staff' table, grouped by the role code and ordered by the number of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of role codes to retrieve.", "virtual_table": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4377", "db_id": "tracking_grants_for_research", "question": "How many project members were leaders or started working before '1989-04-24 23:51:54'?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects a count of all records that meet the specified conditions.", "The conditions filter the records based on the 'role_code' and 'date_from' columns, using placeholders for string values."], "gold_sql": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'", "source_tables": ["project_staff"], "description": "This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which to consider staff involvement.", "virtual_table": "SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4387", "db_id": "tracking_grants_for_research", "question": "What details are there on the research staff? List the result in ascending alphabetical order.", "rationale": ["The query identifies the relevant table, which is 'Research_Staff'.", "Select the column to display, 'staff_details'.", "Add an ORDER BY clause to sort the results in ascending order based on the 'staff_details' column."], "gold_sql": "SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC", "source_tables": ["research_staff"], "description": "This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.", "virtual_table": "SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC"}
{"sample_id": "train.4386", "db_id": "tracking_grants_for_research", "question": "List the research staff details, and order in ascending order.", "rationale": ["The query identifies the relevant table, which is 'Research_Staff'.", "Select the column to display, 'staff_details'.", "Add an ORDER BY clause to sort the results in ascending order based on the 'staff_details' column."], "gold_sql": "SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC", "source_tables": ["research_staff"], "description": "This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.", "virtual_table": "SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["The query identifies the relevant tables: 'Lots', 'Transactions_Lots', and 'Transactions'.", "It selects the 'lot_details' column from the 'Lots' table.", "The JOIN operations link the 'Lots' table to the 'Transactions_Lots' table using 'lot_id' and then to the 'Transactions' table using 'transaction_id'.", "A condition is added to filter the results based on the 'share_count' column from the 'Transactions' table, using a placeholder for numeric values."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "description": "This virtual table describes the details of lots associated with transactions where the number of shares involved in the transaction is less than a specified amount. The placeholders in the WHERE clause represent the numeric value for the share count.", "virtual_table": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["The query is identifying the relevant tables, which are 'Sales' and 'Purchases'.", "It selects the 'sales_details' from the 'Sales' table and 'purchase_details' from the 'Purchases' table.", "The UNION operator is used to combine the results from both tables into a single result set, allowing for a unified view of transaction details."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "description": "This virtual table combines the details of sales and purchase transactions from the 'Sales' and 'Purchases' tables. The placeholder in the SELECT statements represents the specific details of each transaction type.", "virtual_table": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["The query identifies the relevant tables, which are 'Investors' and 'Transactions'.", "It selects the 'Investor_details' column from the 'Investors' table.", "A JOIN operation is performed to link 'Investors' and 'Transactions' based on the 'investor_id'.", "A condition is added to filter the results where the 'share_count' in the 'Transactions' table exceeds a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "description": "This virtual table provides detailed information about investors from the 'Investors' table who have conducted transactions involving a number of shares greater than a specified amount. The placeholder in the WHERE clause represents the minimum share count for filtering the results.", "virtual_table": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5851", "db_id": "tracking_share_transactions", "question": "Show all dates of transactions whose type code is \"SALE\".", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "Select the column to display, 'date_of_transaction'.", "Add a condition to filter the 'transaction_type_code' column for the specified transaction type using a placeholder for string values."], "gold_sql": "SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  'SALE'", "source_tables": ["transactions"], "description": "This virtual table provides the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code.", "virtual_table": "SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "It selects the 'transaction_type_code' to categorize the results by transaction type.", "The query uses aggregate functions 'max' and 'min' to calculate the maximum and minimum share counts for each transaction type.", "The 'GROUP BY' clause is used to group the results by 'transaction_type_code' to ensure the aggregation is performed for each type of transaction."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "description": "This virtual table summarizes the maximum and minimum share counts for each type of transaction recorded in the 'Transactions' table. The placeholder in the SELECT clause represents the transaction type code, while the aggregation functions calculate the maximum and minimum share counts for each group of transaction types.", "virtual_table": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The query identifies the relevant table, which is 'Investors'.", "Select the column to display, 'Investor_details'."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "description": "This virtual table provides detailed information about investors from the 'Investors' table. The query selects the 'Investor_details' column, which contains specific information regarding each investor.", "virtual_table": "SELECT Investor_details FROM INVESTORS"}
{"sample_id": "dev.785", "db_id": "world_1", "question": "What are the names of cities in Europe for which English is not the official language?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'city'.", "It selects distinct city names from the 'city' table.", "A JOIN operation is performed between 'country' and 'city' based on the country code to filter cities by continent.", "A subquery is used to exclude cities from countries where a specified language is official, using placeholders for the continent and language."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "description": "This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.", "virtual_table": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.784", "db_id": "world_1", "question": "Which cities are in European countries where English is not the official language?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'city'.", "It selects distinct city names from the 'city' table.", "A join is performed between 'city' and 'country' on the country code to filter cities based on the continent.", "An additional condition is added to exclude cities from countries where a specified language is official, using a subquery that checks the 'countrylanguage' table for the official status of the language."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "description": "This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.", "virtual_table": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.743", "db_id": "world_1", "question": "Which continent speaks the most languages?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It selects the 'Continent' column from the 'country' table.", "A JOIN operation is performed between 'country' and 'countrylanguage' on the 'CountryCode' to associate countries with their languages.", "The results are grouped by 'Continent' to aggregate the count of countries per continent.", "The ORDER BY clause sorts the continents based on the count of countries in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many continents to return."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a list of continents along with the count of countries that speak languages from those continents. The placeholder in the LIMIT clause allows the user to specify the maximum number of continents to retrieve based on the number of countries speaking languages from each continent.", "virtual_table": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.742", "db_id": "world_1", "question": "Which continent has the most diverse languages?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It selects the 'Continent' column from the 'country' table.", "A JOIN operation is performed between 'country' and 'countrylanguage' on the 'CountryCode' to associate languages with their respective countries.", "The results are grouped by 'Continent' to aggregate the count of countries per continent.", "The results are ordered in descending order based on the count of countries, and a limit is applied to restrict the number of continents returned using a placeholder for numeric values."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a list of continents along with the count of countries that speak languages from those continents. The placeholder in the LIMIT clause allows the user to specify the maximum number of continents to retrieve based on the number of countries associated with each continent.", "virtual_table": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.746", "db_id": "world_1", "question": "What are the names of nations speak both English and French?", "rationale": ["The query is identifying the relevant tables, which are 'country' and 'countrylanguage'.", "It selects the 'Name' column from the 'country' table.", "The JOIN operation is used to connect 'country' and 'countrylanguage' based on the country code.", "The WHERE clause filters the results to include only those countries where the specified languages are spoken.", "The INTERSECT operator is used to find countries that meet both language criteria."], "gold_sql": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'French'", "source_tables": ["country", "countrylanguage"], "description": "This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.", "virtual_table": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.783", "db_id": "world_1", "question": "Return the codes of countries that do not speak English and do not have Republics for governments.", "rationale": ["The query is identifying the relevant table, which is 'country'.", "Select the 'Code' column to display the unique country codes.", "Add a condition to filter the 'GovernmentForm' column for the specified government form using a placeholder for string values.", "Use the EXCEPT clause to exclude countries that have a specific language as an official language, using a placeholder for the language."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "description": "This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.", "virtual_table": "SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.713", "db_id": "world_1", "question": "What language is predominantly spoken in Aruba?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It selects the 'Language' column from the 'countrylanguage' table.", "A JOIN operation is performed on the 'country' table to link it with the 'countrylanguage' table using the country code.", "A condition is added to filter the results based on the specified country's name using a placeholder for string values.", "The results are ordered by the 'Percentage' column in descending order to show the most spoken languages first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  'Aruba' ORDER BY Percentage DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.", "virtual_table": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY Percentage DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.782", "db_id": "world_1", "question": "What are the codes of the countries that do not speak English and whose government forms are not Republic?", "rationale": ["The query is identifying the relevant table, which is 'country'.", "Select the 'Code' column from the 'country' table where the 'GovernmentForm' is not equal to a specified value using a placeholder for string values.", "Use the EXCEPT clause to exclude countries that have a specific language as an official language by selecting 'CountryCode' from the 'countrylanguage' table where 'Language' matches a specified value using a placeholder for string values."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "description": "This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.", "virtual_table": "SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.745", "db_id": "world_1", "question": "What is the number of nations that use English and Dutch?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It uses a JOIN operation to connect the 'country' table with the 'countrylanguage' table based on the country code.", "The INTERSECT operation is used to find countries that have both specified languages spoken.", "The COUNT function is applied to count the number of countries that meet the criteria."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch')", "source_tables": ["country", "countrylanguage"], "description": "This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.", "virtual_table": "SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.767", "db_id": "world_1", "question": "How many people live in countries that do not speak English?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It uses the SUM function to calculate the total population of the countries.", "A subquery is included to filter out countries that have the specified language as an official language.", "The placeholder in the subquery represents the language name that is being checked against the countries."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "description": "This virtual table calculates the total population of countries that do not have a specific language as an official language. The placeholder in the subquery represents the language name that is being checked against the countries.", "virtual_table": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.772", "db_id": "world_1", "question": "What are the countries that have greater surface area than any country in Europe?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the 'Name' column to display the names of the countries.", "A subquery is used to find the minimum surface area of countries filtered by the specified continent using a placeholder for string values."], "gold_sql": "SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  'Europe')", "source_tables": ["country"], "description": "This virtual table describes the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.", "virtual_table": "SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.788", "db_id": "world_1", "question": "What are the name, independence year, and surface area of the country with the smallest population?", "rationale": ["The query identifies the relevant table, which is 'country'.", "Select the columns to display: 'Name', 'SurfaceArea', and 'IndepYear'.", "Order the results by the 'Population' column to sort countries based on their population size.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "description": "This virtual table provides a list of countries, displaying their names, surface areas, and the year they gained independence. The results are ordered by the population of the countries, and the number of entries returned is limited by a specified placeholder for numeric values.", "virtual_table": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.819", "db_id": "world_1", "question": "Count the number of countries for which Spanish is the predominantly spoken language.", "rationale": ["The query identifies the relevant table, which is 'countrylanguage'.", "It selects the count of countries and the maximum percentage of speakers for the specified language.", "The WHERE clause filters the results based on the specified language using a placeholder for string values.", "The results are grouped by 'CountryCode' to provide distinct counts and maximum percentages for each country."], "gold_sql": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "description": "This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.", "virtual_table": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode"}
{"sample_id": "dev.730", "db_id": "world_1", "question": "What is the average GNP and total population in all nations whose government is US territory?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the average GNP and the sum of the population columns to display.", "A condition is added to filter the results based on the 'GovernmentForm' column for the specified government type using a placeholder for string values."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "description": "This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.", "virtual_table": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.779", "db_id": "world_1", "question": "Return the country codes for countries that do not speak English.", "rationale": ["The query is identifying the relevant table, which is 'countrylanguage'.", "It selects the 'CountryCode' from the 'countrylanguage' table.", "The EXCEPT clause is used to exclude country codes where the specified language is an official language, using a placeholder for the language name."], "gold_sql": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["countrylanguage"], "description": "This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.", "virtual_table": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.811", "db_id": "world_1", "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the sum of the 'population' and the average of the 'surfacearea' columns to provide the required metrics.", "Conditions are added to filter the results based on the specified continent and a minimum surface area using placeholders for string and numeric values."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "description": "This virtual table calculates the total population and the average surface area of countries from the 'country' table that are located in a specific continent and have a surface area greater than a specified value. The placeholders in the WHERE clause represent the continent's name and the minimum surface area.", "virtual_table": "select sum(population) ,  avg(surfacearea) from country where continent  =  [PLACEHOLDER-TYPE:STRING] and surfacearea  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.799", "db_id": "world_1", "question": "What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy less than 72?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the sum of the 'Population' and the average of 'LifeExpectancy' along with the 'Continent' column.", "The results are grouped by 'Continent' to aggregate the data accordingly.", "A condition is added to filter the results where the average life expectancy is less than a specified number using a placeholder for numeric values."], "gold_sql": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  72", "source_tables": ["country"], "description": "This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.", "virtual_table": "SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.773", "db_id": "world_1", "question": "Which countries have greater area than that of any country in Europe?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the 'Name' column to display the names of the countries.", "The condition filters countries based on their 'SurfaceArea' being greater than a value obtained from a subquery.", "The subquery retrieves the minimum 'SurfaceArea' from the 'country' table where the 'Continent' matches the specified continent using a placeholder for string values."], "gold_sql": "SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  'Europe')", "source_tables": ["country"], "description": "This virtual table describes the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.", "virtual_table": "SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.801", "db_id": "world_1", "question": "Return the names and surface areas of the 5 largest countries.", "rationale": ["The query identifies the relevant table, which is 'country'.", "Select the columns to display, 'Name' and 'SurfaceArea'.", "Order the results by 'SurfaceArea' in descending order to show the largest countries first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5", "source_tables": ["country"], "description": "This virtual table provides a list of country names along with their surface areas, sorted in descending order by surface area. The placeholder in the LIMIT clause allows the user to specify the number of countries to retrieve.", "virtual_table": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.796", "db_id": "world_1", "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the sum of the 'Population' column and the 'GovernmentForm' column.", "The results are grouped by 'GovernmentForm' to aggregate the population data accordingly.", "A condition is added to filter the results using the HAVING clause, which checks if the average 'LifeExpectancy' is greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "description": "This virtual table summarizes the total population of countries grouped by their government form, filtering for those government forms where the average life expectancy exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average life expectancy value.", "virtual_table": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.704", "db_id": "world_1", "question": "How many countries have a republic as their form of government?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects a count of all entries in the table.", "A condition is added to filter the results based on the 'GovernmentForm' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "description": "This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.", "virtual_table": "SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.734", "db_id": "world_1", "question": "How many type of governments are in Africa?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the count of distinct values in the 'GovernmentForm' column.", "A condition is added to filter the results based on the 'Continent' column using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "description": "This virtual table provides the count of distinct government forms present in countries located within a specific continent. The placeholder in the WHERE clause represents the continent's name.", "virtual_table": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.810", "db_id": "world_1", "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the sum of the 'population' and the average of the 'surfacearea' columns to provide aggregate data.", "A condition is added to filter the results based on the specified continent and a minimum surface area using placeholders for string and numeric values."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "description": "This virtual table provides the total population and average surface area of countries located in a specific continent that have a surface area greater than a specified value. The placeholders in the WHERE clause represent the continent's name and the minimum surface area.", "virtual_table": "select sum(population) ,  avg(surfacearea) from country where continent  =  [PLACEHOLDER-TYPE:STRING] and surfacearea  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.818", "db_id": "world_1", "question": "What is the total number of countries where Spanish is spoken by the largest percentage of people?", "rationale": ["The query identifies the relevant table, which is 'countrylanguage'.", "It selects the count of countries and the maximum percentage of speakers for the specified language.", "The WHERE clause filters the results based on the specified language using a placeholder for string values.", "The results are grouped by 'CountryCode' to provide distinct counts and maximum percentages for each country."], "gold_sql": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "description": "This virtual table provides a count of the number of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.", "virtual_table": "SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode"}
