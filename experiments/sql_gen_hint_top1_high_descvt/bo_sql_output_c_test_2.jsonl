{"sample_id": "train.2612", "db_id": "inn_1", "question": "Find the name of the room with the maximum occupancy.", "rationale": ["Identify the table that contains room information, which is the 'Rooms' table.", "To find the room with the maximum occupancy, we need to select the 'roomName' from the 'Rooms' table.", "We need to determine the maximum occupancy by using a subquery that selects the maximum value from the 'maxOccupancy' column in the 'Rooms' table.", "The main query will filter the 'Rooms' table to find the room(s) where 'maxOccupancy' matches the maximum value found in the subquery."], "gold_sql": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE maxOccupancy = (SELECT MAX(maxOccupancy) FROM Rooms)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n        \"virtual_table\": \"SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room\"\n    }\n}\n"}
{"sample_id": "train.2621", "db_id": "inn_1", "question": "What is the average minimum and price of the rooms for each different decor.", "rationale": ["Identify the required information: average minimum price of rooms for each different decor.", "The average price can be calculated using the AVG() function in SQL.", "We need to group the results by the 'decor' column to get the average price for each type of decor.", "The final SQL query selects the 'decor' and the average of 'basePrice' from the 'Rooms' table, grouping by 'decor'."], "gold_sql": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;", "source_tables": ["rooms"], "pred_sql": "SELECT decor, AVG(basePrice) AS average_price FROM Rooms GROUP BY decor;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;\"\n    }\n}\n"}
{"sample_id": "train.2628", "db_id": "inn_1", "question": "List the name of rooms with king or queen bed.", "rationale": ["Identify the relevant table: The 'Rooms' table contains the information about room names and bed types.", "Determine the required columns: We need 'roomName' and 'decor' from the 'Rooms' table.", "Specify the condition: We want rooms that have either a 'king' or 'queen' bed, which means we will use the IN clause to filter the 'bedType' column.", "Order the results: The results should be ordered by 'basePrice' as specified in the hint.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "pred_sql": "SELECT roomName, decor FROM Rooms WHERE bedType IN ('king', 'queen') ORDER BY basePrice;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;\"\n    }\n}\n"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["Identify the tables involved: Rooms and Reservations.", "We need to find the room name and the count of reservations for each room.", "Join the Rooms table with the Reservations table on the RoomId to get the room names associated with each reservation.", "Use COUNT(*) to count the number of reservations for each room.", "Group the results by the Room identifier to get the count for each room specifically."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T2.roomName, COUNT(*) AS reservation_count FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room = T2.RoomId GROUP BY T1.Room", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n        \"virtual_table\": \"SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room\"\n    }\n}\n"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["Identify the table needed: The question asks for details of trucks, so we will use the 'Trucks' table.", "Select all columns: We need all details, so we will use SELECT *.", "Order by license number: The question specifies to order the results by the truck's license number, so we will add ORDER BY truck_licence_number."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "pred_sql": "SELECT * FROM Trucks ORDER BY truck_licence_number;", "hint": "\n"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["Identify the tables involved: Customers, Customer_Addresses, and Addresses.", "We need to find customer names, so we will select 'customer_name' from the Customers table.", "To filter customers based on their addresses, we will join the Customers table with the Customer_Addresses table using 'customer_id'.", "Next, we will join the Customer_Addresses table with the Addresses table using 'address_id' to access the state information.", "We need to filter out customers who live in California, so we will use a WHERE clause to exclude 'California' from the 'state_province_county' column.", "Using DISTINCT ensures that we get unique customer names in case a customer has multiple addresses."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT DISTINCT c.customer_name \nFROM Customers c \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nJOIN Addresses a ON ca.address_id = a.address_id \nWHERE a.state_province_county != 'California';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the count of customer addresses grouped by state, province, or county from the 'Customer_Addresses' and 'Addresses' tables. The placeholder in the SELECT statement represents the state, province, or county being counted.\",\n        \"virtual_table\": \"SELECT t2.state_province_county ,  count(*) FROM customer_addresses AS t1 JOIN addresses AS t2 ON t1.address_id  =  t2.address_id GROUP BY t2.state_province_county\"\n    }\n}\n"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["Identify the relevant tables: Delivery_Routes, Delivery_Route_Locations, and Order_Deliveries are needed to find the route with the highest number of deliveries.", "Join Delivery_Routes with Delivery_Route_Locations on route_id to link routes with their locations.", "Join the result with Order_Deliveries on location_code to associate deliveries with their respective routes.", "Group the results by route_name to count the number of deliveries for each route.", "Order the results in descending order based on the count of deliveries to find the route with the highest number.", "Limit the results to 1 to get only the top route."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "pred_sql": "SELECT route_name\nFROM Delivery_Routes\nJOIN Delivery_Route_Locations ON Delivery_Routes.route_id = Delivery_Route_Locations.route_id\nJOIN Order_Deliveries ON Delivery_Route_Locations.location_code = Order_Deliveries.location_code\nGROUP BY route_name\nORDER BY COUNT(Order_Deliveries.actual_order_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3175", "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["Identify the relevant tables: PROFESSOR and CLASS are needed to find professors teaching a specific class.", "Determine the relationship: The CLASS table has a foreign key (PROF_NUM) that links to the EMP_NUM in the PROFESSOR table.", "Filter the results: We need to filter the classes to only those with the CLASS_CODE 'ACCT-211'.", "Count the distinct professors: Use COUNT(DISTINCT p.EMP_NUM) to ensure we count each professor only once, even if they teach multiple sections of the same class."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) AS professor_count \nFROM PROFESSOR p \nJOIN CLASS c ON p.EMP_NUM = c.PROF_NUM \nWHERE c.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: PROFESSOR and CLASS are needed to find professors teaching a specific class.", "Determine the relationship: The CLASS table has a foreign key (PROF_NUM) that links to the EMP_NUM in the PROFESSOR table.", "Filter the results: We need to filter the classes to only those with the CLASS_CODE 'ACCT-211'.", "Count the distinct professors: Use COUNT(DISTINCT p.EMP_NUM) to ensure we count each professor only once, even if they teach multiple sections of the same class."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) \nFROM PROFESSOR p \nJOIN CLASS c ON p.EMP_NUM = c.PROF_NUM \nWHERE c.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["Identify the tables needed: EMPLOYEE for professor details and CLASS for course assignments.", "Join the EMPLOYEE table with the CLASS table on the professor's identifier (EMP_NUM).", "Filter the results to only include professors teaching the specific course 'ACCT-211'.", "Select the distinct first names and dates of birth of the professors from the joined tables."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT DISTINCT T1.EMP_FNAME, T1.EMP_DOB FROM EMPLOYEE AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM = T2.PROF_NUM WHERE T2.CRS_CODE = 'ACCT-211'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3188", "db_id": "college_1", "question": "Where is the history department?", "rationale": ["Identify the relevant table: The question asks about the history department, which relates to the DEPARTMENT table.", "Determine the necessary columns: We need the department name and department code, which are 'DEPT_NAME' and 'DEPT_CODE' in the DEPARTMENT table.", "Formulate the SQL query: We will select 'DEPT_NAME' and 'DEPT_CODE' from the DEPARTMENT table where 'DEPT_NAME' is 'History'."], "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"], "pred_sql": "SELECT dept_name, dept_code FROM department WHERE dept_name = 'History'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the table that contains the school locations, which is the DEPARTMENT table.", "Determine the relevant column for the location, which is DEPT_ADDRESS.", "Filter the results based on the SCHOOL_CODE, specifically for the code 'BUS'.", "Use DISTINCT to ensure that only unique locations are returned."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "\n"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["The question asks for the total credit offered by each department.", "To find this, we need to sum the credit hours from the COURSE table, which contains the CRS_CREDIT column.", "We will group the results by DEPT_CODE to get the total credit for each department.", "The final SQL query will select the DEPT_CODE and the sum of CRS_CREDIT, aliased as TOTAL_CREDIT."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT DEPT_CODE, SUM(CRS_CREDIT) AS TOTAL_CREDIT FROM COURSE GROUP BY DEPT_CODE", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3202", "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["The question asks for the total credits offered by each department.", "To find this, we need to sum the 'CRS_CREDIT' from the 'COURSE' table.", "We will group the results by 'DEPT_CODE' to get the total credits for each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT SUM(CRS_CREDIT) AS total_credits, DEPT_CODE FROM COURSE GROUP BY DEPT_CODE;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["Identify the relevant tables: DEPARTMENT and PROFESSOR are needed to find the number of professors per school.", "Join the DEPARTMENT table with the PROFESSOR table on the DEPT_CODE to associate professors with their respective departments.", "Group the results by SCHOOL_CODE to count the number of professors in each school.", "Use COUNT(*) to count the number of professors in each school.", "Order the results by the count of professors in ascending order to find the school with the smallest number of professors.", "Limit the results to 1 to get only the school with the smallest amount of professors."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "pred_sql": "SELECT SCHOOL_CODE, COUNT(*) AS professor_count \nFROM DEPARTMENT \nJOIN PROFESSOR ON DEPARTMENT.DEPT_CODE = PROFESSOR.DEPT_CODE \nGROUP BY SCHOOL_CODE \nORDER BY professor_count ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3215", "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["Identify the main objective: Count the number of professors with a Ph.D. degree in each department.", "Determine the relevant table: The PROFESSOR table contains information about professors, including their highest degree and department code.", "Use the provided hint to create a virtual table that counts professors grouped by department code for those with a specific degree.", "Replace the placeholder in the hint with 'Ph.D.' to filter for professors with that degree.", "Construct the final SQL query using the SELECT statement to count professors and group by department code."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "pred_sql": "SELECT count(*) , dept_code FROM professor WHERE prof_high_degree  = 'Ph.D.' GROUP BY dept_code", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["We need to find the number of students for each department, which requires us to count the students grouped by their department.", "The relevant tables for this query are DEPARTMENT and STUDENT, as we need to get department information and student counts.", "We will perform a LEFT JOIN between DEPARTMENT and STUDENT on the DEPT_CODE to ensure we include all departments even if they have no students.", "We will use COUNT(STUDENT.STU_NUM) to count the number of students in each department.", "Finally, we will group the results by DEPARTMENT.DEPT_CODE and DEPARTMENT.DEPT_NAME to get the count for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, DEPARTMENT.DEPT_NAME, COUNT(STUDENT.STU_NUM) AS student_count \nFROM DEPARTMENT \nLEFT JOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE \nGROUP BY DEPARTMENT.DEPT_CODE, DEPARTMENT.DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["We need to find the total number of hours completed by students in each department.", "The relevant table for student information is the STUDENT table, which contains the total credit hours completed (STU_HRS) and the department code (DEPT_CODE).", "We also need to reference the DEPARTMENT table to group the results by department.", "To get the total hours for each department, we will use the SUM function on the STU_HRS column and group the results by DEPT_CODE.", "The SQL query will involve a JOIN between the STUDENT and DEPARTMENT tables on the DEPT_CODE column to ensure we can group by department while summing the hours."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, SUM(STUDENT.STU_HRS) AS TOTAL_HOURS\nFROM STUDENT\nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE are needed to find out which department offers which courses and their corresponding credits.", "Join the DEPARTMENT table with the COURSE table on the DEPT_CODE to associate courses with their respective departments.", "Use the SUM function to calculate the total credits offered by each department by summing the CRS_CREDIT from the COURSE table.", "Group the results by DEPARTMENT to aggregate the total credits per department.", "Order the results in descending order based on the total credits to find the department with the most credits.", "Limit the results to 1 to get only the department that offers the most credits."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, DEPARTMENT.DEPT_NAME, SUM(COURSE.CRS_CREDIT) AS TOTAL_CREDITS\nFROM DEPARTMENT\nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE, DEPARTMENT.DEPT_NAME\nORDER BY TOTAL_CREDITS DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the tables involved: STUDENT, ENROLL, and CLASS.", "Determine the relationship between the tables: STUDENT is linked to ENROLL through STU_NUM, and ENROLL is linked to CLASS through CLASS_CODE.", "Focus on the specific class code 'ACCT-211' to filter the results.", "Select the first names of students (STU_FNAME) who are enrolled in the specified class."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT T1.STU_FNAME \nFROM STUDENT AS T1 \nJOIN ENROLL AS T2 ON T1.STU_NUM = T2.STU_NUM \nJOIN CLASS AS T3 ON T2.CLASS_CODE = T3.CLASS_CODE \nWHERE T3.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["Identify the tables needed: STUDENT, ENROLL, and CLASS are required to get the first names of students enrolled in a specific class and their grades.", "Join the STUDENT table with the ENROLL table on STU_NUM to link students with their enrollments.", "Join the ENROLL table with the CLASS table on CLASS_CODE to link enrollments with class details.", "Filter the results to include only those students enrolled in the class with CLASS_CODE 'ACCT-211' and who received a grade of 'C'.", "Select the first names of the students from the STUDENT table."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT T1.STU_FNAME \nFROM STUDENT AS T1 \nJOIN ENROLL AS T2 ON T1.STU_NUM = T2.STU_NUM \nJOIN CLASS AS T3 ON T2.CLASS_CODE = T3.CLASS_CODE \nWHERE T3.CLASS_CODE = 'ACCT-211' AND T2.ENROLL_GRADE = 'C';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["Identify the department with the most students enrolled.", "To do this, we need to count the number of students in each department.", "We can achieve this by grouping the students by their department code.", "We will use the COUNT function to count the number of students in each department.", "Next, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to only the top department (the one with the most students).", "We will then select the department name corresponding to the department code that has the highest count of students."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT dept_name FROM department WHERE dept_code IN (SELECT dept_code FROM student GROUP BY dept_code ORDER BY COUNT(stu_num) DESC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3257", "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["Identify the relevant table: The CLASS table contains information about classes, including the room where they are held and the course code associated with each class.", "Determine the specific requirement: We need to find all course codes (CRS_CODE) for classes that take place in room KLR209.", "Construct the SQL query: Use a SELECT statement to retrieve the distinct course codes from the CLASS table where the CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE \nFROM CLASS \nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about class locations, including the CLASS_ROOM column.", "Determine the required data: We need the course codes (CRS_CODE) for classes held in room KLR209.", "Construct the SQL query: Use a SELECT statement to retrieve distinct CRS_CODE values from the CLASS table where CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CRS_CODE FROM CLASS WHERE CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the tables needed: STUDENT, ENROLL, and CLASS.", "We need to find students who received a grade of 'C', so we will focus on the ENROLL table for grades.", "We will join the ENROLL table with the STUDENT table to get the first names of the students.", "The CLASS table is not directly needed for this query since we are only interested in the grades, but it could be included if we wanted more details about the classes.", "The final query will select the distinct first names of students who got a grade of 'C' in any class."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["Identify the table that contains professor information, which is the EMPLOYEE table.", "We need to find professors who do not teach any class, so we will look for professors whose EMP_NUM is not present in the CLASS table's PROF_NUM column.", "To achieve this, we can use a subquery that selects all PROF_NUM from the CLASS table.", "The main query will select EMP_FNAME from the EMPLOYEE table where the EMP_NUM is not in the list of PROF_NUM obtained from the subquery."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME FROM EMPLOYEE WHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the table that contains professor information, which is the PROFESSOR table.", "We need to find professors who are not teaching any classes, so we will check the CLASS table for any entries that match the professors.", "We can use a subquery to select all PROF_NUM from the CLASS table, which represents professors who are teaching classes.", "The main query will select the first names (EMP_FNAME) of professors whose EMP_NUM is not in the list of PROF_NUM from the CLASS table."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME FROM PROFESSOR WHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors and their highest degrees.", "Determine the condition: We need to count professors who have either a Ph.D. or a Masters degree.", "Use the COUNT function: This will allow us to count the number of professors meeting the criteria.", "Construct the SQL query: The query selects the count of professors from the PROFESSOR table where the prof_high_degree is either 'Ph.D.' or 'Masters'."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) AS total_professors FROM professor WHERE prof_high_degree IN ('Ph.D.', 'Masters')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["Identify the tables needed: We need information from the EMPLOYEE table for professors and the CLASS table to find which professors are teaching specific courses.", "Join the EMPLOYEE and CLASS tables on the professor's identifier (EMP_NUM) and the class's professor identifier (PROF_NUM).", "Filter the results to only include classes with the course codes 'CIS-220' and 'QM-261'.", "Select the distinct first names of the professors from the results to avoid duplicates."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "pred_sql": "SELECT DISTINCT T1.EMP_FNAME FROM EMPLOYEE AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM = T2.PROF_NUM WHERE T2.CRS_CODE IN ('CIS-220', 'QM-261')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the requirement to find students enrolled in classes from two specific departments: Accounting and Computer Info. Systems.", "Use the provided hint which describes a virtual table that can be used to find students enrolled in classes from a specific department.", "The hint suggests using an INTERSECT operation to find students who are enrolled in classes from both departments.", "Construct the SQL query by joining the necessary tables: STUDENT, ENROLL, CLASS, COURSE, and DEPARTMENT.", "For the first part of the INTERSECT, filter by the department name 'Accounting'.", "For the second part of the INTERSECT, filter by the department name 'Computer Info. Systems'.", "Combine both parts using the INTERSECT operator to ensure only students enrolled in classes from both departments are returned."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num = T2.stu_num JOIN CLASS AS T3 ON T2.class_code = T3.class_code JOIN course AS T4 ON T3.crs_code = T4.crs_code JOIN department AS T5 ON T5.dept_code = T4.dept_code WHERE T5.dept_name = 'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num = T2.stu_num JOIN CLASS AS T3 ON T2.class_code = T3.class_code JOIN course AS T4 ON T3.crs_code = T4.crs_code JOIN department AS T5 ON T5.dept_code = T4.dept_code WHERE T5.dept_name = 'Computer Info. Systems'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3308", "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["Identify the tables needed: PROFESSOR and DEPARTMENT.", "We need to retrieve the first names and office locations of professors, so we will select EMP_FNAME and PROF_OFFICE.", "To filter the professors by department, we will join the PROFESSOR table with the DEPARTMENT table on DEPT_CODE.", "We need to filter for professors in the 'History' department and those who have a Ph.D., so we will add these conditions in the WHERE clause."], "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"], "pred_sql": "SELECT EMP_FNAME, PROF_OFFICE \nFROM PROFESSOR AS P \nJOIN DEPARTMENT AS D ON P.DEPT_CODE = D.DEPT_CODE \nWHERE D.DEPT_NAME = 'History' AND P.PROF_HIGH_DEGREE = 'Ph.D.';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3319", "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["We need to find the names of students who took some course and received either an A or a C grade.", "To do this, we will join the STUDENT table with the ENROLL table to get the grades for each student.", "Next, we will join the ENROLL table with the CLASS table to ensure we are looking at the correct classes.", "We will filter the results to include only those students whose grades are either 'A' or 'C'.", "Finally, we will select the distinct first and last names of the students to avoid duplicates."], "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME, S.STU_LNAME \nFROM STUDENT AS S \nJOIN ENROLL AS E ON S.STU_NUM = E.STU_NUM \nJOIN CLASS AS C ON E.CLASS_CODE = C.CLASS_CODE \nWHERE E.ENROLL_GRADE IN ('A', 'C');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["Identify the tables needed: PROFESSOR and DEPARTMENT.", "We need to retrieve the first names of professors and their highest degree, so we will select EMP_FNAME and PROF_HIGH_DEGREE from the PROFESSOR table.", "To filter professors by department, we will join the PROFESSOR table with the DEPARTMENT table on DEPT_CODE.", "We will add a WHERE clause to filter for the 'Computer Information Systems' department."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "pred_sql": "SELECT EMP_FNAME, PROF_HIGH_DEGREE \nFROM PROFESSOR AS P \nJOIN DEPARTMENT AS D ON P.DEPT_CODE = D.DEPT_CODE \nWHERE D.DEPT_NAME = 'Computer Information Systems';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: DEPARTMENT, COURSE, and CLASS are needed to find the department name based on the class description.", "Join the DEPARTMENT table with the COURSE table on DEPT_CODE to link courses to their respective departments.", "Join the COURSE table with the CLASS table on CRS_CODE to link classes to their respective courses.", "Use a WHERE clause to filter courses whose description contains the word 'Statistics' using the LIKE operator."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT D.DEPT_NAME \nFROM DEPARTMENT D \nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE \nJOIN CLASS CL ON C.CRS_CODE = CL.CRS_CODE \nWHERE C.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["The user wants to know the types and countries of competitions.", "To get the types of competitions, we need to select the 'Competition_type' column from the 'competition' table.", "To get the countries where these competitions were held, we need to select the 'Country' column from the same table.", "We can use DISTINCT to ensure that we get unique combinations of competition types and countries.", "The final SQL query will select both 'Competition_type' and 'Country' from the 'competition' table."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT Competition_type, Country FROM competition;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the countries that hosted competitions of two specific types. The placeholders in the query represent the types of competitions being compared.\",\n        \"virtual_table\": \"SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3355", "db_id": "sports_competition", "question": "Please show the names and the players of clubs.", "rationale": ["Identify the tables needed: 'club' for club names and 'player' for player names.", "Determine the relationship between the tables: 'player' has a foreign key 'Club_ID' that references 'club'.", "Use a JOIN operation to combine data from both tables based on the 'Club_ID'.", "Select the desired columns: the name of the club and the name of the player."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "pred_sql": "SELECT c.name AS club_name, p.name AS player_name \nFROM club c \nJOIN player p ON c.Club_ID = p.Club_ID;", "hint": "\n"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["Identify the relevant table: The 'player' table contains the information about players and their positions.", "Determine the required calculation: We need to calculate the average number of points scored by players in each position.", "Group the data: Use GROUP BY to group the results by 'Position' so that we can calculate the average points for each position.", "Apply the condition: Use HAVING to filter the groups where the average points are greater than 20."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player GROUP BY Position HAVING AVG(Points) > 20;", "hint": "\n"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant column for player positions, which is 'Position'.", "Identify the column that contains the points scored by players, which is 'Points'.", "Formulate the condition to filter players based on their points: greater than 20 or less than 10.", "Construct the SQL query to select the 'Position' from the 'player' table where the 'Points' meet the specified conditions."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player WHERE Points > 20 OR Points < 10;", "hint": "\n"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about different competitions, including their type and country.", "Filter for tournament competitions: We need to focus on competitions of type 'tournament'.", "Count the number of tournaments per country: We will use the COUNT function to count how many tournaments each country has hosted.", "Group the results by country: This allows us to aggregate the count of tournaments for each country.", "Order the results: We will order the results in descending order to find the country with the most tournaments.", "Limit the results to one: Since we only want the country with the most tournaments, we will limit the output to one result."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT country, COUNT(*) as tournament_count \nFROM competition \nWHERE competition_type = 'tournament' \nGROUP BY country \nORDER BY tournament_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the countries that hosted competitions of two specific types. The placeholders in the query represent the types of competitions being compared.\",\n        \"virtual_table\": \"SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3384", "db_id": "sports_competition", "question": "what is the name of the country that participated in the most tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competitions, including the type and country.", "Filter for tournament competitions: We need to focus on competitions where the type is 'tournament'.", "Count the occurrences: We will count how many times each country has participated in tournament competitions.", "Group by country: To get the count per country, we will group the results by the 'country' column.", "Order the results: We will order the results in descending order based on the count of tournaments.", "Limit the results: To get only the country with the most tournaments, we will limit the results to 1."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT country, COUNT(*) as tournament_count \nFROM competition \nWHERE competition_type = 'tournament' \nGROUP BY country \nORDER BY tournament_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the countries that hosted competitions of two specific types. The placeholders in the query represent the types of competitions being compared.\",\n        \"virtual_table\": \"SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3388", "db_id": "sports_competition", "question": "What are the countries that have never participated in any friendly-type competitions?", "rationale": ["Identify the countries that have hosted competitions by selecting the 'country' column from the 'competition' table.", "Use the EXCEPT clause to exclude countries that have hosted friendly-type competitions.", "The subquery selects countries from the 'competition' table where the 'competition_type' is 'friendly'.", "The final query combines these two parts to return countries that have never participated in friendly-type competitions."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "pred_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type = 'friendly'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the countries where competitions were held, excluding those countries that hosted competitions of a specific type. The placeholder in the WHERE clause represents the type of competition to be excluded.\",\n        \"virtual_table\": \"SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["The task requires listing the full name (first and last name) and salary of employees earning below 6000.", "We need to select the columns FIRST_NAME, LAST_NAME, and SALARY from the employees table.", "To filter the employees based on their salary, we will use a WHERE clause to specify that SALARY should be less than 6000."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME, LAST_NAME, SALARY FROM employees WHERE SALARY < 6000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (first and last name), hire date, salary, and department id.", "To create the full name, concatenate the first name and last name using '||'.", "Filter employees whose first name does not contain the letter 'M' using the NOT LIKE clause.", "Select the relevant fields from the 'employees' table."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: first name, last name, hire date, salary, and department number.", "Filter employees whose first name does not contain the letter 'M'. This is done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by department number using the ORDER BY clause."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT first_name, last_name, hire_date, salary, department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["Identify the required fields: full name (concatenation of first and last name), hire date, salary, and department ID.", "Filter employees whose first name does not contain the letter 'M'.", "Use the 'employees' table to retrieve the necessary information.", "Order the results by department ID in ascending order."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The 'jobs' table contains job titles and their corresponding salary ranges.", "Determine the condition: We need to find jobs where the maximum salary exceeds 9000.", "Construct the SQL query: Use a SELECT statement to retrieve the JOB_TITLE from the jobs table where MAX_SALARY is greater than 9000."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE FROM jobs WHERE MAX_SALARY > 9000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The question pertains to job titles and salary ranges, which are found in the 'jobs' table.", "Determine the columns needed: We need 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY' from the 'jobs' table.", "Formulate the condition: We need to filter jobs based on the maximum salary being between 12000 and 18000.", "Construct the SQL query: Using the SELECT statement to retrieve the required columns and applying the WHERE clause to filter based on the maximum salary range."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY FROM jobs WHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["We need to find the employee IDs and the final dates of employment for each employee.", "The relevant tables are 'employees' and 'job_history'.", "We will join the 'employees' table with the 'job_history' table on the EMPLOYEE_ID.", "To get the final date of employment, we need to find the maximum END_DATE for each employee in the job_history table.", "We can use a subquery to get the maximum END_DATE for each employee and filter the results accordingly."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT e.EMPLOYEE_ID, jh.END_DATE \nFROM employees e \nJOIN job_history jh ON e.EMPLOYEE_ID = jh.EMPLOYEE_ID \nWHERE jh.END_DATE = (SELECT MAX(END_DATE) \n                     FROM job_history \n                     WHERE EMPLOYEE_ID = e.EMPLOYEE_ID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["Identify the tables needed: 'employees' for salary and commission percentage, and 'departments' for department names.", "Join the 'employees' table with the 'departments' table on the DEPARTMENT_ID to get department names along with employee details.", "Filter the employees to include only those who have a non-null commission percentage, indicating they receive a commission.", "Group the results by department name to calculate the average salary for each department.", "Use the AVG() function to compute the average salary of employees in each department who receive a commission."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_NAME, AVG(e.SALARY) AS average_salary\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nWHERE e.COMMISSION_PCT IS NOT NULL\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.\",\n        \"virtual_table\": \"SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["Identify the table needed: The 'employees' table contains salary and commission percentage information.", "Determine the condition: We need to filter employees who have a non-null commission percentage.", "Calculate the average salary: Use the AVG() function to compute the average salary of the filtered employees."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT AVG(SALARY) AS average_salary FROM employees WHERE COMMISSION_PCT IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.\",\n        \"virtual_table\": \"SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["Identify the required columns: COUNTRY_ID from countries and the count of cities from locations.", "To get the number of cities for each country, we need to join the countries table with the locations table on the COUNTRY_ID.", "Use the COUNT function to count the number of cities for each country.", "Group the results by COUNTRY_ID to ensure we get a count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT countries.COUNTRY_ID, COUNT(locations.CITY) AS number_of_cities\nFROM countries\nJOIN locations ON countries.COUNTRY_ID = locations.COUNTRY_ID\nGROUP BY countries.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["Identify the tables needed: 'countries' for country information and 'locations' for city information.", "Determine the relationship between the tables: 'countries' and 'locations' are linked by 'COUNTRY_ID'.", "Use a JOIN clause to combine 'countries' and 'locations' based on 'COUNTRY_ID'.", "Count the number of cities (from the 'locations' table) for each country using COUNT() function.", "Group the results by 'COUNTRY_ID' to get the count of cities for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT c.COUNTRY_ID, COUNT(l.CITY) AS CITY_COUNT\nFROM countries c\nJOIN locations l ON c.COUNTRY_ID = l.COUNTRY_ID\nGROUP BY c.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["Identify the requirement to return detailed info of jobs done by employees earning a salary of 12000 or more.", "The jobs table contains the detailed information we need, so we will select all columns from the jobs table.", "We need to filter the jobs based on the employees' salaries, so we will use a subquery to find the job IDs of employees earning 12000 or more.", "The subquery will select the JOB_ID from the employees table where the SALARY is greater than or equal to 12000.", "Finally, we will use the IN clause to filter the jobs based on the job IDs obtained from the subquery."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "pred_sql": "SELECT j.* FROM jobs j WHERE j.JOB_ID IN (SELECT e.JOB_ID FROM employees e WHERE e.SALARY >= 12000)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["The question asks for all information regarding employees who are managers.", "To identify managers, we need to find employees whose EMPLOYEE_ID appears as a MANAGER_ID in the employees table.", "We can achieve this by using a subquery that selects distinct MANAGER_IDs from the employees table.", "The main query will then select all columns from the employees table where the EMPLOYEE_ID is in the list of MANAGER_IDs obtained from the subquery."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT e.* FROM employees e WHERE e.EMPLOYEE_ID IN (SELECT DISTINCT e2.MANAGER_ID FROM employees e2)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["Identify the requirement: We need unique department IDs where a manager manages 4 or more employees.", "Use the 'employees' table since it contains information about employees and their managers.", "Group the results by 'department_id' and 'manager_id' to count the number of employees under each manager in each department.", "Use the HAVING clause to filter groups that have 4 or more employees.", "Select distinct department IDs from the filtered results."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id, manager_id HAVING COUNT(employee_id) >= 4", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["Identify the requirement to find distinct department IDs where a manager oversees 4 or more employees.", "Use the 'employees' table since it contains the necessary information about employees and their respective departments and managers.", "Group the results by 'department_id' and 'manager_id' to aggregate the employee counts for each department managed by a specific manager.", "Use the HAVING clause to filter groups that have a count of employees greater than or equal to 4, as specified in the query.", "Select distinct department IDs from the filtered results to meet the requirement."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id, manager_id HAVING COUNT(employee_id) >= 4", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["Identify the relevant table: The 'employees' table contains the information about employees and their salaries.", "Determine the conditions: We need to find employees with salaries above the minimum salary for their job and below 2500.", "Use a subquery to get the minimum salary for each job: This will be done by selecting the MIN_SALARY from the 'jobs' table where the JOB_ID matches the employee's JOB_ID.", "Combine the conditions in the WHERE clause: We will filter the employees based on the salary conditions using the results from the subquery."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "pred_sql": "SELECT * FROM employees WHERE salary > (SELECT MIN_SALARY FROM jobs WHERE JOB_ID = employees.JOB_ID) AND salary < 2500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["We need to find the full names and hire dates of employees who work in the same department as an employee named Clara.", "To get the full name, we can concatenate the first name and last name of the employees using the '||' operator.", "We will select the hire date from the employees table as well.", "To filter employees by department, we will use a subquery that selects the department ID of the employee named Clara.", "The subquery will look for the department ID of Clara in the employees table.", "Finally, we will combine the main query and the subquery to get the desired results."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS full_name, e.HIRE_DATE \nFROM employees e \nWHERE e.DEPARTMENT_ID = (SELECT e2.DEPARTMENT_ID \n                         FROM employees e2 \n                         WHERE e2.FIRST_NAME = 'Clara')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the requirement to find employees in the same department as Clara.", "Use a subquery to find the department_id of Clara.", "Select the first name, last name, and hire date of employees whose department_id matches Clara's department_id.", "Exclude Clara from the results by adding a condition to filter out her first name."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT first_name, last_name, hire_date \nFROM employees \nWHERE department_id IN (\n    SELECT department_id \n    FROM employees \n    WHERE first_name = 'Clara'\n) \nAND first_name != 'Clara';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["Identify the requirement to display employee number and name for employees in departments with any employee whose name contains 'T'.", "Use the 'employees' table to get employee details including employee_id, first_name, and last_name.", "To find departments with employees whose names contain 'T', a subquery is needed that selects department_id from the 'employees' table where either first_name or last_name contains 'T'.", "The main query selects employee_id, first_name, and last_name from the 'employees' table where the department_id is in the result of the subquery."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "pred_sql": "SELECT employee_id, first_name, last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' OR last_name LIKE '%T%' )", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the main requirement: We need to display the employee number (EMPLOYEE_ID) and job id (JOB_ID) for employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "To find the salaries of employees with the job title MK_MAN, we will use a subquery that selects the minimum salary from the employees table joined with the jobs table on JOB_ID, filtering for JOB_TITLE = 'MK_MAN'.", "The main query will select EMPLOYEE_ID and JOB_ID from the employees table where the salary is less than the result of the subquery.", "The final SQL query combines these elements to meet the requirement."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID FROM employees WHERE SALARY < (SELECT MIN(SALARY) FROM employees JOIN jobs ON employees.JOB_ID = jobs.JOB_ID WHERE JOB_TITLE = 'MK_MAN')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To do this, we will use the 'employees' table which contains the salary and department ID information.", "We will group the results by 'department_id' to aggregate the salaries for each department.", "We will use the SUM function to calculate the total salaries for each department.", "To filter departments with more than 2 employees, we will use the HAVING clause with COUNT(employee_id) > 2."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT department_id, SUM(salary) AS total_salaries \nFROM employees \nGROUP BY department_id \nHAVING COUNT(employee_id) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["The task is to display the department ID, full name (first and last name), and salary for employees with the highest salary in each department.", "To achieve this, we need to first identify the maximum salary for each department. This can be done using a subquery that groups the employees by department and selects the maximum salary.", "The hint provides a virtual table that summarizes the first names, last names, salaries, and department IDs of employees, along with the maximum salary for each department. We can use this information to construct our main query.", "In the main query, we will select the department ID, concatenate the first and last names to create a full name, and the salary from the employees table.", "To filter the employees to only those with the highest salary in their respective departments, we will use a WHERE clause that checks if the (department_id, salary) pair exists in the results of the subquery that finds the maximum salary for each department."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT department_id, first_name || ' ' || last_name AS full_name, salary \nFROM employees \nWHERE (department_id, salary) IN \n    (SELECT department_id, MAX(salary) \n     FROM employees \n     GROUP BY department_id)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the relevant tables: employees, departments, and locations.", "We need to retrieve the full names of employees, which requires concatenating their first and last names.", "We also need the city of the employees, which is found in the locations table.", "To get the city, we need to join the employees table with the departments table (to get the department ID) and then with the locations table (to get the city based on the location ID).", "The condition specifies that we only want employees whose first names contain the letter 'Z', which can be checked using the LIKE operator with a wildcard."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, CITY \nFROM employees \nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID \nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID \nWHERE FIRST_NAME LIKE '%Z%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "We need to join these tables to get the employee's full name and the country they are currently working in.", "Join employees with departments on DEPARTMENT_ID to get department information.", "Join departments with locations on LOCATION_ID to get location information.", "Join locations with countries on COUNTRY_ID to get the country name.", "Select the first name and last name from employees and the country name from countries.", "Filter the results by the specific employee ID provided in the query."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, c.COUNTRY_NAME \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE e.EMPLOYEE_ID = ?", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "To achieve this, we will select the 'DEPARTMENT_NAME' from the 'departments' table.", "We will also count the number of employees associated with each department, which can be done using the COUNT function on 'EMPLOYEE_ID' from the 'employees' table.", "To link the departments with their employees, we will perform a LEFT JOIN between the 'departments' table and the 'employees' table on the 'DEPARTMENT_ID'.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count of employees for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["We need to retrieve the department names and the count of employees in each department.", "The relevant tables are 'departments' for department names and 'employees' for employee information.", "We will use a LEFT JOIN to connect the 'departments' table with the 'employees' table on the DEPARTMENT_ID column.", "We will use COUNT() to count the number of employees in each department.", "Finally, we will group the results by department name to get the count for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS employee_count \nFROM departments d \nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["We need to display the full name (first and last name) and salary of employees.", "The relevant table for employee information is the 'employees' table, which contains first names, last names, and salaries.", "To find the departments where these employees work, we need to join the 'departments' table using the DEPARTMENT_ID.", "Since we are interested in departments located in London, we also need to join the 'locations' table using the LOCATION_ID from the 'departments' table.", "Finally, we filter the results to include only those records where the city in the 'locations' table is 'London'."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the required information: full names and salaries of employees.", "Full names can be constructed by concatenating first and last names.", "Salaries are directly available from the employees table.", "To filter employees based on the city, we need to join the employees table with the departments table (to get department IDs) and then with the locations table (to get city information).", "The join condition will be based on the foreign keys: employees.DEPARTMENT_ID = departments.DEPARTMENT_ID and departments.LOCATION_ID = locations.LOCATION_ID.", "Finally, apply a WHERE clause to filter results for the city of London."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT CONCAT(first_name, ' ', last_name) AS full_name, salary \nFROM employees \nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID \nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID \nWHERE locations.CITY = 'London';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3532", "db_id": "music_1", "question": "Find the id of the song that lasts the longest.", "rationale": ["Identify the tables involved: 'files' for file details and 'song' for song details.", "We need to find the song with the longest duration, so we will use the 'duration' column from the 'files' table.", "To get the song details, we will join the 'files' table with the 'song' table on the 'f_id' column.", "We will use a subquery to find the maximum duration from the 'files' table.", "Finally, we will select the song name and its id where the duration matches the maximum duration found."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT T2.song_name, T2.f_id FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id WHERE T1.duration = (SELECT max(duration) FROM files)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    }\n}\n"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["Identify the relevant table: The 'song' table contains information about songs and their artists.", "Determine the criteria: We need to find the shortest song, which means we need to look for the minimum duration.", "Use a subquery to find the minimum duration: We can use a subquery to get the shortest duration from the 'song' table.", "Select the artist names: We will select the artist names from the 'song' table where the duration matches the minimum duration found in the subquery."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "pred_sql": "SELECT artist_name FROM song WHERE duration = (SELECT MIN(duration) FROM song)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["Identify the relevant table: The 'song' table contains the duration of songs.", "Determine the condition: We need to count songs with a duration of 4 minutes, which is represented as '4:00'.", "Construct the SQL query: Use the COUNT function to count the number of records in the 'song' table that meet the duration condition."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "pred_sql": "SELECT COUNT(*) FROM song WHERE duration = '4:00'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n        \"virtual_table\": \"SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is\"\n    }\n}\n"}
{"sample_id": "train.3549", "db_id": "music_1", "question": "What is the average rating of songs produced by female artists?", "rationale": ["Identify the tables needed: We need data from the 'artist' table to filter by gender and from the 'song' table to get the ratings.", "We want to find the average rating of songs, so we will use the AVG() function on the 'rating' column from the 'song' table.", "To link the two tables, we will join them on the 'artist_name' column, which is common to both tables.", "We need to filter the results to include only female artists, so we will add a WHERE clause to specify that the gender in the 'artist' table is 'female'.", "Finally, we will select the average rating from the joined tables."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "pred_sql": "SELECT AVG(T2.rating) AS average_rating\nFROM artist AS T1\nJOIN song AS T2 ON T1.artist_name = T2.artist_name\nWHERE T1.gender = 'female';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n        \"virtual_table\": \"SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is\"\n    }\n}\n"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["We need to find the file format that is used by the most files.", "To do this, we will select the 'formats' column from the 'files' table.", "We will count the number of occurrences of each format using COUNT(*) and alias it as 'file_count'.", "We will group the results by 'formats' to aggregate the counts for each format.", "To get the format used by the most files, we will order the results in descending order based on 'file_count'.", "Finally, we will limit the results to 1 to get only the top format."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(*) as file_count FROM files GROUP BY formats ORDER BY file_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    }\n}\n"}
{"sample_id": "train.3556", "db_id": "music_1", "question": "What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?", "rationale": ["Identify the table that contains the file information, which is the 'files' table.", "We need to filter the files based on the format, specifically looking for 'mp4'.", "The 'formats' column in the 'files' table will be checked to see if it contains 'mp4'.", "Next, we need to check the resolution of the files, ensuring it is smaller than 1000.", "The 'resolution' column is also in the 'files' table, but since it is a text type, we will cast it to an integer for comparison.", "Combine these conditions in a SELECT statement to retrieve the 'f_id' of the files that meet both criteria."], "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"], "pred_sql": "SELECT f_id FROM files WHERE formats LIKE '%mp4%' AND CAST(resolution AS INTEGER) < 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    }\n}\n"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["Identify the relevant tables: 'artist' and 'song'.", "We need to find artists who are female and have produced songs in Bangla.", "Join the 'artist' table with the 'song' table on the artist's name.", "Filter the results where the artist's gender is 'female' and the song's language is 'Bangla'.", "Select the country of the artist from the filtered results."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE artist.gender = 'female' AND song.languages = 'Bangla';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["Identify the relevant tables: 'artist' and 'song'.", "We need to find female artists, so we will filter the 'artist' table by gender = 'female'.", "We need to find songs in the language Bangla, so we will filter the 'song' table by languages = 'Bangla'.", "Join the 'artist' and 'song' tables on the artist's name to combine the relevant information.", "Select the country from the 'artist' table for the filtered results."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE song.languages = 'Bangla' AND artist.gender = 'female';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["Identify the relevant tables: We need information from the 'artist' and 'song' tables.", "Determine the required fields: We need the 'gender' and 'artist_name' from the 'artist' table.", "Establish the relationship: The 'artist' table can be joined with the 'song' table on 'artist_name'.", "Find the song with the smallest resolution: We can use a subquery to find the minimum resolution from the 'song' table.", "Combine the results: Use the join to get the artist's gender and name for the song with the smallest resolution."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.gender, artist.artist_name FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE song.resolution = (SELECT MIN(resolution) FROM song)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3567", "db_id": "music_1", "question": "For each file format, return the number of artists who released songs in that format.", "rationale": ["We need to count the number of distinct artists for each file format.", "The relevant tables are 'files' and 'song' since we need to access the file formats and the artists associated with the songs.", "We will join the 'files' table with the 'song' table on the 'f_id' column to link songs to their respective file formats.", "We will select the 'formats' from the 'files' table and count the distinct 'artist_name' from the 'song' table.", "Finally, we will group the results by 'formats' to get the count of artists for each format."], "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(DISTINCT artist_name) AS artist_count FROM files JOIN song ON files.f_id = song.f_id GROUP BY formats;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3576", "db_id": "music_1", "question": "What are the names and genders of all artists who released songs in the month of March?", "rationale": ["Identify the tables needed: We need information from the 'artist' table for names and genders, and from the 'song' table for the release date.", "Determine the relationship between the tables: The 'artist' table can be joined with the 'song' table on the 'artist_name' column.", "Filter the songs released in March: Use the strftime function to extract the month from the 'releasedate' column and check if it equals '03'.", "Select the required columns: We need to select 'artist_name' and 'gender' from the 'artist' table."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.gender FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE strftime('%m', song.releasedate) = '03';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["We need to find out the languages used in songs, which is a column in the 'song' table.", "To determine which languages are used most often, we will count the occurrences of each language in the 'languages' column.", "We will use the COUNT() function to count the number of songs for each language.", "To group the results by language, we will use the GROUP BY clause on the 'languages' column.", "Finally, we will order the results in descending order based on the count of songs for each language to find the most used languages."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "pred_sql": "SELECT languages, COUNT(*) as language_count FROM song GROUP BY languages ORDER BY language_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3590", "db_id": "music_1", "question": "What are the names of all male British artists?", "rationale": ["Identify the relevant table: The 'artist' table contains information about artists, including their country and gender.", "Filter criteria: We need to find male artists from Britain, so we will filter the 'country' column for 'Britain' and the 'gender' column for 'male'.", "Construct the SQL query: Using the SELECT statement to retrieve the 'artist_name' from the 'artist' table with the specified conditions."], "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"], "pred_sql": "SELECT artist_name FROM artist WHERE country = 'Britain' AND gender = 'male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3598", "db_id": "music_1", "question": "What is the average rating and resolution of all bangla songs?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "We need to calculate the average rating of songs, so we will use the AVG() function on the 'rating' column from the 'song' table.", "We also need the resolution of the songs, which is found in the 'files' table, so we will use the MAX() function to get the highest resolution available.", "We will join the 'song' and 'files' tables on the 'f_id' column to combine the necessary information.", "We will filter the results to include only songs where the genre is 'Bangla'.", "Finally, we will select the average rating and the maximum resolution in the final query."], "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"], "pred_sql": "SELECT AVG(s.rating) AS average_rating, MAX(f.resolution) AS max_resolution FROM song AS s JOIN files AS f ON s.f_id = f.f_id WHERE s.genre_is = 'Bangla'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    }\n}\n"}
{"sample_id": "train.3599", "db_id": "music_1", "question": "What are the maximum and minimum resolution of songs whose duration is 3 minutes?", "rationale": ["Identify the requirement to find maximum and minimum resolution of songs.", "Focus on the 'song' table since it contains the resolution and duration information.", "Use the MIN() and MAX() functions to get the minimum and maximum resolution respectively.", "Filter the results to only include songs with a duration of '3 minutes'.", "Construct the SQL query to select the minimum and maximum resolution from the song table with the specified duration."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "pred_sql": "SELECT MIN(resolution) AS min_resolution, MAX(resolution) AS max_resolution \nFROM song \nWHERE duration = '3 minutes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    }\n}\n"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["Identify the required data: maximum duration and resolution of songs, grouped by languages.", "Determine the relevant tables: 'files' for duration and resolution, 'song' for languages.", "Use JOIN to combine 'files' and 'song' on the foreign key 'f_id'.", "Use aggregate functions max() to get the maximum duration and resolution.", "Group the results by languages to get the maximum values for each language category.", "Order the results by languages for better readability."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "pred_sql": "SELECT max(T1.duration), max(T2.resolution), T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    }\n}\n"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["Identify the required information: shortest duration and lowest rating of songs grouped by genre.", "Determine the relevant tables: 'files' for duration and 'song' for rating and genre.", "Use the JOIN clause to combine 'files' and 'song' tables based on the foreign key relationship (f_id).", "Use aggregate functions: min() to find the shortest duration and lowest rating.", "Group the results by genre using GROUP BY clause on genre_is from the song table.", "Order the results by genre using ORDER BY clause."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "pred_sql": "SELECT min(T1.duration), min(T2.rating), T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n        \"virtual_table\": \"SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is\"\n    }\n}\n"}
{"sample_id": "train.3607", "db_id": "music_1", "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "rationale": ["Identify the tables needed: We need information from the 'artist' table for artist names and countries, and from the 'song' table for song resolutions.", "Determine the condition: We want artists who have released at least one song with a resolution greater than 900.", "Join the tables: We need to join the 'artist' table with the 'song' table on the artist's name to correlate artists with their songs.", "Select the required fields: We need to select the artist's name and country from the 'artist' table.", "Apply the condition in the WHERE clause: We filter the results to include only those songs with a resolution greater than 900."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE song.resolution > 900;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3619", "db_id": "music_1", "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.", "rationale": ["Identify the tables involved: 'artist' and 'song'.", "Determine the relationship between the tables: 'artist_name' is the common field.", "Filter the songs based on the language 'Bangla'.", "Group the results by artist name to count the number of songs per artist.", "Order the results by the count of songs in descending order to get the top artists.", "Limit the results to the top 3 artists."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "pred_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name WHERE T2.languages = 'Bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3623", "db_id": "music_1", "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?", "rationale": ["Identify the relevant tables: 'files' for file details and 'song' for genre and title.", "We need to join the 'files' table with the 'song' table on the common field 'f_id'.", "Filter the results to include only songs where the genre is 'pop'.", "Select the required fields: duration, file size, and formats from the 'files' table.", "Order the results by the song title, which is in the 'song' table."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT f.duration, f.file_size, f.formats FROM files AS f JOIN song AS s ON f.f_id = s.f_id WHERE s.genre_is = 'pop' ORDER BY s.song_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n        \"virtual_table\": \"SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is\"\n    }\n}\n"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["Identify the relevant tables: 'files' for file details and 'song' for song details.", "We need to select the duration, file size, and formats from the 'files' table.", "Join the 'files' table with the 'song' table on the foreign key 'f_id' to link songs with their respective files.", "Filter the results to include only those songs that belong to the 'pop' genre.", "Order the results alphabetically by the song title, which is in the 'song' table."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT f.duration, f.file_size, f.formats FROM files AS f JOIN song AS s ON f.f_id = s.f_id WHERE s.genre_is = 'pop' ORDER BY s.song_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    }\n}\n"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["Identify the relevant tables: salary and team.", "We need to calculate the average salary, so we will use the AVG() function on the salary column from the salary table.", "Join the salary table with the team table on the team_id to filter by team name.", "Use a WHERE clause to specify the team name as 'Boston Red Stockings'.", "Select the average salary from the resulting joined table."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "pred_sql": "SELECT AVG(s.salary) AS average_salary \nFROM salary AS s \nJOIN team AS t ON s.team_id = t.team_id \nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their birth countries.", "Select the 'birth_country' column and count the number of players from each country using COUNT(player_id).", "Group the results by 'birth_country' to aggregate the player counts for each country.", "Order the results in ascending order based on the player count to find the countries with the least players.", "Limit the results to the top 3 countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["We need to find the highest salary for each team, which requires joining the salary table with the team table to get the team names and IDs.", "The salary table contains the salary information, and the team table contains the team names and IDs.", "We will use the MAX function to get the highest salary for each team.", "To group the results by team, we will use the GROUP BY clause on the team ID and name."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T3.name, T3.team_id, MAX(T1.salary) AS max_salary \nFROM salary AS T1 \nJOIN team AS T3 ON T1.team_id = T3.team_id \nGROUP BY T3.team_id, T3.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3658", "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["We need to retrieve the team name, team id, and the maximum salary for each team.", "The relevant tables for this query are 'salary' for salary information and 'team' for team details.", "We will join the 'salary' table with the 'team' table on the 'team_id' to get the team names and ids.", "We will use the MAX() function to find the maximum salary for each team.", "Finally, we will group the results by team id and team name to ensure we get one result per team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T3.name, T3.team_id, MAX(T1.salary) AS max_salary \nFROM salary AS T1 \nJOIN team AS T3 ON T1.team_id = T3.team_id \nGROUP BY T3.team_id, T3.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["We need to find the team offering the lowest average salary.", "To do this, we will join the 'salary' table with the 'team' table using the 'team_id' column.", "We will group the results by 'team_id' and 'name' to calculate the average salary for each team.", "We will order the results by the average salary in ascending order to get the team with the lowest average salary.", "Finally, we will limit the results to 1 to get only the team with the lowest average salary."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T3.team_id, T3.name FROM salary AS T1 JOIN team AS T3 ON T1.team_id = T3.team_id GROUP BY T3.team_id, T3.name ORDER BY AVG(T1.salary) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["Identify the tables needed: We need the 'player' table for player names and the 'player_award' table for award information.", "Join the 'player' table with the 'player_award' table to get the names of players who won awards.", "Use the INTERSECT operator to find players who won awards in both 1960 and 1961.", "Construct the SQL query using the provided virtual table structure, replacing placeholders with the specific years (1960 and 1961)."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT T1.name_first, T1.name_last \nFROM player AS T1 \nJOIN player_award AS T2 ON T1.player_id = T2.player_id \nWHERE T2.year = 1960 \nINTERSECT \nSELECT T1.name_first, T1.name_last \nFROM player AS T1 \nJOIN player_award AS T2 ON T1.player_id = T2.player_id \nWHERE T2.year = 1961;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3663", "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["Identify the relevant table: The 'player' table contains the first name, last name, weight, and height of players.", "Determine the conditions: We need to filter players based on their weight being greater than 220 or their height being less than 75.", "Construct the SQL query: Use a SELECT statement to retrieve 'name_first' and 'name_last' from the 'player' table, applying the specified conditions in the WHERE clause."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3664", "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["Identify the relevant table: The 'player' table contains the first name, last name, weight, and height of players.", "Determine the conditions: We need players with a weight greater than 220 or a height less than 75.", "Construct the SQL query: Use a SELECT statement to retrieve 'name_first' and 'name_last' from the 'player' table where the specified conditions are met."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team names.", "Join the 'postseason' table with the 'team' table on the winning team ID to get the team names.", "Filter the results to only include the Boston Red Stockings and ensure that the wins are greater than zero.", "Select the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(T1.wins) AS max_wins\nFROM postseason AS T1\nJOIN team AS T2 ON T1.team_id_winner = T2.team_id\nWHERE T2.name = 'Boston Red Stockings' AND T1.wins > 0;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team names.", "We need to find the maximum scores (wins) for the team 'Boston Red Stockings' when they won in postseason.", "Join the 'postseason' table with the 'team' table on the winning team ID to get the team name.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(T1.wins) AS max_wins\nFROM postseason AS T1\nJOIN team AS T2 ON T1.team_id_winner = T2.team_id\nWHERE T2.name = 'Boston Red Stockings'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
