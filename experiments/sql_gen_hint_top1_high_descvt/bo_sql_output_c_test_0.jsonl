{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["Identify the tables involved: Students, Student_Course_Registrations, and Courses.", "Join the Students table with the Student_Course_Registrations table to link students to their course registrations.", "Join the result with the Courses table to retrieve the course names.", "Group the results by course ID to count the number of students registered for each course.", "Order the results in descending order based on the count of registered students.", "Limit the results to 1 to get the course with the most registered students."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT T3.course_name, COUNT(*) AS number_of_students \nFROM Students AS T1 \nJOIN Student_Course_Registrations AS T2 ON T1.student_id = T2.student_id \nJOIN Courses AS T3 ON T2.course_id = T3.course_id \nGROUP BY T2.course_id \nORDER BY number_of_students DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["We need to find the IDs of students who have attended courses.", "The relevant table for attendance is 'Student_Course_Attendance', which contains the 'student_id' of students who attended courses.", "To get unique student IDs, we will use the DISTINCT keyword to avoid duplicates in the results."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["We need to find the IDs of all students who have attended at least one course.", "The relevant table for attendance is 'Student_Course_Attendance', which contains the 'student_id' of students who attended courses.", "To get unique student IDs, we will use the DISTINCT keyword to avoid duplicates.", "The final SQL query will select the distinct 'student_id' from the 'Student_Course_Attendance' table."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["Identify the relevant tables: Candidates, Student_Course_Attendance, and Student_Course_Registrations.", "We need to find the candidate who accessed a course, which means we need to join Candidates with Student_Course_Attendance.", "The join condition will be on the candidate_id from Candidates and student_id from Student_Course_Attendance.", "We also need to ensure that the attendance is linked to the course registration, so we join with Student_Course_Registrations on student_id and course_id.", "To find the most recent access, we will order the results by date_of_attendance in descending order.", "Finally, we select the candidate_id and limit the results to 1 to get the most recent candidate."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT DISTINCT c.candidate_id\nFROM Candidates c\nJOIN Student_Course_Attendance sca ON c.candidate_id = sca.student_id\nJOIN Student_Course_Registrations scr ON sca.student_id = scr.student_id AND sca.course_id = scr.course_id\nORDER BY sca.date_of_attendance DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.77", "db_id": "student_assessment", "question": "What is detail of the student who registered the most number of courses?", "rationale": ["We need to find the details of the student who registered for the most number of courses.", "To do this, we will join the 'Students' table with the 'Student_Course_Registrations' table on the student_id.", "We will group the results by student_id to count the number of courses each student has registered for.", "Next, we will order the results in descending order based on the count of registered courses.", "Finally, we will limit the results to only the top student, which will give us the student with the most registrations."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT S.student_id, S.student_details \nFROM Students AS S \nJOIN Student_Course_Registrations AS R ON S.student_id = R.student_id \nGROUP BY S.student_id \nORDER BY COUNT(R.course_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["Identify the tables involved: Students, Student_Course_Registrations, and Courses.", "Join the Students table with the Student_Course_Registrations table on student_id to link students to their course registrations.", "Join the result with the Courses table on course_id to retrieve course names.", "Use COUNT(*) to count the number of students registered for each course.", "Group the results by course_id to get the count for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT T3.course_name, COUNT(*) AS student_count \nFROM Students AS T1 \nJOIN Student_Course_Registrations AS T2 ON T1.student_id = T2.student_id \nJOIN Courses AS T3 ON T2.course_id = T3.course_id \nGROUP BY T2.course_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.90", "db_id": "student_assessment", "question": "What are the ids of the students who registered for course 301 most recently?", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Filter the records to only include those where the 'course_id' is '301'.", "Order the results by 'registration_date' in descending order to get the most recent registration first.", "Limit the results to 1 to get only the most recent student registration for course 301."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["We need to find distinct cities of addresses associated with students.", "To do this, we will need to join the Addresses table with the People_Addresses table to link addresses to people.", "Next, we will join the resulting table with the Students table to filter for only those people who are students.", "Finally, we will select the distinct cities from the Addresses table."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "pred_sql": "SELECT DISTINCT a.city\nFROM Addresses a\nJOIN People_Addresses pa ON a.address_id = pa.address_id\nJOIN Students s ON pa.person_id = s.student_id;", "hint": "\n"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["We need to find details of students who registered for courses but did not attend any of them.", "To achieve this, we will use a LEFT JOIN between the Students table and the Student_Course_Registrations table to get all students and their registrations.", "Next, we will perform another LEFT JOIN with the Student_Course_Attendance table to check if there are any attendance records for the registered courses.", "In the WHERE clause, we will filter for cases where the course_id from the Student_Course_Attendance table is NULL, indicating that the student did not attend any course."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "pred_sql": "SELECT S.student_id, S.student_details \nFROM Students S \nLEFT JOIN Student_Course_Registrations R ON S.student_id = R.student_id \nLEFT JOIN Student_Course_Attendance A ON R.student_id = A.student_id AND R.course_id = A.course_id \nWHERE A.course_id IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant tables: We need to look at the 'Students' and 'Student_Course_Registrations' tables to find students who registered for a specific course.", "Determine the course: The course we are interested in is 'Statistics'. We will need to find the course_id associated with this course from the 'Courses' table.", "Join the tables: We will join the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations.", "Filter by course: We will filter the results to only include registrations for the course 'Statistics'.", "Order by registration date: Finally, we will order the results by the registration date to meet the requirement of the query."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant tables: We need to look at the 'Students' and 'Student_Course_Registrations' tables to find student IDs and their course registrations.", "Filter for the specific course: We need to filter the registrations to only include those for the course 'Statistics'.", "Order by registration date: The results should be ordered by the date of registration to meet the requirement of the query.", "Construct the SQL query: Combine the above steps into a single SQL query that selects the student IDs from the 'Student_Course_Registrations' table where the course ID corresponds to 'Statistics', and order the results by the registration date."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.123", "db_id": "bike_1", "question": "For each zip code, return the average mean temperature of August there.", "rationale": ["We need to calculate the average mean temperature for each zip code in August.", "To filter the records for August, we can use the strftime function to extract the month from the date column in the weather table.", "We will select the zip_code and the average of mean_temperature_f, grouping the results by zip_code to get the average for each one."], "gold_sql": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE '8/%' GROUP BY zip_code", "source_tables": ["weather"], "pred_sql": "SELECT zip_code, AVG(mean_temperature_f) AS average_mean_temperature\nFROM weather\nWHERE strftime('%m', date) = '08'\nGROUP BY zip_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.\",\n        \"virtual_table\": \"SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.135", "db_id": "bike_1", "question": "Which bike traveled the most often in zip code 94002?", "rationale": ["Identify the relevant table: The 'trip' table contains information about bike trips, including the bike ID and zip code.", "Filter trips by zip code: We need to focus on trips that started in the zip code 94002.", "Group by bike ID: To find out which bike traveled the most, we will group the results by 'bike_id'.", "Count the number of trips for each bike: We will use COUNT(*) to count how many trips each bike has made.", "Order the results: We will order the results in descending order based on the trip count to get the most frequently used bike at the top.", "Limit the results: We will limit the output to 1 to get only the bike that traveled the most."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id, COUNT(*) as trip_count \nFROM trip \nWHERE zip_code = '94002' \nGROUP BY bike_id \nORDER BY trip_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.136", "db_id": "bike_1", "question": "What is the id of the bike that traveled the most in 94002?", "rationale": ["Identify the relevant table: The 'trip' table contains information about bike trips, including the bike ID and duration.", "Filter trips by zip code: We need to focus on trips that started in the zip code '94002'.", "Order the results: To find the bike that traveled the most, we will order the trips by duration in descending order.", "Limit the results: We only need the bike ID of the trip with the maximum duration, so we will limit the results to 1."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id FROM trip WHERE zip_code = '94002' ORDER BY duration DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.143", "db_id": "bike_1", "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?", "rationale": ["Identify the relevant tables: 'station' and 'status'.", "We need to join these tables on the station ID to access both station names and bike availability.", "Group the results by station ID to calculate the average number of bikes available at each station.", "Use the HAVING clause to filter for stations with an average of more than 14 bikes available.", "Additionally, check if the installation date of the station falls in December by extracting the month from the installation_date column.", "Combine both conditions in the HAVING clause using an OR operator."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT T1.name, T1.id FROM station AS T1 JOIN status AS T2 ON T1.id = T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available) > 14 OR strftime('%m', T1.installation_date) = '12'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n        \"virtual_table\": \"SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] EXCEPT SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.144", "db_id": "bike_1", "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "rationale": ["Identify the tables needed: 'station' for station details and 'status' for bike availability.", "Join the 'station' and 'status' tables on the station ID to access both station names and bike availability.", "Group the results by station ID to calculate the average number of bikes available for each station.", "Use the HAVING clause to filter for stations with an average of more than 14 bikes available or those installed in December.", "The condition for installation in December is checked using a LIKE clause on the installation_date column."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT T1.name, T1.id FROM station AS T1 JOIN status AS T2 ON T1.id = T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available) > 14 OR T1.installation_date LIKE '____-12-%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n        \"virtual_table\": \"SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] EXCEPT SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.145", "db_id": "bike_1", "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?", "rationale": ["Identify the relevant table: The 'weather' table contains the cloud cover data.", "Filter by zip code: We need to focus on the region of zip code 94107, so we will add a WHERE clause to filter the results.", "Group by cloud cover: To find the most common cloud cover rates, we will group the results by the 'cloud_cover' column.", "Count occurrences: We will order the grouped results by the count of occurrences of each cloud cover value in descending order to get the most common ones.", "Limit the results: Finally, we will limit the results to the top 3 most common cloud cover rates."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "pred_sql": "SELECT cloud_cover FROM weather WHERE zip_code = 94107 GROUP BY cloud_cover ORDER BY COUNT(*) DESC LIMIT 3", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.\",\n        \"virtual_table\": \"SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.161", "db_id": "bike_1", "question": "For each trip, return its ending station's installation date.", "rationale": ["We need to return the installation date of the ending station for each trip.", "The trip table contains the ending station's ID in the column 'end_station_id'.", "The station table contains the installation date in the column 'installation_date' and is linked to the trip table through the station ID.", "To get the installation date, we will perform a JOIN operation between the trip table and the station table on the condition that the 'end_station_id' from the trip table matches the 'id' from the station table."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.installation_date FROM trip t JOIN station s ON t.end_station_id = s.id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.162", "db_id": "bike_1", "question": "What is the installation date for each ending station on all the trips?", "rationale": ["Identify the relevant tables: We need information from the 'station' table for installation dates and the 'trip' table for ending stations.", "Determine the relationship: The 'trip' table has 'end_station_id' which corresponds to 'id' in the 'station' table.", "Construct the SQL query: We will perform a JOIN between 'station' and 'trip' on the condition that 'station.id' matches 'trip.end_station_id'.", "Select the 'installation_date' from the 'station' table to get the installation dates for each ending station."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT station.installation_date FROM station JOIN trip ON station.id = trip.end_station_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.163", "db_id": "bike_1", "question": "Which trip started from the station with the largest dock count? Give me the trip id.", "rationale": ["Identify the relevant tables: We need to use the 'trip' table to get the trip id and the 'station' table to find the station with the largest dock count.", "Determine the condition: We need to find the station with the largest dock count. This can be done using a subquery that selects the maximum dock count from the 'station' table.", "Join the tables: We will join the 'trip' table with the 'station' table on the station id to correlate trips with their starting stations.", "Select the trip id: Finally, we will select the trip id from the 'trip' table where the dock count of the corresponding station matches the maximum dock count found in the subquery."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "pred_sql": "SELECT trip.id FROM trip JOIN station ON trip.start_station_id = station.id WHERE station.dock_count = (SELECT MAX(dock_count) FROM station)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.165", "db_id": "bike_1", "question": "Count the number of trips that did not end in San Francisco city.", "rationale": ["Identify the requirement to count trips that did not end in San Francisco.", "To achieve this, we need to filter trips based on the end station name.", "We will use a subquery to get the names of stations located in San Francisco.", "The subquery will select names from the station table where the city is 'San Francisco'.", "We will then use the NOT IN clause to filter out trips that ended at these stations.", "Finally, we will count the remaining trips that did not end in San Francisco."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip WHERE end_station_name NOT IN (SELECT name FROM station WHERE city = 'San Francisco')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.166", "db_id": "bike_1", "question": "How many trips did not end in San Francisco?", "rationale": ["Identify the requirement: We need to count the number of trips that did not end in San Francisco.", "The relevant table for trips is the 'trip' table, which contains the 'end_station_name' column.", "To find trips that did not end in San Francisco, we can use a WHERE clause to filter out those trips.", "We will use COUNT(*) to count the total number of trips that meet the criteria.", "The final SQL query will select the count of trips where the end station name is not 'San Francisco'."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != 'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip WHERE end_station_name != 'San Francisco'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.167", "db_id": "bike_1", "question": "In zip code 94107, on which day neither Fog nor Rain was not observed?", "rationale": ["Identify the relevant zip code from the weather table, which is 94107.", "Filter the weather records for the specified zip code.", "Check for days where the weather events do not include 'Fog' or 'Rain'.", "Select distinct dates that meet the criteria."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT date FROM weather WHERE zip_code = 94107 AND events NOT IN ('Fog', 'Rain')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n        \"virtual_table\": \"SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.168", "db_id": "bike_1", "question": "On which day has it neither been foggy nor rained in the zip code of 94107?", "rationale": ["Identify the relevant table: The 'weather' table contains the necessary information about weather conditions.", "Determine the conditions for the query: We need to find days with no fog (indicated by max_dew_point_f < 32) and no rain (indicated by precipitation_inches = 0).", "Filter by the specific zip code: We are interested in the zip code 94107.", "Select distinct dates: We want to retrieve unique dates that meet the specified conditions."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT date FROM weather WHERE zip_code = 94107 AND max_dew_point_f < 32 AND precipitation_inches = 0", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n        \"virtual_table\": \"SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.183", "db_id": "bike_1", "question": "List all the cities in a decreasing order of each city's stations' highest latitude.", "rationale": ["We need to list all the cities from the station table.", "To find the highest latitude for each city, we will use the MAX function on the 'lat' column.", "We will group the results by 'city' to ensure we get the highest latitude for each city.", "Finally, we will order the results in decreasing order of the highest latitude using ORDER BY clause."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, MAX(lat) as highest_latitude\nFROM station\nGROUP BY city\nORDER BY highest_latitude DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.184", "db_id": "bike_1", "question": "For each city, list their names in decreasing order by their highest station latitude.", "rationale": ["Identify the relevant table: The 'station' table contains the necessary information about bike stations, including their names and latitude coordinates.", "Select the required columns: We need to select the 'city' and 'name' columns from the 'station' table.", "Order the results: We need to order the results by the 'lat' column in descending order to get the highest latitude first.", "Ensure we include all cities: We will not filter by specific cities, so we will include all entries where the city is not null."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, name FROM station WHERE city IS NOT NULL ORDER BY lat DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.189", "db_id": "bike_1", "question": "For each station, return its longitude and the average duration of trips that started from the station.", "rationale": ["Identify the required columns: longitude from the station table and average duration from the trip table.", "The longitude is found in the 'station' table under the 'long' column.", "The average duration of trips is calculated from the 'trip' table under the 'duration' column.", "To get the average duration for each station, we need to join the 'station' table with the 'trip' table on the station ID.", "Group the results by the station ID to calculate the average duration for each station.", "Select the longitude and the calculated average duration in the final output."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT S.long, AVG(T.duration) AS average_duration\nFROM station AS S\nJOIN trip AS T ON S.id = T.start_station_id\nGROUP BY S.id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n        \"virtual_table\": \"SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] EXCEPT SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.190", "db_id": "bike_1", "question": "For each start station id, what is its name, longitude and average duration of trips started there?", "rationale": ["Identify the relevant tables: 'trip' for trip details and 'station' for station details.", "We need to select the start station id, start station name, longitude of the station, and the average duration of trips.", "To get the average duration, we will use the AVG() function on the 'duration' column from the 'trip' table.", "We will join the 'trip' table with the 'station' table on the 'start_station_id' and 'id' columns to get the longitude of the station.", "Group the results by 'start_station_id', 'start_station_name', and 'station.long' to calculate the average duration for each station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT start_station_id, start_station_name, station.long, AVG(duration) AS average_duration\nFROM trip\nJOIN station ON trip.start_station_id = station.id\nGROUP BY start_station_id, start_station_name, station.long", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.192", "db_id": "bike_1", "question": "For each end station id, what is its name, latitude, and minimum duration for trips ended there?", "rationale": ["Identify the required columns: end station id, name, latitude, and minimum duration for trips ended at each station.", "The 'trip' table contains the end station id and duration of trips, while the 'station' table contains the name and latitude of the stations.", "To get the desired information, we need to join the 'trip' table with the 'station' table on the end station id.", "We will group the results by end station id, name, and latitude to calculate the minimum duration for each end station."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT end_station_id, name, lat, MIN(duration) AS min_duration \nFROM trip \nJOIN station ON trip.end_station_id = station.id \nGROUP BY end_station_id, name, lat;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.196", "db_id": "bike_1", "question": "What are all the different zip codes that have a maximum dew point that was always below 70?", "rationale": ["The question asks for unique zip codes with a maximum dew point always below 70.", "To find these zip codes, we can use the EXCEPT clause to exclude any zip codes that have a maximum dew point of 70 or above.", "The virtual table provided in the hint gives a template for this query, where we replace the placeholder with 70 to filter the results accordingly."], "gold_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f >= 70", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n        \"virtual_table\": \"SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.205", "db_id": "bike_1", "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.", "rationale": ["We need to find zip codes where the average mean humidity is below 70 and at least 100 trips took place.", "To achieve this, we will join the 'weather' table with the 'trip' table on the zip code.", "We will group the results by zip code to calculate the average mean humidity and count the number of trips for each zip code.", "In the HAVING clause, we will filter for average mean humidity less than 70 and ensure that the count of trips is at least 100."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT T3.zip_code \nFROM weather AS T3 \nJOIN trip AS T1 ON T3.zip_code = T1.zip_code \nGROUP BY T3.zip_code \nHAVING avg(T3.mean_humidity) < 70 AND COUNT(T1.id) >= 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.206", "db_id": "bike_1", "question": "What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?", "rationale": ["Identify the relevant tables: We need to use the 'trip' table to count the number of trips per zip code and the 'weather' table to calculate the average mean humidity per zip code.", "Join the tables: We will need to join the 'trip' table with the 'weather' table on the zip code to get the mean humidity for each zip code.", "Group by zip code: We will group the results by zip code to calculate the average mean humidity and count the number of trips.", "Apply conditions: We will filter the results to include only those zip codes that have at least 100 trips and an average mean humidity below 70."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code \nFROM trip \nGROUP BY zip_code \nHAVING COUNT(id) >= 100 AND AVG(mean_humidity) < 70;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n        \"virtual_table\": \"SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.304", "db_id": "product_catalog", "question": "What are the attribute data types with more than 3 attribute definitions?", "rationale": ["Identify the table that contains the attribute definitions, which is 'Attribute_Definitions'.", "Determine the relevant column that contains the data types of the attributes, which is 'attribute_data_type'.", "We need to group the results by 'attribute_data_type' to count how many attribute definitions exist for each data type.", "Use the HAVING clause to filter the groups where the count of 'attribute_id' is greater than 3."], "gold_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  3", "source_tables": ["attribute_definitions"], "pred_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING COUNT(attribute_id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.316", "db_id": "product_catalog", "question": "Find the entry names of the catalog with the attribute that have the most entries.", "rationale": ["Identify the tables involved: Catalog_Contents for entry names and Catalog_Contents_Additional_Attributes for attributes.", "Determine the relationship between the tables: Join Catalog_Contents with Catalog_Contents_Additional_Attributes on catalog_entry_id.", "Find the attribute value that has the most entries: Use a subquery to group by attribute_value and order by count, limiting to the top result.", "Construct the main query to select catalog_entry_name where the attribute_value matches the most common one."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id = t2.catalog_entry_id WHERE t2.attribute_value = (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.317", "db_id": "product_catalog", "question": "What is the entry name of the most expensive catalog (in USD)?", "rationale": ["Identify the relevant table: The 'Catalog_Contents' table contains the 'catalog_entry_name' and 'price_in_dollars' columns.", "Determine the requirement: We need to find the entry name of the most expensive catalog in USD, which means we need to find the maximum value in the 'price_in_dollars' column.", "Construct a subquery to find the maximum price: We can use a subquery to select the maximum price from the 'Catalog_Contents' table.", "Join the subquery with the main query: We will select the 'catalog_entry_name' from 'Catalog_Contents' where the 'price_in_dollars' matches the maximum price found in the subquery."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE price_in_dollars = (SELECT MAX(price_in_dollars) FROM Catalog_Contents)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.330", "db_id": "product_catalog", "question": "What are the names of catalog entries with level number 8?", "rationale": ["Identify the relevant table: The question asks for catalog entries, which are found in the 'Catalog_Contents' table.", "Determine the filtering criteria: The level number specified in the question is '8'.", "Construct the SQL query: Select the 'catalog_entry_name' from 'Catalog_Contents' where 'catalog_level_number' equals '8'."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  '8'", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE catalog_level_number = '8'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.331", "db_id": "product_catalog", "question": "Find the names of the products with length smaller than 3 or height greater than 5.", "rationale": ["Identify the relevant table: The question asks for product names, which are found in the Catalog_Contents table under the column catalog_entry_name.", "Determine the conditions: The conditions specified are that the length must be smaller than 3 or the height must be greater than 5.", "Construct the SQL query: Use a SELECT statement to retrieve the catalog_entry_name from the Catalog_Contents table where the specified conditions are met."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name \nFROM Catalog_Contents \nWHERE length < 3 OR height > 5;", "hint": "\n"}
{"sample_id": "train.332", "db_id": "product_catalog", "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.", "rationale": ["Identify the relevant table: The question asks about catalog contents, which are stored in the 'Catalog_Contents' table.", "Determine the filtering criteria: The question specifies lengths below 3 or above 5, so we need to filter based on the 'length' column.", "Select the desired output: We need to retrieve the 'catalog_entry_name' for the entries that meet the length criteria.", "Construct the SQL query: Combine the selected columns and filtering conditions into a valid SQL SELECT statement."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE length < 3 OR length > 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.338", "db_id": "product_catalog", "question": "On which days more than one revisions were made on catalogs.", "rationale": ["Identify the relevant table: The 'Catalogs' table contains the revision dates.", "Group the records by the 'date_of_latest_revision' to aggregate the counts of catalogs for each revision date.", "Use the HAVING clause to filter the groups where the count of catalogs is greater than one, indicating multiple revisions on that date."], "gold_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1", "source_tables": ["catalogs"], "pred_sql": "SELECT date_of_latest_revision \nFROM Catalogs \nGROUP BY date_of_latest_revision \nHAVING count(*) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table provides the latest revision dates of catalogs from the 'Catalogs' table, grouped by the revision date. The placeholder in the HAVING clause represents the minimum count of catalogs that must share the same revision date.\",\n        \"virtual_table\": \"SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flight origins and destinations.", "Determine the required information: We need to find the origins of flights that are headed to Honolulu.", "Construct the SQL query: Use a SELECT statement to retrieve the 'origin' column from the 'flight' table where the 'destination' is 'Honolulu'."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight WHERE destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\",\n        \"virtual_table\": \"SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the required columns: We need the 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We want flights that originate from 'LA' and have 'Honolulu' as the destination.", "Construct the SQL query: Use a SELECT statement to retrieve the specified columns from the 'flight' table with the appropriate WHERE clause."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\",\n        \"virtual_table\": \"SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the necessary information about flights, including their prices and origins.", "Determine the required calculation: We need to calculate the average price of flights, which can be done using the AVG() function.", "Specify the conditions: We need to filter the flights to only include those that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query: Using the identified table, calculation, and conditions, we can construct the SQL query to find the average price of flights from LA to Honolulu."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT avg(price) FROM flight WHERE origin = 'LA' AND destination = 'Honolulu'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\",\n        \"virtual_table\": \"SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["Identify the tables needed: 'flight' for flight data and 'aircraft' for aircraft names.", "Join the 'flight' table with the 'aircraft' table on the aircraft ID (aid) to get the names of the aircraft associated with each flight.", "Use COUNT to count the number of flights for each aircraft.", "Group the results by the aircraft ID to get the count for each aircraft.", "Select the aircraft name and the count of flights as the final output."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT T2.name, COUNT(T1.aid) AS number_of_flights \nFROM flight AS T1 \nJOIN aircraft AS T2 ON T1.aid = T2.aid \nGROUP BY T2.aid", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables needed: 'aircraft' for aircraft names and 'flight' for flight counts.", "Use a LEFT JOIN to include all aircraft, even those with no flights.", "Count the number of flights for each aircraft using COUNT(flight.flno).", "Group the results by aircraft ID to get the count for each aircraft.", "Select the aircraft name and the count of flights as the final output."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT aircraft.name, COUNT(flight.flno) AS flight_count \nFROM aircraft \nLEFT JOIN flight ON aircraft.aid = flight.aid \nGROUP BY aircraft.aid;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["Identify the main table to query: employee table for employee names.", "Use the EXCEPT clause to find employees who are not certified for a specific aircraft.", "Join the employee table with the certificate table to find certified employees.", "Join the certificate table with the aircraft table to filter by the specific aircraft model 'Boeing 737-800'.", "Construct the SQL query using the provided virtual table structure, replacing the placeholder with 'Boeing 737-800'."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT name FROM employee EXCEPT SELECT T1.name FROM employee AS T1 JOIN certificate AS T2 ON T1.eid = T2.eid JOIN aircraft AS T3 ON T3.aid = T2.aid WHERE T3.name = 'Boeing 737-800'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\",\n        \"virtual_table\": \"SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["Identify the tables involved: 'certificate' for employee certifications and 'aircraft' for aircraft details.", "Join the 'certificate' table with the 'aircraft' table on the aircraft ID (aid) to get the names of the aircraft along with their certification counts.", "Group the results by aircraft ID to count how many employees have certificates for each aircraft.", "Order the results by the count of certifications in ascending order to find the aircraft with the fewest certifications.", "Limit the results to 1 to get only the aircraft with the fewest certifications."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT T2.name FROM certificate AS T1 JOIN aircraft AS T2 ON T2.aid = T1.aid GROUP BY T2.aid ORDER BY COUNT(T1.eid) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.432", "db_id": "flight_1", "question": "What are the names of the aircraft that the least people are certified to fly?", "rationale": ["Identify the relevant tables: We need to look at the 'certificate' table to find out how many employees are certified to fly each aircraft, and the 'aircraft' table to get the names of those aircraft.", "Join the tables: We will join the 'certificate' table with the 'aircraft' table on the aircraft ID (aid) to link certifications to aircraft names.", "Group by aircraft: We will group the results by the aircraft ID to count the number of certifications for each aircraft.", "Count certifications: We will use COUNT() to count the number of employees certified for each aircraft.", "Order by count: We will order the results in ascending order based on the count of certifications to find the aircraft with the least certifications.", "Limit the results: We will limit the results to 1 to get only the aircraft with the least number of certifications."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT T2.name FROM certificate AS T1 JOIN aircraft AS T2 ON T2.aid = T1.aid GROUP BY T1.aid ORDER BY COUNT(T1.eid) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["Identify the tables involved: employee, certificate, and aircraft.", "We need to join these tables to get the employee names and their salaries based on the certificates they hold for aircraft that can travel more than 5000 miles.", "The join conditions are: employee.eid = certificate.eid and aircraft.aid = certificate.aid.", "We filter the aircraft based on the distance condition (greater than 5000).", "We group the results by employee ID to count the number of certificates each employee holds.", "We order the results by the count of certificates in descending order to get the employee with the most certificates.", "Finally, we limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT T1.name, E.salary FROM employee AS T1 JOIN certificate AS T2 ON T1.eid = T2.eid JOIN aircraft AS T3 ON T3.aid = T2.aid WHERE T3.distance > 5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The question asks for all the different food allergies, which implies we need to retrieve unique allergy names.", "We will select the 'Allergy' column from the 'Allergy_Type' table.", "Using DISTINCT ensures that we only get unique allergy names, avoiding duplicates."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Allergy_Type", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    }\n}\n"}
{"sample_id": "train.452", "db_id": "allergy_1", "question": "How many animal type allergies exist?", "rationale": ["Identify the relevant table: Allergy_Type contains the allergy types.", "Determine the specific allergy type we are interested in: 'Animal'.", "Construct a SQL query to count the number of entries in the Allergy_Type table where the AllergyType is 'Animal'."], "gold_sql": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  'animal'", "source_tables": ["allergy_type"], "pred_sql": "SELECT COUNT(*) FROM Allergy_Type WHERE AllergyType = 'Animal';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["Identify the relevant tables: Allergy_Type contains allergy names and types, while Has_Allergy links students to their allergies.", "To find the allergy type with the most allergies, we need to count the number of allergies for each type.", "We can use the COUNT function to count the occurrences of each allergy type.", "We will group the results by AllergyType to aggregate the counts for each type.", "Finally, we will order the results in descending order based on the count and limit the results to the top one to get the allergy type with the most allergies."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(Allergy) AS AllergyCount FROM Allergy_Type GROUP BY AllergyType ORDER BY AllergyCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["Identify the relevant tables: We need to look at the 'Has_Allergy' table to see how many students have each allergy, and the 'Allergy_Type' table to categorize those allergies by type.", "Join the tables: We will join 'Has_Allergy' with 'Allergy_Type' on the 'Allergy' column to get the allergy type for each student.", "Count the occurrences: We will count how many times each allergy type appears in the 'Has_Allergy' table using COUNT(*) and group the results by 'AllergyType'.", "Order the results: To find the least common allergy type, we will order the results in ascending order based on the count of allergies.", "Limit the results: Finally, we will limit the results to 1 to get only the least common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(*) AS AllergyCount FROM Has_Allergy JOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy GROUP BY AllergyType ORDER BY AllergyCount ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student information, which is the 'Student' table.", "Determine the columns needed to get the full names of the students, which are 'Fname' and 'LName'.", "Construct the SQL query to select 'Fname' and 'LName' from the 'Student' table."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname, LName FROM Student;", "hint": "\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the table that contains student information, which is the 'Student' table.", "Determine the relevant column for filtering male students, which is the 'Sex' column.", "Construct a SQL SELECT statement to retrieve the 'StuID' for students where 'Sex' is equal to 'Male'."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male';", "hint": "\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the major information, which is the 'Student' table.", "To find the largest major, we need to count the number of students in each major.", "We will use the COUNT function to count the number of students for each major.", "We will group the results by the 'Major' column to get the count for each major.", "To find the largest major, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.502", "db_id": "allergy_1", "question": "Give the advisor with the most students.", "rationale": ["We need to find the advisor with the most students, which requires counting the number of students for each advisor.", "The relevant table for this information is the 'Student' table, which contains the 'Advisor' and 'StuID' columns.", "We will use the COUNT() function to count the number of students (StuID) for each advisor.", "We will group the results by the 'Advisor' column to get the count for each advisor.", "To find the advisor with the most students, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get only the advisor with the highest count."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(StuID) AS StudentCount\nFROM Student\nGROUP BY Advisor\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["Identify the relevant tables: We need to find students with cat allergies, so we will use the Has_Allergy table.", "Determine the specific allergy: The allergy we are interested in is 'cat'.", "Count the number of unique students: We will use COUNT(DISTINCT StuID) to ensure we count each student only once, even if they have multiple entries for the same allergy."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(DISTINCT StuID) FROM Has_Allergy WHERE Allergy = 'cat';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the tables needed: We need to count students, so we will use the Student table and the Has_Allergy table to find students with cat allergies.", "Determine the relationship: The Has_Allergy table links students to their allergies via StuID, which is also present in the Student table.", "Filter for cat allergies: We need to filter the results to only include records where the allergy is 'cat'.", "Count distinct students: We will use COUNT(DISTINCT S.StuID) to ensure we count each student only once, even if they have multiple records for the same allergy."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(DISTINCT S.StuID) FROM Student S JOIN Has_Allergy H ON S.StuID = H.StuID WHERE H.Allergy = 'cat';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the gender of the students we are interested in, which is 'Female'.", "Determine the allergies we are interested in, which are 'Milk' and 'Eggs'.", "Use a subquery to find the student IDs (StuID) of students who have either 'Milk' or 'Eggs' allergies by joining the Has_Allergy and Allergy_Type tables.", "Count the number of students from the Student table who are female and whose StuID is in the list obtained from the subquery."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT count(*) FROM Student WHERE Sex = 'Female' AND StuID IN (SELECT StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy IN ('Milk', 'Eggs'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.514", "db_id": "allergy_1", "question": "Which allergy is the most common?", "rationale": ["To find the most common allergy, we need to count how many students have each type of allergy.", "We will use the Has_Allergy table, which contains the student IDs and their corresponding allergies.", "We will group the results by the Allergy column to get the count of each allergy.", "We will order the results in descending order based on the count of allergies to get the most common one at the top.", "Finally, we will limit the results to just one entry to get the most common allergy."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT Allergy, COUNT(*) as AllergyCount FROM Has_Allergy GROUP BY Allergy ORDER BY AllergyCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["Identify the tables needed: Student, Has_Allergy, and Allergy_Type.", "We need to find students with specific allergies (milk and cat).", "Use the Has_Allergy table to find students (StuID) who have these allergies.", "Join Has_Allergy with Allergy_Type to filter by allergy names (milk and cat).", "Use INTERSECT to find students who have both allergies.", "Select the last name (LName) and age (Age) of these students from the Student table."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT LName, Age FROM Student WHERE StuID IN (SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'milk' INTERSECT SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the relevant tables: Student, Has_Allergy, and Allergy_Type.", "We need to find students who have allergies to both milk and cat.", "Use the Has_Allergy table to find students with specific allergies by joining it with the Allergy_Type table.", "Use the INTERSECT operator to find students who have both allergies.", "Select the last names and ages of these students from the Student table."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT LName, Age FROM Student WHERE StuID IN (SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'milk' INTERSECT SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.523", "db_id": "allergy_1", "question": "Find the first name and gender of the student who has allergy to milk but not cat.", "rationale": ["Identify the tables needed: Student, Has_Allergy.", "We need to find students with a specific allergy (milk) and exclude those with another allergy (cat).", "Join the Student table with the Has_Allergy table to get the necessary student information along with their allergies.", "Use a WHERE clause to filter for students who have the allergy to milk.", "Use a subquery to exclude students who have an allergy to cat by checking their StuID in the Has_Allergy table."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.Fname, S.Sex \nFROM Student AS S \nJOIN Has_Allergy AS HA ON S.StuID = HA.StuID \nWHERE HA.Allergy = 'milk' \nAND S.StuID NOT IN ( \n    SELECT HA2.StuID \n    FROM Has_Allergy AS HA2 \n    WHERE HA2.Allergy = 'cat' \n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    }\n}\n"}
{"sample_id": "train.524", "db_id": "allergy_1", "question": "What are the first name and gender of the students who have allergy to milk but can put up with cats?", "rationale": ["Identify the tables needed: We need to get student information (first name and gender) and their allergies, so we will use the Student, Has_Allergy, and Allergy_Type tables.", "Join the tables: We will join the Student table with the Has_Allergy table to get the allergies for each student. Then, we will join the Allergy_Type table to get the type of each allergy.", "Filter for specific allergies: We need to filter for students who have an allergy to 'milk' and can put up with 'cats'. This means we will need to join the Has_Allergy table twice, once for each allergy, and apply the appropriate filters in the WHERE clause.", "Select the required fields: Finally, we will select the first name and gender of the students who meet the criteria."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.Fname, S.Sex \nFROM Student AS S \nJOIN Has_Allergy AS HA1 ON S.StuID = HA1.StuID \nJOIN Allergy_Type AS AT1 ON HA1.Allergy = AT1.Allergy \nJOIN Has_Allergy AS HA2 ON S.StuID = HA2.StuID \nJOIN Allergy_Type AS AT2 ON HA2.Allergy = AT2.Allergy \nWHERE AT1.Allergy = 'milk' AND AT2.Allergy = 'cats' \nAND AT2.AllergyType = 'can put up with'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    }\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the tables involved: Student, Has_Allergy, and Allergy_Type.", "Determine the columns needed: average age from Student and filtering based on allergies from Has_Allergy and Allergy_Type.", "Use a subquery to find students with both food and animal allergies.", "The subquery uses INTERSECT to ensure that only students with both types of allergies are selected.", "Calculate the average age of the filtered students using the AVG function."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT avg(Age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'food' INTERSECT SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'animal')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["Identify the requirement: We need the full names of students who are not allergic to any type of food.", "Understand the schema: We have three tables - Student, Has_Allergy, and Allergy_Type.", "Determine the allergies related to food: We can find these allergies by querying the Allergy_Type table where AllergyType is 'Food'.", "Construct a subquery to find all StuIDs of students who have any food allergies using the Has_Allergy table.", "Use the NOT IN clause to filter out these students from the main query that selects from the Student table.", "Select the last name (LName) and first name (Fname) of the students who do not have any food allergies."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT LName, Fname FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy IN (SELECT Allergy FROM Allergy_Type WHERE AllergyType = 'Food'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being checked against the students' allergies.\",\n        \"virtual_table\": \"SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["Identify the requirement: Count male students allergic to any type of food.", "The query needs to filter students based on their sex and their allergies.", "Use the 'Student' table to filter by sex ('M').", "Join 'Has_Allergy' and 'Allergy_Type' to find students with food allergies.", "Count the number of students that meet both criteria."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT count(*) FROM Student WHERE Sex = 'M' AND StuID IN (SELECT StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'Food')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables needed: We need to get student information (first names and city codes) and their allergies, so we will use the Student and Has_Allergy tables.", "Determine the relationship: The Has_Allergy table links students to their allergies via StuID, which is also present in the Student table.", "Select the required fields: We need the distinct first names (Fname) and city codes (city_code) of students with specific allergies.", "Filter the results: We want students who have allergies to either 'milk' or 'cat', so we will use a WHERE clause with an IN condition to filter these allergies.", "Construct the SQL query: Combine the SELECT statement with JOINs and the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code \nFROM Student AS S \nJOIN Has_Allergy AS H ON S.StuID = H.StuID \nWHERE H.Allergy IN ('milk', 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    }\n}\n"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["Identify the tables needed: We need data from the Student and Has_Allergy tables.", "We need to find students with specific allergies, so we will join the Has_Allergy table with the Student table on StuID.", "We are looking for students who have allergies to either 'milk' or 'cat', so we will use a WHERE clause with the IN operator to filter these allergies.", "We want distinct first names and cities, so we will select DISTINCT S.Fname and S.city_code."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code \nFROM Student AS S \nJOIN Has_Allergy AS HA ON S.StuID = HA.StuID \nWHERE HA.Allergy IN ('milk', 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    }\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["We need to find the names of the countries and the average invoice size.", "The relevant table for this information is the 'invoices' table, which contains the 'billing_country' and 'total' columns.", "To get the average invoice size per country, we will use the AVG() function on the 'total' column and group the results by 'billing_country'.", "Finally, we will order the results by the average invoice size in descending order to get the top countries by size."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size \nFROM invoices \nGROUP BY billing_country \nORDER BY average_invoice_size DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["Identify the relevant table: The 'invoices' table contains the necessary information about invoices and their billing states.", "Determine the required output: We need to count the number of invoices and sum the total amount billed for each state.", "Use the COUNT() function to count the number of invoices and the SUM() function to calculate the total amount billed.", "Group the results by 'billing_state' to get the totals for each state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS total_invoices, SUM(total) AS total_amount_billed FROM invoices GROUP BY billing_state;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["Identify the relevant table: invoices, which contains billing information including state and country.", "Determine the columns needed: billing_state for the state and a count of invoices for each state.", "Filter the results by country, which is specified in the hint as 'USA'.", "Group the results by billing_state to get the count of invoices per state.", "Order the results by the count of invoices in descending order to find the states with the most invoices."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) FROM invoices WHERE billing_country = 'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.568", "db_id": "store_1", "question": "What is the number of invoices and total money billed in them from CA?", "rationale": ["Identify the relevant table: The 'invoices' table contains the necessary information about invoices and their billing states.", "Determine the required fields: We need to count the number of invoices and sum the total amount billed, which corresponds to COUNT(*) and SUM(total) respectively.", "Apply the filter: We need to filter the results to only include invoices from California (CA), which is done using the WHERE clause.", "Construct the SQL query: Combine the selected fields, the table, and the filter into a complete SQL query."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS number_of_invoices, SUM(total) AS total_billed FROM invoices WHERE billing_state = 'CA';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the relevant table: The 'employees' table contains the information needed (email and phone number).", "Determine the specific employee: The question specifies 'Astrid Gruber', so we need to filter the records based on the first name 'Astrid' and last name 'Gruber'.", "Construct the SQL query: Using the identified table and the filtering criteria, the SQL query is constructed to select the email and phone number of the specified employee."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles, phone numbers, and hire dates of employees from the 'employees' table who have a specific first and last name. The placeholders in the WHERE clause represent the first and last names of the employee.\",\n        \"virtual_table\": \"SELECT title ,  phone ,  hire_date FROM employees WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["Identify the relevant table: The 'customers' table contains information about customers, including their state of residence.", "Determine the condition: We need to count customers specifically from California, which is indicated by the 'state' column.", "Construct the SQL query: Use the COUNT function to count the number of rows in the 'customers' table where the 'state' is 'California'."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) FROM customers WHERE state = 'California';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: employees and customers.", "Join the employees table with the customers table on the support representative ID.", "Group the results by employee ID to count the number of customers each employee supports.", "Order the results in descending order based on the count of customers supported.", "Limit the results to 1 to get the employee who supports the most customers."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT T1.first_name, T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id = T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees who serve as support representatives for customers. The results are grouped by the employee's unique identifier and ordered by the number of customers they support in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of employees to return.\",\n        \"virtual_table\": \"SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["Identify the customer 'Luca Mancini' by querying the 'customers' table to get his unique identifier (id).", "Use the retrieved customer id to count the number of invoices associated with that customer in the 'invoices' table.", "The final SQL query combines these steps to return the total count of invoices for Luca Mancini."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "pred_sql": "SELECT COUNT(*) FROM invoices WHERE customer_id = (SELECT id FROM customers WHERE first_name = 'Luca' AND last_name = 'Mancini');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["Identify the tables involved: We need to find the album title for a specific track, so we will use the 'albums' and 'tracks' tables.", "Determine the relationship: The 'tracks' table has a foreign key 'album_id' that links to the 'albums' table's 'id'.", "Formulate the SQL query: We will select the 'title' from the 'albums' table where the 'id' matches the 'album_id' in the 'tracks' table for the track named 'Balls to the Wall'.", "Use a JOIN to connect the 'albums' and 'tracks' tables based on the album_id and id relationship."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT albums.title \nFROM albums \nJOIN tracks ON albums.id = tracks.album_id \nWHERE tracks.name = 'Balls to the Wall';", "hint": "\n"}
{"sample_id": "train.626", "db_id": "store_1", "question": "What is the name of all tracks in the album named Balls to the Wall?", "rationale": ["Identify the relevant tables: tracks and albums.", "We need to find tracks that belong to a specific album, so we will join the tracks table with the albums table using the album_id foreign key.", "The condition for the join will be that the album's title matches 'Balls to the Wall'.", "Select the name of the tracks from the resulting joined table."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN albums ON tracks.album_id = albums.id \nWHERE albums.title = 'Balls to the Wall';", "hint": "\n"}
{"sample_id": "train.630", "db_id": "store_1", "question": "What are the names of all Rock tracks that are stored on MPEG audio files?", "rationale": ["Identify the relevant tables: tracks, media_types, and genres are needed to get track names, media type, and genre respectively.", "Join the tracks table with media_types on media_type_id to filter tracks based on their media type.", "Join the tracks table with genres on genre_id to filter tracks based on their genre.", "Use a WHERE clause to specify that we want tracks that are of the genre 'Rock' and are stored in 'MPEG audio' files."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN media_types ON tracks.media_type_id = media_types.id \nJOIN genres ON tracks.genre_id = genres.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG audio';", "hint": "\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the tables involved: tracks, genres, and media_types.", "We need to select the track names, so we will select 'tracks.name'.", "To filter tracks by genre, we will join the 'tracks' table with the 'genres' table on 'tracks.genre_id = genres.id'.", "To filter tracks by media type, we will join the 'tracks' table with the 'media_types' table on 'tracks.media_type_id = media_types.id'.", "We will add a WHERE clause to filter for the genre 'Rock' and the media type 'MPEG'.", "Combine all these elements to form the final SQL query."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN genres ON tracks.genre_id = genres.id \nJOIN media_types ON tracks.media_type_id = media_types.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG';", "hint": "\n"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["Identify the relevant tables: tracks, invoice_lines, invoices, and customers are needed to find the tracks bought by a specific customer.", "Join the tracks table with the invoice_lines table on the track_id to get the invoice details for each track.", "Join the invoice_lines table with the invoices table on the invoice_id to link the invoices to the customers.", "Join the invoices table with the customers table on the customer_id to filter by the specific customer, Dean Peeters.", "Use a WHERE clause to specify the first name and last name of the customer to filter the results."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN invoice_lines ON tracks.id = invoice_lines.track_id \nJOIN invoices ON invoice_lines.invoice_id = invoices.id \nJOIN customers ON invoices.customer_id = customers.id \nWHERE customers.first_name = 'Dean' AND customers.last_name = 'Peeters';", "hint": "\n"}
{"sample_id": "train.686", "db_id": "customers_card_transactions", "question": "What are the full names of customers who do not have any accounts?", "rationale": ["Identify the tables involved: Customers and Accounts.", "We need to find customers who do not have any accounts, which means we need to look for customer IDs in the Customers table that are not present in the Accounts table.", "Use a subquery to select customer_ids from the Accounts table.", "Use the NOT IN clause to filter out those customer_ids from the Customers table.", "Select the first and last names of the customers who meet this criteria."], "gold_sql": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name, customer_last_name FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.688", "db_id": "customers_card_transactions", "question": "What are the full names of customers who have accounts?", "rationale": ["Identify the tables involved: Accounts and Customers.", "Determine the relationship between the tables: Accounts has a foreign key 'customer_id' that links to Customers.", "Select the relevant columns: We need the first and last names of customers, which are in the Customers table.", "Join the Accounts table with the Customers table on the 'customer_id' to get the full names of customers who have accounts."], "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT T2.customer_first_name, T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id = T2.customer_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.704", "db_id": "customers_card_transactions", "question": "Return the full name and phone of the customer who has card number 4560596484842.", "rationale": ["Identify the required information: full name (first and last) and phone of the customer.", "Determine the relevant tables: Customers for customer details and Customers_Cards for card information.", "Establish the relationship between the tables: Customers_Cards links to Customers via customer_id.", "Formulate the SQL query to select the customer's first name, last name, and phone number where the card number matches the specified value."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.card_number  =  '4560596484842'", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT C.customer_first_name, C.customer_last_name, C.customer_phone \nFROM Customers AS C \nJOIN Customers_Cards AS CC ON C.customer_id = CC.customer_id \nWHERE CC.card_number = '4560596484842';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.717", "db_id": "customers_card_transactions", "question": "What is the customer id, first and last name with least number of accounts.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "Join the Accounts table with the Customers table on the customer_id field to get customer details associated with each account.", "Group the results by customer_id to aggregate the accounts for each customer.", "Count the number of accounts for each customer using COUNT(*) in the ORDER BY clause.", "Order the results in ascending order to find the customer with the least number of accounts.", "Limit the results to 1 to get only the customer with the least number of accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT T2.customer_id, T2.customer_first_name, T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id = T2.customer_id GROUP BY T1.customer_id ORDER BY COUNT(*) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.718", "db_id": "customers_card_transactions", "question": "Return the id and full name of the customer who has the fewest accounts.", "rationale": ["Identify the tables involved: Accounts and Customers.", "We need to join these tables on the customer_id to get customer details associated with each account.", "Group the results by customer_id to count the number of accounts each customer has.", "Order the results by the count of accounts in ascending order to find the customer with the fewest accounts.", "Limit the results to 1 to get only the customer with the fewest accounts.", "Select the customer_id and concatenate the first and last names to get the full name of the customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT T2.customer_id, T2.customer_first_name || ' ' || T2.customer_last_name AS full_name \nFROM Accounts AS T1 \nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id \nGROUP BY T1.customer_id \nORDER BY COUNT(*) ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.721", "db_id": "customers_card_transactions", "question": "What is the card type code with most number of cards?", "rationale": ["We need to find the card type code with the most number of cards.", "To do this, we will count the number of cards for each card type code in the Customers_Cards table.", "We will use the COUNT function to count the card IDs grouped by card_type_code.", "Next, we will order the results in descending order based on the count of cards.", "Finally, we will limit the results to only the top entry to get the card type code with the most cards."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "pred_sql": "SELECT card_type_code, COUNT(card_id) AS card_count \nFROM Customers_Cards \nGROUP BY card_type_code \nORDER BY card_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have a certain number of cards associated with them. The placeholder in the HAVING clause represents the minimum count of cards a customer must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.735", "db_id": "customers_card_transactions", "question": "Show the number of transaction types.", "rationale": ["Identify the table that contains transaction types, which is the Financial_Transactions table.", "To count the number of each transaction type, we need to use the COUNT() function.", "We will group the results by transaction_type to get the count for each type.", "The final SQL query will select the transaction_type and the count of transactions for each type."], "gold_sql": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, COUNT(*) AS transaction_count \nFROM Financial_Transactions \nGROUP BY transaction_type;", "hint": "\n"}
{"sample_id": "train.743", "db_id": "customers_card_transactions", "question": "What is the transaction type that has processed the greatest total amount in transactions?", "rationale": ["Identify the relevant table: Financial_Transactions contains the transaction details including type and amount.", "We need to group the transactions by their type to calculate the total amount for each type.", "Use the SUM function to calculate the total amount for each transaction type.", "Order the results in descending order to find the transaction type with the greatest total amount.", "Limit the results to 1 to get only the top transaction type."], "gold_sql": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, SUM(transaction_amount) AS total_amount\nFROM Financial_Transactions\nGROUP BY transaction_type\nORDER BY total_amount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.893", "db_id": "insurance_fnol", "question": "What are the customer phone numbers under the policy \"Life Insurance\"?", "rationale": ["Identify the relevant tables: Available_Policies, Customers_Policies, and Services.", "We need to find customer phone numbers, so we will select the 'Customer_Phone' column from the Available_Policies table.", "To link the policies to the services, we will join the Available_Policies table with the Customers_Policies table on 'Policy_ID'.", "Next, we will join the Services table to filter by the specific service name 'Life Insurance'.", "Finally, we will use a WHERE clause to specify that we only want records where the service name is 'Life Insurance'.", "Using DISTINCT ensures that we get unique phone numbers without duplicates."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nJOIN Services s ON s.Service_ID = cp.Policy_ID \nWHERE s.Service_name = 'Life Insurance';", "hint": "\n"}
{"sample_id": "train.895", "db_id": "insurance_fnol", "question": "Which policy type has the most records in the database?", "rationale": ["Identify the relevant table: The question pertains to policy types, so we will focus on the 'Available_Policies' table.", "Count the occurrences of each policy type: We will use the COUNT function to count how many times each policy type appears in the 'Available_Policies' table.", "Group the results by policy type: We will use GROUP BY to aggregate the counts for each unique policy type.", "Order the results by count in descending order: To find the policy type with the most records, we will order the results by the count in descending order.", "Limit the results to the top record: We will use LIMIT 1 to get only the policy type with the highest count."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "pred_sql": "SELECT policy_type_code, COUNT(*) as policy_count \nFROM Available_Policies \nGROUP BY policy_type_code \nORDER BY policy_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.897", "db_id": "insurance_fnol", "question": "What are all the customer phone numbers under the most popular policy type?", "rationale": ["Identify the most popular policy type by counting the occurrences of each policy type in the Available_Policies table.", "Use a subquery to select the policy_type_code that has the highest count of policies issued.", "Join the Available_Policies table with the Customers_Policies table to link policy types with customer phone numbers.", "Select distinct customer phone numbers associated with the most popular policy type."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nWHERE ap.policy_type_code = (\n    SELECT policy_type_code \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    HAVING COUNT(*) > 1 \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.898", "db_id": "insurance_fnol", "question": "Find the phone numbers of customers using the most common policy type among the available policies.", "rationale": ["Identify the most common policy type from the Available_Policies table.", "Use a subquery to find the policy type that has been issued more than a specified number of times, ordering by the count of occurrences and limiting to the top result.", "Join the Available_Policies table with the Customers_Policies table to link customers with their policies.", "Select the distinct phone numbers of customers who have the most common policy type."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nWHERE ap.policy_type_code = (\n    SELECT policy_type_code \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    HAVING COUNT(*) > 1 \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1060", "db_id": "match_season", "question": "Show the players from college UCLA.", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players and their colleges.", "Determine the condition: We need to filter players based on the college they attended, specifically 'UCLA'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Player' column from the 'match_season' table where the 'College' column matches 'UCLA'."], "gold_sql": "SELECT Player FROM match_season WHERE College  =  'UCLA'", "source_tables": ["match_season"], "pred_sql": "SELECT Player FROM match_season WHERE College = 'UCLA'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\",\n        \"virtual_table\": \"SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1082", "db_id": "match_season", "question": "Show the season, the player, and the name of the team that players belong to.", "rationale": ["Identify the columns needed: Season, Player, and Team Name.", "The Season and Player are from the match_season table.", "The Team Name is from the team table.", "To get the Team Name, we need to join the match_season table with the team table on the Team ID.", "Construct the SQL query using SELECT to retrieve the required columns and JOIN to combine the tables."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "pred_sql": "SELECT match_season.Season, match_season.Player, team.Name \nFROM match_season \nJOIN team ON match_season.Team = team.Team_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides information about the draft pick number and draft class of players from the 'match_season' table who play in a specific position. The placeholder in the WHERE clause represents the position of the player.\",\n        \"virtual_table\": \"SELECT Draft_Pick_Number ,  Draft_Class FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1092", "db_id": "match_season", "question": "Show the country names and the corresponding number of players.", "rationale": ["We need to show the country names and the corresponding number of players.", "To achieve this, we will join the 'country' table with the 'match_season' table on the 'Country_id' and 'Country' columns respectively.", "We will select the 'Country_name' from the 'country' table and count the number of players from the 'match_season' table.", "The counting will be done using the COUNT() function, and we will alias this count as 'Number_of_Players'.", "Finally, we will group the results by 'Country_name' to get the count of players for each country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "pred_sql": "SELECT Country_name, COUNT(Player) AS Number_of_Players \nFROM country \nJOIN match_season ON country.Country_id = match_season.Country \nGROUP BY Country_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of countries represented by players who occupy a specific position in matches. It uses an intersection to find countries where players in that position are participating in matches, ensuring that only countries with players in that position are returned. The placeholders in the query represent the position of the players being filtered.\",\n        \"virtual_table\": \"SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1098", "db_id": "match_season", "question": "Show the top 3 most common colleges of players in match seasons.", "rationale": ["The task is to find the top 3 most common colleges of players in match seasons.", "To achieve this, we need to count the occurrences of each college in the match_season table.", "We will use the COUNT function to count how many players attended each college.", "We will group the results by the College column to aggregate the counts for each college.", "To get the most common colleges, we will order the results in descending order based on the count of players from each college.", "Finally, we will limit the results to the top 3 colleges."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as College_Count \nFROM match_season \nGROUP BY College \nORDER BY College_Count DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\",\n        \"virtual_table\": \"SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1099", "db_id": "match_season", "question": "What are the three colleges from which the most players are from?", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players and their colleges.", "We need to count the number of players from each college, so we will use the COUNT() function.", "Group the results by 'College' to aggregate the player counts for each college.", "Order the results in descending order based on the player count to get the colleges with the most players at the top.", "Limit the results to the top three colleges using the LIMIT clause."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as Player_Count \nFROM match_season \nGROUP BY College \nORDER BY Player_Count DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\",\n        \"virtual_table\": \"SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1107", "db_id": "match_season", "question": "Return the names of countries that have players that play the Forward position, as well as players who play the Defender position.", "rationale": ["Identify the requirement to find countries with players in specific positions: Forward and Defender.", "Use the provided hint to create a virtual table that selects country names based on player positions.", "Join the 'country' table with the 'match_season' table on the country ID to filter players by their positions.", "Use the INTERSECT operator to find countries that have players in both the Forward and Defender positions."], "gold_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "pred_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of countries represented by players who occupy a specific position in matches. It uses an intersection to find countries where players in that position are participating in matches, ensuring that only countries with players in that position are returned. The placeholders in the query represent the position of the players being filtered.\",\n        \"virtual_table\": \"SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
