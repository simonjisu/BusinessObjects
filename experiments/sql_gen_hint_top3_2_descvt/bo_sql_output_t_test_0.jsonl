{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["The question asks for the IDs of students who attended some courses.", "To find this information, we need to look at the 'Student_Course_Attendance' table, which records attendance of students for courses.", "We want to select the 'student_id' from this table.", "Since a student may attend multiple courses, we use DISTINCT to ensure each student ID is listed only once."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.\",\n        \"virtual_table\": \"SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.68", "db_id": "student_assessment", "question": "What details do we have on the students who registered for courses most recently?", "rationale": ["Identify the relevant tables: 'Students' and 'Student_Course_Registrations'.", "Join the 'Student_Course_Registrations' table with the 'Students' table using the student_id to get student details for those who registered for courses.", "Order the results by the registration_date in descending order to get the most recent registrations first.", "Select the student_details from the 'Students' table to provide the required information."], "gold_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.\",\n        \"virtual_table\": \"SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["Identify the relevant tables: Candidates and Student_Course_Attendance.", "We need to find the candidate who most recently accessed a course, which implies we need to look at the attendance records.", "Join the Candidates table with the Student_Course_Attendance table on the candidate_id and student_id respectively.", "Order the results by the date_of_attendance in descending order to get the most recent attendance first.", "Limit the results to 1 to get only the most recent candidate."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT C.candidate_id FROM candidates AS C JOIN student_course_attendance AS SCA ON C.candidate_id = SCA.student_id ORDER BY SCA.date_of_attendance DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.\",\n        \"virtual_table\": \"SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.78", "db_id": "student_assessment", "question": "What are the details of the student who registered for the most number of courses?", "rationale": ["Identify the relevant tables: Students and Student_Course_Registrations.", "Join the Students table with the Student_Course_Registrations table on student_id to link students with their course registrations.", "Group the results by student_id to count the number of courses each student has registered for.", "Order the results by the count of course registrations in descending order to find the student with the most registrations.", "Limit the results to 1 to get only the student who registered for the most number of courses."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT T1.student_details FROM Students AS T1 JOIN Student_Course_Registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.\",\n        \"virtual_table\": \"SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["Identify the tables needed: Courses and Student_Course_Registrations.", "We need to count the number of students registered for each course, so we will join the Courses table with the Student_Course_Registrations table on the course_id.", "Use a LEFT JOIN to ensure we include courses even if no students are registered for them.", "Select the course_id and course_name from the Courses table, and count the student_id from the Student_Course_Registrations table to get the number of students registered for each course.", "Group the results by course_id and course_name to aggregate the student counts correctly."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT C.course_id, C.course_name, COUNT(SCR.student_id) AS student_count \nFROM Courses AS C \nLEFT JOIN Student_Course_Registrations AS SCR ON C.course_id = SCR.course_id \nGROUP BY C.course_id, C.course_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.\",\n        \"virtual_table\": \"SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.89", "db_id": "student_assessment", "question": "What is the id of the student who most recently registered course 301?", "rationale": ["Identify the relevant table for student registrations, which is 'Student_Course_Registrations'.", "Filter the records to only include those where the 'course_id' is '301'.", "Order the results by 'registration_date' in descending order to get the most recent registration first.", "Limit the results to 1 to get only the most recent student registration for course 301."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.\",\n        \"virtual_table\": \"SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.92", "db_id": "student_assessment", "question": "What are the different cities where people live?", "rationale": ["Identify the relevant table: The question asks about cities where people live, which relates to the Addresses table.", "Select the appropriate column: The 'city' column in the Addresses table contains the city names.", "Use DISTINCT to avoid duplicate city names: Since we want different cities, we will use the DISTINCT keyword to ensure each city is listed only once."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id", "source_tables": ["addresses", "people_addresses"], "pred_sql": "SELECT DISTINCT city FROM Addresses;", "hint": "\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant tables: 'Student_Course_Registrations' for course registrations and 'Students' for student details.", "Join 'Student_Course_Registrations' with 'Students' on 'student_id' to get student information along with their course registrations.", "Filter the results to include only those registrations for the course named 'Statistics'.", "Order the results by 'registration_date' to list the students in the order they registered for the course."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT T1.student_id FROM Student_Course_Registrations AS T1 JOIN Students AS T2 ON T1.student_id = T2.student_id WHERE T1.course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY T1.registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.\",\n        \"virtual_table\": \"SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant tables: 'Students' and 'Student_Course_Registrations'.", "Join 'Student_Course_Registrations' with 'Students' on 'student_id' to get student details along with their course registrations.", "Filter the results to include only those registrations for the course named 'Statistics'.", "Order the results by the 'registration_date' to get the order of registration.", "Select only the 'student_id' from the results to meet the requirement of the query."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT T1.student_id FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id WHERE T1.course_id = (SELECT course_id FROM courses WHERE course_name = 'Statistics') ORDER BY T1.registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.\",\n        \"virtual_table\": \"SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.387", "db_id": "flight_1", "question": "Show origins of all flights with destination Honolulu.", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flight origins and destinations.", "Determine the required columns: We need the 'origin' column for flights that have 'Honolulu' as their destination.", "Construct the SQL query: Use a SELECT statement to retrieve the 'origin' from the 'flight' table where the 'destination' is 'Honolulu'."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight WHERE destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\",\n        \"virtual_table\": \"SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid\"\n    }\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the required columns: We need the 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We want flights that depart from 'LA' and arrive in 'Honolulu'.", "Construct the SQL query using the SELECT statement to retrieve the specified columns from the 'flight' table with the appropriate WHERE clause."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\",\n        \"virtual_table\": \"SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid\"\n    }\n}\n"}
{"sample_id": "train.400", "db_id": "flight_1", "question": "What are the numbers of the shortest flights?", "rationale": ["Identify the relevant table: The question pertains to flights, so we will focus on the 'flight' table.", "Determine the required information: We need the flight numbers of the shortest flights, which implies we need to sort the flights by distance.", "Construct the SQL query: We will select the flight number (flno) from the flight table, order the results by distance in ascending order, and limit the results to the shortest flight."], "gold_sql": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT 3", "source_tables": ["flight"], "pred_sql": "SELECT flno FROM flight ORDER BY distance ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\",\n        \"virtual_table\": \"SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' table with the 'Aircraft' table based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of aircraft names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.408", "db_id": "flight_1", "question": "What place has the most flights coming from there?", "rationale": ["Identify the table that contains flight information, which is the 'flight' table.", "We need to find out which place has the most flights coming from there, so we will focus on the 'origin' column in the 'flight' table.", "To count the number of flights from each origin, we will use the COUNT() function and group the results by the 'origin' column.", "To get the place with the most flights, we will order the results in descending order based on the flight count.", "Finally, we will limit the results to just one entry to get the top origin with the most flights."], "gold_sql": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "pred_sql": "SELECT origin, COUNT(*) as flight_count FROM flight GROUP BY origin ORDER BY flight_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\",\n        \"virtual_table\": \"SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' table with the 'Aircraft' table based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of aircraft names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables involved: 'flight' and 'aircraft'.", "We need to retrieve the name of each aircraft, which is in the 'aircraft' table.", "We also need to count the number of flights associated with each aircraft, which is in the 'flight' table.", "Join the 'flight' table (T1) with the 'aircraft' table (T2) on the aircraft ID (aid).", "Use the COUNT function to count the number of flights for each aircraft.", "Group the results by the aircraft ID to ensure we get a count for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT T2.name, count(*) FROM flight AS T1 JOIN aircraft AS T2 ON T1.aid = T2.aid GROUP BY T1.aid", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\",\n        \"virtual_table\": \"SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' table with the 'Aircraft' table based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of aircraft names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.429", "db_id": "flight_1", "question": "Show names for all employees who do not have certificate of Boeing 737-800.", "rationale": ["Identify the employees who do not have a certificate for the Boeing 737-800.", "To do this, we need to find the employee IDs (eid) that are associated with the Boeing 737-800 in the certificate table.", "We first find the aircraft ID (aid) for the Boeing 737-800 from the aircraft table.", "Then, we select the employee IDs from the certificate table that match this aircraft ID.", "Finally, we select the names of employees from the employee table whose IDs are not in the list of IDs obtained from the previous step."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT name FROM employee WHERE eid NOT IN (SELECT eid FROM certificate WHERE aid = (SELECT aid FROM aircraft WHERE name = 'Boeing 737-800'));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' table with the 'Aircraft' table based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of aircraft names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\",\n        \"virtual_table\": \"SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid\"\n    }\n}\n"}
{"sample_id": "train.433", "db_id": "flight_1", "question": "Show the name and distance of the aircrafts with more than 5000 distance and which at least 5 people have its certificate.", "rationale": ["Identify the tables involved: 'certificate' for the number of certificates and 'aircraft' for aircraft details.", "Join the 'certificate' table with the 'aircraft' table on the aircraft ID (aid).", "Group the results by aircraft ID to count the number of certificates for each aircraft.", "Use the HAVING clause to filter for aircraft that have more than 5 certificates.", "Also, filter for aircraft that have a distance greater than 5000.", "Select the name and distance of the aircraft that meet these criteria."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT T2.name, T2.distance FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid = T1.aid GROUP BY T1.aid HAVING count(*) > 5 AND T2.distance > 5000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' table with the 'Aircraft' table based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of aircraft names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\",\n        \"virtual_table\": \"SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid\"\n    }\n}\n"}
{"sample_id": "train.434", "db_id": "flight_1", "question": "What is the name and distance of every aircraft that can cover a distance of more than 5000 and which at least 5 people can fly?", "rationale": ["Identify the relevant tables: We need information from the 'aircraft' table for aircraft names and distances, and the 'certificate' table to count the number of employees certified for each aircraft.", "Filter aircraft based on distance: We want aircraft that can cover a distance of more than 5000, so we will add a condition in the WHERE clause for 'distance'.", "Count the number of certificates: We need to ensure that at least 5 people can fly the aircraft, which means we need to count the number of certificates associated with each aircraft. This can be done using a subquery that groups by 'aid' and uses HAVING to filter for counts greater than or equal to 5.", "Combine the results: We will use an IN clause to filter the aircraft based on the results of the subquery that counts certificates, ensuring we only select aircraft that meet both criteria."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT T2.name, T2.distance FROM Aircraft AS T2 WHERE T2.distance > 5000 AND T2.aid IN (SELECT T1.aid FROM Certificate AS T1 GROUP BY T1.aid HAVING COUNT(T1.eid) >= 5)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' table with the 'Aircraft' table based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of aircraft names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\",\n        \"virtual_table\": \"SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.437", "db_id": "flight_1", "question": "What is the salary and name of the employee who has the most number of certificates on aircrafts with distance more than 5000?", "rationale": ["Identify the tables needed: employee, certificate, and aircraft.", "Join the employee table with the certificate table on employee ID (eid) to get the employees who hold certificates.", "Join the resulting table with the aircraft table on aircraft ID (aid) to filter by aircraft distance.", "Use a WHERE clause to filter aircraft with a distance greater than 5000.", "Group the results by employee ID to count the number of certificates each employee has.", "Order the results by the count of certificates in descending order to get the employee with the most certificates.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.name, e.salary \nFROM employee AS e \nJOIN certificate AS c ON e.eid = c.eid \nJOIN aircraft AS a ON c.aid = a.aid \nWHERE a.distance > 5000 \nGROUP BY e.eid \nORDER BY COUNT(c.eid) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' table with the 'Aircraft' table based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of aircraft names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\",\n        \"virtual_table\": \"SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid\"\n    }\n}\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The user is asking for all the different food allergies, which implies we need to retrieve distinct allergy names from the Allergy_Type table.", "The Allergy_Type table contains a column named 'Allergy' that lists the names of different allergies.", "To get all unique food allergies, we can use the SELECT DISTINCT statement on the 'Allergy' column of the Allergy_Type table."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Allergy_Type", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.456", "db_id": "allergy_1", "question": "Which allergy type is most common?", "rationale": ["To find the most common allergy type, we need to count how many students have each type of allergy.", "We will join the 'Has_Allergy' table with the 'Allergy_Type' table on the Allergy column to get the type of each allergy.", "We will group the results by AllergyType to count the number of students for each type.", "We will order the results in descending order based on the count of students to get the most common allergy type at the top.", "Finally, we will limit the results to 1 to get only the most common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT T2.AllergyType, COUNT(*) as StudentCount \nFROM Has_Allergy AS T1 \nJOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \nGROUP BY T2.AllergyType \nORDER BY StudentCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["To find the least common allergy type, we need to count how many students have each type of allergy.", "We will join the 'Has_Allergy' table with the 'Allergy_Type' table to get the allergy types associated with each allergy.", "We will group the results by 'AllergyType' to get the count of students for each type.", "We will order the results by the count in ascending order to get the least common allergy type at the top.", "Finally, we will limit the results to 1 to get only the least common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT T2.AllergyType, COUNT(*) AS StudentCount \nFROM Has_Allergy AS T1 \nJOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \nGROUP BY T2.AllergyType \nORDER BY StudentCount ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["The user wants the full names of all students, which includes their first and last names.", "To get the full names, I need to select the 'Fname' and 'LName' columns from the 'Student' table.", "There are no conditions or filters specified in the question, so I will select all records from the 'Student' table."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname, LName FROM Student", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n        \"virtual_table\": \"SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the table that contains the information about students, which is the 'Student' table.", "Determine the relevant column for filtering male students, which is the 'Sex' column.", "Construct a SQL SELECT statement to retrieve the 'StuID' of students where 'Sex' is equal to 'Male'."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male';", "hint": "\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the major information, which is the 'Student' table.", "To find the largest major, we need to count the number of students in each major.", "We will use the COUNT function to count the number of students for each major.", "We will group the results by the 'Major' column to get the count for each major.", "To find the largest major, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get the major with the highest count."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.501", "db_id": "allergy_1", "question": "Which advisor has most number of students?", "rationale": ["Identify the relevant table: The 'Student' table contains the 'Advisor' and 'StuID' columns.", "Count the number of students for each advisor: Use COUNT(StuID) to count the number of students associated with each advisor.", "Group the results by advisor: Use GROUP BY Advisor to aggregate the counts for each advisor.", "Order the results to find the advisor with the most students: Use ORDER BY StudentCount DESC to sort the counts in descending order.", "Limit the results to the top advisor: Use LIMIT 1 to get only the advisor with the highest count."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(StuID) AS StudentCount\nFROM Student\nGROUP BY Advisor\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the relevant tables: Has_Allergy and Allergy_Type.", "Determine the relationship between students and their allergies using the Has_Allergy table.", "Count the number of students with a specific allergy by joining Has_Allergy with Allergy_Type on the Allergy column.", "Filter the results to only include students with 'cat' allergies by using a WHERE clause."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'cat'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.508", "db_id": "allergy_1", "question": "Which students are unaffected by allergies?", "rationale": ["Identify the main goal: to find students who are unaffected by allergies.", "To determine students without allergies, we need to select from the 'Student' table.", "We will use a subquery to find all students who have allergies by selecting their StuID from the 'Has_Allergy' table.", "The main query will select the first names and majors of students whose StuID is not in the list of students with allergies."], "gold_sql": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy being checked against the 'Has_Allergy' table.\",\n        \"virtual_table\": \"SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n        \"virtual_table\": \"SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.509", "db_id": "allergy_1", "question": "How many female students have milk or egg allergies?", "rationale": ["Identify the target group: female students with specific allergies (milk or egg).", "Use the Student table to filter for female students by checking the 'Sex' column.", "Join the Has_Allergy table to find students with either 'Milk' or 'Egg' allergies.", "Use a subquery to select StuID from Has_Allergy where the Allergy is either 'Milk' or 'Egg'.", "Count the number of female students that match the criteria."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(*) FROM Student WHERE Sex = 'Female' AND StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'Milk' OR Allergy = 'Egg')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n        \"virtual_table\": \"SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.\",\n        \"virtual_table\": \"SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the target group: female students.", "Count the number of students who are female.", "Filter students based on their allergies to either milk or eggs.", "Use a subquery to find students with the specified allergies from the Has_Allergy table."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(*) FROM Student WHERE Sex = 'Female' AND StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'milk' OR Allergy = 'eggs')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n        \"virtual_table\": \"SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.\",\n        \"virtual_table\": \"SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.513", "db_id": "allergy_1", "question": "Which allergy has most number of students affected?", "rationale": ["Identify the tables involved: Has_Allergy and Allergy_Type.", "We need to count the number of students affected by each allergy, which requires joining the Has_Allergy table with the Allergy_Type table on the Allergy column.", "Use COUNT() to count the number of unique StuID entries for each allergy.", "Group the results by the Allergy to get the count for each allergy type.", "Order the results in descending order based on the count of students affected.", "Limit the results to 1 to get the allergy with the most students affected."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT T2.Allergy, COUNT(T1.StuID) AS StudentCount \nFROM Has_Allergy AS T1 \nJOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \nGROUP BY T2.Allergy \nORDER BY StudentCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.518", "db_id": "allergy_1", "question": "How many students are affected by each allergy type?", "rationale": ["The question asks for the number of students affected by each allergy type, which implies a need to group the results by allergy type.", "To achieve this, we will join the 'Has_Allergy' table with the 'Allergy_Type' table on the common column 'Allergy'.", "We will then use the COUNT function to count the number of students for each allergy type.", "Finally, we will group the results by 'AllergyType' to get the count for each type of allergy."], "gold_sql": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype", "source_tables": ["has_allergy", "allergy_type"], "pred_sql": "SELECT T2.AllergyType, COUNT(*) AS StudentCount \nFROM Has_Allergy AS T1 \nJOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \nGROUP BY T2.AllergyType;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the required information: last names and ages of students with specific allergies.", "Determine the allergies of interest: milk and cat.", "Use a subquery to find students with the first allergy (milk) and another subquery for the second allergy (cat).", "Combine the results of the two subqueries using INTERSECT to find students who have both allergies.", "Select the last names and ages from the Student table where the student IDs match those found in the combined subquery results."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT LName, Age FROM Student WHERE StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'milk' INTERSECT SELECT StuID FROM Has_Allergy WHERE Allergy = 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n        \"virtual_table\": \"SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.\",\n        \"virtual_table\": \"SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.522", "db_id": "allergy_1", "question": "What are the allergies the girl named Lisa has? And what are the types of them? Order the result by allergy names.", "rationale": ["Identify the tables needed: We need to get information from the Student, Has_Allergy, and Allergy_Type tables.", "We need to filter the students by first name 'Lisa' and gender 'Female'.", "Join the Student table with Has_Allergy to link students to their allergies.", "Join the resulting table with Allergy_Type to get the type of each allergy.", "Select the Allergy and AllergyType columns from the joined tables.", "Order the results by the Allergy names."], "gold_sql": "SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  'Lisa' ORDER BY T1.Allergy", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT A.Allergy, AT.AllergyType FROM Student AS S JOIN Has_Allergy AS HA ON S.StuID = HA.StuID JOIN Allergy_Type AS AT ON HA.Allergy = AT.Allergy WHERE S.Fname = 'Lisa' AND S.Sex = 'Female' ORDER BY A.Allergy;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n        \"virtual_table\": \"SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the tables involved: We need to get student ages from the 'Student' table and filter students based on their allergies from the 'Has_Allergy' table, which links to the 'Allergy_Type' table for allergy types.", "Determine the allergies of interest: We are looking for students with allergies categorized as 'food' and 'animal'.", "Use a subquery to find students with the specified allergies: We can use a subquery to select 'StuID' from 'Has_Allergy' where the 'Allergy' matches those in the 'Allergy_Type' table with 'AllergyType' as 'food' or 'animal'.", "Calculate the average age: Finally, we will calculate the average age of the students whose 'StuID' is in the result of the subquery."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT AVG(Age) FROM Student WHERE StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy IN (SELECT Allergy FROM Allergy_Type WHERE AllergyType IN ('food', 'animal')));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n        \"virtual_table\": \"SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.527", "db_id": "allergy_1", "question": "List the first and last name of the students who do not have any food type allergy.", "rationale": ["Identify the tables involved: We need to get student names from the 'Student' table and check their allergies in the 'Has_Allergy' table.", "We want to list students who do not have any food type allergy, so we need to filter out those students from the 'Student' table.", "The subquery will select all StuID from the 'Has_Allergy' table where the Allergy is of type 'Food'.", "The main query will select the first and last names of students whose StuID is not in the result of the subquery."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname, LName FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE AllergyType = 'Food')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy being checked against the 'Has_Allergy' table.\",\n        \"virtual_table\": \"SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n        \"virtual_table\": \"SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.529", "db_id": "allergy_1", "question": "Find the number of male (sex is 'M') students who have some food type allery.", "rationale": ["Identify the requirement: Count the number of male students with food allergies.", "Use the 'Student' table to filter by gender (Sex = 'M').", "Join the 'Has_Allergy' table to find students with allergies.", "Filter the allergies to only include those categorized as 'Food' using the 'Allergy_Type' table.", "Construct the SQL query to count the number of male students who have food allergies."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT count(*) FROM Student WHERE Sex = 'M' AND StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy IN (SELECT Allergy FROM Allergy_Type WHERE AllergyType = 'Food'));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.\",\n        \"virtual_table\": \"SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables involved: We need to get student information (first names and city codes) and their allergies, which involves the Student and Has_Allergy tables.", "Determine the necessary columns: We need the distinct first names (Fname) and city codes (city_code) from the Student table.", "Establish the relationship: We will join the Student table with the Has_Allergy table on the StuID column, which is common to both tables.", "Set the conditions for the allergies: We need to filter the results to include only those students who have an allergy to either 'milk' or 'cat'.", "Construct the SQL query: Using the information gathered, we can construct the SQL query to select distinct first names and city codes based on the specified allergies."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT T1.Fname, T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.StuID = T2.StuID WHERE T2.Allergy = 'milk' OR T2.Allergy = 'cat'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n        \"virtual_table\": \"SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.\",\n        \"virtual_table\": \"SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.533", "db_id": "allergy_1", "question": "Find the number of students who are older than 18 and do not have allergy to either food or animal.", "rationale": ["Identify the main requirement: count students older than 18 without allergies to food or animals.", "Use the 'Student' table to filter students by age.", "Use a subquery to find students with allergies to food or animals from the 'Has_Allergy' table.", "The subquery selects 'StuID' from 'Has_Allergy' where the 'Allergy' is either 'food' or 'animal'.", "Use the NOT IN clause to exclude these students from the main query.", "Finally, count the remaining students who meet the age requirement."], "gold_sql": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' OR T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT COUNT(*) FROM Student WHERE Age > 18 AND StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy IN ('food', 'animal'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n        \"virtual_table\": \"SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy being checked against the 'Has_Allergy' table.\",\n        \"virtual_table\": \"SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.535", "db_id": "allergy_1", "question": "Find the first name and major of the students who are not allegry to soy.", "rationale": ["Identify the required fields: first name (Fname) and major from the Student table.", "Determine the condition: we need students who do not have an allergy to soy.", "Use a subquery to find all student IDs (StuID) that have an allergy to soy from the Has_Allergy table.", "Use the NOT IN clause to filter out those students from the main query that selects from the Student table."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'soy')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy being checked against the 'Has_Allergy' table.\",\n        \"virtual_table\": \"SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.\",\n        \"virtual_table\": \"SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.\",\n        \"virtual_table\": \"SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["We need to find the names of the countries and the average invoice size for those countries.", "To do this, we will join the 'customers' table with the 'invoices' table on the customer ID.", "We will select the 'country' from the 'customers' table and calculate the average of the 'total' from the 'invoices' table.", "We will group the results by 'country' to get the average invoice size for each country.", "Finally, we will order the results by the average invoice size in descending order to get the top countries by size."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT customers.country, AVG(invoices.total) AS average_invoice_size\nFROM customers\nJOIN invoices ON customers.id = invoices.customer_id\nGROUP BY customers.country\nORDER BY average_invoice_size DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.553", "db_id": "store_1", "question": "List every album ordered by album title in ascending order.", "rationale": ["Identify the table needed to retrieve album titles, which is the 'albums' table.", "Determine the required columns to be selected, which is the 'title' column from the 'albums' table.", "Specify the ordering of the results, which is by 'title' in ascending order.", "Construct the SQL query using the SELECT statement, specifying the table and the order clause."], "gold_sql": "SELECT title FROM albums ORDER BY title;", "source_tables": ["albums"], "pred_sql": "SELECT title FROM albums ORDER BY title ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.\",\n        \"virtual_table\": \"SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.560", "db_id": "store_1", "question": "What are the total amount of money in the invoices billed from Chicago, Illinois?", "rationale": ["Identify the relevant table: invoices, which contains billing information.", "Determine the columns needed: total for the amount of money in the invoices, and billing_city and billing_state for filtering.", "Construct the SQL query to sum the total amounts from the invoices where the billing city is Chicago and the billing state is Illinois."], "gold_sql": "SELECT sum(total) FROM invoices WHERE billing_city  =  'Chicago' AND billing_state  =  'IL';", "source_tables": ["invoices"], "pred_sql": "SELECT SUM(total) FROM invoices WHERE billing_city = 'Chicago' AND billing_state = 'Illinois';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["We need to count the number of invoices for each state.", "The relevant tables are 'customers' and 'invoices'.", "We will join these two tables on the customer ID, which is the foreign key in the invoices table.", "We will group the results by the state of the customers to get the count of invoices per state.", "Finally, we will select the state and the count of invoices in the output."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT customers.state, COUNT(invoices.id) AS invoice_count \nFROM customers \nJOIN invoices ON customers.id = invoices.customer_id \nGROUP BY customers.state;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.565", "db_id": "store_1", "question": "List the state in the US with the most invoices.", "rationale": ["We need to find the state in the US with the most invoices, which means we will be working with the 'invoices' table.", "The 'invoices' table contains a column 'billing_state' that indicates the state for each invoice.", "To find the state with the most invoices, we will group the results by 'billing_state' and count the number of invoices in each state using COUNT(*).", "We will then order the results in descending order based on the count of invoices to get the state with the highest number of invoices at the top.", "Finally, we will limit the results to 1 to get only the state with the most invoices."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) as invoice_count \nFROM invoices \nGROUP BY billing_state \nORDER BY invoice_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["We need to find the states with the most invoices, which means we need to count the number of invoices per state.", "The relevant table for invoices is the 'invoices' table, which contains a 'billing_state' column.", "We will use the COUNT() function to count the number of invoices for each state.", "To group the results by state, we will use the GROUP BY clause on the 'billing_state' column.", "Finally, to get the states with the most invoices, we will order the results in descending order using ORDER BY clause."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count \nFROM invoices \nGROUP BY billing_state \nORDER BY invoice_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.567", "db_id": "store_1", "question": "List the number of invoices and the invoice total from California.", "rationale": ["We need to count the number of invoices and sum the total amount of those invoices for customers located in California.", "To achieve this, we will join the 'invoices' table with the 'customers' table on the customer ID.", "We will filter the results to include only those customers whose state is 'California'.", "We will use COUNT(*) to get the total number of invoices and SUM(total) to get the total invoice amount."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS number_of_invoices, SUM(total) AS invoice_total FROM invoices AS T1 JOIN customers AS T2 ON T1.customer_id = T2.id WHERE T2.state = 'California';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the table that contains the information needed: the 'employees' table has the email and phone number.", "Determine the specific columns to select: 'email' and 'phone'.", "Filter the results to find the specific employee by their first and last name: 'Astrid Gruber'.", "Construct the SQL query using the SELECT statement with the appropriate WHERE clause."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["We need to find the employee who supported the most number of customers.", "To do this, we will join the 'employees' table with the 'customers' table on the 'support_rep_id' field.", "We will group the results by the employee's ID to count the number of customers each employee supports.", "We will order the results in descending order based on the count of customers supported.", "Finally, we will limit the results to only the top employee, which gives us the one who supported the most customers.", "To get the full name of the employee, we will concatenate the first and last name fields."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees AS e\nJOIN customers AS c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.594", "db_id": "store_1", "question": "What is the full name of the employee who has the most customers?", "rationale": ["Identify the relevant tables: employees and customers.", "We need to find the employee who has the most customers, which means we need to join the employees table with the customers table on the support_rep_id.", "Group the results by employee ID to count the number of customers each employee has.", "Order the results by the count of customers in descending order to get the employee with the most customers at the top.", "Limit the results to 1 to get only the top employee.", "Select the full name of the employee by concatenating first_name and last_name."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.604", "db_id": "store_1", "question": "How many employees who are IT staff are from each city?", "rationale": ["Identify the relevant table: The 'employees' table contains information about employees, including their job titles and cities.", "Determine the criteria: We need to filter employees who are in the IT staff category, which can be identified by checking if the 'title' column contains 'IT'.", "Count the number of employees: We will use the COUNT() function to count the number of employees that meet the criteria.", "Group the results: We will group the results by 'city' to get the count of IT staff from each city."], "gold_sql": "SELECT count(*) ,  city FROM employees WHERE title  =  'IT Staff' GROUP BY city", "source_tables": ["employees"], "pred_sql": "SELECT city, COUNT(*) AS employee_count \nFROM employees \nWHERE title LIKE '%IT%' \nGROUP BY city;", "hint": "\n"}
{"sample_id": "train.624", "db_id": "store_1", "question": "What is the name of the album that has the track Ball to the Wall?", "rationale": ["Identify the tables involved: We need to find the album title from the 'albums' table and the track name from the 'tracks' table.", "Determine the relationship: The 'albums' table is related to the 'tracks' table through the 'album_id' foreign key in the 'tracks' table.", "Use a JOIN operation: We will join the 'albums' table (aliased as T1) with the 'tracks' table (aliased as T2) on the condition that T1.id equals T2.album_id.", "Filter the results: We need to filter the results to only include tracks with the name 'Ball to the Wall'.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.album_id WHERE T2.name = 'Ball to the Wall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.\",\n        \"virtual_table\": \"SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the tables involved: We need to get track names, which are in the 'tracks' table, and we need to filter by genre and media type, which are in the 'genres' and 'media_types' tables respectively.", "Join the necessary tables: We will join the 'tracks' table with the 'media_types' table on the media_type_id and with the 'genres' table on the genre_id to access the names of the media type and genre.", "Filter the results: We will filter the results to only include tracks that belong to the 'Rock' genre and have a media type of 'MPEG'.", "Construct the SQL query: Based on the above steps, we will construct the SQL query to select the names of the tracks that meet the criteria."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT T2.name \nFROM tracks AS T2 \nJOIN media_types AS T3 ON T2.media_type_id = T3.id \nJOIN genres AS T4 ON T2.genre_id = T4.id \nWHERE T4.name = 'Rock' AND T3.name = 'MPEG';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.\",\n        \"virtual_table\": \"SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.946", "db_id": "medicine_enzyme_interaction", "question": "What are the names and trade names of the medcines that are FDA approved?", "rationale": ["Identify the relevant table: The question pertains to medicines, so we will use the 'medicine' table.", "Determine the required columns: We need the 'name' and 'Trade_Name' of the medicines.", "Filter the results: We only want medicines that are FDA approved, which is indicated by the 'FDA_approved' column.", "Construct the SQL query: We will select the 'name' and 'Trade_Name' from the 'medicine' table where 'FDA_approved' is 'yes'."], "gold_sql": "SELECT name ,  trade_name FROM medicine WHERE FDA_approved  =  'Yes'", "source_tables": ["medicine"], "pred_sql": "SELECT name, Trade_Name FROM medicine WHERE FDA_approved = 'yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of medicines along with their unique identifiers and FDA approval status, sorted by the number of interactions they have with enzymes. The placeholder in the query allows for dynamic filtering based on the specific criteria of interest.\",\n        \"virtual_table\": \"SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and trade names of medicines that have specific types of interactions with enzymes. The placeholders in the WHERE clause represent the types of interactions being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of enzyme names, their geographical locations, and the products they produce, specifically for those enzymes that interact with medicines in a certain way. The placeholder in the WHERE clause represents the type of interaction being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name ,  T1.location ,  T1.product FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.enzyme_id  =  T1.id WHERE T2.interaction_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.951", "db_id": "medicine_enzyme_interaction", "question": "What are the ids, names and FDA approval status of medicines in descending order of the number of enzymes that it can interact with.", "rationale": ["Identify the relevant tables: medicine and medicine_enzyme_interaction.", "We need to retrieve the ids, names, and FDA approval status of medicines.", "Join the medicine table with the medicine_enzyme_interaction table on the medicine_id.", "Group the results by medicine id to count the number of enzyme interactions for each medicine.", "Order the results in descending order based on the count of enzyme interactions."], "gold_sql": "SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC", "source_tables": ["medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT T1.id, T1.name, T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id = T1.id GROUP BY T1.id ORDER BY count(*) DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of medicines along with their unique identifiers and FDA approval status, sorted by the number of interactions they have with enzymes. The placeholder in the query allows for dynamic filtering based on the specific criteria of interest.\",\n        \"virtual_table\": \"SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of enzyme identifiers and their names from the 'enzyme' table that are involved in a specific type of interaction with medicines. The interaction type is specified by a placeholder, and the results are grouped by enzyme ID, ordered by the frequency of interactions in descending order, with a limit on the number of results returned, specified by another placeholder.\",\n        \"virtual_table\": \"SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and trade names of medicines that have specific types of interactions with enzymes. The placeholders in the WHERE clause represent the types of interactions being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.953", "db_id": "medicine_enzyme_interaction", "question": "What is the id and name of the enzyme with most number of medicines that can interact as 'activator'?", "rationale": ["Identify the relevant tables: 'enzyme' and 'medicine_enzyme_interaction'.", "We need to find the enzyme with the most interactions as an 'activator'.", "Join the 'enzyme' table with the 'medicine_enzyme_interaction' table on the enzyme ID.", "Filter the results where the interaction type is 'activator'.", "Group the results by enzyme ID to count the number of interactions for each enzyme.", "Order the results by the count of interactions in descending order to get the enzyme with the most interactions at the top.", "Limit the results to 1 to get only the enzyme with the highest count."], "gold_sql": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  'activitor' GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["enzyme", "medicine_enzyme_interaction"], "pred_sql": "SELECT T1.id, T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id = T2.enzyme_id WHERE T2.interaction_type = 'activator' GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of enzyme identifiers and their names from the 'enzyme' table that are involved in a specific type of interaction with medicines. The interaction type is specified by a placeholder, and the results are grouped by enzyme ID, ordered by the frequency of interactions in descending order, with a limit on the number of results returned, specified by another placeholder.\",\n        \"virtual_table\": \"SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of medicines along with their unique identifiers and FDA approval status, sorted by the number of interactions they have with enzymes. The placeholder in the query allows for dynamic filtering based on the specific criteria of interest.\",\n        \"virtual_table\": \"SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and trade names of medicines that have specific types of interactions with enzymes. The placeholders in the WHERE clause represent the types of interactions being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.968", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that can interact as an inhibitor and activitor with enzymes?", "rationale": ["Identify the tables involved: medicine and medicine_enzyme_interaction.", "Determine the required fields: medicine name and trade name from the medicine table.", "Identify the interaction types needed: 'inhibitor' and 'activator'.", "Use JOIN to connect the medicine table with the medicine_enzyme_interaction table based on medicine_id.", "Use INTERSECT to find medicines that have both 'inhibitor' and 'activator' interactions."], "gold_sql": "SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'inhibitor' INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'activitor'", "source_tables": ["medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT T1.name, T1.Trade_Name \nFROM medicine AS T1 \nJOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id = T1.id \nWHERE T2.interaction_type = 'inhibitor' \nINTERSECT \nSELECT T1.name, T1.Trade_Name \nFROM medicine AS T1 \nJOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id = T1.id \nWHERE T2.interaction_type = 'activator'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and trade names of medicines that have specific types of interactions with enzymes. The placeholders in the WHERE clause represent the types of interactions being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of medicines along with their unique identifiers and FDA approval status, sorted by the number of interactions they have with enzymes. The placeholder in the query allows for dynamic filtering based on the specific criteria of interest.\",\n        \"virtual_table\": \"SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of enzyme names, their geographical locations, and the products they produce, specifically for those enzymes that interact with medicines in a certain way. The placeholder in the WHERE clause represents the type of interaction being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name ,  T1.location ,  T1.product FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.enzyme_id  =  T1.id WHERE T2.interaction_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.970", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that cannot interact with the enzyme with the product 'Heme'?", "rationale": ["Identify the columns needed: medicine name and trade name from the medicine table.", "We need to find medicines that cannot interact with a specific enzyme product, which is 'Heme'.", "To do this, we will use a subquery to find all medicine IDs that interact with the enzyme that produces 'Heme'.", "The subquery will join the medicine_enzyme_interaction table with the enzyme table to filter by the product 'Heme'.", "The main query will select the medicine names and trade names where the medicine ID is not in the list of IDs returned by the subquery."], "gold_sql": "SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  'Protoporphyrinogen IX'", "source_tables": ["enzyme", "medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT T1.name, T1.Trade_Name \nFROM medicine AS T1 \nWHERE T1.id NOT IN (\n    SELECT T2.medicine_id \n    FROM medicine_enzyme_interaction AS T2 \n    JOIN enzyme AS T3 ON T2.enzyme_id = T3.id \n    WHERE T3.Product = 'Heme'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and trade names of medicines that have specific types of interactions with enzymes. The placeholders in the WHERE clause represent the types of interactions being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of medicines along with their unique identifiers and FDA approval status, sorted by the number of interactions they have with enzymes. The placeholder in the query allows for dynamic filtering based on the specific criteria of interest.\",\n        \"virtual_table\": \"SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of enzyme names, their geographical locations, and the products they produce, specifically for those enzymes that interact with medicines in a certain way. The placeholder in the WHERE clause represents the type of interaction being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name ,  T1.location ,  T1.product FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.enzyme_id  =  T1.id WHERE T2.interaction_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1355", "db_id": "college_2", "question": "What is the name of the department with an instructure who has a name like 'Soisalon'?", "rationale": ["Identify the relevant tables: department and instructor.", "We need to find the department name associated with instructors.", "Join the department table with the instructor table on the dept_name column since it is the common attribute.", "Filter the results where the instructor's name matches the pattern 'Soisalon' using the LIKE operator."], "gold_sql": "SELECT dept_name FROM instructor WHERE name LIKE '%Soisalon%'", "source_tables": ["instructor"], "pred_sql": "SELECT department.dept_name \nFROM department \nJOIN instructor ON department.dept_name = instructor.dept_name \nWHERE instructor.name LIKE '%Soisalon%';", "hint": "\n"}
{"sample_id": "train.1365", "db_id": "college_2", "question": "What are the titles of courses that are in the Statistics department but not the Psychology department?", "rationale": ["Identify the relevant table: The 'course' table contains the titles of courses and their associated departments.", "Filter the courses: We need to select courses that belong to the 'Statistics' department. This can be done using a WHERE clause that checks for dept_name = 'Statistics'.", "Exclude courses from the Psychology department: We also need to ensure that these courses are not from the 'Psychology' department. However, since a course can only belong to one department, we can simply check for the 'Statistics' department and not include any condition for 'Psychology'.", "Construct the SQL query: Combine the conditions into a single SQL SELECT statement that retrieves the titles of courses from the 'course' table where the department is 'Statistics'."], "gold_sql": "SELECT title FROM course WHERE dept_name  =  'Statistics' EXCEPT SELECT title FROM course WHERE dept_name  =  'Psychology'", "source_tables": ["course"], "pred_sql": "SELECT title FROM course WHERE dept_name = 'Statistics' AND dept_name != 'Psychology';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the titles of courses from the 'course' table that have prerequisites. The prerequisite courses are identified by their titles, which are specified using a placeholder in the subquery.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.1424", "db_id": "college_2", "question": "Find the title of course whose prerequisite is course Differential Geometry.", "rationale": ["Identify the course title we want to find, which is related to the prerequisite 'Differential Geometry'.", "Use the provided hint to construct a SQL query that finds courses with prerequisites.", "The inner query selects course IDs from the 'prereq' table where the prerequisite course title matches 'Differential Geometry'.", "The outer query selects the titles of courses from the 'course' table that have those course IDs from the inner query."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  =  'Differential Geometry')", "source_tables": ["course", "prereq"], "pred_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  = 'Differential Geometry')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the titles of courses from the 'course' table that have prerequisites. The prerequisite courses are identified by their titles, which are specified using a placeholder in the subquery.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.1426", "db_id": "college_2", "question": "Find the names of students who have taken any course in the fall semester of year 2003.", "rationale": ["Identify the main entity of interest: students who have taken courses.", "Determine the relevant tables: 'student' for student names and 'takes' for course enrollment details.", "Use a subquery to find student IDs from the 'takes' table where the semester is 'Fall' and the year is '2003'.", "Select the names of students from the 'student' table whose IDs match those found in the subquery."], "gold_sql": "SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  'Fall' AND YEAR  =  2003)", "source_tables": ["student", "takes"], "pred_sql": "SELECT name FROM student WHERE ID IN (SELECT ID FROM takes WHERE semester = 'Fall' AND year = '2003')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of students who are enrolled in courses during a specific semester and year. The placeholders in the WHERE clause represent the semester and year for which the student enrollment is being queried.\",\n        \"virtual_table\": \"SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.1435", "db_id": "college_2", "question": "What are the names of all instructors who advise students in the math depart sorted by total credits of the student.", "rationale": ["Identify the tables involved: instructor, advisor, and student.", "We need to find instructors who advise students, so we will join the instructor table with the advisor table on the instructor's ID.", "Next, we join the advisor table with the student table on the student's ID to get the students being advised.", "We need to filter the results to only include students from the math department, so we add a WHERE clause for student.dept_name = 'math'.", "Finally, we want to sort the results by the total credits of the students, so we add an ORDER BY clause for student.tot_cred."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id WHERE T3.dept_name  =  'Math' ORDER BY T3.tot_cred", "source_tables": ["instructor", "student", "advisor"], "pred_sql": "SELECT instructor.name \nFROM instructor \nJOIN advisor ON instructor.ID = advisor.i_ID \nJOIN student ON advisor.s_ID = student.ID \nWHERE student.dept_name = 'math' \nORDER BY student.tot_cred;", "hint": "\n"}
{"sample_id": "train.1436", "db_id": "college_2", "question": "What is the course title of the prerequisite of course Mobile Computing?", "rationale": ["Identify the course title of the prerequisite for the course 'Mobile Computing'.", "Use the 'prereq' table to find the prerequisite course ID for 'Mobile Computing'.", "Join the 'prereq' table with the 'course' table to get the prerequisite course ID based on the course title.", "Select the title of the course from the 'course' table where the course ID matches the prerequisite course ID found in the previous step."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  'Mobile Computing')", "source_tables": ["course", "prereq"], "pred_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id = T2.course_id WHERE T2.title = 'Mobile Computing')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the titles of courses from the 'course' table that have prerequisites. The prerequisite courses are identified by their titles, which are specified using a placeholder in the subquery.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.1439", "db_id": "college_2", "question": "What is the name of the instructor who advises the student with the greatest number of total credits?", "rationale": ["Identify the tables involved: instructor, advisor, and student.", "We need to find the instructor's name who advises a specific student.", "The student with the greatest number of total credits can be found using a subquery that selects the maximum total credits from the student table.", "Join the instructor table with the advisor table on the instructor's ID, and then join the advisor table with the student table on the student's ID.", "Filter the results to only include the instructor advising the student with the maximum total credits."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT 1", "source_tables": ["instructor", "student", "advisor"], "pred_sql": "SELECT instructor.name \nFROM instructor \nJOIN advisor ON instructor.ID = advisor.i_ID \nJOIN student ON advisor.s_ID = student.ID \nWHERE student.tot_cred = (SELECT MAX(tot_cred) FROM student);", "hint": "\n"}
{"sample_id": "train.1448", "db_id": "college_2", "question": "Find the number and averaged salary of all instructors who are in the department with the highest budget.", "rationale": ["Identify the department with the highest budget by selecting the 'dept_name' from the 'department' table and ordering by 'budget' in descending order, limiting the result to 1.", "Use the result of the above subquery to filter the 'instructor' table to find instructors belonging to that department.", "Count the number of instructors in that department using COUNT(ID) and calculate the average salary using AVG(salary).", "Select both the count and average salary in the final output."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "pred_sql": "SELECT COUNT(ID) AS number_of_instructors, AVG(salary) AS average_salary\nFROM instructor\nWHERE dept_name = (\n    SELECT dept_name\n    FROM department\n    ORDER BY budget DESC\n    LIMIT 1\n);", "hint": "\n"}
{"sample_id": "train.1449", "db_id": "college_2", "question": "How many instructors are in the department with the highest budget, and what is their average salary?", "rationale": ["Identify the department with the highest budget by using a subquery that selects the maximum budget from the department table.", "Join the instructor table with the department table on the dept_name to associate instructors with their respective departments.", "Filter the results to only include instructors from the department that has the highest budget, as determined by the subquery.", "Count the number of instructors in that department and calculate their average salary using COUNT() and AVG() functions."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "pred_sql": "SELECT COUNT(i.ID) AS instructor_count, AVG(i.salary) AS average_salary\nFROM instructor i\nJOIN department d ON i.dept_name = d.dept_name\nWHERE d.budget = (SELECT MAX(budget) FROM department);", "hint": "\n"}
{"sample_id": "train.1452", "db_id": "college_2", "question": "Find the name of students who didn't take any course from Biology department.", "rationale": ["Identify the students from the student table.", "We need to find students who have not taken any courses from the Biology department.", "To do this, we will use a subquery to find all course_ids that belong to the Biology department from the course table.", "Next, we will use another subquery to find all student IDs from the takes table that have taken any of those Biology courses.", "Finally, we will select the names of students whose IDs are not in the list of IDs from the previous subquery."], "gold_sql": "SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  'Biology')", "source_tables": ["course", "student", "takes"], "pred_sql": "SELECT name FROM student WHERE ID NOT IN (SELECT ID FROM takes WHERE course_id IN (SELECT course_id FROM course WHERE dept_name = 'Biology'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of students who are enrolled in courses during a specific semester and year. The placeholders in the WHERE clause represent the semester and year for which the student enrollment is being queried.\",\n        \"virtual_table\": \"SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.1458", "db_id": "college_2", "question": "Find the name and salary of instructors whose salary is below the average salary of the instructors in the Physics department.", "rationale": ["Identify the relevant table: The 'instructor' table contains the information about instructors, including their names and salaries.", "Determine the condition: We need to find instructors whose salary is below the average salary of instructors in the Physics department.", "Calculate the average salary: Use a subquery to calculate the average salary of instructors in the Physics department.", "Combine the conditions: Use a SELECT statement to retrieve the names and salaries of instructors in the Physics department who meet the salary condition."], "gold_sql": "SELECT name ,  salary FROM instructor WHERE salary  <  (SELECT avg(salary) FROM instructor WHERE dept_name  =  'Physics')", "source_tables": ["instructor"], "pred_sql": "SELECT name, salary \nFROM instructor \nWHERE dept_name = 'Physics' \nAND salary < (SELECT AVG(salary) FROM instructor WHERE dept_name = 'Physics');", "hint": "\n"}
{"sample_id": "train.1461", "db_id": "college_2", "question": "What are the names of students who have taken Statistics courses?", "rationale": ["Identify the relevant tables: We need to find student names and their course enrollments, so we will use the 'student' and 'takes' tables.", "Determine the relationship: The 'takes' table links students to the courses they have taken, and the 'course' table contains the course titles.", "Filter for Statistics courses: We need to find courses with 'Statistics' in their title, which can be done using a LIKE clause in the 'course' table.", "Construct the inner query: Create a subquery to select course_ids from the 'course' table where the title contains 'Statistics'.", "Construct the middle query: Create another subquery to select student IDs from the 'takes' table where the course_id is in the result of the previous subquery.", "Final query: Select names from the 'student' table where the ID is in the result of the middle query."], "gold_sql": "SELECT T3.name FROM course AS T1 JOIN takes AS T2 ON T1.course_id  =  T2.course_id JOIN student AS T3 ON T2.id  =  T3.id WHERE T1.dept_name  =  'Statistics'", "source_tables": ["course", "student", "takes"], "pred_sql": "SELECT name FROM student WHERE ID IN (SELECT ID FROM takes WHERE course_id IN (SELECT course_id FROM course WHERE title LIKE '%Statistics%'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of students who are enrolled in courses during a specific semester and year. The placeholders in the WHERE clause represent the semester and year for which the student enrollment is being queried.\",\n        \"virtual_table\": \"SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.1464", "db_id": "college_2", "question": "Find the names of all instructors in computer science department", "rationale": ["Identify the table that contains instructor information, which is the 'instructor' table.", "Determine the relevant column for instructor names, which is 'name'.", "Identify the condition needed to filter instructors by department, which is 'dept_name'.", "Specify the department of interest, which is 'computer science'.", "Construct the SQL query to select the names of instructors from the 'instructor' table where the 'dept_name' matches 'computer science'."], "gold_sql": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'", "source_tables": ["instructor"], "pred_sql": "SELECT name FROM instructor WHERE dept_name = 'computer science';", "hint": "\n"}
{"sample_id": "train.1480", "db_id": "college_2", "question": "Find courses that ran in Fall 2009 but not in Spring 2010.", "rationale": ["Identify the courses that were offered in Fall 2009.", "Use the section table to find the course_ids for sections offered in Fall 2009.", "Use the section table again to find the course_ids for sections offered in Spring 2010.", "Select the course titles from the course table where the course_id is in the list from Fall 2009 but not in the list from Spring 2010."], "gold_sql": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 EXCEPT SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010", "source_tables": ["section"], "pred_sql": "SELECT title FROM course WHERE course_id IN (SELECT sec_id FROM section WHERE semester = 'Fall' AND year = '2009') AND course_id NOT IN (SELECT sec_id FROM section WHERE semester = 'Spring' AND year = '2010');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of students who are enrolled in courses during a specific semester and year. The placeholders in the WHERE clause represent the semester and year for which the student enrollment is being queried.\",\n        \"virtual_table\": \"SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.\",\n        \"virtual_table\": \"SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.1489", "db_id": "college_2", "question": "What are the names of instructors who earn more than at least one instructor from the Biology department?", "rationale": ["Identify the main requirement: we need the names of instructors who earn more than at least one instructor from the Biology department.", "To find this, we need to compare the salaries of instructors in general with those in the Biology department.", "We can use a subquery to find the maximum salary of instructors in the Biology department.", "The outer query will select the names of instructors whose salary is greater than the maximum salary found in the subquery."], "gold_sql": "SELECT name FROM instructor WHERE salary  >  (SELECT min(salary) FROM instructor WHERE dept_name  =  'Biology')", "source_tables": ["instructor"], "pred_sql": "SELECT DISTINCT i1.name \nFROM instructor i1 \nWHERE i1.salary > (SELECT MAX(i2.salary) \n                   FROM instructor i2 \n                   WHERE i2.dept_name = 'Biology');", "hint": "\n"}
{"sample_id": "train.1515", "db_id": "insurance_and_eClaims", "question": "Find the total and average amount paid in claim headers.", "rationale": ["Identify the relevant table: The 'Claim_Headers' table contains the 'Amount_Paid' column which is needed for the calculations.", "Determine the required calculations: We need to calculate both the total and average of the 'Amount_Paid' column.", "Construct the SQL query: Use the SUM() function to calculate the total amount paid and the AVG() function to calculate the average amount paid from the 'Claim_Headers' table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\",\n        \"virtual_table\": \"SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\",\n        \"virtual_table\": \"SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["The question asks for the total and average amount paid in claim headers.", "To get the total amount paid, we can use the SUM function on the Amount_Paid column from the Claim_Headers table.", "To get the average amount paid, we can use the AVG function on the same Amount_Paid column.", "We will select both the total and average amounts in a single SQL query."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\",\n        \"virtual_table\": \"SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\",\n        \"virtual_table\": \"SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1517", "db_id": "insurance_and_eClaims", "question": "Find the total amount claimed in the most recently created document.", "rationale": ["Identify the tables involved: Claim_Headers for the amount claimed and Claims_Documents for the document creation date.", "Join the Claim_Headers table with the Claims_Documents table on the Claim_ID to link claims with their documents.", "Filter the results to only include claims that have documents created on the most recent date.", "Use a subquery to find the most recent Created_Date from the Claims_Documents table, ordering by Created_Date in descending order and limiting the result to 1.", "Sum the Amount_Claimed from the filtered results to get the total amount claimed for the most recently created document."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT sum(t1.Amount_Claimed) FROM Claim_Headers AS t1 JOIN Claims_Documents AS t2 ON t1.Claim_Header_ID = t2.Claim_ID WHERE t2.Created_Date = (SELECT Created_Date FROM Claims_Documents ORDER BY Created_Date DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\",\n        \"virtual_table\": \"SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\",\n        \"virtual_table\": \"SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Claim_Headers for claims, Policies for linking claims to customers, and Customers for customer details.", "Join the Claim_Headers table with the Policies table on Policy_ID to link claims to their respective policies.", "Join the resulting table with the Customers table on Customer_ID to get customer details associated with each claim.", "Order the results by Amount_Claimed in descending order to find the claim with the largest amount.", "Limit the results to 1 to get only the customer associated with the largest claim."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details \nFROM Claim_Headers ch \nJOIN Policies p ON ch.Policy_ID = p.Policy_ID \nJOIN Customers c ON p.Customer_ID = c.Customer_ID \nORDER BY ch.Amount_Claimed DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\",\n        \"virtual_table\": \"SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\",\n        \"virtual_table\": \"SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of customer details from the 'Customers' table for those customers who have specific types of insurance policies. The placeholders in the WHERE clause represent the policy type codes that the user can specify.\",\n        \"virtual_table\": \"SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING] OR t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1527", "db_id": "insurance_and_eClaims", "question": "What is the name of the claim processing stage that most of the claims are on?", "rationale": ["Identify the relevant tables: Claims_Processing and Claims_Processing_Stages are needed to get the claim processing stage names.", "Join the Claims_Processing table with the Claims_Processing_Stages table on the Claim_Stage_ID to get the claim status names.", "Group the results by Claim_Stage_ID to aggregate the counts of claims in each stage.", "Order the results by the count of claims in descending order to find the most common claim processing stage.", "Limit the results to 1 to get only the name of the most common claim processing stage."], "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"], "pred_sql": "SELECT t2.Claim_Status_Name FROM Claims_Processing AS t1 JOIN Claims_Processing_Stages AS t2 ON t1.Claim_Stage_ID = t2.Claim_Stage_ID GROUP BY t1.Claim_Stage_ID ORDER BY count(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\",\n        \"virtual_table\": \"SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\",\n        \"virtual_table\": \"SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of customer details from the 'Customers' table for those customers who have specific types of insurance policies. The placeholders in the WHERE clause represent the policy type codes that the user can specify.\",\n        \"virtual_table\": \"SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING] OR t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1535", "db_id": "insurance_and_eClaims", "question": "Find the names of all the customers and staff members.", "rationale": ["The task is to find the names of all customers and staff members.", "We need to retrieve data from two different tables: Customers and Staff.", "The Customers table has a column named 'Customer_Details' which contains the information we need.", "The Staff table has a column named 'Staff_Details' which contains the information we need.", "To combine the results from both tables, we can use the UNION operator, which allows us to combine the results of two SELECT statements into a single result set.", "The virtual table provided in the hint suggests using a SELECT statement for both tables and combining them with UNION.", "Thus, the final SQL query will select 'Customer_Details' from the Customers table and 'Staff_Details' from the Staff table using UNION."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "pred_sql": "SELECT Customer_Details FROM Customers UNION SELECT Staff_Details FROM Staff", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table combines detailed information about customers and staff members from the 'Customers' and 'Staff' tables. The placeholder in the SELECT statement allows for the retrieval of customer details and staff details, providing a comprehensive view of both entities.\",\n        \"virtual_table\": \"SELECT customer_details FROM customers UNION SELECT staff_details FROM staff\"\n    }\n}\n"}
{"sample_id": "train.1545", "db_id": "insurance_and_eClaims", "question": "Which customer is associated with the latest policy?", "rationale": ["Identify the relevant tables: We need to find the customer associated with the latest policy, so we will use the 'Policies' and 'Customers' tables.", "Join the 'Policies' table with the 'Customers' table on 'Customer_ID' to get customer details associated with each policy.", "To find the latest policy, we need to look for the maximum 'Start_Date' in the 'Policies' table.", "Use a subquery to get the maximum 'Start_Date' and filter the main query to only include the policy with that date.", "Select the 'Customer_Details' from the 'Customers' table for the policy that has the latest start date."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT t2.Customer_Details FROM Policies AS t1 JOIN Customers AS t2 ON t1.Customer_ID = t2.Customer_ID WHERE t1.Start_Date = (SELECT MAX(Start_Date) FROM Policies)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of customer details from the 'Customers' table for those customers who have specific types of insurance policies. The placeholders in the WHERE clause represent the policy type codes that the user can specify.\",\n        \"virtual_table\": \"SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING] OR t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of customer details from the 'Customers' table for those customers who hold a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code that is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table combines detailed information about customers and staff members from the 'Customers' and 'Staff' tables. The placeholder in the SELECT statement allows for the retrieval of customer details and staff details, providing a comprehensive view of both entities.\",\n        \"virtual_table\": \"SELECT customer_details FROM customers UNION SELECT staff_details FROM staff\"\n    }\n}\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: We need to find customer details and their associated policies, so we will use the Customers and Policies tables.", "Join the tables: We will join the Customers table with the Policies table on the Customer_ID to link customers with their policies.", "Order by the Start_Date: To find the most recently started policy, we will order the results by the Start_Date in descending order.", "Limit the results: Since we only want the customer with the most recent policy, we will limit the results to 1."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT t2.Customer_Details FROM Policies AS t1 JOIN Customers AS t2 ON t1.Customer_ID = t2.Customer_ID ORDER BY t1.Start_Date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of customer details from the 'Customers' table for those customers who have specific types of insurance policies. The placeholders in the WHERE clause represent the policy type codes that the user can specify.\",\n        \"virtual_table\": \"SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING] OR t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of customer details from the 'Customers' table for those customers who hold a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code that is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "We need to retrieve account details, so we will select columns from the Accounts table: account_id, account_name, and other_account_details.", "To filter accounts by the customer's first name, we need to join the Accounts table with the Customers table on customer_id.", "The WHERE clause will specify that we only want accounts for customers with the first name 'Meaghan'."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT A.account_id, A.account_name, A.other_account_details \nFROM Accounts AS A \nJOIN Customers AS C ON A.customer_id = C.customer_id \nWHERE C.customer_first_name = 'Meaghan';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    }\n}\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Accounts and Customers are needed to get account details for a specific customer.", "Join the Accounts table with the Customers table on the customer_id to link accounts to customers.", "Filter the results to only include the customer named Meaghan Keeling by using the WHERE clause with the customer's first and last name.", "Select the desired columns from the Accounts table, which include account_id, account_name, date_account_opened, and other_account_details."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT A.account_id, A.account_name, A.date_account_opened, A.other_account_details \nFROM Accounts AS A \nJOIN Customers AS C ON A.customer_id = C.customer_id \nWHERE C.customer_first_name = 'Meaghan' AND C.customer_last_name = 'Keeling';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    }\n}\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to join these tables on the customer_id to get customer details along with their account information.", "We are specifically looking for customers with the account name '900'.", "Select the full name of the customers by concatenating their first and last names.", "Construct the SQL query using the SELECT statement with the appropriate JOIN and WHERE clauses."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT T2.customer_first_name || ' ' || T2.customer_last_name AS full_name \nFROM Accounts AS T1 \nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id \nWHERE T1.account_name = '900'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1569", "db_id": "customers_and_invoices", "question": "Show id, first name and last name for all customers and the number of accounts.", "rationale": ["Identify the required fields: customer_id, customer_first_name, customer_last_name from the Customers table, and the count of accounts from the Accounts table.", "Use a LEFT JOIN to connect the Customers table with the Accounts table on the customer_id field to ensure all customers are included, even those without accounts.", "Use COUNT(A.account_id) to count the number of accounts for each customer.", "Group the results by customer_id to aggregate the account counts for each customer.", "Order the results by the number of accounts in descending order to show customers with the most accounts first."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT C.customer_id, C.customer_first_name, C.customer_last_name, COUNT(A.account_id) AS number_of_accounts \nFROM Customers AS C \nLEFT JOIN Accounts AS A ON C.customer_id = A.customer_id \nGROUP BY C.customer_id \nORDER BY number_of_accounts DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    }\n}\n"}
{"sample_id": "train.1570", "db_id": "customers_and_invoices", "question": "What are the the full names and ids for all customers, and how many accounts does each have?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to retrieve customer IDs and full names, which requires joining the Customers table.", "To get the full name, concatenate the first and last names from the Customers table.", "Count the number of accounts for each customer, which requires grouping by customer ID.", "Use a LEFT JOIN to ensure all customers are included, even those without accounts.", "Group the results by customer ID and full name to get the count of accounts for each customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT C.customer_id, C.customer_first_name || ' ' || C.customer_last_name AS full_name, COUNT(A.account_id) AS account_count \nFROM Customers AS C \nLEFT JOIN Accounts AS A ON C.customer_id = A.customer_id \nGROUP BY C.customer_id, C.customer_first_name, C.customer_last_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    }\n}\n"}
{"sample_id": "train.1580", "db_id": "customers_and_invoices", "question": "Count the number of financial transactions that correspond to each account id.", "rationale": ["Identify the tables involved: Financial_Transactions and Accounts.", "Determine the relationship between the tables: Financial_Transactions has a foreign key account_id that references Accounts.", "Select the necessary fields: account_name from Accounts and account_id from Accounts, along with a count of transactions from Financial_Transactions.", "Use a JOIN to combine the two tables based on the account_id.", "Group the results by account_id to get the count of transactions for each account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT T2.account_name, T1.account_id, count(*) FROM Financial_Transactions AS T1 JOIN Accounts AS T2 ON T1.account_id = T2.account_id GROUP BY T1.account_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1607", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of invoices for each order.", "rationale": ["We need to show the order IDs and the number of invoices for each order.", "To achieve this, we will join the 'Invoices' table with the 'Orders' table using the common column 'order_id'.", "We will select the 'order_id' from the 'Orders' table and count the number of 'invoice_number' entries from the 'Invoices' table for each order.", "The results will be grouped by 'order_id' to ensure we get the count of invoices for each specific order."], "gold_sql": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id", "source_tables": ["invoices"], "pred_sql": "SELECT T2.order_id, COUNT(T1.invoice_number) AS number_of_invoices \nFROM Invoices AS T1 \nJOIN Orders AS T2 ON T1.order_id = T2.order_id \nGROUP BY T2.order_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of order IDs and their corresponding details from the 'Orders' table, specifically for those orders that are associated with invoices. The results are grouped by order ID, and only those orders that have more than a specified number of associated invoices are included. The placeholder in the HAVING clause represents the minimum count of invoices required for an order to be displayed.\",\n        \"virtual_table\": \"SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of invoice numbers and their corresponding invoice dates from the 'Invoices' table, filtered by the number of financial transactions associated with each invoice. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["We need to show the order IDs and the number of items in each order.", "To get the number of items per order, we will use the 'Order_Items' table, which contains the 'order_id' and 'order_item_id'.", "We will join the 'Order_Items' table with the 'Orders' table on 'order_id' to ensure we are counting items for each specific order.", "We will use the COUNT function to count the number of 'order_item_id' entries for each 'order_id'.", "Finally, we will group the results by 'order_id' to get the count of items for each order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT T2.order_id, COUNT(T1.order_item_id) AS number_of_items \nFROM Order_Items AS T1 \nJOIN Orders AS T2 ON T1.order_id = T2.order_id \nGROUP BY T2.order_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of order IDs and their corresponding details from the 'Orders' table, specifically for those orders that are associated with invoices. The results are grouped by order ID, and only those orders that have more than a specified number of associated invoices are included. The placeholder in the HAVING clause represents the minimum count of invoices required for an order to be displayed.\",\n        \"virtual_table\": \"SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    }\n}\n"}
{"sample_id": "train.1622", "db_id": "customers_and_invoices", "question": "What are teh names of the different products, as well as the number of customers who have ordered each product.", "rationale": ["Identify the relevant tables: Products, Order_Items, and Orders are needed to get product names and customer orders.", "Join the Products table with the Order_Items table on product_id to link products with their orders.", "Join the Order_Items table with the Orders table on order_id to access customer information related to each order.", "Count the distinct customer IDs for each product to determine how many customers ordered each product.", "Group the results by product name to get the count of customers for each product."], "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"], "pred_sql": "SELECT P.product_name, COUNT(DISTINCT O.customer_id) AS customer_count \nFROM Products AS P \nJOIN Order_Items AS OI ON P.product_id = OI.product_id \nJOIN Orders AS O ON OI.order_id = O.order_id \nGROUP BY P.product_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2050", "db_id": "party_people", "question": "Which ministers are not a part of the Progress Party?", "rationale": ["Identify the relevant table: The 'party' table contains information about political parties and their associated ministers.", "Filter for the 'Progress Party': We need to exclude the ministers associated with the 'Progress Party'.", "Select distinct ministers: We want to retrieve a list of ministers who are not part of the 'Progress Party'.", "Ensure that we only include ministers that are not null: This ensures we only get valid minister identifiers."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT DISTINCT p.Minister \nFROM party p \nWHERE p.Party_name != 'Progress Party' \nAND p.Minister IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement allows for the retrieval of the party name and the count of members belonging to that party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT statement represents the party names, while the count function aggregates the total number of events for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    }\n}\n"}
{"sample_id": "train.2057", "db_id": "party_people", "question": "Show all party names and the number of members in each party.", "rationale": ["The task is to show all party names and the number of members in each party.", "To achieve this, we need to join the 'member' table with the 'party' table using the Party_ID as the common key.", "We will select the Party_name from the 'party' table and count the number of members from the 'member' table.", "The COUNT(*) function will count all members associated with each party.", "Finally, we will group the results by Party_ID to ensure we get the count for each party separately."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT T2.Party_name, COUNT(*) AS Number_of_Members \nFROM member AS T1 \nJOIN party AS T2 ON T1.Party_ID = T2.Party_ID \nGROUP BY T2.Party_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement allows for the retrieval of the party name and the count of members belonging to that party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT statement represents the party names, while the count function aggregates the total number of events for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    }\n}\n"}
{"sample_id": "train.2072", "db_id": "party_people", "question": "How many events are there for each party?", "rationale": ["The question asks for the number of events for each party.", "To get this information, we need to count the events from the 'party_events' table.", "We will join the 'party_events' table with the 'party' table to associate each event with its corresponding party name.", "The SQL query will select the party name and the count of events, grouping the results by party ID to aggregate the counts correctly."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT T2.party_name, count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id = T2.party_id GROUP BY T1.party_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT statement represents the party names, while the count function aggregates the total number of events for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement allows for the retrieval of the party name and the count of members belonging to that party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    }\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the relevant tables: party_events, party, and region.", "We need to count the number of events, so we will use the COUNT() function.", "Join the party_events table with the party table to get the party names associated with the events.", "Join the resulting table with the region table to filter by the United Kingdom region.", "Add a WHERE clause to filter for events specifically named 'Annual Meeting'.", "Finally, use COUNT(*) to get the total number of Annual Meeting events in the United Kingdom."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT COUNT(*) FROM party_events AS T1 JOIN party AS T2 ON T1.Party_ID = T2.Party_ID JOIN region AS T3 ON T2.Region_ID = T3.Region_ID WHERE T1.Event_Name = 'Annual Meeting' AND T3.Region_name = 'United Kingdom'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT statement represents the party names, while the count function aggregates the total number of events for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    }\n}\n"}
{"sample_id": "train.2167", "db_id": "formula_1", "question": "What is the id and family name of the driver who has the longest laptime?", "rationale": ["We need to find the driver with the longest lap time, which means we will be looking for the maximum value in the lap times recorded in the 'lapTimes' table.", "To do this, we will join the 'drivers' table with the 'lapTimes' table on the driverId, which is the common key between these two tables.", "We will select the driverId and surname from the 'drivers' table.", "To find the longest lap time, we will order the results by the milliseconds column in the 'lapTimes' table in descending order, as we want the longest time at the top.", "Finally, we will limit the results to just one entry to get the driver with the longest lap time."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "pred_sql": "SELECT T1.driverId, T1.surname FROM drivers AS T1 JOIN lapTimes AS T2 ON T1.driverId = T2.driverId ORDER BY T2.milliseconds DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded during races in a specific year and for a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    }\n}\n"}
{"sample_id": "train.2174", "db_id": "formula_1", "question": "How many drivers did not race in 2009?", "rationale": ["Identify the requirement: We need to count the number of drivers who did not race in the year 2009.", "To achieve this, we will use the 'results' table to find all drivers and filter out those who participated in races held in 2009.", "We will use a subquery to select all raceIds from the 'races' table where the year is 2009.", "The main query will count distinct driverIds from the 'results' table, excluding those raceIds obtained from the subquery."], "gold_sql": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )", "source_tables": ["results", "races"], "pred_sql": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE year = 2009 )", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.\",\n        \"virtual_table\": \"SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2179", "db_id": "formula_1", "question": "Find the id and forenames of drivers who participated both the races with name Australian Grand Prix and the races with name Chinese Grand Prix?", "rationale": ["Identify the tables needed: We need the 'drivers' table to get driver information, the 'results' table to link drivers to races, and the 'races' table to filter by race names.", "Join the 'drivers' table with the 'results' table to get the races each driver participated in.", "Join the 'results' table again to link it to the 'races' table for both the Australian Grand Prix and the Chinese Grand Prix.", "Use a WHERE clause to filter the races by their names: 'Australian Grand Prix' and 'Chinese Grand Prix'.", "Select the driverId and forename from the 'drivers' table, ensuring we only get drivers who participated in both races by grouping by driverId and forename."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.driverId, d.forename \nFROM drivers AS d \nJOIN results AS r1 ON d.driverId = r1.driverId \nJOIN races AS ra1 ON r1.raceId = ra1.raceId \nJOIN results AS r2 ON d.driverId = r2.driverId \nJOIN races AS ra2 ON r2.raceId = ra2.raceId \nWHERE ra1.name = 'Australian Grand Prix' \nAND ra2.name = 'Chinese Grand Prix' \nGROUP BY d.driverId, d.forename;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the driver standings, a certain number of wins, and more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2180", "db_id": "formula_1", "question": "What is the id and first name of all the drivers who participated in the Australian Grand Prix and the Chinese Grand Prix?", "rationale": ["Identify the tables needed: We need the 'drivers', 'results', and 'races' tables to get the required information about drivers who participated in specific races.", "Join the 'drivers' table with the 'results' table on 'driverId' to link drivers to their race results.", "Join the 'results' table with the 'races' table on 'raceId' to filter results based on the race names.", "Use a WHERE clause to filter for the 'Australian Grand Prix' and 'Chinese Grand Prix'.", "Select distinct 'driverId' and 'forename' from the resulting joined tables to avoid duplicates."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT DISTINCT d.driverId, d.forename \nFROM drivers AS d \nJOIN results AS r ON d.driverId = r.driverId \nJOIN races AS ra ON r.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' OR ra.name = 'Chinese Grand Prix';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the driver standings, a certain number of wins, and more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the tables needed: We need the 'drivers', 'results', and 'races' tables to get the required information about drivers and the races they participated in.", "We need to find drivers who participated in the 'Australian Grand Prix'. This requires joining the 'drivers' table with the 'results' table and then with the 'races' table to filter by the race name.", "Next, we need to exclude drivers who participated in the 'Chinese Grand Prix'. This can be done using a subquery that selects driver IDs from the same tables but filters for the 'Chinese Grand Prix'.", "The final query will select distinct first and last names of drivers who meet the criteria of participating in the Australian Grand Prix but not in the Chinese Grand Prix."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT DISTINCT d.forename, d.surname \nFROM drivers d \nJOIN results r1 ON d.driverId = r1.driverId \nJOIN races ra ON r1.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' \nAND d.driverId NOT IN (\n    SELECT d2.driverId \n    FROM drivers d2 \n    JOIN results r2 ON d2.driverId = r2.driverId \n    JOIN races rb ON r2.raceId = rb.raceId \n    WHERE rb.name = 'Chinese Grand Prix'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the driver standings, a certain number of wins, and more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2190", "db_id": "formula_1", "question": "For each constructor id, how many races are there?", "rationale": ["Identify the relevant table: The 'constructorResults' table contains the relationship between constructors and races.", "Determine the required information: We need to count the number of races for each constructor.", "Use the COUNT function to count the occurrences of raceId for each constructorId.", "Group the results by constructorId to get the count for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(raceId) AS race_count FROM constructorResults GROUP BY constructorId;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.\",\n        \"virtual_table\": \"SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded during races in a specific year and for a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    }\n}\n"}
{"sample_id": "train.2194", "db_id": "formula_1", "question": "What are the names of all races held after 2000 in Spain?", "rationale": ["Identify the relevant tables: 'races' for race details and 'circuits' for circuit location.", "We need to find races held after the year 2000, so we will filter the 'year' column in the 'races' table.", "We also need to filter for races held in Spain, which requires joining the 'races' table with the 'circuits' table on 'circuitId'.", "Select the 'name' of the races that meet both conditions: year > 2000 and country = 'Spain'."], "gold_sql": "SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = 'Spain' AND T1.year > 2000", "source_tables": ["races", "circuits"], "pred_sql": "SELECT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.year > 2000 AND T2.country = 'Spain'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of distinct drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.\",\n        \"virtual_table\": \"SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.2217", "db_id": "formula_1", "question": "Find the names of Japanese constructors that have once earned more than 5 points?", "rationale": ["Identify the relevant tables: We need to find constructors and their points, so we will use the 'constructors' and 'constructorResults' tables.", "Join the tables: We will join 'constructors' with 'constructorResults' on 'constructorId' to link constructors with their results.", "Filter by nationality: We need to filter the constructors to only include those from Japan, so we add a WHERE clause for 'nationality'.", "Set the points condition: We need to find constructors that have earned more than 5 points, so we add another condition in the WHERE clause for 'points'.", "Select the names: Finally, we select the distinct names of the constructors that meet the criteria."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT DISTINCT c.name \nFROM constructors AS c \nJOIN constructorResults AS cr ON c.constructorId = cr.constructorId \nWHERE c.nationality = 'Japanese' \nAND cr.points > 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the driver standings, a certain number of wins, and more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the relevant tables: We need to get the names of constructors, which are in the 'constructors' table, and their points, which are in the 'constructorResults' table.", "Join the 'constructors' table with the 'constructorResults' table on the 'constructorId' to link constructors with their results.", "Filter the results to include only those constructors whose nationality is 'Japanese'.", "Add a condition to ensure that the points earned by the constructors are greater than 5.", "Select the distinct names of the constructors that meet these criteria."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT DISTINCT constructors.name \nFROM constructors \nJOIN constructorResults ON constructors.constructorId = constructorResults.constructorId \nWHERE constructors.nationality = 'Japanese' \nAND constructorResults.points > 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the driver standings, a certain number of wins, and more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: 'races' for race details and 'results' for lap speeds.", "We need to find the average fastest lap speed for a specific race (Monaco Grand Prix) in a specific year (2008).", "Join the 'races' table with the 'results' table on the raceId to access the fastest lap speed.", "Filter the results to only include the Monaco Grand Prix in 2008 using the WHERE clause.", "Use the AVG() function to calculate the average fastest lap speed."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT avg(T2.fastestLapSpeed) FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded during races in a specific year and for a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    }\n}\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: 'races' for race details and 'results' for fastest lap speeds.", "We need to find the maximum fastest lap speed for a specific race (Monaco Grand Prix) in a specific year (2008).", "Join the 'races' table with the 'results' table on the raceId to access both race and result data.", "Use the WHERE clause to filter for the year 2008 and the race name 'Monaco Grand Prix'.", "Select the maximum value of the fastest lap speed from the results."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT max(T2.fastestLapSpeed) FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded during races in a specific year and for a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    }\n}\n"}
{"sample_id": "train.2223", "db_id": "formula_1", "question": "What are the maximum fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the tables needed: 'races' for race details and 'results' for fastest lap speeds.", "Join the 'races' table with the 'results' table on 'raceId' to access both race names and fastest lap speeds.", "Filter the results to include only races held after the year 2004 using the WHERE clause.", "Group the results by race name and year to calculate the maximum fastest lap speed for each race.", "Select the maximum fastest lap speed using the MAX function and include the race name and year in the output.", "Order the final results by year to present them in chronological order."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT T1.name, T1.year, max(T2.fastestLapSpeed) AS max_fastest_lap_speed \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nWHERE T1.year > 2004 \nGROUP BY T1.name, T1.year \nORDER BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded during races in a specific year and for a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    }\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["Identify the tables needed: 'races' for race names and years, and 'results' for fastest lap speeds.", "Join the 'races' table with the 'results' table on 'raceId' to access both race names and their corresponding fastest lap speeds.", "Filter the results to include only races that occurred after the year 2004.", "Group the results by race name to calculate the maximum fastest lap speed for each race.", "Select the maximum fastest lap speed for each race and order the results by year."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT T1.name, max(T2.fastestLapSpeed) as max_fastest_lap_speed \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nWHERE T1.year > 2004 \nGROUP BY T1.name \nORDER BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded during races in a specific year and for a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    }\n}\n"}
{"sample_id": "train.2325", "db_id": "csu_1", "question": "What campuses are located in the county of Los Angeles?", "rationale": ["Identify the relevant table: The question asks about campuses, which are listed in the 'Campuses' table.", "Determine the condition: The question specifies that we are looking for campuses located in 'Los Angeles', which relates to the 'County' column in the 'Campuses' table.", "Construct the SQL query: We need to select the 'Campus' column from the 'Campuses' table where the 'County' is 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have faculty data for a specific year. The campuses are ordered by the number of faculty members in descending order, and the result is limited to a specified number of campuses. The placeholders in the WHERE clause represent the year of the faculty data and the limit on the number of campuses to return.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have total enrollments exceeding a specified number and full-time equivalent enrollments exceeding another specified number for a given academic year. The placeholders in the WHERE clause represent the year and the enrollment thresholds.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] AND totalenrollment_ay  >  [PLACEHOLDER-TYPE:NUMBER] AND FTE_AY  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2347", "db_id": "csu_1", "question": "In what year was the most degrees conferred?", "rationale": ["We need to find out in which year the most degrees were conferred.", "To do this, we will aggregate the total number of degrees awarded by year.", "We will use the 'degrees' table, which contains the 'Year' and 'Degrees' columns.", "We will group the results by 'Year' to get the total degrees for each year.", "Then, we will order the results in descending order based on the total degrees awarded.", "Finally, we will limit the results to 1 to get the year with the highest total degrees."], "gold_sql": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Year, SUM(Degrees) AS TotalDegrees FROM degrees GROUP BY Year ORDER BY TotalDegrees DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2348", "db_id": "csu_1", "question": "Which campus has the most degrees conferred in all times?", "rationale": ["We need to find the campus with the most degrees conferred.", "To do this, we will join the 'Campuses' table with the 'degrees' table on the campus identifier.", "We will sum the total degrees awarded for each campus using the SUM function.", "We will group the results by campus to aggregate the total degrees for each campus.", "To find the campus with the most degrees, we will order the results in descending order based on the total degrees.", "Finally, we will limit the results to only one campus to get the campus with the highest total degrees."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT T1.Campus, SUM(T2.Degrees) AS TotalDegrees\nFROM Campuses AS T1\nJOIN degrees AS T2 ON T1.Id = T2.Campus\nGROUP BY T1.Campus\nORDER BY TotalDegrees DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2349", "db_id": "csu_1", "question": "What campus has the most degrees  conferrred over its entire existence?", "rationale": ["Identify the tables involved: We need to look at the 'Campuses' table for campus information and the 'degrees' table for the degrees awarded.", "Join the 'Campuses' table with the 'degrees' table on the campus identifier to relate campuses to their awarded degrees.", "Use the SUM function to calculate the total number of degrees awarded for each campus.", "Group the results by campus to aggregate the total degrees awarded per campus.", "Order the results in descending order to find the campus with the most degrees awarded.", "Limit the results to 1 to get only the campus with the highest total degrees."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT T1.Campus, SUM(T2.Degrees) AS TotalDegrees\nFROM Campuses AS T1\nJOIN degrees AS T2 ON T1.Id = T2.Campus\nGROUP BY T1.Campus\nORDER BY TotalDegrees DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2351", "db_id": "csu_1", "question": "What campus has the most faculties in 2003?", "rationale": ["Identify the relevant tables: 'Campuses' and 'faculty'.", "We need to find the campus with the most faculty members in the year 2003.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Filter the results to only include records from the year 2003.", "Order the results by the number of faculty members in descending order to get the campus with the most faculty at the top.", "Limit the results to 1 to get only the campus with the highest number of faculty."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T1.Campus FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus WHERE T2.Year = 2003 ORDER BY T2.Faculty DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have faculty data for a specific year. The campuses are ordered by the number of faculty members in descending order, and the result is limited to a specified number of campuses. The placeholders in the WHERE clause represent the year of the faculty data and the limit on the number of campuses to return.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\",\n        \"virtual_table\": \"SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\",\n        \"virtual_table\": \"SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2358", "db_id": "csu_1", "question": "For each Orange county campus, report the number of degrees granted after 2000.", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to filter campuses located in Orange County, so we will use the County column from the Campuses table.", "We need to count the number of degrees granted after the year 2000, so we will filter the degrees table based on the Year column.", "Join the Campuses table with the degrees table on the Campus identifier to relate campuses to their awarded degrees.", "Use COUNT to aggregate the number of degrees granted for each campus, grouping by the Campus identifier."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT T1.Campus, COUNT(T2.Degrees) AS DegreesGranted \nFROM Campuses AS T1 \nJOIN degrees AS T2 ON T1.Id = T2.Campus \nWHERE T1.County = 'Orange' AND T2.Year > '2000' \nGROUP BY T1.Campus;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to join these tables on the campus identifier (Id in Campuses and Campus in degrees).", "Filter the results to include only campuses in Orange County and degrees awarded after the year 2000.", "Use the SUM function to calculate the total number of degrees granted for each campus.", "Group the results by campus to get the total degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT T1.Campus, SUM(T2.Degrees) AS TotalDegrees\nFROM Campuses AS T1\nJOIN degrees AS T2 ON T1.Id = T2.Campus\nWHERE T1.County = 'Orange' AND T2.Year >= '2001'\nGROUP BY T1.Campus;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant tables: 'Campuses' for campus information and 'enrollments' for enrollment data.", "Join the 'Campuses' table with the 'enrollments' table on the campus identifier.", "Filter the results for the year 1956 using the WHERE clause.", "Add conditions to check for total enrollment greater than 400 and full-time equivalent enrollment greater than 200."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT T1.Campus FROM Campuses AS T1 JOIN enrollments AS T2 ON T1.Id = T2.Campus WHERE T2.Year = 1956 AND T2.TotalEnrollment_AY > 400 AND T2.FTE_AY > 200", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have total enrollments exceeding a specified number and full-time equivalent enrollments exceeding another specified number for a given academic year. The placeholders in the WHERE clause represent the year and the enrollment thresholds.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] AND totalenrollment_ay  >  [PLACEHOLDER-TYPE:NUMBER] AND FTE_AY  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2367", "db_id": "csu_1", "question": "What campuses are in Los Angeles county?", "rationale": ["Identify the relevant table: The question asks about campuses, which are listed in the 'Campuses' table.", "Determine the filtering criteria: The question specifies 'Los Angeles county', so we need to filter the results based on the 'County' column.", "Construct the SQL query: We will select all columns from the 'Campuses' table where the 'County' is 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT * FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have total enrollments exceeding a specified number and full-time equivalent enrollments exceeding another specified number for a given academic year. The placeholders in the WHERE clause represent the year and the enrollment thresholds.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] AND totalenrollment_ay  >  [PLACEHOLDER-TYPE:NUMBER] AND FTE_AY  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have faculty data for a specific year. The campuses are ordered by the number of faculty members in descending order, and the result is limited to a specified number of campuses. The placeholders in the WHERE clause represent the year of the faculty data and the limit on the number of campuses to return.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to count the number of degrees conferred, so we will use the COUNT function on the Degrees column from the degrees table.", "Join the Campuses table with the degrees table on the campus identifier (Id in Campuses and Campus in degrees).", "Filter the results to only include records where the campus name is 'San Jose State University' and the year is '2000'.", "Construct the SQL query using the identified columns and conditions."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT COUNT(T2.Degrees) FROM Campuses AS T1 JOIN degrees AS T2 ON T1.Id = T2.Campus WHERE T1.Campus = 'San Jose State University' AND T2.Year = '2000'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "Use a JOIN to connect the 'faculty' table with the 'Campuses' table based on the campus identifier.", "Filter the results for the specific year (2004) and the specific campus ('San Francisco State University').", "Select the number of faculty members from the filtered results."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T1.Faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.Campus = T2.Id WHERE T1.Year = 2004 AND T2.Campus = 'San Francisco State University'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\",\n        \"virtual_table\": \"SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\",\n        \"virtual_table\": \"SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have faculty data for a specific year. The campuses are ordered by the number of faculty members in descending order, and the result is limited to a specified number of campuses. The placeholders in the WHERE clause represent the year of the faculty data and the limit on the number of campuses to return.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2378", "db_id": "csu_1", "question": "List the campus that have between 600 and 1000 faculty lines in year 2004.", "rationale": ["Identify the relevant tables: 'Campuses' and 'faculty'.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Filter the results to include only those records from the year 2004.", "Add a condition to filter faculty counts to be between 600 and 1000.", "Select the campus names from the filtered results."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T1.Campus FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus WHERE T2.Year = 2004 AND T2.Faculty BETWEEN 600 AND 1000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have faculty data for a specific year. The campuses are ordered by the number of faculty members in descending order, and the result is limited to a specified number of campuses. The placeholders in the WHERE clause represent the year of the faculty data and the limit on the number of campuses to return.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\",\n        \"virtual_table\": \"SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\",\n        \"virtual_table\": \"SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2379", "db_id": "csu_1", "question": "What are the campuses that had between 600 and 1000 faculty members in 2004?", "rationale": ["Identify the relevant tables: 'Campuses' and 'faculty'.", "We need to join these tables on the campus identifier.", "Filter the results for the year 2004 using the 'Year' column from the 'faculty' table.", "Apply a condition to filter faculty members between 600 and 1000 using the 'Faculty' column from the 'faculty' table."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T1.Campus FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus WHERE T2.Year = 2004 AND T2.Faculty BETWEEN 600 AND 1000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have faculty data for a specific year. The campuses are ordered by the number of faculty members in descending order, and the result is limited to a specified number of campuses. The placeholders in the WHERE clause represent the year of the faculty data and the limit on the number of campuses to return.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\",\n        \"virtual_table\": \"SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\",\n        \"virtual_table\": \"SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2380", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the most number of degrees in year 2002?", "rationale": ["Identify the year of interest, which is 2002, to filter the degrees awarded.", "Use the provided virtual table to calculate the total number of degrees awarded at each campus in 2002.", "Group the results by campus and order them by the total number of degrees in descending order to find the campus with the most degrees awarded.", "Limit the results to the top campus (the one with the most degrees) using LIMIT 1.", "Join this result with the faculty table to count the number of faculty lines for that specific campus."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(*) FROM faculty AS T1 JOIN (SELECT T1.campus, SUM(T2.degrees) AS total_degrees FROM campuses AS T1 JOIN degrees AS T2 ON T1.id = T2.campus WHERE T2.year = '2002' GROUP BY T1.campus ORDER BY total_degrees DESC LIMIT 1) AS T2 ON T1.campus = T2.campus;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\",\n        \"virtual_table\": \"SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the campus that awarded the least number of degrees in 2001 by summing the degrees from the 'degrees' table and grouping by campus.", "Use the virtual table provided to create a subquery that selects the campus with the minimum total degrees awarded in 2001.", "Join this subquery with the 'faculty' table to get the number of faculty members for that campus.", "Filter the faculty data for the year 2001 to get the correct count of faculty members."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT T1.Faculty FROM faculty AS T1 JOIN (SELECT T1.Campus, SUM(T2.Degrees) AS TotalDegrees FROM Campuses AS T1 JOIN degrees AS T2 ON T1.Id = T2.Campus WHERE T2.Year = '2001' GROUP BY T1.Campus ORDER BY TotalDegrees ASC LIMIT 1) AS T3 ON T1.Campus = T3.Campus WHERE T1.Year = '2001';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\",\n        \"virtual_table\": \"SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "Determine the specific campus of interest, which is 'San Jose State'.", "Use a subquery to find the 'Id' of 'San Jose State' from the 'Campuses' table.", "Filter the 'discipline_enrollments' table by the campus 'Id' obtained from the subquery.", "Sum the 'Undergraduate' column to get the total number of undergraduates at 'San Jose State'."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT SUM(Undergraduate) AS TotalUndergraduates FROM discipline_enrollments WHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Jose State')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have total enrollments exceeding a specified number and full-time equivalent enrollments exceeding another specified number for a given academic year. The placeholders in the WHERE clause represent the year and the enrollment thresholds.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] AND totalenrollment_ay  >  [PLACEHOLDER-TYPE:NUMBER] AND FTE_AY  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.3131", "db_id": "assets_maintenance", "question": "Which engineer has visited the most times? Show the engineer id, first name and last name.", "rationale": ["Identify the relevant tables: Engineer_Visits and Maintenance_Engineers.", "We need to count the number of visits for each engineer, so we will use COUNT(*) to aggregate the visits.", "Join the Engineer_Visits table with the Maintenance_Engineers table on the engineer_id to get the first name and last name of the engineers.", "Group the results by engineer_id, first_name, and last_name to get the count of visits for each engineer.", "Order the results by visit_count in descending order to find the engineer with the most visits.", "Limit the results to 1 to get only the engineer with the highest visit count."], "gold_sql": "SELECT T1.engineer_id ,  T1.first_name ,  T1.last_name FROM Maintenance_Engineers AS T1 JOIN Engineer_Visits AS T2 GROUP BY T1.engineer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["maintenance_engineers", "engineer_visits"], "pred_sql": "SELECT engineer_id, first_name, last_name, COUNT(*) as visit_count\nFROM Engineer_Visits\nJOIN Maintenance_Engineers ON Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id\nGROUP BY engineer_id, first_name, last_name\nORDER BY visit_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3139", "db_id": "assets_maintenance", "question": "How many fault status codes are recorded in the fault log parts table?", "rationale": ["The user wants to know how many unique fault status codes are recorded in the fault log parts table.", "To achieve this, we need to count the distinct fault status codes from the joined data of the Fault_Log and Fault_Log_Parts tables.", "The hint provides a virtual table that joins these two tables and selects the fault description and fault status.", "We will use this virtual table as a subquery to count the distinct fault statuses.", "The final SQL query will select the count of distinct fault statuses from this subquery."], "gold_sql": "SELECT DISTINCT fault_status FROM Fault_Log_Parts", "source_tables": ["fault_log_parts"], "pred_sql": "SELECT COUNT(DISTINCT fault_status) AS unique_fault_status_count FROM (SELECT T1.fault_description, T2.fault_status FROM Fault_Log AS T1 JOIN Fault_Log_Parts AS T2 ON T1.fault_log_entry_id = T2.fault_log_entry_id) AS fault_statuses;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of fault descriptions and their corresponding statuses from the 'Fault_Log' and 'Fault_Log_Parts' tables. The join operation links the fault log entries with the parts associated with those faults, allowing users to see the details of each fault alongside its current status.\",\n        \"virtual_table\": \"SELECT T1.fault_description ,  T2.fault_status FROM Fault_Log AS T1 JOIN Fault_Log_Parts AS T2 ON T1.fault_log_entry_id  =  T2.fault_log_entry_id\"\n    }\n}\n"}
{"sample_id": "train.3143", "db_id": "assets_maintenance", "question": "Which part fault requires the most number of skills to fix? List part id and name.", "rationale": ["Identify the tables involved: Part_Faults, Skills_Required_To_Fix, and Parts.", "We need to find the part fault that requires the most skills, so we will join Part_Faults with Skills_Required_To_Fix on part_fault_id.", "We also need the part name, so we will join with the Parts table on part_id.", "Group the results by part_id and part_name to count the number of skills required for each part fault.", "Order the results by the count of skills in descending order to get the part fault with the most skills at the top.", "Limit the results to 1 to get only the top result."], "gold_sql": "SELECT T1.part_id ,  T1.part_name FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id  =  T2.part_id JOIN Skills_Required_To_Fix AS T3 ON T2.part_fault_id  =  T3.part_fault_id GROUP BY T1.part_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["part_faults", "parts", "skills_required_to_fix"], "pred_sql": "SELECT PF.part_id, P.part_name\nFROM Part_Faults AS PF\nJOIN Skills_Required_To_Fix AS SR ON PF.part_fault_id = SR.part_fault_id\nJOIN Parts AS P ON PF.part_id = P.part_id\nGROUP BY PF.part_id, P.part_name\nORDER BY COUNT(SR.skill_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of fault descriptions and their corresponding statuses from the 'Fault_Log' and 'Fault_Log_Parts' tables. The join operation links the fault log entries with the parts associated with those faults, allowing users to see the details of each fault alongside its current status.\",\n        \"virtual_table\": \"SELECT T1.fault_description ,  T2.fault_status FROM Fault_Log AS T1 JOIN Fault_Log_Parts AS T2 ON T1.fault_log_entry_id  =  T2.fault_log_entry_id\"\n    }\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant table: The CLASS table contains information about classes and the professors teaching them.", "Determine the specific class code: The user is interested in the class with the code 'ACCT-211'.", "Count the distinct professors: We need to count the number of unique professors (PROF_NUM) teaching this class.", "Construct the SQL query: Use COUNT(DISTINCT) to count unique professors from the CLASS table where the CRS_CODE matches 'ACCT-211'."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT T1.prof_num) AS professor_count \nFROM CLASS AS T1 \nWHERE T1.CRS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n        \"virtual_table\": \"SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3180", "db_id": "college_1", "question": "What are the first names and birthdates of the professors in charge of ACCT-211?", "rationale": ["Identify the tables needed: We need information from the EMPLOYEE table for professors and the CLASS table to link professors to courses.", "Determine the relevant columns: We need the first names (EMP_FNAME) and birthdates (EMP_DOB) of the professors.", "Establish the join condition: The EMPLOYEE table should be joined with the CLASS table on the professor's identifier (EMP_NUM) and the professor's identifier in the CLASS table (PROF_NUM).", "Filter the results: We need to filter the results to only include professors teaching the course with the code 'ACCT-211'.", "Construct the SQL query: Using the SELECT statement to retrieve the distinct first names and birthdates of the professors who teach the specified course."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT DISTINCT T1.EMP_FNAME, T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM = T2.PROF_NUM WHERE T2.CRS_CODE = 'ACCT-211'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n        \"virtual_table\": \"SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors who teach a specific course. The data is retrieved from the 'employee' table, which contains information about professors, and is joined with the 'class' table to filter by the course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names of professors along with the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3189", "db_id": "college_1", "question": "How many different locations does the school with code BUS has?", "rationale": ["Identify the relevant tables: We need to find the locations of classes offered by the school with code 'BUS'. The relevant tables are DEPARTMENT and CLASS.", "Join the DEPARTMENT and CLASS tables: We will join these tables on the department code to link classes to their respective departments.", "Filter by school code: We will filter the results to only include departments that belong to the school with code 'BUS'.", "Count distinct locations: We need to count the distinct CLASS_ROOM entries to find out how many different locations are associated with the classes from the BUS school."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT COUNT(DISTINCT CLASS_ROOM) AS different_locations FROM DEPARTMENT JOIN CLASS ON DEPARTMENT.DEPT_CODE = CLASS.CRS_CODE WHERE DEPARTMENT.SCHOOL_CODE = 'BUS';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows for specifying the maximum number of school codes to return.\",\n        \"virtual_table\": \"SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of school codes from the 'department' table, grouped by school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows for specifying the maximum number of school codes to return.\",\n        \"virtual_table\": \"SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the relevant table: The question asks for locations associated with a specific school code, which relates to the DEPARTMENT table.", "Determine the required columns: We need the physical address of the department, which is in the DEPT_ADDRESS column.", "Apply the filter: We need to filter the results to only include departments that belong to the school with the code 'BUS'.", "Use DISTINCT to ensure that we only get unique addresses, as there may be multiple departments under the same school code with the same address."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows for specifying the maximum number of school codes to return.\",\n        \"virtual_table\": \"SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of school codes from the 'department' table, grouped by school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows for specifying the maximum number of school codes to return.\",\n        \"virtual_table\": \"SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3206", "db_id": "college_1", "question": "How many classes are held in each department?", "rationale": ["Identify the tables involved: CLASS and COURSE are needed to get the count of classes per department.", "Determine the relationship: CLASS has a foreign key CRS_CODE that links to COURSE, allowing us to join these tables.", "Select the count of classes: Use COUNT(*) to count the number of classes for each department.", "Group by department: Use GROUP BY on the department code from the COURSE table to aggregate the counts by department."], "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"], "pred_sql": "SELECT COUNT(*) AS class_count, T2.dept_code \nFROM CLASS AS T1 \nJOIN COURSE AS T2 ON T1.CRS_CODE = T2.CRS_CODE \nGROUP BY T2.dept_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3209", "db_id": "college_1", "question": "What is the number of professors for different school?", "rationale": ["We need to find the number of professors for different schools.", "To do this, we will join the DEPARTMENT table with the PROFESSOR table on the DEPT_CODE.", "We will count the number of professors (EMP_NUM) for each school (SCHOOL_CODE).", "We will group the results by SCHOOL_CODE to get the count of professors per school.", "Finally, we will order the results by the count of professors in descending order."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "pred_sql": "SELECT T1.school_code, COUNT(T2.emp_num) AS professor_count \nFROM department AS T1 \nJOIN professor AS T2 ON T1.dept_code = T2.dept_code \nGROUP BY T1.school_code \nORDER BY professor_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of school codes from the 'department' table, grouped by school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows for specifying the maximum number of school codes to return.\",\n        \"virtual_table\": \"SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3210", "db_id": "college_1", "question": "How many different professors are there for the different schools?", "rationale": ["We need to find the number of different professors across different schools.", "Professors are associated with departments, and each department belongs to a school.", "To get the count of different professors, we can use the COUNT function with DISTINCT on the professor's unique identifier (EMP_NUM).", "We will join the PROFESSOR table with the DEPARTMENT table to ensure we are counting professors from different schools.", "The final SQL query will select the count of distinct professors from the joined tables."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "pred_sql": "SELECT COUNT(DISTINCT T1.emp_num) AS different_professors FROM professor AS T1 JOIN department AS T2 ON T1.dept_code = T2.dept_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n        \"virtual_table\": \"SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["To find the number of students for each department, we need to join the DEPARTMENT table with the STUDENT table based on the DEPT_CODE.", "The DEPARTMENT table contains the department names and codes, while the STUDENT table contains the student information including their department code.", "We will use a COUNT function to count the number of students (STU_NUM) for each department.", "The results will be grouped by the department name (DEPT_NAME) to get the count for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT D.DEPT_NAME, COUNT(S.STU_NUM) AS NUM_STUDENTS \nFROM DEPARTMENT AS D \nJOIN STUDENT AS S ON D.DEPT_CODE = S.DEPT_CODE \nGROUP BY D.DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3218", "db_id": "college_1", "question": "How many students are in each department?", "rationale": ["We need to count the number of students in each department.", "To do this, we will join the DEPARTMENT table with the STUDENT table on the DEPT_CODE column.", "We will select the DEPT_NAME from the DEPARTMENT table and count the number of students (STU_NUM) from the STUDENT table.", "We will group the results by DEPT_CODE to get the count of students for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPT.DEPT_NAME, COUNT(STU.STU_NUM) AS STUDENT_COUNT \nFROM DEPARTMENT AS DEPT \nJOIN STUDENT AS STU ON DEPT.DEPT_CODE = STU.DEPT_CODE \nGROUP BY DEPT.DEPT_CODE;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3220", "db_id": "college_1", "question": "How many hours do the students spend studying in each department?", "rationale": ["The question asks for the total hours students spend studying in each department, which implies we need to aggregate data related to courses and their respective departments.", "We start by identifying the relevant tables: COURSE (for course credit hours), CLASS (to link courses to classes), DEPARTMENT (to get department names), ENROLL (to link students to classes), and STUDENT (to ensure we are considering students).", "We will join these tables based on their relationships: CLASS to COURSE on CRS_CODE, CLASS to ENROLL on CLASS_CODE, and ENROLL to STUDENT on STU_NUM.", "Next, we need to sum the credit hours from the COURSE table, which represents the hours spent studying, and group the results by department name from the DEPARTMENT table.", "Finally, we will select the department name and the total study hours, ensuring the output is grouped by department."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT T3.dept_name, SUM(T1.crs_credit) AS total_study_hours \nFROM course AS T1 \nJOIN class AS T2 ON T1.crs_code = T2.crs_code \nJOIN department AS T3 ON T1.dept_code = T3.dept_code \nJOIN enroll AS T4 ON T2.class_code = T4.class_code \nJOIN student AS T5 ON T4.stu_num = T5.stu_num \nGROUP BY T3.dept_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3222", "db_id": "college_1", "question": "What is the highest, lowest, and average student GPA for every department?", "rationale": ["Identify the relevant tables: STUDENT and DEPARTMENT are needed to get student GPAs and their associated departments.", "Join the STUDENT table with the DEPARTMENT table on the DEPT_CODE to associate each student with their department.", "Use aggregate functions MAX, MIN, and AVG to calculate the highest, lowest, and average GPAs respectively.", "Group the results by department name to get the GPA statistics for each department."], "gold_sql": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT D.DEPT_NAME, MAX(S.STU_GPA) AS Highest_GPA, MIN(S.STU_GPA) AS Lowest_GPA, AVG(S.STU_GPA) AS Average_GPA\nFROM STUDENT S\nJOIN DEPARTMENT D ON S.DEPT_CODE = D.DEPT_CODE\nGROUP BY D.DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3234", "db_id": "college_1", "question": "How many courses does the department of Computer Information Systmes offer?", "rationale": ["Identify the relevant tables: CLASS, COURSE, and DEPARTMENT are needed to find the number of courses offered by a specific department.", "Join the CLASS table with the COURSE table on the CRS_CODE to link classes to their respective courses.", "Join the COURSE table with the DEPARTMENT table on the DEPT_CODE to filter courses by department.", "Use a WHERE clause to specify the department name as 'Computer Information Systems'.", "Count the number of courses that meet the criteria using COUNT(*) in the SELECT statement."], "gold_sql": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "department"], "pred_sql": "SELECT count(*) FROM CLASS AS T1 JOIN COURSE AS T2 ON T1.CRS_CODE = T2.CRS_CODE JOIN DEPARTMENT AS T3 ON T2.DEPT_CODE = T3.DEPT_CODE WHERE T3.DEPT_NAME = 'Computer Information Systems'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3238", "db_id": "college_1", "question": "What are the total number of credits offered by each department?", "rationale": ["Identify the relevant tables: We need to gather information about courses and their associated departments, which involves the COURSE and CLASS tables.", "Determine the relationship: The CLASS table has a foreign key (CRS_CODE) that links to the COURSE table, allowing us to join these tables based on course codes.", "Select the necessary columns: We want the department code (DEPT_CODE) from the COURSE table and the total credit hours (CRS_CREDIT) offered by each department.", "Use aggregate function: To get the total credits offered by each department, we will use the SUM function on the CRS_CREDIT column.", "Group the results: We need to group the results by department code to get the total credits for each department."], "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"], "pred_sql": "SELECT T1.dept_code, SUM(T1.crs_credit) AS total_credits \nFROM COURSE AS T1 \nJOIN CLASS AS T2 ON T1.crs_code = T2.crs_code \nGROUP BY T1.dept_code", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the tables involved: We need to get student names from the STUDENT table and their enrollment information from the ENROLL table, as well as the class information from the CLASS table.", "Determine the relationships: The STUDENT table is linked to the ENROLL table through the STU_NUM, and the ENROLL table is linked to the CLASS table through the CLASS_CODE.", "Select the required fields: We need the first names of the students, which is the STU_FNAME column from the STUDENT table.", "Filter the results: We need to filter the results to only include students enrolled in the class with the CRS_CODE 'ACCT-211'.", "Construct the SQL query: Using the identified tables, relationships, fields, and filters, we can construct the SQL query."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num = T2.stu_num JOIN class AS T3 ON T2.class_code = T3.class_code WHERE T3.crs_code = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of students from the 'student' table who have received specific grades in their enrolled classes. The placeholders in the WHERE clause represent the grades being queried.\",\n        \"virtual_table\": \"SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING] OR T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n        \"virtual_table\": \"SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names of professors along with the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3253", "db_id": "college_1", "question": "What is the name of the department that has the largest number of students enrolled?", "rationale": ["We need to find the department with the largest number of students enrolled.", "To do this, we will join the STUDENT table with the DEPARTMENT table on the DEPT_CODE.", "We will group the results by DEPT_NAME to count the number of students in each department.", "We will use COUNT(STU_NUM) to count the number of students in each department.", "Finally, we will order the results in descending order based on the count and limit the results to 1 to get the department with the largest number of students."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT T2.DEPT_NAME\nFROM STUDENT AS T1\nJOIN DEPARTMENT AS T2 ON T1.DEPT_CODE = T2.DEPT_CODE\nGROUP BY T2.DEPT_NAME\nORDER BY COUNT(T1.STU_NUM) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["We need to find the department with the most students enrolled.", "To do this, we will join the STUDENT table with the DEPARTMENT table using the DEPT_CODE.", "We will group the results by the department name to count the number of students in each department.", "We will order the results in descending order based on the count of students to get the department with the most students at the top.", "Finally, we will limit the results to 1 to get only the top department."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT T2.DEPT_NAME\nFROM STUDENT AS T1\nJOIN DEPARTMENT AS T2 ON T1.DEPT_CODE = T2.DEPT_CODE\nGROUP BY T2.DEPT_NAME\nORDER BY COUNT(T1.STU_NUM) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about class locations and course codes.", "Determine the required columns: We need the course codes (CRS_CODE) from the CLASS table.", "Specify the condition: We want to filter the results to only include classes held in room 'KLR209'.", "Use DISTINCT to ensure that we only get unique course codes in case multiple classes share the same code in that room.", "Construct the SQL query using the SELECT statement with the appropriate WHERE clause."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE \nFROM CLASS \nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n        \"virtual_table\": \"SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows for specifying the maximum number of school codes to return.\",\n        \"virtual_table\": \"SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: We need to retrieve student names and their grades, so we will use the STUDENT and ENROLL tables.", "Join the STUDENT and ENROLL tables: We will join these tables on the student number (STU_NUM) to link students with their grades.", "Filter for grade 'C': We will add a WHERE clause to filter the results to only include students who received a grade of 'C'.", "Select the first names: We will select the first names of the students from the STUDENT table."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num = T2.stu_num WHERE T2.enroll_grade = 'C'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of students from the 'student' table who have received specific grades in their enrolled classes. The placeholders in the WHERE clause represent the grades being queried.\",\n        \"virtual_table\": \"SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING] OR T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n        \"virtual_table\": \"SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["Identify the table that contains professor information, which is the EMPLOYEE table.", "We need to find professors who do not teach any class, so we will look for professors whose EMP_NUM is not present in the CLASS table's PROF_NUM column.", "We can achieve this by using a subquery that selects all PROF_NUM from the CLASS table.", "The main query will select the first names (emp_fname) from the EMPLOYEE table where the EMP_NUM is not in the list of PROF_NUM from the CLASS table."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT emp_fname FROM employee WHERE emp_num NOT IN (SELECT prof_num FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n        \"virtual_table\": \"SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors who teach a specific course. The data is retrieved from the 'employee' table, which contains information about professors, and is joined with the 'class' table to filter by the course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names of professors along with the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the table that contains professor information, which is the EMPLOYEE table.", "We need to find professors who are not teaching any classes, so we will look for professors whose EMP_NUM is not present in the CLASS table's PROF_NUM column.", "To achieve this, we can use a subquery that selects all PROF_NUM from the CLASS table.", "The main query will select the EMP_FNAME from the EMPLOYEE table where the EMP_NUM is not in the list of PROF_NUM obtained from the subquery."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME FROM EMPLOYEE WHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n        \"virtual_table\": \"SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors who teach a specific course. The data is retrieved from the 'employee' table, which contains information about professors, and is joined with the 'class' table to filter by the course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names of professors along with the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors, including their highest degree obtained.", "Determine the condition: We need to count professors who have either a Ph.D. or a Masters degree.", "Use the COUNT function: To get the total number of professors meeting the criteria, we will use COUNT(*) in the SELECT statement.", "Specify the condition in the WHERE clause: We will filter the results using the WHERE clause to include only those professors whose PROF_HIGH_DEGREE is either 'Ph.D.' or 'Masters'.", "Construct the final SQL query: Combine all the elements into a complete SQL query that counts the number of professors with the specified degrees."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) AS number_of_professors FROM PROFESSOR WHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n        \"virtual_table\": \"SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the tables needed: We need to find students, their enrollments, the classes they are taking, and the courses associated with those classes, which are linked to departments.", "Join the STUDENT table with the ENROLL table to get the classes each student is enrolled in.", "Join the CLASS table to get the course codes for those classes.", "Join the COURSE table to get the department codes for those courses.", "Join the DEPARTMENT table to filter by the specific departments: Accounting and Computer Info. Systems.", "Use a WHERE clause to filter the departments and ensure we only get students enrolled in both departments.", "Group the results by student first name and use HAVING to ensure that we only select students who are enrolled in classes from both departments."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT T1.stu_fname \nFROM student AS T1 \nJOIN enroll AS T2 ON T1.stu_num = T2.stu_num \nJOIN class AS T3 ON T2.class_code = T3.class_code \nJOIN course AS T4 ON T3.crs_code = T4.crs_code \nJOIN department AS T5 ON T4.dept_code = T5.dept_code \nWHERE T5.dept_name IN ('Accounting', 'Computer Info. Systems') \nGROUP BY T1.stu_fname \nHAVING COUNT(DISTINCT T5.dept_name) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n        \"virtual_table\": \"SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of students from the 'student' table who have received specific grades in their enrolled classes. The placeholders in the WHERE clause represent the grades being queried.\",\n        \"virtual_table\": \"SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING] OR T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names of professors along with the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3300", "db_id": "college_1", "question": "What is the name of the department with the student that has the lowest GPA?", "rationale": ["Identify the relevant tables: STUDENT and DEPARTMENT are needed to find the department name associated with the student.", "Join the STUDENT table with the DEPARTMENT table on the DEPT_CODE to access department names for each student.", "Order the results by the student's GPA in ascending order to get the student with the lowest GPA at the top.", "Limit the results to 1 to retrieve only the department name of the student with the lowest GPA."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "pred_sql": "SELECT T2.DEPT_NAME FROM STUDENT AS T1 JOIN DEPARTMENT AS T2 ON T1.DEPT_CODE = T2.DEPT_CODE ORDER BY T1.STU_GPA ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of students from the 'student' table who have received specific grades in their enrolled classes. The placeholders in the WHERE clause represent the grades being queried.\",\n        \"virtual_table\": \"SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING] OR T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3314", "db_id": "college_1", "question": "What are the first names, office locations of all lecturers who have taught some course?", "rationale": ["Identify the relevant tables: We need to retrieve first names and office locations of lecturers, which are found in the PROFESSOR table.", "Join the PROFESSOR table with the CLASS table: This is necessary to ensure we only get professors who have taught some course.", "Select the required fields: We need to select the first names (EMP_FNAME) and office locations (PROF_OFFICE) of the professors.", "Group the results: Since we want distinct entries of professors, we can group by their first names and office locations."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num", "source_tables": ["course", "employee", "professor", "class"], "pred_sql": "SELECT T1.EMP_FNAME, T1.PROF_OFFICE \nFROM PROFESSOR AS T1 \nJOIN CLASS AS T2 ON T1.EMP_NUM = T2.PROF_NUM \nGROUP BY T1.EMP_FNAME, T1.PROF_OFFICE;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n        \"virtual_table\": \"SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors who teach a specific course. The data is retrieved from the 'employee' table, which contains information about professors, and is joined with the 'class' table to filter by the course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3315", "db_id": "college_1", "question": "Find the first names and offices of all instructors who have taught some course and the course description and the department name.", "rationale": ["Identify the required fields: first names of instructors, their offices, course descriptions, and department names.", "The relevant tables are EMPLOYEE (for first names), PROFESSOR (for offices), COURSE (for course descriptions), and DEPARTMENT (for department names).", "Establish the relationships between these tables using JOINs: EMPLOYEE joins with PROFESSOR on EMP_NUM, PROFESSOR joins with CLASS on PROF_NUM, CLASS joins with COURSE on CRS_CODE, and PROFESSOR joins with DEPARTMENT on DEPT_CODE.", "Construct the SQL SELECT statement to retrieve the desired fields from the joined tables."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code", "source_tables": ["course", "department", "professor", "class", "employee"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE, COURSE.CRS_DESCRIPTION, DEPARTMENT.DEPT_NAME \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n        \"virtual_table\": \"SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: CLASS, COURSE, and DEPARTMENT are needed to find the department name based on class description.", "The CLASS table contains the class information, including the class code and course code.", "The COURSE table contains the course descriptions and is linked to the CLASS table via the CRS_CODE.", "The DEPARTMENT table contains the department names and is linked to the COURSE table via the DEPT_CODE.", "To find the department offering a class with 'Statistics' in its description, we need to join these tables on their respective keys.", "Use a WHERE clause to filter the course descriptions that contain the word 'Statistics'.", "Select the DEPT_NAME from the DEPARTMENT table after performing the necessary joins."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT D.DEPT_NAME \nFROM CLASS AS C \nJOIN COURSE AS CRS ON C.CRS_CODE = CRS.CRS_CODE \nJOIN DEPARTMENT AS D ON CRS.DEPT_CODE = D.DEPT_CODE \nWHERE CRS.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3417", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "The data is sourced from the 'employees' table.", "The condition specifies that the first name should not contain the letter 'M', which can be checked using the NOT LIKE operator with a wildcard."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%';", "hint": "\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: FULL_NAME (concatenation of FIRST_NAME and LAST_NAME), HIRE_DATE, SALARY, and DEPARTMENT_ID.", "The data is to be retrieved from the 'employees' table.", "To get the full name, we will concatenate FIRST_NAME and LAST_NAME using '||'.", "We need to filter employees whose FIRST_NAME does not contain the letter 'M'.", "The SQL 'NOT LIKE' operator will be used to exclude names with 'M'.", "Construct the SELECT statement with the identified fields and the WHERE clause for filtering."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%';", "hint": "\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by department number, which corresponds to DEPARTMENT_ID.", "Construct the SQL query using the SELECT statement with the identified fields and conditions."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID FROM employees WHERE FIRST_NAME NOT LIKE '%M%' ORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant tables: We need to look at the 'jobs' table for job titles and the 'employees' table for salary information.", "Join the 'jobs' table with the 'employees' table on the JOB_ID to link job titles with their corresponding salaries.", "Filter the results to include only those employees whose salary is greater than 9000.", "Select distinct job titles to avoid duplicates in the results."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT DISTINCT jobs.JOB_TITLE \nFROM jobs \nJOIN employees ON jobs.JOB_ID = employees.JOB_ID \nWHERE employees.SALARY > 9000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The 'jobs' table contains the job titles and salary information.", "Determine the required columns: We need 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY'.", "Set the condition for filtering: We want jobs where the 'MAX_SALARY' is between 12000 and 18000.", "Construct the SQL query using the SELECT statement to retrieve the specified columns from the 'jobs' table with the appropriate WHERE clause."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY \nFROM jobs \nWHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["Identify the relevant tables: employees and job_history.", "We need to retrieve employee IDs and the final dates of employment, which are found in the employees and job_history tables respectively.", "Join the employees table with the job_history table on the EMPLOYEE_ID column to link employees with their job history.", "To get the final date of employment for each employee, we need to filter the job_history records to only include the maximum END_DATE for each employee.", "Use a subquery to find the maximum END_DATE for each employee in the job_history table.", "Select the EMPLOYEE_ID from the employees table and the corresponding END_DATE from the job_history table."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT e.EMPLOYEE_ID, jh.END_DATE\nFROM employees e\nJOIN job_history jh ON e.EMPLOYEE_ID = jh.EMPLOYEE_ID\nWHERE jh.END_DATE = (SELECT MAX(END_DATE) FROM job_history WHERE EMPLOYEE_ID = e.EMPLOYEE_ID);", "hint": "\n"}
{"sample_id": "train.3451", "db_id": "hr_1", "question": "Find the ids of the departments where any manager is managing 4 or more employees.", "rationale": ["We need to find departments where any manager is managing 4 or more employees.", "To do this, we will join the 'employees' table with the 'departments' table on the department_id.", "We will group the results by manager_id to count the number of employees managed by each manager.", "Using the HAVING clause, we will filter the groups to only include those where the count of employees is 4 or more.", "Finally, we will select the department_id from the filtered results."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT T2.department_id FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id GROUP BY T2.manager_id HAVING COUNT(T1.employee_id) >= 4", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that each employee-manager pair is unique.\",\n        \"virtual_table\": \"SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3457", "db_id": "hr_1", "question": "display job ID for those jobs that were done by two or more for more than 300 days.", "rationale": ["We need to display job IDs for jobs that were done by two or more employees for more than 300 days.", "To achieve this, we will use the 'job_history' table, which contains records of employees' job history including job IDs, start dates, and end dates.", "We will group the results by 'job_id' to aggregate the data for each job.", "We will use the HAVING clause to filter the groups: we want to count the number of distinct employees (using COUNT(employee_id)) and ensure that this count is 2 or more.", "Additionally, we will calculate the total duration of each job by summing the difference between the end date and start date (using SUM(julianday(end_date) - julianday(start_date))). We will filter this sum to be greater than 300 days."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "pred_sql": "SELECT job_id FROM job_history GROUP BY job_id HAVING COUNT(employee_id) >= 2 AND SUM(julianday(end_date) - julianday(start_date)) > 300;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3458", "db_id": "hr_1", "question": "What are the job ids for jobs done more than once for a period of more than 300 days?", "rationale": ["Identify the relevant tables: We need to look at the 'job_history' table to find job IDs and their corresponding periods.", "Group the results by job_id: We want to count how many times each job_id appears in the job_history table.", "Use the HAVING clause to filter: We need to ensure that the job_id has been done more than once, which means the count of job_id should be greater than 1.", "Calculate the duration of each job: We need to sum the duration of each job by calculating the difference between start_date and end_date using julianday function.", "Filter for periods greater than 300 days: We will use the HAVING clause to ensure that the total duration for each job_id is greater than 300 days."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "pred_sql": "SELECT job_id FROM job_history GROUP BY job_id HAVING COUNT(*) > 1 AND SUM(julianday(end_date) - julianday(start_date)) > 300;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.3463", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["Identify the tables needed: 'employees' for employee data and 'departments' for department names.", "Join the 'employees' table with the 'departments' table on the common column 'DEPARTMENT_ID'.", "Select the department name from the 'departments' table and count the number of employees from the 'employees' table.", "Use the COUNT function to count the number of employees in each department.", "Group the results by department name to get the count for each department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT T2.DEPARTMENT_NAME, COUNT(*) AS NUMBER_OF_EMPLOYEES \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nGROUP BY T2.DEPARTMENT_NAME", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3470", "db_id": "hr_1", "question": "Provide the full names of employees earning more than the employee with id 163.", "rationale": ["Identify the requirement: We need to find the full names of employees earning more than the employee with ID 163.", "To achieve this, we need to first find the salary of the employee with ID 163.", "We can do this by using a subquery that selects the salary from the employees table where EMPLOYEE_ID is 163.", "Next, we will select the FIRST_NAME and LAST_NAME from the employees table where the SALARY is greater than the salary obtained from the subquery.", "The final SQL query combines these elements to retrieve the desired information."], "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = 163 )", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME, LAST_NAME FROM employees WHERE SALARY > (SELECT SALARY FROM employees WHERE EMPLOYEE_ID = 163)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3471", "db_id": "hr_1", "question": "return the smallest salary for every departments.", "rationale": ["We need to find the smallest salary for every department.", "To do this, we will join the 'employees' table with the 'departments' table using the 'DEPARTMENT_ID' as the linking key.", "We will select the department name from the 'departments' table and the minimum salary from the 'employees' table.", "The MIN() function will be used to calculate the smallest salary for each department.", "Finally, we will group the results by the department name to ensure we get the minimum salary for each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT T2.DEPARTMENT_NAME, MIN(T1.SALARY) AS MIN_SALARY \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nGROUP BY T2.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3472", "db_id": "hr_1", "question": "What is the minimum salary in each department?", "rationale": ["Identify the tables needed: 'employees' for salary information and 'departments' for department names.", "Join the 'employees' table with the 'departments' table on the DEPARTMENT_ID to associate employees with their respective departments.", "Use the MIN() function to calculate the minimum salary for each department.", "Group the results by department name to get the minimum salary per department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT T2.DEPARTMENT_NAME, MIN(T1.SALARY) AS MIN_SALARY \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nGROUP BY T2.DEPARTMENT_NAME", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the requirement: We need to find all information regarding employees who are managers.", "Understand the relationship: An employee is a manager if their employee_id matches the manager_id in the departments table.", "Use a JOIN operation: We will join the employees table with the departments table on the department_id to get the relevant information.", "Use DISTINCT: To ensure that we do not have duplicate records for employees who manage multiple departments, we will use DISTINCT.", "Construct the SQL query: The final SQL query will select all columns from both tables where the employee_id matches the manager_id."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id WHERE T1.employee_id = T2.manager_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that each employee-manager pair is unique.\",\n        \"virtual_table\": \"SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find distinct department IDs where a manager oversees 4 or more employees.", "To achieve this, we will join the 'employees' table with the 'departments' table on the department ID.", "We will group the results by department ID to count the number of employees in each department.", "Using the HAVING clause, we will filter the groups to include only those departments that have 4 or more employees."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DISTINCT T2.department_id \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nGROUP BY T2.department_id \nHAVING COUNT(T1.employee_id) >= 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that each employee-manager pair is unique.\",\n        \"virtual_table\": \"SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3497", "db_id": "hr_1", "question": "Find the ids of the employees who does not work in those departments where some employees works whose manager id within the range 100 and 200.", "rationale": ["Identify the requirement to find employee IDs who do not work in certain departments.", "Determine that the departments to exclude are those where the manager ID falls within the range of 100 to 200.", "Use a subquery to select department IDs from the 'departments' table where the manager_id is between 100 and 200.", "Use the NOT IN clause to filter out these department IDs from the main query that selects employee IDs from the 'employees' table."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "pred_sql": "SELECT employee_id FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that each employee-manager pair is unique.\",\n        \"virtual_table\": \"SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the requirement: We need the full names and hire dates of employees who work in the same department as an employee named Clara, excluding Clara herself.", "To get the full names, we will concatenate the FIRST_NAME and LAST_NAME of the employees.", "We need to join the employees table with itself to find employees in the same department as Clara. This is a self-join where one instance of the table represents Clara and the other represents other employees.", "The join condition will be that the DEPARTMENT_ID of both instances of the employees table must match.", "We will filter the results to only include those employees where the FIRST_NAME is not 'Clara'.", "Finally, we will select the concatenated full name and the hire date from the resulting set."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE\nFROM employees e\nJOIN employees c ON e.DEPARTMENT_ID = c.DEPARTMENT_ID\nWHERE c.FIRST_NAME = 'Clara' AND e.FIRST_NAME != 'Clara';", "hint": "\n"}
{"sample_id": "train.3506", "db_id": "hr_1", "question": "What are the ids, full names, and salaries for employees making more than average and who work in a department with employees who have the letter J in their first name?", "rationale": ["Identify the required fields: employee IDs, full names (first and last), and salaries.", "To get the full name, concatenate the first and last names using '||'.", "Filter employees whose salary is greater than the average salary of all employees. This requires a subquery to calculate the average salary.", "Additionally, filter employees based on their department. We need to find departments that have at least one employee with a first name containing the letter 'J'.", "This requires another subquery that selects distinct department IDs from the employees table where the first name contains 'J'.", "Combine these conditions using the IN clause to ensure we only select employees from the relevant departments."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%J%')", "source_tables": ["employees"], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY > (SELECT AVG(SALARY) FROM employees) \nAND e.DEPARTMENT_ID IN (\n    SELECT DISTINCT d.DEPARTMENT_ID \n    FROM employees e2 \n    JOIN departments d ON e2.DEPARTMENT_ID = d.DEPARTMENT_ID \n    WHERE e2.FIRST_NAME LIKE '%J%'\n);", "hint": "\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the main requirement: to display employee number (EMPLOYEE_ID) and job id (JOB_ID) for employees with a salary smaller than any salary of those with the job title 'MK_MAN'.", "To achieve this, we need to first find the minimum salary of employees with the job title 'MK_MAN'.", "This requires a subquery that selects the JOB_ID for 'MK_MAN' from the jobs table, and then uses that JOB_ID to find the corresponding salaries in the employees table.", "Next, we will use this minimum salary in the main query to filter employees whose salary is less than this value.", "The final SQL query will select EMPLOYEE_ID and JOB_ID from the employees table where the salary is less than the result of the subquery."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID FROM employees WHERE SALARY < (SELECT MIN(SALARY) FROM employees WHERE JOB_ID = (SELECT JOB_ID FROM jobs WHERE JOB_TITLE = 'MK_MAN'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.3510", "db_id": "hr_1", "question": "What are the employee ids, full names, and job ids for employees who make more than the highest earning employee with title PU_MAN?", "rationale": ["Identify the required fields: employee ids, full names, and job ids.", "To get the full names, concatenate the FIRST_NAME and LAST_NAME fields.", "Filter employees based on their salary being greater than a certain threshold.", "Determine the threshold: the highest salary of employees with the job title 'PU_MAN'.", "Use a subquery to find the maximum salary of employees with the job title 'PU_MAN'.", "Construct the main query to select the EMPLOYEE_ID, full name, and JOB_ID from the employees table where the salary exceeds the threshold."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, JOB_ID \nFROM employees \nWHERE SALARY > (SELECT MAX(SALARY) \n                 FROM employees \n                 WHERE JOB_ID = (SELECT JOB_ID \n                                 FROM jobs \n                                 WHERE JOB_TITLE = 'PU_MAN'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department id for each department with more than 2 employees.", "To do this, we will join the 'employees' table with the 'departments' table on the department_id.", "We will use the SUM function to calculate the total salaries for each department.", "We will group the results by department_id to get the total salaries per department.", "To filter the departments that have more than 2 employees, we will use the HAVING clause with COUNT to count the number of employees in each department."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT T2.department_id, SUM(T1.salary) AS total_salaries \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nGROUP BY T2.department_id \nHAVING COUNT(T1.employee_id) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that each employee-manager pair is unique.\",\n        \"virtual_table\": \"SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id\"\n    }\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To find the highest salary in each department, we can use a subquery that groups the employees by department and selects the maximum salary for each group.", "The subquery will return a table with department IDs and their corresponding maximum salaries.", "Next, we join this subquery with the employees table to get the full name and salary of the employees who have this maximum salary.", "We concatenate the first name and last name to create the full name.", "Finally, we select the required fields: department ID, full name, and salary."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.department_id, e.first_name || ' ' || e.last_name AS full_name, e.salary \nFROM employees e \nJOIN (\n    SELECT department_id, MAX(salary) AS max_salary \n    FROM employees \n    GROUP BY department_id\n) AS max_salaries \nON e.department_id = max_salaries.department_id AND e.salary = max_salaries.max_salary;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3516", "db_id": "hr_1", "question": "What are the department ids, full names, and salaries for employees who make the most in their departments?", "rationale": ["Identify the required fields: department ids, full names, and salaries of employees.", "To get the full names, concatenate the FIRST_NAME and LAST_NAME from the employees table.", "To find the highest salary in each department, use a subquery that selects the maximum salary for each department.", "Join the employees table with itself in the subquery to compare salaries within the same department.", "Select the department ID, full name, and salary from the employees table where the salary matches the maximum salary found in the subquery."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(e2.SALARY) \n                  FROM employees e2 \n                  WHERE e2.DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the required information: full names and cities of employees with 'Z' in their first names.", "To get the full names, concatenate FIRST_NAME and LAST_NAME with a space in between.", "The employees table contains the first and last names, but we also need the city, which is in the locations table.", "To connect employees to their locations, we need to join the employees table with the departments table (using DEPARTMENT_ID) and then with the locations table (using LOCATION_ID).", "Use a WHERE clause to filter employees whose FIRST_NAME contains the letter 'Z' using the LIKE operator."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, CITY \nFROM employees \nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID \nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID \nWHERE FIRST_NAME LIKE '%Z%';", "hint": "\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed: We need the 'employees' table for employee names, the 'locations' table to find the country, and the 'countries' table to get the country name.", "Join the 'employees' table with the 'locations' table using the 'DEPARTMENT_ID' to 'LOCATION_ID' relationship.", "Join the resulting table with the 'countries' table using the 'COUNTRY_ID' to get the country name.", "Select the full name of the employee (concatenating first and last names) and the country name.", "Use a WHERE clause to filter the results for a specific employee ID."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT T2.FIRST_NAME || ' ' || T2.LAST_NAME AS FULL_NAME, T3.COUNTRY_NAME \nFROM employees AS T2 \nJOIN locations AS T4 ON T2.DEPARTMENT_ID = T4.LOCATION_ID \nJOIN countries AS T3 ON T4.COUNTRY_ID = T3.COUNTRY_ID \nWHERE T2.EMPLOYEE_ID = ?", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["Identify the tables needed: 'employees' for employee data and 'departments' for department names.", "Join the 'employees' table with the 'departments' table on the common column 'DEPARTMENT_ID'.", "Select the department name from the 'departments' table and count the number of employees from the 'employees' table.", "Use the COUNT function to count the number of employees in each department.", "Group the results by department name to get the count for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT T2.DEPARTMENT_NAME, COUNT(*) AS NUMBER_OF_EMPLOYEES \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nGROUP BY T2.DEPARTMENT_NAME", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["Identify the tables needed: 'employees' for employee data and 'departments' for department names.", "Join the 'employees' table with the 'departments' table on the common column 'DEPARTMENT_ID'.", "Select the department name from the 'departments' table and count the number of employees from the 'employees' table.", "Group the results by department name to get the count of employees in each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT T2.DEPARTMENT_NAME, COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID GROUP BY T2.DEPARTMENT_NAME", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "We need to get the full names of employees, which requires concatenating their first and last names from the employees table.", "We also need the salary of the employees from the employees table.", "To filter employees based on the city, we need to join the locations table to access the city information.", "The departments table is necessary to link employees to their respective locations.", "The countries table is included to ensure we have the correct country information, but in this case, we are specifically filtering by city.", "Construct the SQL query using JOINs to connect these tables and apply the WHERE clause to filter for employees in London."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT CONCAT(e.FIRST_NAME, ' ', e.LAST_NAME) AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3641", "db_id": "baseball_1", "question": "In 2014, what are the id and rank of the team that has the largest average number of attendance?", "rationale": ["Identify the relevant tables: home_game for attendance and team for team details.", "We need to find the team with the largest average attendance in 2014.", "Join the home_game table with the team table on team_id to get the rank of the team.", "Filter the results for the year 2014.", "Order the results by attendance in descending order to get the team with the largest attendance at the top.", "Select the team_id and rank of the top team.", "Limit the results to 1 to get only the top team."], "gold_sql": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  2014 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT T1.team_id, T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id WHERE T1.year = 2014 ORDER BY T1.attendance DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\",\n        \"virtual_table\": \"SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\",\n        \"virtual_table\": \"SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3647", "db_id": "baseball_1", "question": "Which 3 players won the most player awards? List their full name and id.", "rationale": ["Identify the relevant tables: We need to use the 'player' table to get player names and IDs, and the 'player_award' table to count the awards each player has won.", "Join the 'player' table with the 'player_award' table on 'player_id' to associate players with their awards.", "Group the results by 'player_id' to aggregate the awards for each player.", "Count the number of awards for each player using COUNT() function.", "Order the results in descending order based on the count of awards to get the players with the most awards at the top.", "Limit the results to the top 3 players to meet the requirement of the query."], "gold_sql": "SELECT T1.name_first ,  T1.name_last ,  T1.player_id FROM player AS T1 JOIN player_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT 3;", "source_tables": ["player_award", "player"], "pred_sql": "SELECT player.player_id, player.name_first, player.name_last\nFROM player\nJOIN player_award ON player.player_id = player_award.player_id\nGROUP BY player.player_id\nORDER BY COUNT(player_award.award_id) DESC\nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3649", "db_id": "baseball_1", "question": "List three countries which are the origins of the least players.", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their country of birth.", "Determine the required information: We need to count the number of players from each country.", "Use the COUNT function to count players grouped by their birth country.", "Group the results by 'birth_country' to aggregate the counts for each country.", "Order the results in ascending order based on the count of players to find the countries with the least players.", "Limit the results to the top 3 countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count FROM player GROUP BY birth_country ORDER BY player_count ASC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["We need to find the countries with the least number of players.", "The relevant table for player information is the 'player' table, which includes the 'birth_country' column.", "We will group the results by 'birth_country' to count the number of players from each country.", "To get the countries with the least players, we will order the results by the count of players in ascending order.", "Finally, we will limit the results to the top 3 countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count \nFROM player \nGROUP BY birth_country \nORDER BY player_count ASC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3651", "db_id": "baseball_1", "question": "Find all the players' first name and last name who have empty death record.", "rationale": ["Identify the relevant table: The 'player' table contains the first and last names of players as well as their death records.", "Determine the condition for empty death records: A player has an empty death record if the 'death_year', 'death_month', and 'death_day' fields are all NULL.", "Construct the SQL query: Use a SELECT statement to retrieve 'name_first' and 'name_last' from the 'player' table where the death record fields are NULL."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE death_year = '';", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE death_year IS NULL AND death_month IS NULL AND death_day IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["Identify the tables needed: 'team' for team names and IDs, and 'salary' for salary information.", "Join the 'team' table with the 'salary' table on 'team_id' to associate each team with its players' salaries.", "Use the MAX function to find the highest salary for each team.", "Group the results by 'team_id' to ensure each team is represented only once with its maximum salary."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T1.name, T1.team_id, max(T2.salary) \nFROM team AS T1 \nJOIN salary AS T2 ON T1.team_id = T2.team_id \nGROUP BY T1.team_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and identifiers of teams along with their highest recorded salary from the 'salary' table. The data is grouped by team identifiers to ensure that each team is represented only once with its maximum salary.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of team names and their corresponding team IDs from the 'team' table, along with the average salary of players from each team. The results are ordered by the average salary in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3662", "db_id": "baseball_1", "question": "Which players won awards in both 1960 and 1961? Return their first names and last names.", "rationale": ["Identify the players who won awards in 1960 and 1961.", "Use the player table to get the first and last names of the players.", "Join the player table with the player_award table to filter by the years 1960 and 1961.", "Use the INTERSECT operator to find players who appear in both years' results."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT T1.name_first, T1.name_last \nFROM player AS T1 \nJOIN player_award AS T2 ON T1.player_id = T2.player_id \nWHERE T2.year = 1960 \nINTERSECT \nSELECT T1.name_first, T1.name_last \nFROM player AS T1 \nJOIN player_award AS T2 ON T1.player_id = T2.player_id \nWHERE T2.year = 1961;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "Join the postseason table with the team table to get the names of the winning teams.", "Filter the results to only include the Boston Red Stockings.", "Group the results by team name to count the number of wins for the Boston Red Stockings.", "Order the results by the count of wins in descending order to get the maximum scores."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT T2.name, COUNT(*) AS max_scores \nFROM postseason AS T1 \nJOIN team AS T2 ON T1.team_id_winner = T2.team_id_br \nWHERE T2.name = 'Boston Red Stockings' \nGROUP BY T2.name \nORDER BY max_scores DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) for the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Group the results by year to get the wins for each year.", "Use the MAX function to get the maximum wins from the grouped results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' GROUP BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3669", "db_id": "baseball_1", "question": "What are the name and id of the team with the most victories in 2008 postseason?", "rationale": ["Identify the relevant tables: We need to find the team with the most victories in the postseason, which involves the 'postseason' table for wins and the 'team' table for team names and IDs.", "Use the provided virtual table structure: The hint provides a virtual table that selects the team names and IDs from the postseason table, joining it with the team table based on the winning team ID.", "Filter by year: We need to filter the results to only include the year 2008.", "Group by team ID: To count the number of wins for each team, we group the results by the winning team ID.", "Order by count of wins: We order the results in descending order to get the team with the most wins at the top.", "Limit the results: Since we only need the team with the most victories, we limit the results to 1."], "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"], "pred_sql": "SELECT T2.name, T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner = T2.team_id_br WHERE T1.year = 2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3673", "db_id": "baseball_1", "question": "What is the total number of postseason games that team Boston Red Stockings participated in?", "rationale": ["Identify the tables involved: postseason and team.", "Determine the relationship between the tables: postseason records wins and losses for teams, while team provides team names.", "Use a UNION to combine the counts of wins and losses for the specified team.", "Count the total number of postseason games by counting the combined results from the UNION query.", "Filter the results by the team name 'Boston Red Stockings'."], "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"], "pred_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' );", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason appearances for a specific team, including both wins and losses. It combines data from the 'postseason' table and the 'team' table, filtering by the team's name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );\"\n    }\n}\n"}
{"sample_id": "train.3678", "db_id": "baseball_1", "question": "What is the total salary expenses of team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant tables: salary and team.", "We need to calculate the total salary expenses for a specific team in a specific year, which requires summing the salary from the salary table.", "Join the salary table with the team table on the team_id to filter by team name.", "Use the WHERE clause to specify the team name as 'Boston Red Stockings' and the year as 2010.", "Construct the SQL query using the identified elements."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year = 2010", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3679", "db_id": "baseball_1", "question": "How many players were in the team Boston Red Stockings in 2000?", "rationale": ["Identify the relevant tables: 'appearances' for player participation and 'team' for team identification.", "Join the 'appearances' table with the 'team' table on 'team_id' to link players to their respective teams.", "Filter the results to include only players from the 'Boston Red Stockings' team in the year 2000.", "Count the distinct 'player_id' to get the total number of players in that team for the specified year."], "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"], "pred_sql": "SELECT COUNT(DISTINCT player_id) FROM appearances AS A JOIN team AS T ON A.team_id = T.team_id WHERE T.name = 'Boston Red Stockings' AND A.year = '2000';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant table for salary information, which is the 'salary' table.", "Filter the records for the year 2001 using the WHERE clause.", "Order the results by salary in descending order to get the highest salaries.", "Limit the results to the top 3 salaries using the LIMIT clause."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and identifiers of teams along with their highest recorded salary from the 'salary' table. The data is grouped by team identifiers to ensure that each team is represented only once with its maximum salary.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3684", "db_id": "baseball_1", "question": "List all the salary values players received in 2010 and 2001.", "rationale": ["Identify the relevant table for salary data, which is the 'salary' table.", "Determine the years of interest, which are 2010 and 2001.", "Construct a SQL query to select the 'salary' column from the 'salary' table where the 'year' is either 2010 or 2001 using the IN clause."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT salary FROM salary WHERE year IN (2010, 2001);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of team names and their corresponding team IDs from the 'team' table, along with the average salary of players from each team. The results are ordered by the average salary in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "To do this, we will count the number of players inducted for each year using the 'hall_of_fame' table.", "We will group the results by the 'yearid' column to get the count of inductees for each year.", "Next, we will order the results in ascending order based on the count of inductees to find the year with the least number of inductees.", "Finally, we will limit the results to just one record to get the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) AS num_inducted FROM hall_of_fame GROUP BY yearid ORDER BY num_inducted ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "To do this, we will count the number of inductions for each year in the hall_of_fame table.", "We will group the results by the year of induction (yearid) and count the number of entries for each year.", "Finally, we will order the results in ascending order based on the count of inductions and limit the output to 1 to get the year with the least inductions."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) AS num_inductions FROM hall_of_fame GROUP BY yearid ORDER BY num_inductions ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: home_game and park.", "We need to sum the number of games played in a specific park for a specific year.", "Join the home_game table with the park table on park_id to access park names.", "Filter the results for the year 1907 and the park name 'Columbia Park'.", "Use the SUM function to calculate the total number of games played."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(T1.games) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id = T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by the total attendance of those games. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: home_game and park.", "We need to count the number of games, so we will use COUNT(*) function.", "Join the home_game table with the park table on park_id to access park names.", "Filter the results for the year 1907 and the park name 'Columbia Park'.", "Construct the SQL query using the SELECT statement with the COUNT function and the necessary JOIN and WHERE clauses."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT COUNT(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id = T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by the total attendance of those games. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant tables: home_game and team.", "We need to sum the total number of games played in Atlanta in the year 2000.", "Join the home_game table with the team table on team_id to access team information.", "Filter the results to only include games played in Atlanta for the year 2000.", "Use the SUM function to calculate the total number of games played."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.city = 'Atlanta' AND T1.year = 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by the total attendance of those games. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: home_game and park.", "We need to find the total number of games played in Atlanta in the year 2000.", "Join the home_game table with the park table on park_id to access the city information.", "Filter the results to only include games played in Atlanta and in the year 2000.", "Use the SUM function to calculate the total number of games."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(T1.games) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id = T2.park_id WHERE T2.city = 'Atlanta' AND T1.year = 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by the total attendance of those games. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3697", "db_id": "baseball_1", "question": "List players' first name and last name who received salary from team Washington Nationals in both 2005 and 2007.", "rationale": ["Identify the relevant tables: player, salary, and team.", "Join the player table with the salary table on player_id to get salary information for each player.", "Join the salary table with the team table on team_id to filter for the Washington Nationals.", "Use a WHERE clause to filter for the years 2005 and 2007.", "Group the results by player_id to aggregate the data for each player.", "Use HAVING to ensure that only players who received salaries in both years (count of distinct years = 2) are included."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT T1.name_first, T1.name_last \nFROM player AS T1 \nJOIN salary AS T2 ON T1.player_id = T2.player_id \nJOIN team AS T3 ON T2.team_id = T3.team_id \nWHERE T3.name = 'Washington Nationals' AND T2.year IN (2005, 2007) \nGROUP BY T1.player_id \nHAVING COUNT(DISTINCT T2.year) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of team names and their corresponding team IDs from the 'team' table, along with the average salary of players from each team. The results are ordered by the average salary in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3699", "db_id": "baseball_1", "question": "How many home games did the team Boston Red Stockings play from 1990 to 2000 in total?", "rationale": ["Identify the relevant tables: home_game and team.", "We need to sum the total number of home games played by the Boston Red Stockings.", "Join the home_game table with the team table on the team_id to filter by team name.", "Use the WHERE clause to specify the team name as 'Boston Red Stockings'.", "Use the BETWEEN clause to filter the years from 1990 to 2000.", "Select the sum of the games from the home_game table."], "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant tables: home_game and team.", "We need to find the team with the least number of home games in 1980, so we will filter the home_game table for the year 1980.", "Join the home_game table with the team table to get the team names associated with the home games.", "Order the results by the number of games in ascending order to get the team with the least number of home games.", "Limit the results to 1 to get only the team with the least number of home games."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id WHERE T1.year = 1980 ORDER BY T1.games ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3710", "db_id": "baseball_1", "question": "Which park did the most people attend in 2008?", "rationale": ["Identify the relevant tables: home_game for attendance data and park for park names.", "Join the home_game table with the park table on the park_id to get park names along with attendance data.", "Filter the results for the year 2008 using a WHERE clause.", "Order the results by attendance in descending order to get the park with the highest attendance.", "Limit the results to 1 to get only the park with the most attendance."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id = T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by the total attendance of those games. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\",\n        \"virtual_table\": \"SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the tables involved: Department and Physician.", "We need to count the number of employees in each department, which means we will join the Department table with the Physician table on the Head of the department.", "Use a LEFT JOIN to ensure we include departments even if they have no physicians.", "Group the results by DepartmentID to get the count of employees per department.", "Count the EmployeeID from the Physician table to get the number of employees in each department.", "Order the results by the count of employees in descending order to find the department with the largest number of employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT D.Name, COUNT(P.EmployeeID) AS EmployeeCount \nFROM Department D \nLEFT JOIN Physician P ON D.Head = P.EmployeeID \nGROUP BY D.DepartmentID \nORDER BY EmployeeCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results based on the count of departments, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["We need to find the department with the most employees, which means we need to count the number of physicians affiliated with each department.", "The relevant tables are 'Department' and 'Affiliated_With'.", "We will join these two tables on the department ID to associate physicians with their respective departments.", "Next, we will use the COUNT function to count the number of physicians in each department.", "We will group the results by department name to get the count for each department.", "To find the department with the most employees, we will order the results by the count in descending order.", "Finally, we will limit the results to 1 to get only the department with the highest count."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Affiliated_With.Physician) AS EmployeeCount\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["Identify the tables involved: Department and Physician.", "We need to find the head of the department with the least number of employees, which requires joining the Department table with the Physician table.", "The join condition is based on the Head of the department being a Physician, so we join on Department.Head = Physician.EmployeeID.", "We need to group the results by DepartmentID to count the number of employees in each department.", "We order the results by the count of employees in ascending order to get the department with the least number of employees.", "Finally, we limit the results to 1 to get only the head of the department with the least number of employees."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT T2.Name, T2.Position FROM Department AS T1 JOIN Physician AS T2 ON T1.Head = T2.EmployeeID GROUP BY T1.DepartmentID ORDER BY COUNT(T1.DepartmentID) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results based on the count of departments, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["Identify the relevant tables: Appointment and Patient.", "Determine the relationship between the tables: Appointment table has a foreign key reference to Patient's SSN.", "Select the Name column from the Patient table to get the names of patients who made appointments.", "Join the Appointment table with the Patient table on the Patient's SSN to retrieve the names of patients associated with each appointment."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT T1.Name FROM Appointment AS T1 JOIN Patient AS T2 ON T1.Patient = T2.SSN", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3905", "db_id": "hospital_1", "question": "List the names of patients who have made appointments.", "rationale": ["Identify the relevant tables: Appointment and Patient.", "Determine the relationship between the tables: Appointment table has a foreign key reference to Patient's SSN.", "Select the distinct names of patients from the Patient table who have made appointments by joining the Appointment and Patient tables on the Patient's SSN."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT P.Name \nFROM Appointment A \nJOIN Patient P ON A.Patient = P.SSN;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["Identify the tables needed: Physician, Affiliated_With, and Department.", "We need to join the Physician table with the Affiliated_With table to get the department affiliations of each physician.", "Next, join the result with the Department table to get the names of the departments.", "Filter the results to include only those affiliations that are marked as primary (assuming 'Yes' indicates primary affiliation).", "Select the names of the physicians and their corresponding department names."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT P.Name, D.Name \nFROM Physician P \nJOIN Affiliated_With A ON P.EmployeeID = A.Physician \nJOIN Department D ON A.Department = D.DepartmentID \nWHERE A.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results based on the count of departments, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3915", "db_id": "hospital_1", "question": "What are the name and primarily affiliated department name of each physician?", "rationale": ["Identify the relevant tables: Physician, Department, and Affiliated_With are needed to get the physician names and their affiliated departments.", "Join the Affiliated_With table with the Physician table to get the names of the physicians based on their EmployeeID.", "Join the resulting table with the Department table to get the names of the departments based on the DepartmentID.", "Filter the results to include only those affiliations that are marked as primary by checking the PrimaryAffiliation column."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name, Department.Name \nFROM Affiliated_With \nJOIN Physician ON Affiliated_With.Physician = Physician.EmployeeID \nJOIN Department ON Affiliated_With.Department = Department.DepartmentID \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results based on the count of departments, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3929", "db_id": "hospital_1", "question": "Return the name of each physician and the number of patients he or she treats.", "rationale": ["Identify the tables involved: Physician and Patient.", "We need to get the names of physicians and the number of patients they treat.", "The relationship between physicians and patients is established through the PCP (Primary Care Physician) field in the Patient table.", "Join the Physician table with the Patient table on the condition that Physician.EmployeeID matches Patient.PCP.", "Select the physician's name and count the number of patients for each physician.", "Group the results by the physician's EmployeeID to aggregate the patient counts."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT T1.Name, COUNT(*) AS NumberOfPatients FROM Physician AS T1 JOIN Patient AS T2 ON T1.EmployeeID = T2.PCP GROUP BY T1.EmployeeID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    }\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["We need to find physicians who are in charge of more than one patient, which means we need to count the number of patients for each physician.", "The 'Patient' table has a column 'PCP' that indicates the primary care physician for each patient, which we can use to join with the 'Physician' table.", "We will join the 'Physician' table with the 'Patient' table on the condition that the physician's EmployeeID matches the patient's PCP.", "After joining, we will group the results by the physician's EmployeeID to count the number of patients associated with each physician.", "Finally, we will use the HAVING clause to filter the results to only include physicians who have more than one patient (i.e., count > 1)."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Patient AS T2 ON T1.EmployeeID = T2.PCP GROUP BY T1.EmployeeID HAVING COUNT(T2.SSN) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    }\n}\n"}
{"sample_id": "train.3931", "db_id": "hospital_1", "question": "Which physicians are in charge of more than one patient? Give me their names.", "rationale": ["We need to find physicians who are in charge of more than one patient, which means we need to count the number of patients for each physician.", "The 'Patient' table has a column 'PCP' that indicates the primary care physician for each patient, and the 'Physician' table has the names of the physicians.", "We will join the 'Physician' table with the 'Patient' table on the condition that the physician's EmployeeID matches the patient's PCP.", "After joining, we will group the results by the physician's EmployeeID to count the number of patients associated with each physician.", "Finally, we will use the HAVING clause to filter the results to only include physicians who have more than one patient."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Patient AS T2 ON T1.EmployeeID = T2.PCP GROUP BY T1.EmployeeID HAVING COUNT(T2.SSN) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    }\n}\n"}
{"sample_id": "train.3934", "db_id": "hospital_1", "question": "Find the number of rooms for different block code?", "rationale": ["Identify the relevant table: The Room table contains information about rooms and their block codes.", "Determine the required information: We need to count the number of rooms for each block code.", "Use the COUNT() function to count the rooms and GROUP BY BlockCode to get the count for each unique block code.", "Construct the SQL query to select the BlockCode and the count of RoomNumber, grouping by BlockCode."], "gold_sql": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode", "source_tables": ["block", "room"], "pred_sql": "SELECT BlockCode, COUNT(RoomNumber) AS NumberOfRooms\nFROM Room\nGROUP BY BlockCode;", "hint": "\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["The task is to find the number of medications prescribed for each brand.", "We need to count the number of prescriptions for each brand of medication.", "To achieve this, we will join the 'Medication' table with the 'Prescribes' table on the medication code.", "We will select the count of prescriptions and the brand name from the 'Medication' table.", "Finally, we will group the results by the brand name to get the count for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT count(*), T1.Brand FROM Medication AS T1 JOIN Prescribes AS T2 ON T1.Code = T2.Medication GROUP BY T1.Brand", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    }\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["We need to find the physician who prescribed the highest dose of medication.", "To do this, we will join the 'Physician' table with the 'Prescribes' table on the physician's unique identifier (EmployeeID).", "We will select the physician's name from the 'Physician' table.", "To find the highest dose, we will order the results by the 'Dose' column in the 'Prescribes' table in descending order.", "Finally, we will limit the results to only one record to get the physician with the highest dose."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Prescribes AS T2 ON T1.EmployeeID = T2.Physician ORDER BY T2.Dose DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    }\n}\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["Identify the tables needed: Physician and Affiliated_With.", "We need to select the EmployeeID from the Physician table and the Department from the Affiliated_With table.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns respectively.", "Filter the results to include only those records where the PrimaryAffiliation is 'Yes' to get the primary affiliations."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department FROM Physician JOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician WHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    }\n}\n"}
{"sample_id": "train.3961", "db_id": "hospital_1", "question": "What are each physician's employee id and department id primarily affiliated.", "rationale": ["Identify the relevant tables: Physician and Affiliated_With.", "We need to select the EmployeeID from the Physician table and the Department from the Affiliated_With table.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns respectively.", "Filter the results to include only those records where the PrimaryAffiliation is 'Yes' to get the primary affiliations."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department FROM Physician JOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician WHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    }\n}\n"}
{"sample_id": "train.3970", "db_id": "hospital_1", "question": "Find the three most expensive procedures.", "rationale": ["Identify the table that contains the procedures and their costs, which is the 'Procedures' table.", "To find the most expensive procedures, we need to order the results by the 'Cost' column in descending order.", "We want to limit the results to the top three most expensive procedures, so we will use the LIMIT clause with a value of 3."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["The question asks for the three most costly procedures, which means we need to retrieve data from the Procedures table.", "We need to select the 'Name' and 'Cost' columns from the Procedures table.", "To find the most costly procedures, we will order the results by the 'Cost' column in descending order.", "Finally, we will limit the results to the top three entries using 'LIMIT 3'."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    }\n}\n"}
{"sample_id": "train.3973", "db_id": "hospital_1", "question": "Which physicians are trained in procedures that are more expensive than 5000?", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find physicians who are trained in certain procedures, so we will join the Physician table with the Trained_In table on the Physician's EmployeeID.", "Next, we join the Trained_In table with the Procedures table on the Treatment code to access the cost of the procedures.", "Finally, we filter the results to include only those procedures that have a cost greater than 5000."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT P.Name \nFROM Physician P \nJOIN Trained_In T ON P.EmployeeID = T.Physician \nJOIN Procedures R ON T.Treatment = R.Code \nWHERE R.Cost > 5000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results based on the count of departments, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["We need to find the physician who was trained in the most expensive procedure.", "To do this, we will join the 'Physician' table with the 'Trained_In' table to get the procedures each physician is trained in.", "Next, we will join the 'Trained_In' table with the 'Procedures' table to access the cost of each procedure.", "We will then order the results by the cost of the procedures in descending order to get the most expensive one at the top.", "Finally, we will limit the results to just one record to get the physician associated with the most expensive procedure."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT T1.Name\nFROM Physician AS T1\nJOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician\nJOIN Procedures AS T3 ON T2.Treatment = T3.Code\nORDER BY T3.Cost DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    }\n}\n"}
{"sample_id": "train.3985", "db_id": "hospital_1", "question": "What procedures cost less than 5000 and have John Wen as a trained physician?", "rationale": ["Identify the relevant tables: Procedures, Trained_In, and Physician.", "We need to find procedures that cost less than 5000, so we will filter the Procedures table based on the Cost column.", "We also need to check if John Wen is a trained physician for those procedures, which requires joining the Trained_In table with the Physician table.", "Join Procedures with Trained_In on the procedure code and then join with Physician on the physician's identifier.", "Apply the WHERE clause to filter procedures with a cost less than 5000 and the physician's name as 'John Wen'."], "gold_sql": "SELECT name FROM procedures WHERE cost  <  5000 INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT P.Name, Pr.Name \nFROM Procedures AS Pr \nJOIN Trained_In AS T ON Pr.Code = T.Treatment \nJOIN Physician AS P ON T.Physician = P.EmployeeID \nWHERE Pr.Cost < 5000 AND P.Name = 'John Wen';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    }\n}\n"}
{"sample_id": "train.4321", "db_id": "tracking_grants_for_research", "question": "What are the different grant amounts for documents sent before '1986-08-26 20:49:27' and after the grant ended on '1989-03-16 18:27:16'?", "rationale": ["Identify the relevant tables: Grants and Documents are needed to get grant amounts and filter by document sent dates.", "Join the Grants table with the Documents table on the grant_id to link documents to their respective grants.", "Filter the results to include only those documents sent before '1986-08-26 20:49:27'.", "Also, filter to ensure that the grant end date is before '1989-03-16 18:27:16'.", "Select distinct grant amounts to avoid duplicates in the results."], "gold_sql": "SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  '1986-08-26 20:49:27' INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  '1989-03-16 18:27:16'", "source_tables": ["grants", "documents"], "pred_sql": "SELECT DISTINCT G.grant_amount \nFROM Grants AS G \nJOIN Documents AS D ON G.grant_id = D.grant_id \nWHERE D.sent_date < '1986-08-26 20:49:27' \nAND G.grant_end_date < '1989-03-16 18:27:16';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation IDs and their corresponding details from the 'Organisations' table, which are associated with grants from the 'Grants' table. The results are grouped by organisation ID, and only those organisations that have a total grant amount exceeding a specified threshold are included, as indicated by the placeholder in the HAVING clause.\",\n        \"virtual_table\": \"SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4322", "db_id": "tracking_grants_for_research", "question": "List the project details of the project both producing patent and paper as outcomes.", "rationale": ["The task is to list project details for projects that produce both patent and paper outcomes.", "We need to identify the outcome codes for 'PATENT' and 'PAPER'.", "Using the provided hint, we can create a query that selects project details from the 'Projects' table joined with the 'Project_Outcomes' table.", "We will use the INTERSECT operation to find projects that have both outcomes by creating two separate SELECT statements, one for each outcome code.", "The final SQL query will select project details from the 'Projects' table where the project has both 'PATENT' and 'PAPER' outcomes."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT T1.project_details \nFROM Projects AS T1 \nJOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id \nWHERE T2.outcome_code = 'PATENT' \nINTERSECT \nSELECT T1.project_details \nFROM Projects AS T1 \nJOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id \nWHERE T2.outcome_code = 'PAPER';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the outcome descriptions of research outcomes associated with specific project outcomes. The join between the 'Research_Outcomes' and 'Project_Outcomes' tables is based on the matching outcome codes, allowing users to retrieve detailed descriptions of research outcomes linked to projects.\",\n        \"virtual_table\": \"SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: Grants and Organisations.", "We need to sum the grant amounts, so we will use the SUM function on the grant_amount column from the Grants table.", "To filter the organisations that are described as research, we will join the Grants table with the Organisations table on organisation_id.", "We will use a WHERE clause to filter organisations based on their type, specifically looking for those that match the description 'research'.", "To get the organisation type, we can use a subquery to select the organisation_type from the Organisation_Types table where the description matches 'research'.", "Finally, we will select the total sum of the grant amounts for these organisations."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT SUM(T1.grant_amount) AS total_grant_amount \nFROM Grants AS T1 \nJOIN Organisations AS T2 ON T1.organisation_id = T2.organisation_id \nWHERE T2.organisation_type = (SELECT organisation_type FROM Organisation_Types WHERE organisation_type_description = 'research')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation IDs and their corresponding details from the 'Organisations' table, which are associated with grants from the 'Grants' table. The results are grouped by organisation ID, and only those organisations that have a total grant amount exceeding a specified threshold are included, as indicated by the placeholder in the HAVING clause.\",\n        \"virtual_table\": \"SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the role code for the leader role from the Staff_Roles table.", "Determine the project ID that has the most staff by grouping the Project_Staff table by project_id and ordering by the count of staff_id in descending order, limiting the result to 1.", "Join the Project_Staff table with the Projects table to get the relevant project details.", "Filter the results to only include staff members with the leader role code and the project ID identified in the previous step.", "Select the date_from and date_to columns to get the working dates of the staff on that project."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to FROM Project_Staff AS PS JOIN Projects AS P ON PS.project_id = P.project_id WHERE PS.role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Leader') AND P.project_id = (SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY COUNT(staff_id) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields to link organisations with their research staff.", "Select the organisation_type and organisation_id from the joined tables.", "Group the results by organisation_id to aggregate the count of research staff for each organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most research staff.", "Limit the results to 1 to get only the organisation with the highest count."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT T1.organisation_type, T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the relevant tables: Documents, Grants, Organisations, and Organisation_Types.", "We need to find the send dates of documents, so we will select the 'sent_date' from the Documents table.", "To filter documents based on grant amount, we will join the Documents table with the Grants table using the 'grant_id'.", "Next, we need to join the Grants table with the Organisations table to access the organisation details related to the grants.", "Finally, we will apply the condition to filter grants with an amount greater than 5000 in the WHERE clause."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT D.sent_date \nFROM Documents AS D \nJOIN Grants AS G ON D.grant_id = G.grant_id \nJOIN Organisations AS O ON G.organisation_id = O.organisation_id \nJOIN Organisation_Types AS OT ON O.organisation_type = OT.organisation_type \nWHERE G.grant_amount > 5000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation IDs and their corresponding details from the 'Organisations' table, which are associated with grants from the 'Grants' table. The results are grouped by organisation ID, and only those organisations that have a total grant amount exceeding a specified threshold are included, as indicated by the placeholder in the HAVING clause.\",\n        \"virtual_table\": \"SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4338", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects which did not hire any staff for a researcher role.", "rationale": ["We need to list project details for projects that did not hire any staff for a researcher role.", "To achieve this, we will select from the Projects table, specifically the project_id and project_details columns.", "We will perform a LEFT JOIN with the Project_Staff table on the project_id to find any associated staff members.", "To filter for only those staff members with a researcher role, we will add a condition in the JOIN clause that checks for the role_code corresponding to 'Researcher'.", "Finally, we will filter the results where the staff_id from the Project_Staff table is NULL, indicating that no staff were hired for that role."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT P.project_id, P.project_details \nFROM Projects AS P \nLEFT JOIN Project_Staff AS PS ON P.project_id = PS.project_id AND PS.role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Researcher') \nWHERE PS.staff_id IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4339", "db_id": "tracking_grants_for_research", "question": "What are the details for all projects that did not hire any staff in a research role?", "rationale": ["Identify the relevant tables: Projects and Project_Staff.", "We need to find projects that did not hire any staff in a research role, which implies looking for projects without any associated entries in the Project_Staff table.", "Use a LEFT JOIN to connect Projects with Project_Staff on project_id, allowing us to see all projects even if they have no staff.", "Filter the results where the staff_id from Project_Staff is NULL, indicating no staff were hired for that project."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT P.* FROM Projects AS P LEFT JOIN Project_Staff AS PS ON P.project_id = PS.project_id WHERE PS.staff_id IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4342", "db_id": "tracking_grants_for_research", "question": "When do all the researcher role staff start to work, and when do they stop working?", "rationale": ["Identify the relevant tables: We need to look at the Project_Staff table to find the start and end dates of researcher role staff.", "Filter for researcher role staff: We will filter the Project_Staff table based on the projects associated with organisations that employ research staff.", "Use subqueries: We will use subqueries to first find the organisation IDs that employ research staff, then find the project IDs associated with those organisations, and finally get the start and end dates from the Project_Staff table.", "Aggregate the results: We will use MIN() to find the earliest start date and MAX() to find the latest end date for the researcher role staff."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT MIN(date_from) AS start_date, MAX(date_to) AS end_date FROM Project_Staff WHERE project_id IN (SELECT project_id FROM Projects WHERE organisation_id IN (SELECT organisation_id FROM Organisations WHERE organisation_id IN (SELECT employer_organisation_id FROM Research_Staff)));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4350", "db_id": "tracking_grants_for_research", "question": "How many staff does each project has? List the project id and the number in an ascending order.", "rationale": ["Identify the relevant tables: We need to count the number of staff associated with each project, so we will use the Project_Staff table.", "Use the COUNT function: To get the number of staff for each project, we will use the COUNT function on the staff_id column.", "Group by project_id: Since we want the count of staff for each project, we will group the results by project_id.", "Order the results: The final result should be ordered in ascending order based on the number of staff, so we will use ORDER BY staff_count ASC."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT project_id, COUNT(staff_id) AS staff_count FROM Project_Staff GROUP BY project_id ORDER BY staff_count ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4351", "db_id": "tracking_grants_for_research", "question": "For each project id, how many staff does it have? List them in increasing order.", "rationale": ["Identify the relevant tables: We need to count the number of staff associated with each project, so we will use the Project_Staff table.", "Use the COUNT function: To count the number of staff members for each project, we will use the COUNT function on the staff_id column.", "Group by project_id: Since we want the count for each project, we will group the results by project_id.", "Order the results: Finally, we will order the results in increasing order of project_id to meet the requirement of listing them in ascending order."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT project_id, COUNT(staff_id) AS staff_count FROM Project_Staff GROUP BY project_id ORDER BY project_id ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the tables involved: Projects and Project_Outcomes.", "We need to join these tables on the project_id to relate projects to their outcomes.", "Select the project details and project ID from the Projects table.", "Group the results by project ID to aggregate the outcomes for each project.", "Order the results by the count of outcomes in descending order to find the project with the most outcomes.", "Limit the results to 1 to get only the project with the highest number of outcomes."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT T1.project_details, T1.project_id FROM Projects AS T1 JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4359", "db_id": "tracking_grants_for_research", "question": "What are the details of the project with no outcomes?", "rationale": ["The user wants to find details of projects that have no outcomes associated with them.", "To achieve this, we need to select all columns from the 'Projects' table.", "We will use a subquery to find project IDs that exist in the 'Project_Outcomes' table.", "The subquery will select all project IDs from 'Project_Outcomes'.", "We will use the NOT IN clause to filter out those project IDs from the main query, ensuring we only get projects with no outcomes."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT * FROM Projects WHERE project_id NOT IN (SELECT project_id FROM Project_Outcomes)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the outcome descriptions of research outcomes associated with specific project outcomes. The join between the 'Research_Outcomes' and 'Project_Outcomes' tables is based on the matching outcome codes, allowing users to retrieve detailed descriptions of research outcomes linked to projects.\",\n        \"virtual_table\": \"SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code\"\n    }\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields to get the organisations that employ research staff.", "Select the organisation_id, organisation_type, and organisation_details from the Organisations table.", "Group the results by organisation_id to count the number of research staff for each organisation.", "Order the results in descending order based on the count of research staff to find the organisation with the most staff.", "Limit the results to 1 to get only the organisation that hired the most research staff."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT T1.organisation_id, T1.organisation_type, T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff and Staff_Roles are needed to get staff IDs and their role descriptions.", "Join Project_Staff with Staff_Roles on role_code to get the role descriptions for each staff member.", "To find the role involved with the most number of projects, we need to count the number of projects each staff member is involved in.", "Use a subquery to count the number of projects for each staff member and find the maximum count.", "Filter the results to only include staff members whose project count matches the maximum count found in the previous step."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT PS.staff_id, SR.role_description\nFROM Project_Staff AS PS\nJOIN Staff_Roles AS SR ON PS.role_code = SR.role_code\nWHERE PS.project_id IN (\n    SELECT project_id\n    FROM Project_Staff\n    GROUP BY project_id\n    HAVING COUNT(*) = (\n        SELECT MAX(project_count)\n        FROM (\n            SELECT project_id, COUNT(*) AS project_count\n            FROM Project_Staff\n            GROUP BY project_id\n        ) AS project_counts\n    )\n)\nGROUP BY PS.staff_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4364", "db_id": "tracking_grants_for_research", "question": "Which document type is described with the prefix 'Initial'?", "rationale": ["Identify the table that contains document types, which is 'Document_Types'.", "Determine the relevant columns needed: 'document_type_code' and 'document_description'.", "The question asks for document types with descriptions that start with the prefix 'Initial'.", "Use the SQL 'LIKE' operator to filter results where 'document_description' starts with 'Initial'.", "Construct the SQL query to select the required columns from the 'Document_Types' table with the appropriate condition."], "gold_sql": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'", "source_tables": ["document_types"], "pred_sql": "SELECT document_type_code, document_description FROM Document_Types WHERE document_description LIKE 'Initial%';", "hint": "\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["Identify the relevant tables: We need to work with the 'Documents' table to count the documents per grant and find the one with the most documents.", "Count the number of documents for each grant: We can use COUNT() to count the documents grouped by 'grant_id'.", "Find the document with the most occurrences for each grant: We can use a subquery to find the document ID that has the maximum count for each grant.", "Join the results: We will join the main query with the subquery to get the document ID that corresponds to the maximum count for each grant.", "Construct the final SQL query: Combine the counting and the maximum document ID retrieval into a single SQL statement."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT d.grant_id, COUNT(d.document_id) AS document_count, d.document_id \nFROM Documents d \nJOIN ( \n    SELECT grant_id, MAX(document_id) AS document_id \n    FROM Documents \n    GROUP BY grant_id \n) AS max_docs ON d.grant_id = max_docs.grant_id AND d.document_id = max_docs.document_id \nGROUP BY d.grant_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation IDs and their corresponding details from the 'Organisations' table, which are associated with grants from the 'Grants' table. The results are grouped by organisation ID, and only those organisations that have a total grant amount exceeding a specified threshold are included, as indicated by the placeholder in the HAVING clause.\",\n        \"virtual_table\": \"SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4374", "db_id": "tracking_grants_for_research", "question": "How many Patent outcomes are generated from all the projects?", "rationale": ["Identify the relevant tables: Project_Outcomes and Research_Outcomes are needed to find the patent outcomes.", "Join the Project_Outcomes table with the Research_Outcomes table on the outcome_code to access the descriptions of the outcomes.", "Filter the results to only include outcomes that contain the word 'Patent' in their description.", "Count the number of rows that meet the criteria to get the total number of Patent outcomes."], "gold_sql": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  'Patent'", "source_tables": ["project_outcomes"], "pred_sql": "SELECT COUNT(*) FROM Project_Outcomes AS T1 JOIN Research_Outcomes AS T2 ON T1.outcome_code = T2.outcome_code WHERE T2.outcome_description LIKE '%Patent%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the outcome descriptions of research outcomes associated with specific project outcomes. The join between the 'Research_Outcomes' and 'Project_Outcomes' tables is based on the matching outcome codes, allowing users to retrieve detailed descriptions of research outcomes linked to projects.\",\n        \"virtual_table\": \"SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4376", "db_id": "tracking_grants_for_research", "question": "How many project staff worked as leaders or started working before '1989-04-24 23:51:54'?", "rationale": ["Identify the relevant table: Project_Staff contains information about staff members and their roles.", "Determine the criteria for counting staff: We need to count those who worked as leaders and started before a specific date.", "Use a subquery to find the role_code for 'Leader' from the Staff_Roles table.", "Filter the Project_Staff table based on the role_code and the date_from condition.", "Count the number of records that meet these criteria."], "gold_sql": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'", "source_tables": ["project_staff"], "pred_sql": "SELECT COUNT(*) FROM Project_Staff WHERE role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Leader') AND date_from < '1989-04-24 23:51:54';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant table: The question asks for project details, which are stored in the 'Projects' table.", "Determine the specific condition: The user is looking for projects with a specific detail, which is 'sint'.", "Construct the SQL query: Use a SELECT statement to retrieve 'project_details' from the 'Projects' table where 'project_details' matches 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT project_details FROM Projects WHERE project_details = 'sint';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the outcome descriptions of research outcomes associated with specific project outcomes. The join between the 'Research_Outcomes' and 'Project_Outcomes' tables is based on the matching outcome codes, allowing users to retrieve detailed descriptions of research outcomes linked to projects.\",\n        \"virtual_table\": \"SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes are needed to get project details and their associated outcome descriptions.", "Join the Projects table with Project_Outcomes to link projects with their outcomes using the project_id.", "Join the resulting table with Research_Outcomes to get the descriptions of the outcomes using the outcome_code.", "Filter the results to only include projects where the project_details match 'sint'.", "Select the project details and the corresponding outcome descriptions in the final output."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT P.project_details, R.outcome_description \nFROM Projects AS P \nJOIN Project_Outcomes AS PO ON P.project_id = PO.project_id \nJOIN Research_Outcomes AS R ON PO.outcome_code = R.outcome_code \nWHERE P.project_details = 'sint';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the outcome descriptions of research outcomes associated with specific project outcomes. The join between the 'Research_Outcomes' and 'Project_Outcomes' tables is based on the matching outcome codes, allowing users to retrieve detailed descriptions of research outcomes linked to projects.\",\n        \"virtual_table\": \"SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4385", "db_id": "tracking_grants_for_research", "question": "What are the details for the projects which were launched by the organization with the most projects?", "rationale": ["Identify the organisation with the most projects by counting the number of projects associated with each organisation.", "Use a subquery to select the organisation_id of the organisation with the highest project count, limiting the results to 1.", "Join the Projects table with the result of the subquery to get all details of the projects associated with that organisation."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT P.* FROM Projects AS P JOIN (SELECT organisation_id, COUNT(*) AS project_count FROM Projects GROUP BY organisation_id ORDER BY project_count DESC LIMIT 1) AS Org ON P.organisation_id = Org.organisation_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4391", "db_id": "tracking_grants_for_research", "question": "For each project id, how many tasks are there?", "rationale": ["Identify the relevant tables: We need to count tasks associated with each project, so we will use the 'Tasks' table.", "Determine the necessary columns: We need 'project_id' from the 'Tasks' table and a count of 'task_id' to get the number of tasks per project.", "Group the results: To get the count of tasks for each project, we will group the results by 'project_id'.", "Construct the SQL query: Combine the selected columns and the grouping into a complete SQL query."], "gold_sql": "SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id", "source_tables": ["tasks", "projects"], "pred_sql": "SELECT project_id, COUNT(task_id) AS task_count FROM Tasks GROUP BY project_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["The question asks for the staff roles of the staff who are involved in projects.", "To find the staff roles, we need to access the 'Project_Staff' table, which contains the staff IDs and their associated roles.", "We will join the 'Project_Staff' table with the 'Staff_Roles' table to get the role descriptions corresponding to the role codes.", "Additionally, we will join with the 'Research_Staff' table to ensure we are only considering research staff.", "The final query will select the role code and role description from the joined tables."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT SR.role_code, SR.role_description \nFROM Project_Staff AS PS \nJOIN Staff_Roles AS SR ON PS.role_code = SR.role_code \nJOIN Research_Staff AS RS ON PS.staff_id = RS.staff_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["Identify the relevant table: The 'Project_Staff' table contains information about staff members and their roles.", "Determine the necessary columns: We need the 'role_code' to identify the roles and a count of how many staff members have each role.", "Group the results: Use GROUP BY on 'role_code' to aggregate the counts of each role.", "Order the results: Use ORDER BY to sort the counts in descending order so that the most common role appears first.", "Limit the results: Use LIMIT 1 to get only the most common role."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count FROM Project_Staff GROUP BY role_code ORDER BY role_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to count the number of products, so we will use COUNT(*) in the SELECT statement.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to filter products by category.", "Add a WHERE clause to filter for products in the 'Spices' category and with a typical selling price greater than 1000."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT COUNT(*) FROM Products AS p JOIN Ref_Product_Categories AS c ON p.product_category_code = c.product_category_code WHERE c.product_category_description = 'Spices' AND p.typical_selling_price > 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the frequency of products associated with each color. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the tables involved: We need to get product category descriptions from the Ref_Product_Categories table and filter products based on their descriptions from the Products table.", "Determine the relationship: The Products table has a foreign key relationship with the Ref_Product_Categories table through the product_category_code.", "Construct the JOIN clause: We will join Ref_Product_Categories (aliased as T1) with Products (aliased as T2) on the product_category_code.", "Add the WHERE clause: We need to filter the products where the product_description contains the letter 't'. This is done using the LIKE operator with '%t%'.", "Select the required field: We want to select the product_category_description from the Ref_Product_Categories table."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT T1.product_category_description FROM Ref_Product_Categories AS T1 JOIN Products AS T2 ON T1.product_category_code = T2.product_category_code WHERE T2.product_description LIKE '%t%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\",\n        \"virtual_table\": \"SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the frequency of products associated with each color. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color in ascending order. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5576", "db_id": "products_gen_characteristics", "question": "Count the products that have the color description \"white\" or have the characteristic name \"hot\".", "rationale": ["Identify the tables needed: Products, Ref_Colors, Product_Characteristics, and Characteristics.", "Join the Products table with Ref_Colors to filter by color description.", "Join the Product_Characteristics table with Products to access the characteristics of each product.", "Join the Characteristics table to filter by characteristic name.", "Use a WHERE clause to specify the conditions: color description must be 'white' or characteristic name must be 'hot'.", "Count the total number of products that meet either of the conditions."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(*) FROM Products AS p JOIN Ref_Colors AS c ON p.color_code = c.color_code JOIN Product_Characteristics AS pc ON p.product_id = pc.product_id JOIN Characteristics AS ch ON pc.characteristic_id = ch.characteristic_id WHERE c.color_description = 'white' OR ch.characteristic_name = 'hot';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the frequency of products associated with each color. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color in ascending order. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the columns needed: unit_of_measure from Ref_Product_Categories.", "Establish the relationship between Products and Ref_Product_Categories using the product_category_code foreign key.", "Filter the results to include only products that have 'Herb' in their product name using a LIKE clause."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT Ref_Product_Categories.unit_of_measure \nFROM Products \nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code \nWHERE Products.product_name LIKE '%Herb%';", "hint": "\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the tables needed: We need to retrieve the unit of measurement and product category code, which are in the 'Ref_Product_Categories' table, and we need to filter based on the product name, which is in the 'Products' table.", "Join the 'Ref_Product_Categories' table with the 'Products' table on the product category code to access the relevant information from both tables.", "Use a WHERE clause to filter the products by the name 'chervil'.", "Select the required columns: product_category_code and unit_of_measure from the joined tables."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT T1.product_category_code, T1.unit_of_measure FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code = T2.product_category_code WHERE T2.product_name = 'chervil'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\",\n        \"virtual_table\": \"SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the frequency of products associated with each color. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5589", "db_id": "products_gen_characteristics", "question": "What are the names of products that are not 'white' in color and are not measured by the unit 'Handful'?", "rationale": ["Identify the relevant tables: Products, Ref_Colors, and Ref_Product_Categories.", "Join the Products table with the Ref_Colors table on the color_code to filter products based on color.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to filter products based on the unit of measure.", "Use a WHERE clause to specify the conditions: color_description should not be 'white' and unit_of_measure should not be 'Handful'.", "Select the product_name from the resulting joined tables that meet the specified conditions."], "gold_sql": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  'white' AND t2.unit_of_measure != 'Handful'", "source_tables": ["products", "ref_colors", "ref_product_categories"], "pred_sql": "SELECT product_name FROM Products p JOIN Ref_Colors c ON p.color_code = c.color_code JOIN Ref_Product_Categories pc ON p.product_category_code = pc.product_category_code WHERE c.color_description != 'white' AND pc.unit_of_measure != 'Handful';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the frequency of products associated with each color. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color in ascending order. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["The question asks for the description of the color used by the least products.", "To find this, we need to join the Products table with the Ref_Colors table on the color_code.", "We will group the results by color description to count how many products are associated with each color.", "To find the color used by the least products, we will order the results by the count in ascending order.", "Finally, we will limit the results to 1 to get the color description used by the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT t2.color_description FROM Products AS t1 JOIN Ref_Colors AS t2 ON t1.color_code = t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the frequency of products associated with each color. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color in ascending order. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\",\n        \"virtual_table\": \"SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["Identify the Characteristics table which contains the names of characteristics.", "Join the Product_Characteristics table to link characteristics to products.", "Group the results by characteristic_id to aggregate the data for each characteristic.", "Use the HAVING clause to filter the grouped results to only include characteristics that are associated with two or more distinct products."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT c.characteristic_name \nFROM Characteristics AS c \nJOIN Product_Characteristics AS pc ON c.characteristic_id = pc.characteristic_id \nGROUP BY c.characteristic_id \nHAVING COUNT(DISTINCT pc.product_id) >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the frequency of products associated with each color. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5669", "db_id": "dorm_1", "question": "What are the names of the all-female dorms?", "rationale": ["Identify the table that contains information about dormitories, which is the 'Dorm' table.", "Determine the relevant column that specifies the gender designation for the dormitory, which is the 'gender' column.", "Formulate a SQL query to select the 'dorm_name' from the 'Dorm' table where the 'gender' is 'female'."], "gold_sql": "SELECT dorm_name FROM dorm WHERE gender  =  'F'", "source_tables": ["dorm"], "pred_sql": "SELECT dorm_name FROM Dorm WHERE gender = 'female';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    }\n}\n"}
{"sample_id": "train.5688", "db_id": "dorm_1", "question": "Find the average and total capacity of dorms for the students with gender X.", "rationale": ["Identify the tables needed: Dorm, Lives_in, and Student.", "We need to calculate the average and total capacity of dorms, so we will use the AVG() and SUM() functions on the student_capacity column from the Dorm table.", "To filter the dorms based on the students' gender, we will join the Lives_in table to link students to their dorms and then join the Student table to access the gender information.", "The WHERE clause will filter the results to include only those students with gender 'X'.", "Finally, we will select the average and total capacity from the resulting dataset."], "gold_sql": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  'X'", "source_tables": ["dorm"], "pred_sql": "SELECT AVG(D.student_capacity) AS average_capacity, SUM(D.student_capacity) AS total_capacity \nFROM Dorm AS D \nJOIN Lives_in AS L ON D.dormid = L.dormid \nJOIN Student AS S ON L.stuid = S.StuID \nWHERE S.Sex = 'X';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    }\n}\n"}
{"sample_id": "train.5699", "db_id": "dorm_1", "question": "What are the names and types of the dorms that have a capacity greater than 300 or less than 100?", "rationale": ["Identify the relevant table: The question pertains to dormitories, so we will focus on the Dorm table.", "Determine the required columns: We need the names and types of the dorms, which correspond to the 'dorm_name' and 'student_capacity' columns in the Dorm table.", "Establish the filtering criteria: The question specifies dorms with a capacity greater than 300 or less than 100, which translates to a WHERE clause in SQL.", "Construct the SQL query: Combine the selected columns and the filtering criteria into a complete SQL statement."], "gold_sql": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100", "source_tables": ["dorm"], "pred_sql": "SELECT dorm_name, student_capacity FROM Dorm WHERE student_capacity > 300 OR student_capacity < 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    }\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables needed: We need to count students living in male dorms, so we will use the Lives_in and Dorm tables.", "Join the Lives_in table with the Dorm table on the dormid to get the gender of the dorms where students live.", "Filter the results to include only those dorms where the gender is 'male'.", "Count the distinct student IDs (stuid) from the Lives_in table to get the total number of students living in male dorms."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(DISTINCT L.stuid) AS total_students \nFROM Lives_in L \nJOIN Dorm D ON L.dormid = D.dormid \nWHERE D.gender = 'male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    }\n}\n"}
{"sample_id": "train.5755", "db_id": "dorm_1", "question": "What is the most common amenity in the dorms?", "rationale": ["We need to find the most common amenity in the dorms, which requires counting the occurrences of each amenity.", "To do this, we will join the Dorm_amenity table with the Has_amenity table to link amenities to dorms.", "Next, we will join the resulting table with the Dorm table to filter by dorms that have a certain student capacity.", "We will group the results by amenity name to count how many times each amenity appears.", "Finally, we will order the results by the count in descending order and limit the output to the top result to find the most common amenity."], "gold_sql": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_amenity", "dorm_amenity"], "pred_sql": "SELECT amenity_name, COUNT(*) as amenity_count \nFROM Dorm_amenity AS DA \nJOIN Has_amenity AS HA ON DA.amenid = HA.amenid \nJOIN Dorm AS D ON HA.dormid = D.dormid \nWHERE D.student_capacity > 0 \nGROUP BY DA.amenity_name \nORDER BY amenity_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    }\n}\n"}
{"sample_id": "train.5757", "db_id": "dorm_1", "question": "What are the first names of all students who live in the dorm with the most amenities?", "rationale": ["Identify the dormitory with the most amenities by counting the number of amenities for each dormitory.", "Use a subquery to select the dormid of the dormitory that has the highest count of amenities.", "Select the first names of students who live in that dormitory by checking the Lives_in table for the corresponding dormid."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT Fname FROM Student WHERE StuID IN (SELECT stuid FROM Lives_in WHERE dormid = (SELECT dormid FROM (SELECT count(*) AS amenity_count, T1.dormid FROM Dorm AS T1 JOIN Has_amenity AS T2 ON T1.dormid = T2.dormid GROUP BY T1.dormid ORDER BY amenity_count DESC LIMIT 1)))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    }\n}\n"}
{"sample_id": "train.5776", "db_id": "customer_complaints", "question": "Find the emails of customers who has filed a complaints of the product with the most complaints.", "rationale": ["Identify the product with the most complaints by grouping the Complaints table by product_id and counting the number of complaints for each product.", "Order the results by the count of complaints in descending order and limit the results to 1 to get the product_id with the most complaints.", "Join the Customers table with the Complaints table on customer_id to find the email addresses of customers who filed complaints.", "Filter the results to only include those complaints that are related to the product_id identified in the previous step."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address FROM Customers c JOIN Complaints comp ON c.customer_id = comp.customer_id WHERE comp.product_id = (SELECT product_id FROM Complaints GROUP BY product_id ORDER BY COUNT(*) DESC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names of staff members from the 'Staff' table who are associated with complaints in the 'Complaints' table. The results are grouped by staff member, and the number of complaints handled by each staff member is counted. The placeholder in the LIMIT clause allows for specifying the maximum number of staff members to return based on the count of complaints they have handled.\",\n        \"virtual_table\": \"SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the main goal: Retrieve the emails of customers who filed complaints on the product with the greatest number of complaints.", "To find the product with the greatest number of complaints, a subquery is needed that counts complaints grouped by product_id and orders them in descending order, limiting the result to the top one.", "Join the Customers table with the Complaints table on customer_id to access customer emails related to the complaints.", "Use the result of the subquery to filter the complaints to only those related to the product with the highest complaint count."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address \nFROM Customers c \nJOIN Complaints co ON c.customer_id = co.customer_id \nWHERE co.product_id = (\n    SELECT product_id \n    FROM Complaints \n    GROUP BY product_id \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names of staff members from the 'Staff' table who are associated with complaints in the 'Complaints' table. The results are grouped by staff member, and the number of complaints handled by each staff member is counted. The placeholder in the LIMIT clause allows for specifying the maximum number of staff members to return based on the count of complaints they have handled.\",\n        \"virtual_table\": \"SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5779", "db_id": "customer_complaints", "question": "Return the names of products that have had complaints filed by the customer who has filed the fewest complaints.", "rationale": ["Identify the products that have had complaints filed against them, which requires joining the Products and Complaints tables on the product_id.", "To find the customer who has filed the fewest complaints, we need to group the Complaints table by customer_id and count the number of complaints for each customer.", "We will order the results of this grouping by the count of complaints in ascending order and limit the results to 1 to get the customer with the fewest complaints.", "Finally, we will use the customer_id from the subquery to filter the complaints in the main query, allowing us to select the product names associated with that customer."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT p.product_name \nFROM Products p \nJOIN Complaints c ON p.product_id = c.product_id \nWHERE c.customer_id = (\n    SELECT customer_id \n    FROM Complaints \n    GROUP BY customer_id \n    ORDER BY COUNT(*) ASC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names of staff members from the 'Staff' table who are associated with complaints in the 'Complaints' table. The results are grouped by staff member, and the number of complaints handled by each staff member is counted. The placeholder in the LIMIT clause allows for specifying the maximum number of staff members to return based on the count of complaints they have handled.\",\n        \"virtual_table\": \"SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the relevant tables: Staff, Complaints, and Products are needed to find the last name of the staff member handling the complaint related to the product with the lowest price.", "Join the Staff table with the Complaints table on staff_id to link staff members to the complaints they handle.", "Join the resulting table with the Products table on product_id to access product details related to the complaints.", "Use a subquery to find the minimum product price from the Products table.", "Filter the results to only include complaints related to the product with the lowest price.", "Select the last name of the staff member from the filtered results."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT s.last_name \nFROM Staff AS s \nJOIN Complaints AS c ON s.staff_id = c.staff_id \nJOIN Products AS p ON c.product_id = p.product_id \nWHERE p.product_price = (SELECT MIN(product_price) FROM Products)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names of staff members from the 'Staff' table who are associated with complaints in the 'Complaints' table. The results are grouped by staff member, and the number of complaints handled by each staff member is counted. The placeholder in the LIMIT clause allows for specifying the maximum number of staff members to return based on the count of complaints they have handled.\",\n        \"virtual_table\": \"SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5800", "db_id": "customer_complaints", "question": "How many customers are there in the customer type with the most customers?", "rationale": ["Identify the relevant table: Customers.", "Determine the columns needed: customer_type_code and customer_id.", "Count the number of customers for each customer type using COUNT(customer_id).", "Group the results by customer_type_code to aggregate the counts.", "Order the results in descending order based on the count of customers.", "Limit the results to 1 to get the customer type with the most customers."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT customer_type_code, COUNT(customer_id) AS customer_count\nFROM Customers\nGROUP BY customer_type_code\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the tables involved: Staff and Complaints.", "We need to find the first names of staff members, so we will select 'first_name' from the Staff table.", "To find out how many complaints each staff member has handled, we will join the Staff table with the Complaints table on 'staff_id'.", "We will group the results by 'staff_id' to count the number of complaints handled by each staff member.", "We will order the results by the count of complaints in descending order to get the staff who handled the most complaints at the top.", "Finally, we will limit the results to the top 5 staff members."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT t1.first_name FROM Staff AS t1 JOIN Complaints AS t2 ON t1.staff_id = t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) DESC LIMIT 5", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names of staff members from the 'Staff' table who are associated with complaints in the 'Complaints' table. The results are grouped by staff member, and the number of complaints handled by each staff member is counted. The placeholder in the LIMIT clause allows for specifying the maximum number of staff members to return based on the count of complaints they have handled.\",\n        \"virtual_table\": \"SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5812", "db_id": "customer_complaints", "question": "Which state has the most customers?", "rationale": ["Identify the relevant table: Customers.", "Determine the column that represents the state: 'state'.", "Count the number of customers in each state using COUNT(customer_id).", "Group the results by state to aggregate the counts: GROUP BY state.", "Order the results in descending order to find the state with the most customers: ORDER BY customer_count DESC.", "Limit the results to only the top entry to get the state with the most customers: LIMIT 1."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT state, COUNT(customer_id) AS customer_count\nFROM Customers\nGROUP BY state\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5813", "db_id": "customer_complaints", "question": "Give the state that has the most customers.", "rationale": ["Identify the table that contains customer information, which is the 'Customers' table.", "We need to count the number of customers in each state, so we will use the COUNT() function on 'customer_id'.", "To group the results by state, we will use the GROUP BY clause on the 'state' column.", "To find the state with the most customers, we will order the results in descending order based on the count of customers using ORDER BY.", "Finally, we will limit the results to only the top entry using LIMIT 1."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT state, COUNT(customer_id) AS customer_count\nFROM Customers\nGROUP BY state\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5865", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions whose share count is bigger than 100 and whose type code is \"PUR\"?", "rationale": ["Identify the relevant tables: We need to retrieve lot details, which are in the 'Lots' table, and we need to filter based on transactions, which are in the 'Transactions' table.", "Determine the join condition: The 'Lots' table is linked to the 'Transactions' table through the 'investor_id'. We will join these two tables on this column.", "Specify the filtering criteria: We need to filter transactions where the share count is greater than 100 and the transaction type code is 'PUR'.", "Construct the SQL query: Using the identified tables, join condition, and filtering criteria, we can construct the SQL query to select the lot details."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  100 AND T3.transaction_type_code  =  'PUR'", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT L.lot_details \nFROM Lots AS L \nJOIN Transactions AS T ON L.investor_id = T.investor_id \nWHERE T.share_count > 100 AND T.transaction_type_code = 'PUR';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides detailed information about investors from the 'Investors' table who have conducted transactions involving a number of shares greater than a specified amount. The placeholder in the WHERE clause represents the minimum share count for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table combines the details of sales and purchase transactions from the 'Sales' and 'Purchases' tables. The placeholder in the SELECT statements represents the specific details of each transaction type.\",\n        \"virtual_table\": \"SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases\"\n    }\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["Identify the relevant tables: Transactions and Ref_Transaction_Types are needed to get transaction amounts and their types.", "Join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to get descriptions of each transaction type.", "Use the AVG() function to calculate the average transaction amount for each transaction type.", "Group the results by transaction_type_description to get the average for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table combines the details of sales and purchase transactions from the 'Sales' and 'Purchases' tables. The placeholder in the SELECT statements represents the specific details of each transaction type.\",\n        \"virtual_table\": \"SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases\"\n    }\n}\n"}
{"sample_id": "train.5873", "db_id": "tracking_share_transactions", "question": "Show the number of transactions with transaction type code \"SALE\" for different investors if it is larger than 0.", "rationale": ["Identify the relevant tables: Investors and Transactions are needed to get investor details and transaction counts.", "Join the Investors table with the Transactions table on the investor_id to link investors with their transactions.", "Filter the transactions to only include those with the transaction type code 'SALE'.", "Group the results by investor_id and Investor_details to count the number of transactions for each investor.", "Use the HAVING clause to filter out investors with a transaction count of 0."], "gold_sql": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  'SALE' GROUP BY investor_id", "source_tables": ["transactions"], "pred_sql": "SELECT I.investor_id, I.Investor_details, COUNT(T.transaction_id) AS transaction_count \nFROM Investors AS I \nJOIN Transactions AS T ON I.investor_id = T.investor_id \nWHERE T.transaction_type_code = 'SALE' \nGROUP BY I.investor_id, I.Investor_details \nHAVING COUNT(T.transaction_id) > 0;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides detailed information about investors from the 'Investors' table who have conducted transactions involving a number of shares greater than a specified amount. The placeholder in the WHERE clause represents the minimum share count for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table combines the details of sales and purchase transactions from the 'Sales' and 'Purchases' tables. The placeholder in the SELECT statements represents the specific details of each transaction type.\",\n        \"virtual_table\": \"SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases\"\n    }\n}\n"}
{"sample_id": "train.5876", "db_id": "tracking_share_transactions", "question": "Show the transaction type code that occurs the most frequently.", "rationale": ["Identify the relevant table: The Transactions table contains the transaction_type_code which we need to analyze for frequency.", "Group the results: We will group the results by transaction_type_code to count how many times each code appears.", "Count occurrences: Use COUNT(*) to count the number of occurrences for each transaction_type_code.", "Order the results: We will order the results in descending order based on the count to find the most frequent transaction type code.", "Limit the results: Finally, we will limit the results to 1 to get only the most frequent transaction type code."], "gold_sql": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["transactions"], "pred_sql": "SELECT transaction_type_code FROM Transactions GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table combines the details of sales and purchase transactions from the 'Sales' and 'Purchases' tables. The placeholder in the SELECT statements represents the specific details of each transaction type.\",\n        \"virtual_table\": \"SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases\"\n    }\n}\n"}
{"sample_id": "train.5884", "db_id": "tracking_share_transactions", "question": "What are the details of the lots which are not used in any transactions?", "rationale": ["Identify the main goal: to find details of lots not used in any transactions.", "Understand the relationship between Lots and Transactions through the Transactions_Lots table.", "Use a subquery to select all lot_ids that are present in the Transactions_Lots table.", "Filter the Lots table to return only those lots whose lot_id is not in the list obtained from the subquery."], "gold_sql": "SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id", "source_tables": ["lots", "transactions_lots"], "pred_sql": "SELECT * FROM Lots WHERE lot_id NOT IN (SELECT lot_id FROM Transactions_Lots)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table combines the details of sales and purchase transactions from the 'Sales' and 'Purchases' tables. The placeholder in the SELECT statements represents the specific details of each transaction type.\",\n        \"virtual_table\": \"SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides detailed information about investors from the 'Investors' table who have conducted transactions involving a number of shares greater than a specified amount. The placeholder in the WHERE clause represents the minimum share count for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5893", "db_id": "cre_Theme_park", "question": "Show details of all visitors.", "rationale": ["The user wants to show details of all visitors, which means we need to select all columns from the Visitors table.", "The SQL query to retrieve all columns from a table is done using SELECT * FROM table_name.", "In this case, the table name is Visitors, so the query becomes SELECT * FROM Visitors."], "gold_sql": "SELECT Tourist_Details FROM VISITORS", "source_tables": ["visitors"], "pred_sql": "SELECT * FROM Visitors;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table, ensuring that only attractions with visit counts below or equal to the specified threshold are included.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5901", "db_id": "cre_Theme_park", "question": "What is the detail of the location UK Gallery?", "rationale": ["Identify the table that contains location details, which is the 'Locations' table.", "Determine the columns needed: 'Location_Name', 'Address', and 'Other_Details'.", "Use a WHERE clause to filter the results for the specific location 'UK Gallery'.", "Construct the SQL query to select the required columns from the 'Locations' table where the 'Location_Name' matches 'UK Gallery'."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "pred_sql": "SELECT Location_Name, Address, Other_Details FROM Locations WHERE Location_Name = 'UK Gallery'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.\",\n        \"virtual_table\": \"SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The data is retrieved by joining the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for the royal family that corresponds to the tourist attraction.\",\n        \"virtual_table\": \"SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5902", "db_id": "cre_Theme_park", "question": "Return the detail of the location named \"UK Gallery\".", "rationale": ["Identify the table that contains location details, which is the 'Locations' table.", "Determine the columns needed: 'Location_Name', 'Address', and 'Other_Details'.", "Formulate the SQL query to select these columns from the 'Locations' table.", "Add a WHERE clause to filter the results to only include the location named 'UK Gallery'."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "pred_sql": "SELECT Location_Name, Address, Other_Details FROM Locations WHERE Location_Name = 'UK Gallery'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.\",\n        \"virtual_table\": \"SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The data is retrieved by joining the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for the royal family that corresponds to the tourist attraction.\",\n        \"virtual_table\": \"SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5914", "db_id": "cre_Theme_park", "question": "Give me the star rating descriptions of the hotels that cost more than 10000.", "rationale": ["Identify the relevant tables: Hotels and Ref_Hotel_Star_Ratings.", "Determine the columns needed: star_rating_description from Ref_Hotel_Star_Ratings and price_range from Hotels.", "Establish the relationship between the tables using the foreign key: Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code.", "Filter the hotels based on the price range condition: cost more than 10000.", "Construct the SQL query to select the star rating descriptions of the filtered hotels."], "gold_sql": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  10000", "source_tables": ["ref_hotel_star_ratings", "hotels"], "pred_sql": "SELECT R.star_rating_description FROM Hotels AS H JOIN Ref_Hotel_Star_Ratings AS R ON H.star_rating_code = R.star_rating_code WHERE H.price_range = 'More than 10000'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table, ensuring that only attractions with visit counts below or equal to the specified threshold are included.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["The user wants to know the details and opening hours of museums.", "To get this information, we need to join the 'Museums' table with the 'Tourist_Attractions' table.", "The 'Museums' table contains the details of the museums, while the 'Tourist_Attractions' table contains the opening hours.", "We will select the 'Museum_Details' from the 'Museums' table and 'Opening_Hours' from the 'Tourist_Attractions' table.", "The join condition will be based on the matching 'Museum_ID' in the 'Museums' table and 'Tourist_Attraction_ID' in the 'Tourist_Attractions' table."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT T1.Museum_Details, T2.Opening_Hours FROM Museums AS T1 JOIN Tourist_Attractions AS T2 ON T1.Museum_ID = T2.Tourist_Attraction_ID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.\",\n        \"virtual_table\": \"SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The data is retrieved by joining the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for the royal family that corresponds to the tourist attraction.\",\n        \"virtual_table\": \"SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the tables involved: Royal_Family and Tourist_Attractions.", "Determine the relationship between the tables: Royal_Family_ID in Royal_Family corresponds to Tourist_Attraction_ID in Tourist_Attractions.", "Select the required fields: Royal_Family_Details from Royal_Family and How_to_Get_There from Tourist_Attractions.", "Construct the SQL query using a JOIN to combine the two tables based on the identified relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "pred_sql": "SELECT T1.Royal_Family_Details, T2.How_to_Get_There \nFROM Royal_Family AS T1 \nJOIN Tourist_Attractions AS T2 ON T1.Royal_Family_ID = T2.Tourist_Attraction_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The data is retrieved by joining the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for the royal family that corresponds to the tourist attraction.\",\n        \"virtual_table\": \"SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5924", "db_id": "cre_Theme_park", "question": "Find the details of the shops that can be reached by walk.", "rationale": ["Identify the tables involved: Shops and Tourist Attractions.", "Determine the relationship between the tables: Shops are linked to Tourist Attractions via the Shop_ID and Tourist_Attraction_ID.", "Focus on the requirement: Find shops that can be reached by walking, which implies filtering based on the How_to_Get_There column in the Tourist Attractions table.", "Construct the SQL query to select Shop_Details from the Shops table, joining it with the Tourist Attractions table, and applying the filter for walking instructions."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "pred_sql": "SELECT T1.Shop_Details FROM Shops AS T1 JOIN Tourist_Attractions AS T2 ON T1.Shop_ID = T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There = 'walk'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.\",\n        \"virtual_table\": \"SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5927", "db_id": "cre_Theme_park", "question": "What are the details of the markets that can be accessed by walk or bus?", "rationale": ["Identify the relevant tables: Street_Markets and Tourist_Attractions.", "We need to retrieve details from the Street_Markets table, specifically Market_ID and Market_Details.", "To filter the markets that can be accessed by walk or bus, we need to join the Street_Markets table with the Tourist_Attractions table on the Tourist_Attraction_ID.", "The condition for filtering is based on the How_to_Get_There column in the Tourist_Attractions table, which should be either 'walk' or 'bus'.", "Construct the SQL query using the SELECT statement to get the required fields and the JOIN clause to connect the two tables, along with the WHERE clause for filtering."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "pred_sql": "SELECT T1.Market_ID, T1.Market_Details \nFROM Street_Markets AS T1 \nJOIN Tourist_Attractions AS T2 ON T1.Market_ID = T2.Tourist_Attraction_ID \nWHERE T2.How_to_Get_There IN ('walk', 'bus')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.\",\n        \"virtual_table\": \"SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5928", "db_id": "cre_Theme_park", "question": "Find the details of all the markets that are accessible by walk or bus.", "rationale": ["Identify the relevant tables: Street_Markets and Tourist_Attractions.", "We need to join these tables on the common identifier, which is Market_ID in Street_Markets and Tourist_Attraction_ID in Tourist_Attractions.", "We want to filter the results based on the accessibility of the markets, specifically those that can be reached by walking or by bus.", "The condition for filtering will be applied to the How_to_Get_There column in the Tourist_Attractions table, checking if it is either 'walk' or 'bus'.", "Construct the SQL query to select the Market_Details from Street_Markets where the How_to_Get_There condition is met."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "pred_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN Tourist_Attractions AS T2 ON T1.Market_ID = T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There IN ('walk', 'bus')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.\",\n        \"virtual_table\": \"SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "To find the most expensive hotels, we need to sort the hotels by their price range in descending order.", "We will limit the results to the top three entries to get the three most expensive hotels."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The data is retrieved by joining the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for the royal family that corresponds to the tourist attraction.\",\n        \"virtual_table\": \"SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5943", "db_id": "cre_Theme_park", "question": "Show the details and star ratings of the 3 least expensive hotels.", "rationale": ["Identify the relevant tables: Hotels and Ref_Hotel_Star_Ratings.", "Select the columns needed: hotel_id, star_rating_code, price_range from Hotels and star_rating_description from Ref_Hotel_Star_Ratings.", "Join the Hotels table with Ref_Hotel_Star_Ratings on the star_rating_code to get the star rating descriptions.", "Order the results by price_range in ascending order to find the least expensive hotels.", "Limit the results to 3 to get the details of the 3 least expensive hotels."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT H.hotel_id, H.star_rating_code, H.price_range, R.star_rating_description \nFROM Hotels AS H \nJOIN Ref_Hotel_Star_Ratings AS R ON H.star_rating_code = R.star_rating_code \nORDER BY H.price_range ASC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table, ensuring that only attractions with visit counts below or equal to the specified threshold are included.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Visits are needed to determine how people get to attractions and the number of visits.", "Join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID to correlate the transportation method with the number of visits.", "Group the results by the How_to_Get_There column to count how many visits correspond to each transportation method.", "Order the results by the count of visits in descending order to find the most popular transportation method.", "Limit the results to 1 to get only the top transportation method."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT T1.How_to_Get_There, COUNT(*) AS Visit_Count \nFROM Tourist_Attractions AS T1 \nJOIN Visits AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID \nGROUP BY T1.How_to_Get_There \nORDER BY Visit_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant tables: 'Tourist_Attractions' for attraction details and 'Visits' for visit records.", "Join the 'Tourist_Attractions' table with the 'Visits' table on the 'Tourist_Attraction_ID' to link visits to specific attractions.", "Group the results by the 'How_to_Get_There' column from the 'Tourist_Attractions' table to count how many visits correspond to each transportation method.", "Count the number of visits for each transportation method using COUNT(*) and alias it as 'Visit_Count'.", "Order the results in descending order based on 'Visit_Count' to find the most used transportation method.", "Limit the results to 1 to get only the top transportation method."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT T1.How_to_Get_There, COUNT(*) AS Visit_Count \nFROM Tourist_Attractions AS T1 \nJOIN Visits AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID \nGROUP BY T1.How_to_Get_There \nORDER BY Visit_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5951", "db_id": "cre_Theme_park", "question": "Show different tourist attractions' names, ids, and the corresponding number of visits.", "rationale": ["Identify the tables needed: 'Tourist_Attractions' for attraction names and IDs, and 'Visits' for counting visits.", "Join the 'Tourist_Attractions' table with the 'Visits' table on the common column 'Tourist_Attraction_ID'.", "Select the attraction name and ID from 'Tourist_Attractions', and count the number of visits from 'Visits'.", "Group the results by 'Tourist_Attraction_ID' to get the count of visits for each attraction."], "gold_sql": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT T1.Name, T1.Tourist_Attraction_ID, COUNT(*) AS Number_of_Visits FROM Tourist_Attractions AS T1 JOIN Visits AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID GROUP BY T1.Tourist_Attraction_ID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table, ensuring that only attractions with visit counts below or equal to the specified threshold are included.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to select the names of tourist attractions, so we will select the 'Name' column from the Tourist_Attractions table.", "To find attractions with specific features, we will join the Tourist_Attractions table with the Tourist_Attraction_Features table on the Tourist_Attraction_ID.", "Next, we will join the Tourist_Attraction_Features table with the Features table on the Feature_ID to access the feature details.", "We will filter the results using a WHERE clause to include only those attractions that have 'parking' or 'shopping' as their feature details."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT T1.Name \nFROM Tourist_Attractions AS T1 \nJOIN Tourist_Attraction_Features AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID \nJOIN Features AS T3 ON T2.Feature_ID = T3.Feature_ID \nWHERE T3.Feature_Details IN ('parking', 'shopping')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table, ensuring that only attractions with visit counts below or equal to the specified threshold are included.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions with their features.", "Join the resulting table with the Features table to access the feature details.", "Filter the results to include only those attractions that have 'parking' or 'shopping' as their feature details.", "Select the names of the tourist attractions that meet the criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT T1.Name \nFROM Tourist_Attractions AS T1 \nJOIN Tourist_Attraction_Features AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID \nJOIN Features AS T3 ON T2.Feature_ID = T3.Feature_ID \nWHERE T3.Feature_Details IN ('parking', 'shopping')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table, ensuring that only attractions with visit counts below or equal to the specified threshold are included.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5964", "db_id": "cre_Theme_park", "question": "Which tourist attractions do the tourists Vincent and Marcelle visit? Tell me the names of the attractions.", "rationale": ["Identify the relevant tables: Tourist_Attractions, Visits, and Visitors are needed to find the attractions visited by specific tourists.", "Join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID to link attractions with visits.", "Join the resulting table with the Visitors table on Tourist_ID to filter visits by specific tourists.", "Use a WHERE clause to specify the names of the tourists (Vincent and Marcelle) based on their details in the Visitors table.", "Group the results by Tourist_Attraction_ID to ensure unique attraction names are returned."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT T1.Name \nFROM Tourist_Attractions AS T1 \nJOIN Visits AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID \nJOIN Visitors AS T3 ON T2.Tourist_ID = T3.Tourist_ID \nWHERE T3.Tourist_Details IN ('Vincent', 'Marcelle') \nGROUP BY T1.Tourist_Attraction_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6059", "db_id": "customers_and_addresses", "question": "What is the average amount of items ordered in each order?", "rationale": ["To find the average amount of items ordered in each order, we need to calculate the average of the 'order_quantity' from the 'Order_Items' table.", "We will use the AVG() function to compute the average of the 'order_quantity'.", "Since we want the average per order, we will group the results by 'order_id' to ensure we get the average for each individual order."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "pred_sql": "SELECT AVG(order_quantity) AS average_items_ordered FROM Order_Items GROUP BY order_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of product details and their identifiers from the 'Products' table, based on the quantities ordered from the 'Order_Items' table. The results are grouped by product ID and ordered by the total quantity ordered, with a limit specified by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6066", "db_id": "customers_and_addresses", "question": "Find the payment method that is used most frequently.", "rationale": ["Identify the relevant table: The question asks about payment methods, which are stored in the Customers table.", "Count the occurrences of each payment method: We need to count how many times each payment method appears in the Customers table.", "Group the results by payment method: This allows us to aggregate the counts for each unique payment method.", "Order the results by frequency: To find the most frequently used payment method, we will order the results in descending order based on the count.", "Limit the results to one: Since we only want the most frequently used payment method, we will limit the results to one."], "gold_sql": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT payment_method, COUNT(payment_method) AS frequency\nFROM Customers\nGROUP BY payment_method\nORDER BY frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: We need to find the city with the most customers, so we will use the Customer_Addresses and Addresses tables.", "Join the tables: We will join Customer_Addresses with Addresses on the address_id to get the city information for each customer.", "Count distinct customers: We will count the distinct customer_id for each city to avoid counting the same customer multiple times if they have multiple addresses.", "Group by city: We will group the results by city to aggregate the customer counts for each city.", "Order the results: We will order the results in descending order based on the customer count to find the city with the most customers.", "Limit the results: We will limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(DISTINCT customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6098", "db_id": "customers_and_addresses", "question": "Find the contact channel code that was used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the tables involved: Customers and Customer_Contact_Channels.", "Determine the relationship between the tables: Customers is linked to Customer_Contact_Channels via customer_id.", "The goal is to find the contact channel code for a specific customer, so we need to filter by the customer's name.", "Use a JOIN to combine the two tables on customer_id.", "Select the distinct channel_code from the joined tables where the customer_name matches 'Tillman Ernser'."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT DISTINCT channel_code FROM Customers AS t1 JOIN Customer_Contact_Channels AS t2 ON t1.customer_id = t2.customer_id WHERE t1.customer_name = 'Tillman Ernser'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\",\n        \"virtual_table\": \"SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n        \"virtual_table\": \"SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6099", "db_id": "customers_and_addresses", "question": "What is the \"active to date\" of the latest contact channel used by \"Tillman Ernser\"?", "rationale": ["Identify the customer by name 'Tillman Ernser' from the Customers table.", "Join the Customers table with the Customer_Contact_Channels table on customer_id to access the contact channel details.", "Select the 'active_to_date' from the Customer_Contact_Channels table for the identified customer.", "Order the results by 'active_from_date' in descending order to get the latest contact channel used.", "Limit the results to 1 to get only the latest 'active_to_date'."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT t2.active_to_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id = t2.customer_id WHERE t1.customer_name = 'Tillman Ernser' ORDER BY t2.active_from_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n        \"virtual_table\": \"SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\",\n        \"virtual_table\": \"SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "Join the Customers table with the Customer_Contact_Channels table on customer_id to access contact channel information for each customer.", "Filter the results to only include the customer named 'Tillman Ernser'.", "Select the 'active_to_date' from the Customer_Contact_Channels table.", "To get the latest contact channel, order the results by 'active_from_date' in descending order and limit the results to 1."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT t2.active_to_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id = t2.customer_id WHERE t1.customer_name = 'Tillman Ernser' ORDER BY t2.active_from_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n        \"virtual_table\": \"SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\",\n        \"virtual_table\": \"SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["To find the average time span of contact channels, we need to calculate the difference between the activation and deactivation dates of each contact channel.", "The 'Customer_Contact_Channels' table contains the 'active_from_date' and 'active_to_date' columns which are essential for this calculation.", "We can use the `julianday` function to convert these date strings into Julian day numbers, allowing us to compute the difference in days.", "We will join the 'Customers' table to ensure we have access to customer information, although it is not strictly necessary for the average calculation.", "Finally, we will use the `AVG` function to compute the average of these time spans."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(t2.active_to_date) - julianday(t2.active_from_date)) AS average_time_span\nFROM customers AS t1\nJOIN customer_contact_channels AS t2 ON t1.customer_id = t2.customer_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n        \"virtual_table\": \"SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\",\n        \"virtual_table\": \"SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6102", "db_id": "customers_and_addresses", "question": "Compute the average active time span of contact channels.", "rationale": ["To compute the average active time span of contact channels, we need to calculate the difference between the activation date and deactivation date for each contact channel.", "We will use the 'Customer_Contact_Channels' table to get the 'active_from_date' and 'active_to_date'.", "The difference between these two dates can be calculated using the 'julianday' function, which converts the date to a Julian day number, allowing us to subtract the two dates to get the duration in days.", "We will then use the 'AVG' function to compute the average of these durations.", "We need to ensure that we only consider channels that have an 'active_to_date' (i.e., they have been deactivated) to avoid null values affecting our average calculation."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(t2.active_to_date) - julianday(t2.active_from_date)) AS average_active_time_span\nFROM customers AS t1\nJOIN customer_contact_channels AS t2 ON t1.customer_id = t2.customer_id\nWHERE t2.active_to_date IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n        \"virtual_table\": \"SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\",\n        \"virtual_table\": \"SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6104", "db_id": "customers_and_addresses", "question": "Return the channel code and contact number of the customer contact channel whose active duration was the longest.", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the channel code and contact number.", "Determine the criteria for the longest active duration: This can be inferred from the active_from_date and active_to_date fields.", "To find the longest active duration, we can look for the maximum active_to_date or check if the channel is still active (active_to_date IS NULL).", "Construct the SQL query to select channel_code and contact_number based on the criteria established."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT channel_code, contact_number FROM Customer_Contact_Channels WHERE active_to_date IS NULL OR active_to_date = (SELECT MAX(active_to_date) FROM Customer_Contact_Channels)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n        \"virtual_table\": \"SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\",\n        \"virtual_table\": \"SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6105", "db_id": "customers_and_addresses", "question": "Find the name and active date of the customer that use email as the contact channel.", "rationale": ["Identify the tables involved: Customers and Customer_Contact_Channels.", "Determine the columns needed: customer_name from Customers and active_from_date from Customer_Contact_Channels.", "Establish the relationship between the tables using the customer_id foreign key.", "Filter the results to include only those customers who use 'email' as their contact channel."], "gold_sql": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT t1.customer_name, t2.active_from_date FROM Customers AS t1 JOIN Customer_Contact_Channels AS t2 ON t1.customer_id = t2.customer_id WHERE t2.channel_code = 'email'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n        \"virtual_table\": \"SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\",\n        \"virtual_table\": \"SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6127", "db_id": "customers_and_addresses", "question": "Who made the latest order?", "rationale": ["Identify the table that contains order information, which is 'Customer_Orders'.", "To find the latest order, we need to sort the orders by 'order_date' in descending order.", "We will select the 'customer_id' from the 'Customer_Orders' table.", "To get only the latest order, we will limit the results to 1 using 'LIMIT 1'."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT 1", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT customer_id FROM Customer_Orders ORDER BY order_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total quantity of products ordered from the 'Customer_Orders' table, filtered by a specific order status. The placeholder in the WHERE clause represents the order status to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_status  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["Identify the tables involved: We need to retrieve product information, which is in the 'Products' table, and we need to consider the order quantities, which are in the 'Order_Items' table.", "Join the 'Order_Items' table with the 'Products' table on the product_id to access product details along with their order quantities.", "Group the results by product_id to aggregate the order quantities for each product.", "Use the SUM function to calculate the total order quantity for each product.", "Order the results in descending order based on the total order quantity to find the product with the largest quantity ordered.", "Limit the results to 1 to get only the product with the highest total order quantity."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT t2.product_id, t2.product_details FROM Order_Items AS t1 JOIN Products AS t2 ON t1.product_id = t2.product_id GROUP BY t1.product_id ORDER BY SUM(t1.order_quantity) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of product details and their identifiers from the 'Products' table, based on the quantities ordered from the 'Order_Items' table. The results are grouped by product ID and ordered by the total quantity ordered, with a limit specified by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The question asks for addresses, so we will use the 'Addresses' table.", "Determine the filtering criteria: We need to find addresses in two specific cities (East Julianaside and Gleasonmouth) and their corresponding states (Texas and Arizona).", "Construct the WHERE clause: We will use an OR condition to combine the two sets of criteria for the cities and states.", "Formulate the SQL query: We will select all columns from the 'Addresses' table where the conditions in the WHERE clause are met."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "\n"}
{"sample_id": "train.6134", "db_id": "customers_and_addresses", "question": "What are all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The question asks for addresses, so we will use the 'Addresses' table.", "Determine the filtering criteria: We need to filter addresses based on the city and state. The cities are 'East Julianaside' and 'Gleasonmouth', and the states are 'Texas' and 'Arizona'.", "Construct the WHERE clause: We will use an OR condition to include addresses from either of the specified cities and states.", "Formulate the SQL query: We will select all columns from the 'Addresses' table where the conditions in the WHERE clause are met."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "\n"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["Identify the table that contains the competition information, which is the 'match' table.", "Determine the column that holds the competition name, which is 'Competition'.", "Formulate a subquery to find the Competition ID for '1994 FIFA World Cup qualification'.", "Use the result of the subquery to filter the main query to get the Match_ID associated with that competition."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "pred_sql": "SELECT Match_ID FROM match WHERE Competition = (SELECT Competition FROM match WHERE Competition = '1994 FIFA World Cup qualification')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6275", "db_id": "city_record", "question": "Find the city that hosted the most events.", "rationale": ["Identify the relevant tables: 'city' for city names and 'hosting_city' for match hosting information.", "Join the 'city' table with the 'hosting_city' table on the city identifier to link cities with their hosted matches.", "Group the results by the host city to count the number of matches hosted by each city.", "Order the grouped results in descending order based on the count of matches to find the city with the most events.", "Limit the results to 1 to get only the top city that hosted the most events."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN hosting_city AS T2 ON T1.City_ID = T2.Host_City GROUP BY T2.Host_City ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6282", "db_id": "city_record", "question": "Which three cities have the largest regional population?", "rationale": ["Identify the table that contains the relevant data: the 'city' table has the 'Regional_Population' column.", "We need to select the 'City' and 'Regional_Population' columns from the 'city' table.", "To find the cities with the largest populations, we will order the results by 'Regional_Population' in descending order.", "Finally, we limit the results to the top three cities by using 'LIMIT 3'."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "pred_sql": "SELECT City, Regional_Population FROM city ORDER BY Regional_Population DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6283", "db_id": "city_record", "question": "What are the three largest cities in terms of regional population?", "rationale": ["Identify the relevant table: The 'city' table contains the information about cities and their populations.", "Select the columns needed: We need the 'City' name and 'Regional_Population'.", "Order the results: To find the largest cities, we will order the results by 'Regional_Population' in descending order.", "Limit the results: We only want the top three cities, so we will use 'LIMIT 3' to restrict the output."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "pred_sql": "SELECT City, Regional_Population FROM city ORDER BY Regional_Population DESC LIMIT 3", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that have a March average temperature lower than July or higher than October. The query joins the 'city' table with the 'temperature' table based on the city identifier, allowing for the comparison of temperature data across different months.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct\"\n    }\n}\n"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables: 'city' for city names and 'temperature' for temperature data.", "Join the 'city' table with the 'temperature' table on the City_ID to access both city names and their February temperatures.", "Order the results by the February temperature in descending order to get the highest temperature at the top.", "Limit the results to 1 to retrieve only the city with the highest temperature in February."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID ORDER BY T2.Feb DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that have a March average temperature lower than July or higher than October. The query joins the 'city' table with the 'temperature' table based on the city identifier, allowing for the comparison of temperature data across different months.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: 'city' for city names and 'temperature' for temperature data.", "Join the 'city' table with the 'temperature' table using the City_ID to access temperature data for each city.", "Formulate the condition to filter cities: March temperature (T2.Mar) should be less than July temperature (T2.Jul) or greater than October temperature (T2.Oct).", "Select the city names that meet the specified temperature conditions."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID WHERE T2.Mar < T2.Jul OR T2.Mar > T2.Oct", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that have a March average temperature lower than July or higher than October. The query joins the 'city' table with the 'temperature' table based on the city identifier, allowing for the comparison of temperature data across different months.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6290", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in July and which have also served as host cities?", "rationale": ["Identify the relevant tables: 'city', 'temperature', and 'hosting_city'.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data.", "Join the resulting table with the 'hosting_city' table on 'City_ID' to filter for cities that have hosted matches.", "Apply the condition to filter cities where the average temperature in March is lower than in July.", "Select the city names from the final joined table."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID JOIN hosting_city AS T3 ON T1.City_ID = T3.Host_City WHERE T2.Mar < T2.Jul;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that have a March average temperature lower than July or higher than October. The query joins the 'city' table with the 'temperature' table based on the city identifier, allowing for the comparison of temperature data across different months.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the cities from the 'city' table that have a March average temperature lower than December.", "Join the 'city' table with the 'temperature' table using the City_ID to access temperature data.", "Use a WHERE clause to filter cities where the March temperature is less than the December temperature.", "Additionally, ensure that these cities have never served as host cities by using a subquery that selects all Host_City from the 'hosting_city' table and excluding them from the main query."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID WHERE T2.Mar < T2.Dec AND T1.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that have a March average temperature lower than July or higher than October. The query joins the 'city' table with the 'temperature' table based on the city identifier, allowing for the comparison of temperature data across different months.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6295", "db_id": "city_record", "question": "Which cities have higher temperature in Feb than in Jun or have once served as host cities?", "rationale": ["Identify the cities from the 'city' table that have temperature data in the 'temperature' table.", "Join the 'city' table with the 'temperature' table on the City_ID to access temperature data.", "Use a WHERE clause to filter cities where the average temperature in February (T2.Feb) is greater than the average temperature in June (T2.Jun).", "Additionally, check if the city has ever hosted a match by using a subquery that selects Host_City from the 'hosting_city' table.", "Use DISTINCT to ensure that each city is listed only once in the final result."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT DISTINCT T1.City \nFROM city AS T1 \nJOIN temperature AS T2 ON T1.City_ID = T2.City_ID \nWHERE T2.Feb > T2.Jun \n   OR T1.City_ID IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that have a March average temperature lower than July or higher than October. The query joins the 'city' table with the 'temperature' table based on the city identifier, allowing for the comparison of temperature data across different months.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6324", "db_id": "e_government", "question": "Find the last name of the first ever contact person of the organization with the highest UK Vat number.", "rationale": ["Identify the organization with the highest UK VAT number by using a subquery to select the maximum value from the Organizations table.", "Join the Organization_Contact_Individuals table with the Individuals table to get the contact person's last name.", "Join the Organization_Contact_Individuals table with the Organizations table to filter by the organization with the highest UK VAT number.", "Order the results by the date of contact to find the first contact person.", "Limit the results to 1 to get only the first contact person's last name."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.uk_vat_number  =  (SELECT max(uk_vat_number) FROM organizations) ORDER BY t2.date_contact_to ASC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "pred_sql": "SELECT i.individual_last_name\nFROM Organization_Contact_Individuals oci\nJOIN Individuals i ON oci.individual_id = i.individual_id\nJOIN Organizations org ON oci.organization_id = org.organization_id\nWHERE org.uk_vat_number = (SELECT MAX(uk_vat_number) FROM Organizations)\nORDER BY oci.date_contact_from ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6328", "db_id": "e_government", "question": "Find name of the services that has never been used.", "rationale": ["Identify the main table to query from, which is the 'Services' table to get the service names.", "Determine the condition for services that have never been used, which means they should not appear in the 'Party_Services' table.", "Use the EXCEPT clause to filter out service names that are present in the 'Party_Services' table, indicating those services have been booked.", "Construct the SQL query to select service names from 'Services' and exclude those that are linked to any entries in 'Party_Services'."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "pred_sql": "SELECT service_name FROM Services EXCEPT SELECT t1.service_name FROM Services AS t1 JOIN Party_Services AS t2 ON t1.service_id = t2.service_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of services from the 'Services' table that have not been booked by any party. The query uses an EXCEPT clause to exclude service names that are present in the 'Party_Services' table, indicating that those services have been booked. The placeholder in the query represents the service names that are being filtered out based on their booking status.\",\n        \"virtual_table\": \"SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id\"\n    }\n}\n"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table: The question asks for cities and states, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' for cities and 'state_province_county' for states.", "Use DISTINCT to avoid duplicate entries: Since we want the names of all cities and states, using DISTINCT will ensure that we only get unique combinations.", "Construct the SQL query: Combine the selected columns and the table name into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6331", "db_id": "e_government", "question": "What are the names of all cities and states?", "rationale": ["Identify the relevant table: The question asks for city and state names, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' and 'state_province_county' from the Addresses table.", "Use DISTINCT to avoid duplicate entries: Since cities and states may repeat, we use DISTINCT to get unique combinations.", "Construct the SQL query: Combine the selected columns and table into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the relevant tables: We need to find individuals who are contact individuals for organizations, so we will use the 'Organization_Contact_Individuals' and 'Individuals' tables.", "Determine the relationship: The 'Organization_Contact_Individuals' table has a foreign key 'individual_id' that links to the 'Individuals' table.", "Select the required field: We need the last names of the individuals, which is in the 'Individuals' table under the column 'individual_last_name'.", "Construct the SQL query: We will use a JOIN to connect the two tables on the 'individual_id' and select the 'individual_last_name' from the 'Individuals' table."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "pred_sql": "SELECT Individuals.individual_last_name \nFROM Organization_Contact_Individuals \nJOIN Individuals ON Organization_Contact_Individuals.individual_id = Individuals.individual_id;", "hint": "\n"}
{"sample_id": "train.6723", "db_id": "activity_1", "question": "Show the first name, last name, and phone number for all female faculty members.", "rationale": ["Identify the relevant table: The Faculty table contains the information about faculty members, including their first name, last name, phone number, and gender.", "Select the required columns: We need to retrieve the first name (Fname), last name (Lname), and phone number (Phone) of the faculty members.", "Filter the results: We need to include only female faculty members, which can be done by adding a WHERE clause that checks if the Sex column is equal to 'Female'.", "Construct the SQL query: Combine the selected columns and the filter condition into a complete SQL query."], "gold_sql": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'", "source_tables": ["faculty"], "pred_sql": "SELECT F.Fname, F.Lname, F.Phone FROM Faculty AS F WHERE F.Sex = 'Female';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    }\n}\n"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the table that contains faculty information, which is the 'Faculty' table.", "Determine the column that indicates the gender of faculty members, which is 'Sex'.", "Formulate a query to select the unique identifiers (FacID) of faculty members where the 'Sex' column is equal to 'Male'."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "pred_sql": "SELECT FacID FROM Faculty WHERE Sex = 'Male'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique identifiers of students who are advised by faculty members of a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6738", "db_id": "activity_1", "question": "Find the building that has the largest number of faculty members.", "rationale": ["To find the building with the largest number of faculty members, we need to count the number of faculty members in each building.", "We will use the 'Faculty' table, which contains the 'Building' column and the unique identifier for each faculty member.", "We will group the results by 'Building' to get the count of faculty members in each building.", "We will order the results in descending order based on the count of faculty members to get the building with the most faculty members at the top.", "Finally, we will limit the results to 1 to get only the building with the largest number of faculty members."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(*) AS FacultyCount \nFROM Faculty \nGROUP BY Building \nORDER BY FacultyCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n        \"virtual_table\": \"SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier, and the count reflects the number of students associated with each advisor.\",\n        \"virtual_table\": \"SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID\"\n    }\n}\n"}
{"sample_id": "train.6740", "db_id": "activity_1", "question": "In which buildings are there at least ten professors?", "rationale": ["Identify the relevant table: Faculty, which contains information about faculty members including their building.", "We need to find buildings with at least ten professors, so we will group the results by the 'Building' column.", "Use the COUNT function to count the number of faculty members (FacID) in each building.", "Apply the HAVING clause to filter groups that have a count of at least 10."], "gold_sql": "SELECT building FROM Faculty WHERE rank  =  'Professor' GROUP BY building HAVING count(*)  >=  10", "source_tables": ["faculty"], "pred_sql": "SELECT Building\nFROM Faculty\nGROUP BY Building\nHAVING COUNT(FacID) >= 10;", "hint": "\n"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their rank and sex.", "Filter for assistant professors: We need to focus on faculty members with the rank of 'Assistant Professor'.", "Group by sex: To get the count of male and female assistant professors, we will group the results by the 'Sex' column.", "Count the number of professors: We will use the COUNT() function to count the number of faculty members in each sex group."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) AS NumberOfProfessors \nFROM Faculty \nWHERE Rank = 'Assistant Professor' \nGROUP BY Sex;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty advisors. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students for each rank.\",\n        \"virtual_table\": \"SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n        \"virtual_table\": \"SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier, and the count reflects the number of students associated with each advisor.\",\n        \"virtual_table\": \"SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID\"\n    }\n}\n"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the tables needed: Faculty and Student.", "We need to find the advisor of a specific student, Linda Smith, so we will join the Faculty table with the Student table on the advisor relationship.", "Filter the results to only include the student with the first name 'Linda' and last name 'Smith'.", "Select the first name and last name of the faculty member who is the advisor of Linda Smith."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT F.Fname, F.Lname FROM Faculty AS F JOIN Student AS S ON F.FacID = S.Advisor WHERE S.Fname = 'Linda' AND S.Lname = 'Smith';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier, and the count reflects the number of students associated with each advisor.\",\n        \"virtual_table\": \"SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies faculty members who serve as advisors to students. It retrieves the unique identifiers of faculty members from the 'Faculty' table, joining it with the 'Student' table based on the advisor relationship. The results are grouped by faculty ID, and only those faculty members who have advised a specified number of students are included, as indicated by the placeholder in the HAVING clause.\",\n        \"virtual_table\": \"SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique identifiers of students who are advised by faculty members of a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["We need to find the IDs of students whose advisors are professors.", "The 'Student' table contains the student IDs and their advisor IDs.", "The 'Faculty' table contains the faculty IDs.", "We can join the 'Student' table with the 'Faculty' table based on the advisor relationship.", "We will select the student IDs from the 'Student' table where the advisor is in the list of faculty IDs."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT T2.StuID FROM Student AS T2 WHERE T2.Advisor IN (SELECT T1.FacID FROM Faculty AS T1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier, and the count reflects the number of students associated with each advisor.\",\n        \"virtual_table\": \"SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n        \"virtual_table\": \"SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies faculty members who serve as advisors to students. It retrieves the unique identifiers of faculty members from the 'Faculty' table, joining it with the 'Student' table based on the advisor relationship. The results are grouped by faculty ID, and only those faculty members who have advised a specified number of students are included, as indicated by the placeholder in the HAVING clause.\",\n        \"virtual_table\": \"SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the tables needed: We need to retrieve student names and their advisors, so we will use the Student and Faculty tables.", "Determine the join condition: We will join the Student table with the Faculty table on the advisor field (Student.advisor = Faculty.FacID).", "Specify the columns to select: We need the first name (Fname) and last name (LName) of the students.", "Add the filtering condition: We need to filter the results to only include students advised by Michael Goodrich, so we will add a WHERE clause to check for the first name and last name of the faculty member."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT T1.Fname, T1.LName \nFROM Student AS T1 \nJOIN Faculty AS T2 ON T1.advisor = T2.FacID \nWHERE T2.Fname = 'Michael' AND T2.LName = 'Goodrich';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique identifiers of students who are advised by faculty members of a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6759", "db_id": "activity_1", "question": "What are the first and last name of the faculty who has the most students?", "rationale": ["We need to find the faculty member with the most students participating in activities.", "First, we will join the Faculty table with the Faculty_Participates_in table to link faculty members with their activities.", "Next, we will join the result with the Participates_in table to link those activities with the students participating in them.", "We will group the results by the faculty member's unique identifier (FacID) to count the number of students associated with each faculty member.", "Finally, we will order the results by the count of students in descending order and limit the result to 1 to get the faculty member with the most students."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty", "student"], "pred_sql": "SELECT F.fname, F.lname\nFROM Faculty AS F\nJOIN Faculty_Participates_in AS FP ON F.FacID = FP.FacID\nJOIN Participates_in AS P ON FP.actid = P.actid\nGROUP BY F.FacID\nORDER BY COUNT(P.stuid) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n        \"virtual_table\": \"SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank\"\n    }\n}\n"}
{"sample_id": "train.6765", "db_id": "activity_1", "question": "What activities do we have?", "rationale": ["The question asks for a list of activities, which corresponds to the 'Activity' table in the database.", "To retrieve all activities, we need to select all columns from the 'Activity' table.", "The SQL query to achieve this is 'SELECT * FROM Activity;'"], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "pred_sql": "SELECT * FROM Activity;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities being compared.\",\n        \"virtual_table\": \"SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6766", "db_id": "activity_1", "question": "List all the activities we have.", "rationale": ["The user wants to list all activities, which means we need to retrieve all records from the 'Activity' table.", "To get all activities, we can use a simple SELECT statement that selects all columns from the 'Activity' table.", "The SQL query will be: SELECT * FROM Activity;"], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "pred_sql": "SELECT * FROM Activity;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities being compared.\",\n        \"virtual_table\": \"SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6780", "db_id": "activity_1", "question": "What is the first and last name of the faculty members who participated in at least one activity? For each of them, also show the number of activities they participated in.", "rationale": ["Identify the relevant tables: Faculty and Faculty_Participates_in.", "We need to retrieve the first name and last name of faculty members, so we select T1.Fname and T1.Lname from the Faculty table.", "To count the number of activities each faculty member participated in, we use COUNT(*) and alias it as activity_count.", "Join the Faculty table (T1) with the Faculty_Participates_in table (T2) on the FacID to link faculty members with their activities.", "Group the results by T1.FacID to ensure we get a count of activities for each faculty member."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT T1.Fname, T1.Lname, COUNT(*) AS activity_count \nFROM Faculty AS T1 \nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID \nGROUP BY T1.FacID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities being compared.\",\n        \"virtual_table\": \"SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6781", "db_id": "activity_1", "question": "Show all the activity names and the number of faculty involved in each activity.", "rationale": ["Identify the tables needed: We need the 'Activity' table for activity names and the 'Faculty_Participates_in' table to count faculty participation.", "Join the 'Activity' table with the 'Faculty_Participates_in' table on the activity ID ('actid') to link activities with faculty participation.", "Use a LEFT JOIN to ensure we include all activities, even those with no faculty participation.", "Group the results by 'activity_name' to count the number of faculty members involved in each activity.", "Select the 'activity_name' and the count of faculty members (using COUNT function) as 'faculty_count'."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "pred_sql": "SELECT A.activity_name, COUNT(FP.FacID) AS faculty_count \nFROM Activity AS A \nLEFT JOIN Faculty_Participates_in AS FP ON A.actid = FP.actid \nGROUP BY A.activity_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n        \"virtual_table\": \"SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank\"\n    }\n}\n"}
{"sample_id": "train.6782", "db_id": "activity_1", "question": "How many faculty members participate in each activity? Return the activity names and the number of faculty members.", "rationale": ["Identify the tables needed: We need the 'Activity' table for activity names and the 'Faculty_Participates_in' table to count faculty participation.", "Join the 'Activity' table with the 'Faculty_Participates_in' table on the activity identifier (actid) to link activities with their participating faculty members.", "Use a LEFT JOIN to ensure that we include all activities, even those with no faculty participation.", "Group the results by activity name to count the number of faculty members participating in each activity.", "Select the activity name and the count of faculty members as the final output."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "pred_sql": "SELECT A.activity_name, COUNT(FP.FacID) AS faculty_count \nFROM Activity AS A \nLEFT JOIN Faculty_Participates_in AS FP ON A.actid = FP.actid \nGROUP BY A.activity_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier, and the count reflects the number of students associated with each advisor.\",\n        \"virtual_table\": \"SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID\"\n    }\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: We need to find students who participate in activities, so we will use the 'Participates_in' and 'Student' tables.", "Determine the columns needed: We need the 'stuid' from the 'Participates_in' table and the 'Age' from the 'Student' table.", "Establish the relationship: We will join the 'Participates_in' table with the 'Student' table on the 'stuid' column.", "Add the condition: We need to filter the results to include only those students who are under 20 years old, which means we will add a WHERE clause to check if 'Age' is less than 20."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT stuid FROM Participates_in JOIN Student ON Participates_in.stuid = Student.StuID WHERE Student.Age < 20;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities being compared.\",\n        \"virtual_table\": \"SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6795", "db_id": "activity_1", "question": "Find the first names of the faculty members who are playing Canoeing or Kayaking.", "rationale": ["Identify the tables needed: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members, so we will select from the Faculty table.", "To find out which activities the faculty members are participating in, we will join the Faculty table with the Faculty_Participates_in table on the FacID.", "Next, we need to join the result with the Activity table to filter by activity names.", "We will filter the activities to include only 'Canoeing' or 'Kayaking' using the WHERE clause with the IN operator.", "Finally, we will select the first names of the faculty members who meet these criteria."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty AS F \nJOIN Faculty_Participates_in AS FPI ON F.FacID = FPI.FacID \nJOIN Activity AS A ON FPI.actid = A.actid \nWHERE A.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6796", "db_id": "activity_1", "question": "Which faculty members are playing either Canoeing or Kayaking? Tell me their first names.", "rationale": ["Identify the relevant tables: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members who participate in specific activities (Canoeing or Kayaking).", "Join the Faculty table with the Faculty_Participates_in table on FacID to link faculty members with their activities.", "Join the result with the Activity table on actid to access the activity names.", "Filter the results to include only those activities that are either 'Canoeing' or 'Kayaking'.", "Select the first names of the faculty members from the filtered results."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty AS F \nJOIN Faculty_Participates_in AS FPI ON F.FacID = FPI.FacID \nJOIN Activity AS A ON FPI.actid = A.actid \nWHERE A.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique identifiers of students who are advised by faculty members of a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the relevant tables: Faculty, Faculty_Participates_in, and Activity.", "We need to select the first names of faculty members, so we will select F.Fname from the Faculty table.", "We need to check the activities they participate in, so we will join the Faculty table with the Faculty_Participates_in table on FacID.", "Next, we will join the result with the Activity table on actid to get the activity names.", "We want faculty members who do not participate in 'Canoeing' or 'Kayaking', so we will use a WHERE clause to filter out these activities.", "To ensure we include faculty members who may not participate in any activities, we will use a LEFT JOIN and check for NULL values in the activity name.", "Finally, we will group the results by F.FacID to avoid duplicates."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty AS F \nLEFT JOIN Faculty_Participates_in AS FPI ON F.FacID = FPI.FacID \nLEFT JOIN Activity AS A ON FPI.actid = A.actid \nWHERE A.activity_name NOT IN ('Canoeing', 'Kayaking') OR A.activity_name IS NULL \nGROUP BY F.FacID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the activities of interest: Canoeing and Kayaking.", "Use the 'Participates_in' table to find students participating in these activities.", "Join the 'Participates_in' table with the 'Activity' table to filter by activity names.", "Use the INTERSECT operator to find students who participate in both activities."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT T1.stuid FROM Participates_in AS T1 JOIN Activity AS T2 ON T1.actid = T2.actid WHERE T2.activity_name = 'Canoeing' INTERSECT SELECT T1.stuid FROM Participates_in AS T1 JOIN Activity AS T2 ON T1.actid = T2.actid WHERE T2.activity_name = 'Kayaking'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities being compared.\",\n        \"virtual_table\": \"SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant tables: 'car_names' for car models and 'cars_data' for horsepower.", "Join the 'car_names' table with the 'cars_data' table on the MakeId to access horsepower data for each model.", "Order the results by horsepower in ascending order to find the model with the minimum horsepower.", "Limit the results to 1 to get only the model with the minimum horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id ORDER BY T2.Horsepower ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of car makes and their identifiers from the 'car_names' table, specifically for cars that have a horsepower greater than the minimum horsepower recorded in the 'cars_data' table and have a cylinder count less than a specified number. The placeholder in the WHERE clause represents the maximum number of cylinders allowed.\",\n        \"virtual_table\": \"select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.97", "db_id": "car_1", "question": "Find the model of the car whose weight is below the average weight.", "rationale": ["Identify the relevant tables: 'car_names' for car models and 'cars_data' for car specifications including weight.", "Join 'car_names' and 'cars_data' on the 'MakeId' and 'Id' columns respectively to access both car models and their weights.", "Use a subquery to calculate the average weight of all cars in the 'cars_data' table.", "Filter the results to include only those car models where the weight is less than the average weight calculated in the subquery."], "gold_sql": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT t1.Model \nFROM car_names AS t1 \nJOIN cars_data AS t2 ON t1.MakeId = t2.Id \nWHERE t2.Weight < (SELECT AVG(Weight) FROM cars_data);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their fuel efficiency (MPG) in descending order. The placeholder in the LIMIT clause represents the maximum number of car models to return.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car models.", "Join the 'cars_data' table with the 'car_names' table on the 'Id' and 'MakeId' columns to link car specifications with their respective models.", "Filter the results to find the specific model 'amc hornet sportabout (sw)'.", "Select the 'Accelerate' column from the 'cars_data' table to get the acceleration time for the specified car model."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT T1.Accelerate FROM cars_data AS T1 JOIN car_names AS T2 ON T1.Id = T2.MakeId WHERE T2.Model = 'amc hornet sportabout (sw)';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for car models from the 'cars_data' table, specifically for a given model name. The query joins the 'cars_data' table with the 'car_names' table to filter results based on the specified model. The results are ordered by the acceleration time in ascending order, and a limit is applied to restrict the number of returned records.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of cylinders for car models from the 'cars_data' table, specifically for a given model name. The query joins the 'cars_data' table with the 'car_names' table to filter results based on the specified model. The results are ordered by the acceleration time in ascending order, and a limit is applied to restrict the number of returned records.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.112", "db_id": "car_1", "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: 'cars_data' for acceleration data and 'car_names' for car model names.", "Join the 'cars_data' table with the 'car_names' table on the 'MakeId' to link car models with their acceleration data.", "Filter the results to only include the model 'hornet sportabout'.", "Order the results by the acceleration time in ascending order to find the fastest acceleration.", "Limit the results to 1 to get the specific acceleration time for the AMC Hornet Sportabout."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT T1.accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id = T2.MakeId WHERE T2.Model = 'hornet sportabout' ORDER BY T1.accelerate ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the number of cylinders for car models from the 'cars_data' table, specifically for a given model name. The query joins the 'cars_data' table with the 'car_names' table to filter results based on the specified model. The results are ordered by the acceleration time in ascending order, and a limit is applied to restrict the number of returned records.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the relevant tables: 'car_makers' and 'countries'.", "Determine the relationship between the tables: 'car_makers' is linked to 'countries' through the 'Country' identifier.", "Use a JOIN to combine 'car_makers' and 'countries' on the 'Country' field.", "Filter the results to only include car makers based in France by specifying the condition in the WHERE clause.", "Count the number of records that meet the criteria using count(*)."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT count(*) FROM car_makers AS T1 JOIN countries AS T2 ON T1.Country = T2.CountryId WHERE T2.CountryName = 'France';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of car makers based in a specific country. It joins the 'car_makers' table with the 'countries' table using the country identifier, and filters the results based on the specified country name.\",\n        \"virtual_table\": \"SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of car makers grouped by their respective countries from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents a numeric threshold for the minimum number of car makers that must be associated with a country.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.121", "db_id": "car_1", "question": "What are all the makers and models?", "rationale": ["Identify the tables needed to get the makers and models: 'car_makers' for makers and 'car_names' for models.", "Establish the relationship between the tables: 'car_makers' is linked to 'model_list' through 'Maker', and 'model_list' is linked to 'car_names' through 'Model'.", "Construct the SQL query to select the Maker from 'car_makers' and Model from 'car_names' using JOINs to connect the tables based on their relationships."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "pred_sql": "SELECT car_makers.Maker, car_names.Model \nFROM car_makers \nJOIN model_list ON car_makers.Id = model_list.Maker \nJOIN car_names ON model_list.Model = car_names.Model;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n        \"virtual_table\": \"SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the relevant tables: countries and car_makers.", "We need to find countries in Europe, so we will filter by the continent.", "Join the countries table with the car_makers table on the country identifier.", "Group the results by country to count the number of car manufacturers per country.", "Use the HAVING clause to filter countries that have at least 3 car manufacturers.", "Additionally, ensure that the countries belong to Europe by checking the continent in the WHERE clause."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName FROM countries AS c JOIN car_makers AS m ON c.CountryId = m.Country GROUP BY c.CountryId HAVING COUNT(m.Id) >= 3 AND c.Continent = (SELECT ContId FROM continents WHERE Continent = 'Europe');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of car makers grouped by their respective countries from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents a numeric threshold for the minimum number of car makers that must be associated with a country.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of car makers based in a specific country. It joins the 'car_makers' table with the 'countries' table using the country identifier, and filters the results based on the specified country name.\",\n        \"virtual_table\": \"SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.130", "db_id": "car_1", "question": "What are the names of all European countries with at least 3 manufacturers?", "rationale": ["Identify the relevant tables: countries and car_makers.", "We need to filter countries that are in Europe, so we will join the countries table with the continents table to get the ContId for Europe.", "Join the car_makers table to the countries table to count the number of manufacturers per country.", "Group the results by country to aggregate the count of manufacturers.", "Use the HAVING clause to filter countries that have at least 3 manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName \nFROM countries AS c \nJOIN car_makers AS cm ON c.CountryId = cm.Country \nWHERE c.Continent = (SELECT ContId FROM continents WHERE Continent = 'Europe') \nGROUP BY c.CountryId \nHAVING COUNT(cm.Id) >= 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of car makers based in a specific country. It joins the 'car_makers' table with the 'countries' table using the country identifier, and filters the results based on the specified country name.\",\n        \"virtual_table\": \"SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of car makers grouped by their respective countries from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents a numeric threshold for the minimum number of car makers that must be associated with a country.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the relevant tables: 'cars_data' for horsepower and cylinders, and 'car_names' for the make of the car.", "We need to find the maximum horsepower for car models with 3 cylinders, so we will use the MAX() function on the horsepower column.", "Join the 'cars_data' table with the 'car_names' table on the MakeId to get the make of the car.", "Filter the results where the number of cylinders is equal to 3.", "Select the maximum horsepower and the corresponding make of the car."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(T2.Horsepower) AS MaxHorsepower, T1.Make \nFROM cars_data AS T2 \nJOIN car_names AS T1 ON T2.Id = T1.MakeId \nWHERE T2.Cylinders = 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of car makes and their identifiers from the 'car_names' table, specifically for cars that have a horsepower greater than the minimum horsepower recorded in the 'cars_data' table and have a cylinder count less than a specified number. The placeholder in the WHERE clause represents the maximum number of cylinders allowed.\",\n        \"virtual_table\": \"select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of car models from the 'car_names' table that have a specific number of cylinders. The results are filtered based on the cylinder count in the 'cars_data' table, and the output is ordered by horsepower in descending order. The placeholders in the query represent the number of cylinders and the limit for the number of results to return.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.141", "db_id": "car_1", "question": "Which model has the most version(make) of cars?", "rationale": ["Identify the relevant tables: We need to find car models and their corresponding makes, which are in the 'car_names' table.", "Count the number of makes for each model: We will use the COUNT function to count how many makes correspond to each model.", "Group the results by model: This allows us to aggregate the counts for each unique model.", "Order the results by the count of makes in descending order: This will help us find the model with the most versions.", "Limit the results to 1: We only need the model with the highest count of makes."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "pred_sql": "SELECT Model, COUNT(Make) AS VersionCount FROM car_names GROUP BY Model ORDER BY VersionCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n        \"virtual_table\": \"SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.142", "db_id": "car_1", "question": "What model has the most different versions?", "rationale": ["The question asks for the model with the most different versions, which implies we need to count the occurrences of each model in the 'car_names' table.", "To achieve this, we will use the COUNT() function to count how many times each model appears.", "We will group the results by the 'Model' column to get the count for each model.", "Next, we will order the results in descending order based on the count of versions (i.e., how many times each model appears).", "Finally, we will limit the results to 1 to get only the model with the highest count."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "pred_sql": "SELECT Model, COUNT(*) as VersionCount FROM car_names GROUP BY Model ORDER BY VersionCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their fuel efficiency (MPG) in descending order. The placeholder in the LIMIT clause represents the maximum number of car models to return.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n        \"virtual_table\": \"SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);\"\n    }\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["Identify the relevant tables: We need to get information from the 'car_makers' and 'model_list' tables.", "We need the names and ids of car makers, which are in the 'car_makers' table.", "To find out how many models each maker has, we will join 'car_makers' with 'model_list' on the maker's ID.", "We will group the results by the maker's ID and name to count the number of models for each maker.", "Finally, we will filter the results to include only those makers that have more than 3 models using the HAVING clause."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker \nFROM car_makers AS cm \nJOIN model_list AS ml ON cm.Id = ml.Maker \nGROUP BY cm.Id, cm.Maker \nHAVING COUNT(ml.ModelId) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of car makes and their identifiers from the 'car_names' table, specifically for cars that have a horsepower greater than the minimum horsepower recorded in the 'cars_data' table and have a cylinder count less than a specified number. The placeholder in the WHERE clause represents the maximum number of cylinders allowed.\",\n        \"virtual_table\": \"select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.161", "db_id": "car_1", "question": "How many countries has more than 2 car makers ?", "rationale": ["Identify the tables involved: 'countries' and 'car_makers'.", "We need to count the number of car makers for each country, so we will join these two tables on the country identifier.", "Group the results by country to get the count of car makers per country.", "Use the HAVING clause to filter the results to only include countries with more than 2 car makers."], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "source_tables": ["car_makers", "countries"], "pred_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.CountryId = t2.Country group by t1.CountryId having count(*) > 2", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of car makers grouped by their respective countries from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents a numeric threshold for the minimum number of car makers that must be associated with a country.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of car makers based in a specific country. It joins the 'car_makers' table with the 'countries' table using the country identifier, and filters the results based on the specified country name.\",\n        \"virtual_table\": \"SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables: 'car_names' for car models and 'cars_data' for car specifications.", "We need to filter the cars based on the number of cylinders, which is specified as 4 in the query.", "Join the 'car_names' table with the 'cars_data' table on the MakeId to access both the model names and their horsepower.", "Order the results by horsepower in descending order to get the model with the largest horsepower at the top.", "Limit the results to 1 to get only the top model with the largest horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id WHERE T2.Cylinders = 4 ORDER BY T2.Horsepower DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of car models from the 'car_names' table that have a specific number of cylinders. The results are filtered based on the cylinder count in the 'cars_data' table, and the output is ordered by horsepower in descending order. The placeholders in the query represent the number of cylinders and the limit for the number of results to return.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of car makes and their identifiers from the 'car_names' table, specifically for cars that have a horsepower greater than the minimum horsepower recorded in the 'cars_data' table and have a cylinder count less than a specified number. The placeholder in the WHERE clause represents the maximum number of cylinders allowed.\",\n        \"virtual_table\": \"select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.171", "db_id": "car_1", "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?", "rationale": ["Identify the relevant tables: car_names, cars_data, model_list, and car_makers are needed to get the car models, their weights, and to filter out those made by 'Ford Motor Company'.", "Join the car_names table with cars_data on MakeId to access the weight of each car model.", "Join the model_list table to link car models to their respective car makers.", "Join the car_makers table to filter out the models made by 'Ford Motor Company'.", "Use a WHERE clause to specify the conditions: weight less than 3500 and not made by 'Ford Motor Company'.", "Select the Model from the car_names table that meets the criteria."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';", "source_tables": ["car_makers", "model_list", "car_names", "cars_data"], "pred_sql": "SELECT cn.Model \nFROM car_names AS cn \nJOIN cars_data AS cd ON cn.MakeId = cd.Id \nJOIN model_list AS ml ON cn.Model = ml.Model \nJOIN car_makers AS cm ON ml.Maker = cm.Id \nWHERE cd.Weight < 3500 \nAND cm.FullName != 'Ford Motor Company';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their fuel efficiency (MPG) in descending order. The placeholder in the LIMIT clause represents the maximum number of car models to return.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.175", "db_id": "car_1", "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .", "rationale": ["Identify the relevant tables: We need to work with the 'car_makers' and 'model_list' tables to find car makers and their models.", "Join the 'car_makers' table with the 'model_list' table on the Maker ID to associate each car maker with their respective models.", "Group the results by car maker ID and name to aggregate the number of models each maker produces.", "Use the HAVING clause to filter for car makers that produce at least 2 models.", "Additionally, ensure that the count of distinct car makers is greater than 3, which implies we are looking for a minimum of 4 car makers in total."], "gold_sql": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker \nFROM car_makers AS cm \nJOIN model_list AS ml ON cm.Id = ml.Maker \nGROUP BY cm.Id, cm.Maker \nHAVING COUNT(ml.ModelId) >= 2 \nAND COUNT(DISTINCT cm.Id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of car makes and their identifiers from the 'car_names' table, specifically for cars that have a horsepower greater than the minimum horsepower recorded in the 'cars_data' table and have a cylinder count less than a specified number. The placeholder in the WHERE clause represents the maximum number of cylinders allowed.\",\n        \"virtual_table\": \"select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["Identify the relevant tables: car_makers, model_list, car_names, and cars_data.", "Join the car_makers table with model_list to get the models produced by each maker.", "Join the model_list with car_names to link the models to their respective makes.", "Join car_names with cars_data to count the number of cars produced for each make.", "Group the results by car maker's ID and name to aggregate the counts.", "Use HAVING clause to filter for makers that produce at least 2 distinct models and have more than 3 cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker \nFROM car_makers AS cm \nJOIN model_list AS ml ON cm.Id = ml.Maker \nJOIN car_names AS cn ON ml.Model = cn.Model \nJOIN cars_data AS cd ON cn.MakeId = cd.Id \nGROUP BY cm.Id, cm.Maker \nHAVING COUNT(DISTINCT ml.Model) >= 2 AND COUNT(cd.Id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of car makes and their identifiers from the 'car_names' table, specifically for cars that have a horsepower greater than the minimum horsepower recorded in the 'cars_data' table and have a cylinder count less than a specified number. The placeholder in the WHERE clause represents the maximum number of cylinders allowed.\",\n        \"virtual_table\": \"select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n        \"virtual_table\": \"SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);\"\n    }\n}\n"}
{"sample_id": "dev.526", "db_id": "student_transcripts_tracking", "question": "What are the names and ids of every course with less than 2 sections?", "rationale": ["Identify the relevant tables: Courses and Sections.", "We need to find courses with less than 2 sections, so we will join the Courses table with the Sections table on the course_id.", "Use a LEFT JOIN to ensure we include courses that may not have any sections.", "Group the results by course_id to aggregate the sections for each course.", "Use the HAVING clause to filter the grouped results to only include courses with a count of sections less than 2."], "gold_sql": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2", "source_tables": ["courses", "sections"], "pred_sql": "SELECT Courses.course_id, Courses.course_name \nFROM Courses \nLEFT JOIN Sections ON Courses.course_id = Sections.course_id \nGROUP BY Courses.course_id \nHAVING COUNT(Sections.section_id) < 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first name, middle name, last name, and student ID of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.534", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?", "rationale": ["Identify the relevant tables: Students and Student_Enrolment are needed to get student details and their enrolment information.", "Use a subquery to find semesters where students are enrolled in two different degree programs. This involves using the INTERSECT operator to find common semesters for two degree programs.", "Join the Students table with the Student_Enrolment table to get the names and IDs of students who are enrolled in the semesters identified in the previous step.", "Group the results by student ID and use HAVING to filter for students who are enrolled in exactly two degree programs."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT S.student_id, S.first_name, S.middle_name, S.last_name \nFROM Students AS S \nJOIN Student_Enrolment AS SE ON S.student_id = SE.student_id \nWHERE SE.semester_id IN (\n    SELECT semester_id \n    FROM (\n        SELECT T2.semester_id \n        FROM Degree_Programs AS T1 \n        JOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id \n        WHERE T1.degree_summary_name = 'Degree Program 1' \n        INTERSECT \n        SELECT T2.semester_id \n        FROM Degree_Programs AS T1 \n        JOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id \n        WHERE T1.degree_summary_name = 'Degree Program 2'\n    ) \n) \nGROUP BY S.student_id \nHAVING COUNT(DISTINCT SE.degree_program_id) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. It uses an intersection of two queries to ensure that the semesters returned are common to two instances of the same degree program, represented by a placeholder for the degree program's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. It uses an intersection of two queries to ensure that the semesters returned are common to two instances of the same degree program, represented by a placeholder for the degree program's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.535", "db_id": "student_transcripts_tracking", "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs are needed to get student names and their degree programs.", "Join the Students table with the Student_Enrolment table on student_id to link students with their enrolment records.", "Join the resulting table with the Degree_Programs table on degree_program_id to access degree program details.", "Filter the results to include only those students enrolled in a Bachelor degree program by using a WHERE clause with a LIKE condition on the degree_summary_name.", "Select the first name, middle name, and last name of the students from the final joined table."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT S.first_name, S.middle_name, S.last_name \nFROM Students AS S \nJOIN Student_Enrolment AS SE ON S.student_id = SE.student_id \nJOIN Degree_Programs AS DP ON SE.degree_program_id = DP.degree_program_id \nWHERE DP.degree_summary_name LIKE '%Bachelor%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first name, middle name, last name, and student ID of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. It uses an intersection of two queries to ensure that the semesters returned are common to two instances of the same degree program, represented by a placeholder for the degree program's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["To find the program with the most number of students enrolled, we need to join the Degree_Programs table with the Student_Enrolment table.", "The join condition is based on the degree_program_id, which is present in both tables.", "We will group the results by degree_program_id to count the number of students enrolled in each program.", "We will order the results in descending order based on the count of students to get the program with the highest enrollment first.", "Finally, we will limit the results to 1 to get only the program with the most students enrolled."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT T1.degree_program_id, T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of degree program names from the 'Degree_Programs' table, which are associated with student enrolments. The results are grouped by the degree program name and ordered by the number of enrolments in descending order, allowing users to see the most popular degree programs. The placeholder in the LIMIT clause represents the maximum number of degree programs to return.\",\n        \"virtual_table\": \"SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first name, middle name, last name, and student ID of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment are needed to get student details and their enrollment counts.", "Join the Students table with the Student_Enrolment table on the student_id to link students with their enrollments.", "Use COUNT(*) to count the number of enrollments for each student.", "Group the results by student_id to aggregate the counts for each student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Limit the results to 1 to get only the student with the highest enrollment count."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, COUNT(*) AS number_of_enrollments \nFROM Students AS T1 \nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id \nGROUP BY T1.student_id \nORDER BY number_of_enrollments DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first name, middle name, last name, and student ID of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of degree program names from the 'Degree_Programs' table, which are associated with student enrolments. The results are grouped by the degree program name and ordered by the number of enrolments in descending order, allowing users to see the most popular degree programs. The placeholder in the LIMIT clause represents the maximum number of degree programs to return.\",\n        \"virtual_table\": \"SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["To find the course with the most enrollments, we need to join the Courses table with the Student_Enrolment_Courses table, as this latter table contains the enrollments for each course.", "We will select the course name from the Courses table.", "We will group the results by course name to aggregate the enrollments for each course.", "To determine which course has the most enrollments, we will order the results by the count of enrollments in descending order.", "Finally, we will limit the results to just one course, which will be the one with the highest number of enrollments."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first name, middle name, last name, and student ID of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of degree program names from the 'Degree_Programs' table, which are associated with student enrolments. The results are grouped by the degree program name and ordered by the number of enrolments in descending order, allowing users to see the most popular degree programs. The placeholder in the LIMIT clause represents the maximum number of degree programs to return.\",\n        \"virtual_table\": \"SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.548", "db_id": "student_transcripts_tracking", "question": "What is the name of the course with the most students enrolled?", "rationale": ["Identify the relevant tables: Courses and Student_Enrolment_Courses are needed to find the course names and their enrollments.", "Join the Courses table with the Student_Enrolment_Courses table on the course_id to link courses with their enrollments.", "Group the results by course_name to aggregate the number of students enrolled in each course.", "Use COUNT on the student_course_id from the Student_Enrolment_Courses table to count the number of students enrolled in each course.", "Order the results in descending order to get the course with the most students at the top.", "Limit the results to 1 to get only the course with the highest enrollment."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id GROUP BY T1.course_name ORDER BY COUNT(T2.student_course_id) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first name, middle name, last name, and student ID of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of degree program names from the 'Degree_Programs' table, which are associated with student enrolments. The results are grouped by the degree program name and ordered by the number of enrolments in descending order, allowing users to see the most popular degree programs. The placeholder in the LIMIT clause represents the maximum number of degree programs to return.\",\n        \"virtual_table\": \"SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["We need to find the last names of students who live in North Carolina and have not registered in any degree programs.", "To do this, we will join the Students table with the Addresses table to filter students based on their permanent address.", "We will also perform a LEFT JOIN with the Student_Enrolment table to check if the students are enrolled in any degree programs.", "In the WHERE clause, we will specify that the state is 'North Carolina' and that the degree_program_id from the Student_Enrolment table is NULL, indicating that they are not enrolled in any degree programs."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "SELECT last_name \nFROM Students AS s \nJOIN Addresses AS a ON s.permanent_address_id = a.address_id \nLEFT JOIN Student_Enrolment AS se ON s.student_id = se.student_id \nWHERE a.state_province_county = 'North Carolina' \nAND se.degree_program_id IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\",\n        \"virtual_table\": \"select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile number.\",\n        \"virtual_table\": \"select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table: The 'Students' table contains the information about students, including their mobile phone numbers.", "Determine the required information: We need the 'cell_mobile_number' of the student named Timmothy Ward.", "Construct the SQL query: Use a SELECT statement to retrieve the 'cell_mobile_number' from the 'Students' table where the 'first_name' is 'Timmothy' and the 'last_name' is 'Ward'."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\",\n        \"virtual_table\": \"select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile number.\",\n        \"virtual_table\": \"select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["We need to find the address that holds the most number of students currently.", "To do this, we will join the 'Addresses' table with the 'Students' table on the current address ID.", "We will group the results by the address ID to count the number of students associated with each address.", "Next, we will order the results in descending order based on the count of students to find the address with the most students.", "Finally, we will limit the results to only one address, which will be the one with the highest count."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT A.address_id, A.line_1, A.line_2, A.line_3\nFROM Addresses AS A\nJOIN Students AS S ON S.current_address_id = A.address_id\nGROUP BY A.address_id\nORDER BY COUNT(S.student_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile number.\",\n        \"virtual_table\": \"select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\",\n        \"virtual_table\": \"select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.578", "db_id": "student_transcripts_tracking", "question": "What are the different addresses that have students living there?", "rationale": ["We need to find different addresses where students live, which includes both current and permanent addresses.", "The 'Students' table contains the identifiers for both current and permanent addresses.", "The 'Addresses' table contains the details of the addresses.", "We will perform a JOIN operation between the 'Students' table and the 'Addresses' table using both 'current_address_id' and 'permanent_address_id'.", "To ensure we get unique addresses, we will use DISTINCT in our SELECT statement."], "gold_sql": "SELECT count(DISTINCT current_address_id) FROM Students", "source_tables": ["students"], "pred_sql": "SELECT DISTINCT t2.line_1, t2.line_2, t2.line_3, t2.city, t2.zip_postcode, t2.state_province_county, t2.country \nFROM Students AS t1 \nJOIN Addresses AS t2 ON t1.current_address_id = t2.address_id \nOR t1.permanent_address_id = t2.address_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\",\n        \"virtual_table\": \"select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile number.\",\n        \"virtual_table\": \"select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve information about a section, we need to select all columns from the Sections table.", "We will use a WHERE clause to filter the results to only include the section with the name 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT * FROM Sections WHERE section_name = 'h';", "hint": "\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms.", "Determine the specific condition: We need to count countries where the 'GovernmentForm' is 'Republic'.", "Construct the SQL query: Use the COUNT function to count the number of rows in the 'country' table that meet the specified condition."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(*) FROM country WHERE GovernmentForm = 'Republic'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.723", "db_id": "world_1", "question": "How many people live in Asia, and what is the largest GNP among them?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their population and GNP.", "Determine the conditions: We need to filter the countries that are located in Asia, which is specified by the 'Continent' column.", "Select the required fields: We need to calculate the total population and find the maximum GNP for the countries in Asia.", "Construct the SQL query: Use the SUM function to get the total population and the MAX function to get the largest GNP, applying the WHERE clause to filter for Asia."], "gold_sql": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  'Asia'", "source_tables": ["country"], "pred_sql": "SELECT SUM(Population) AS TotalPopulation, MAX(GNP) AS LargestGNP \nFROM country \nWHERE Continent = 'Asia';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY Percentage DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of continents along with the count of countries that speak languages from those continents. The placeholder in the LIMIT clause allows the user to specify the maximum number of continents to retrieve based on the number of countries associated with each continent.\",\n        \"virtual_table\": \"SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.724", "db_id": "world_1", "question": "What is the average life expectancy in African countries that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains the life expectancy and government form information.", "Filter for African countries: Use the 'Continent' column to select countries in Africa.", "Filter for republics: Use the 'GovernmentForm' column to select countries that are republics.", "Calculate the average life expectancy: Use the AVG() function on the 'LifeExpectancy' column to get the average for the filtered countries."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT AVG(LifeExpectancy) FROM country WHERE Continent = 'Africa' AND GovernmentForm = 'Republic';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.725", "db_id": "world_1", "question": "Give the average life expectancy for countries in Africa which are republics?", "rationale": ["Identify the relevant table: The 'country' table contains the information about countries, including their life expectancy and government form.", "Determine the conditions: We need to filter countries that are located in Africa and have a government form that includes 'Republic'.", "Use the AVG function: To find the average life expectancy, we will use the AVG() function on the 'LifeExpectancy' column.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter the results based on the identified conditions."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT AVG(LifeExpectancy) FROM country WHERE Continent = 'Africa' AND GovernmentForm LIKE '%Republic%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.731", "db_id": "world_1", "question": "Give the mean GNP and total population of nations which are considered US territory.", "rationale": ["Identify the countries that are considered US territories. In this case, we can assume 'USA' and 'Puerto Rico' (PR) are the relevant codes.", "We need to calculate the mean GNP and total population for these countries.", "Use the AVG function to calculate the mean GNP and the SUM function to calculate the total population.", "The SQL query will select the average GNP and total population from the country table where the country name is in the list of US territories."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT AVG(GNP) AS Mean_GNP, SUM(Population) AS Total_Population FROM country WHERE Name IN (SELECT Name FROM country WHERE Code = 'USA' OR Code = 'PR');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total population of countries that do not have a specific language as an official language. The placeholder in the subquery represents the language name that is being checked against the countries.\",\n        \"virtual_table\": \"SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of continents along with the count of countries that speak languages from those continents. The placeholder in the LIMIT clause allows the user to specify the maximum number of continents to retrieve based on the number of countries associated with each continent.\",\n        \"virtual_table\": \"SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains the 'GovernmentForm' and 'Continent' columns.", "Filter for countries in Africa: Use a WHERE clause to specify that we are only interested in countries where the 'Continent' is 'Africa'.", "Count distinct government forms: Use COUNT(DISTINCT GovernmentForm) to count the number of unique forms of government in the filtered results."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(DISTINCT GovernmentForm) FROM country WHERE Continent = 'Africa';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.754", "db_id": "world_1", "question": "What are the countries where either English or Dutch is the official language ?", "rationale": ["Identify the tables involved: We need to use the 'country' and 'countrylanguage' tables.", "Determine the relationship: The 'country' table is linked to the 'countrylanguage' table through the 'Code' and 'CountryCode' columns.", "Define the criteria: We are looking for countries where either English or Dutch is an official language.", "Use the INTERSECT operator: Since we want countries that have both languages as official, we will use the INTERSECT operator to find common countries that meet both conditions.", "Construct the SQL query: Create the SQL query using the identified tables, relationships, and criteria."], "gold_sql": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'english' and isofficial  =  't' union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'dutch' and isofficial  =  't'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'Dutch'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\",\n        \"virtual_table\": \"SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["The question asks for countries that have either English or Dutch as an official language.", "To find this, we need to join the 'country' table with the 'countrylanguage' table on the country code.", "We will filter the results where the language is either 'English' or 'Dutch'.", "Additionally, we need to ensure that the language is marked as official, which is indicated by the 'IsOfficial' column being 'T'.", "We will use the DISTINCT keyword to ensure that we do not have duplicate country names in the result."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' OR T2.Language = 'Dutch' AND T2.IsOfficial = 'T'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\",\n        \"virtual_table\": \"SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.758", "db_id": "world_1", "question": "Which languages are spoken by only one country in republic governments?", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find languages spoken in countries with a republican form of government.", "Filter countries by government form: We will filter the 'country' table to include only those countries where the 'GovernmentForm' is 'Republic'.", "Join the tables: We will join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' fields to get the languages spoken in those countries.", "Group by language: We will group the results by language to count how many countries speak each language.", "Count distinct countries: We will use the HAVING clause to filter the groups to only include languages that are spoken in exactly one country."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.GovernmentForm = 'Republic' GROUP BY T2.Language HAVING COUNT(DISTINCT T1.Code) = 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\",\n        \"virtual_table\": \"SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.759", "db_id": "world_1", "question": "What languages are only used by a single country with a republic government?", "rationale": ["Identify the relevant tables: countrylanguage for languages and country for government forms.", "We need to find languages that are official (IsOfficial = 'T') and are spoken in countries with a republic government (GovernmentForm = 'Republic').", "Join the countrylanguage table with the country table on CountryCode to access both languages and their corresponding countries.", "Group the results by language to count how many distinct countries speak each language.", "Use HAVING clause to filter the grouped results to only include languages that are spoken in exactly one country (COUNT(DISTINCT c.Code) = 1)."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl.Language \nFROM countrylanguage AS cl \nJOIN country AS c ON cl.CountryCode = c.Code \nWHERE cl.IsOfficial = 'T' \nAND c.GovernmentForm = 'Republic' \nGROUP BY cl.Language \nHAVING COUNT(DISTINCT c.Code) = 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\",\n        \"virtual_table\": \"SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.760", "db_id": "world_1", "question": "Find the city with the largest population that uses English.", "rationale": ["Identify the requirement: Find the city with the largest population that uses English.", "To find cities that use English, we need to look at the countrylanguage table to filter countries where English is spoken.", "We will then join this result with the country table to get the country codes.", "Finally, we will join this with the city table to get the cities and order them by population in descending order, limiting the result to the top city."], "gold_sql": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  'English' ORDER BY T1.Population DESC LIMIT 1", "source_tables": ["city", "countrylanguage"], "pred_sql": "SELECT Name FROM city WHERE CountryCode IN (SELECT Code FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English')) ORDER BY Population DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY Percentage DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\",\n        \"virtual_table\": \"SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the requirement: We need to find the total population of countries that do not use English as an official language.", "Use the provided hint to create a subquery that selects the CountryCode of countries where English is an official language.", "The subquery will be: SELECT CountryCode FROM countrylanguage WHERE Language = 'English'.", "We will use this subquery in the main query to filter out these countries from the total population calculation.", "The main query will sum the population of countries whose Code is not in the result of the subquery."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT sum(Population) FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total population of countries that do not have a specific language as an official language. The placeholder in the subquery represents the language name that is being checked against the countries.\",\n        \"virtual_table\": \"SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.774", "db_id": "world_1", "question": "What are the African countries that have a  population less than any country in Asia?", "rationale": ["Identify the countries in Africa by filtering the 'country' table for 'Continent' = 'Africa'.", "Determine the maximum population of countries in Asia by using a subquery that selects the maximum 'Population' from the 'country' table where 'Continent' = 'Asia'.", "Combine these two conditions to find African countries with a population less than the maximum population found in Asia."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Africa'  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  'Asia')", "source_tables": ["country"], "pred_sql": "SELECT Name FROM country WHERE Continent = 'Africa' AND Population < (SELECT MAX(Population) FROM country WHERE Continent = 'Asia')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total population of countries that do not have a specific language as an official language. The placeholder in the subquery represents the language name that is being checked against the countries.\",\n        \"virtual_table\": \"SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of continents along with the count of countries that speak languages from those continents. The placeholder in the LIMIT clause allows the user to specify the maximum number of continents to retrieve based on the number of countries associated with each continent.\",\n        \"virtual_table\": \"SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.777", "db_id": "world_1", "question": "What are the Asian countries which have a population larger than that of any country in Africa?", "rationale": ["Identify the countries in Asia by filtering the 'country' table where the 'Continent' column is 'Asia'.", "Determine the population of these Asian countries by using the 'Population' column in the 'country' table.", "To find countries in Asia with a population larger than any country in Africa, we need to compare the populations.", "Use a subquery to find the maximum population of countries in Africa by filtering the 'country' table where the 'Continent' column is 'Africa' and selecting the maximum value from the 'Population' column.", "Combine these conditions in the main query to select the names of Asian countries that meet the population criteria."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Asia'  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  'Africa')", "source_tables": ["country"], "pred_sql": "SELECT Name FROM country WHERE Continent = 'Asia' AND Population > (SELECT MAX(Population) FROM country WHERE Continent = 'Africa');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of continents along with the count of countries that speak languages from those continents. The placeholder in the LIMIT clause allows the user to specify the maximum number of continents to retrieve based on the number of countries associated with each continent.\",\n        \"virtual_table\": \"SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of continents along with the count of countries that speak languages from those continents. The placeholder in the LIMIT clause allows the user to specify the maximum number of continents to retrieve based on the number of countries speaking languages from each continent.\",\n        \"virtual_table\": \"SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.778", "db_id": "world_1", "question": "What are the country codes for countries that do not speak English?", "rationale": ["The question asks for country codes of countries that do not speak English.", "To find this, we can use the country table to get all country codes.", "We will then exclude the country codes that are associated with the English language in the countrylanguage table.", "Using the EXCEPT clause allows us to subtract the country codes that speak English from the total list of country codes.", "The final SQL query selects the country codes from the country table and excludes those found in the countrylanguage table where the language is 'English'."], "gold_sql": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["countrylanguage"], "pred_sql": "SELECT Code FROM country EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = 'English'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\",\n        \"virtual_table\": \"SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.786", "db_id": "world_1", "question": "Which unique cities are in Asian countries where Chinese is the official language ?", "rationale": ["Identify the relevant tables: city, country, and countrylanguage.", "We need to find unique cities, so we will use SELECT DISTINCT on city.Name.", "Join the city table with the country table on the CountryCode to get country details for each city.", "Join the country table with the countrylanguage table to filter by language.", "Filter the results to include only cities in Asian countries by checking the Continent column in the country table.", "Filter the results to include only cities where Chinese is an official language by checking the Language and IsOfficial columns in the countrylanguage table."], "gold_sql": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  't' and t2.language  =  'chinese' and t1.continent  =  'asia'", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT DISTINCT city.Name FROM city JOIN country ON city.CountryCode = country.Code JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE country.Continent = 'Asia' AND countrylanguage.Language = 'Chinese' AND countrylanguage.IsOfficial = 'T';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\",\n        \"virtual_table\": \"SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the required fields: Name, year of independence (IndepYear), and surface area (SurfaceArea) of the country.", "Determine the condition: We need the country with the lowest population.", "Use a subquery to find the minimum population from the country table.", "Select the country details where the population matches the minimum population found in the subquery."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["We need to find countries that speak more than 2 languages.", "To do this, we will join the 'country' table with the 'countrylanguage' table on the 'CountryCode'.", "We will group the results by the country name to count the number of languages spoken in each country.", "Using the COUNT function, we will count the number of languages for each country.", "Finally, we will use the HAVING clause to filter the results to only include countries that have more than 2 languages."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT T1.Name, COUNT(T2.Language) AS LanguageCount \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nGROUP BY T1.Name \nHAVING COUNT(T2.Language) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\",\n        \"virtual_table\": \"SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY Percentage DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the columns needed: GovernmentForm and Population from the country table.", "Filter the countries based on the condition that LifeExpectancy is greater than 72.", "Group the results by GovernmentForm to get the total population for each government form.", "Use the SUM function to calculate the total population for each group."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation \nFROM country \nWHERE LifeExpectancy > 72 \nGROUP BY GovernmentForm;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the table to query: The 'city' table contains the population data.", "Determine the condition for filtering: We need cities with a population between 160000 and 900000.", "Construct the SQL query using the SELECT statement to retrieve all columns from the 'city' table where the population meets the specified range."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT * FROM city WHERE Population BETWEEN '160000' AND '900000';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.820", "db_id": "world_1", "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?", "rationale": ["Identify the relevant table: We need to look at the 'country' and 'countrylanguage' tables to find the countries where Spanish is spoken.", "Determine the condition: We are interested in the language 'Spanish' and its percentage of speakers.", "Use a subquery: We will create a subquery to select the 'CountryCode' from 'countrylanguage' where the 'Language' is 'Spanish'.", "Order the results by 'Percentage' in descending order to get the countries where Spanish is spoken by the largest percentage of people.", "Finally, select the 'Code' from the 'country' table that matches the 'CountryCode' from the subquery."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "pred_sql": "SELECT Code FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' ORDER BY Percentage DESC)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY Percentage DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\",\n        \"virtual_table\": \"SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.821", "db_id": "world_1", "question": "Return the codes of countries for which Spanish is the predominantly spoken language.", "rationale": ["Identify the requirement: We need to find the codes of countries where Spanish is predominantly spoken.", "Spanish should be an official language, so we will filter the countrylanguage table for entries where Language = 'Spanish' and IsOfficial = 'Yes'.", "We need the country codes, which are in the country table, so we will join the countrylanguage table with the country table using the CountryCode.", "The final query will select the Code from the country table where the CountryCode matches the filtered results from the countrylanguage table."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "pred_sql": "SELECT Code FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' AND IsOfficial = 'Yes')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\",\n        \"virtual_table\": \"SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.920", "db_id": "dog_kennels", "question": "What is the average age of the dogs who have gone through any treatments?", "rationale": ["Identify the main objective: Calculate the average age of dogs that have received treatments.", "Determine the relevant tables: The 'Dogs' table contains the age of the dogs, and the 'Treatments' table links dogs to their treatments.", "Use a subquery to find all dog_ids from the Treatments table, as we only want to include dogs that have received treatments.", "Construct the SQL query to calculate the average age using the AVG() function on the age column from the Dogs table, filtering by the dog_ids obtained from the subquery."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers if needed.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum allowable total treatment cost.\",\n        \"virtual_table\": \"select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "dev.936", "db_id": "dog_kennels", "question": "Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.", "rationale": ["Identify the relevant tables: Owners, Dogs, and Treatments.", "Join the Owners table with the Dogs table on owner_id to link owners to their dogs.", "Join the resulting table with the Treatments table on dog_id to link dogs to their treatments.", "Group the results by owner_id and last_name to aggregate treatment costs for each owner.", "Use SUM to calculate the total cost of treatments for each owner.", "Order the results by the total treatment cost in descending order to find the owner who has paid the most.", "Limit the results to 1 to get only the top owner."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT O.owner_id, O.last_name\nFROM Owners AS O\nJOIN Dogs AS D ON O.owner_id = D.owner_id\nJOIN Treatments AS T ON D.dog_id = T.dog_id\nGROUP BY O.owner_id, O.last_name\nORDER BY SUM(T.cost_of_treatment) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum allowable total treatment cost.\",\n        \"virtual_table\": \"select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["Identify the tables involved: Professionals and Treatments.", "We need to join these tables on the professional_id to link professionals with the treatments they have administered.", "We want to group the results by professional_id to count the number of different treatment types each professional has administered.", "Use the HAVING clause to filter professionals who have administered at least two different types of treatments.", "Select the professional_id and cell_number from the Professionals table."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT T1.professional_id, T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id = T2.professional_id GROUP BY T1.professional_id HAVING count(DISTINCT T2.treatment_type_code) >= 2", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of professionals along with their cell numbers from the 'Professionals' table who have administered a specified number of treatments. The placeholder in the HAVING clause represents the minimum count of treatments that a professional must have administered.\",\n        \"virtual_table\": \"SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "dev.944", "db_id": "dog_kennels", "question": "What are the first name and last name of the professionals who have done treatment with cost below average?", "rationale": ["Identify the tables involved: Professionals and Treatments.", "We need the first name and last name of professionals, so we will select 'first_name' and 'last_name' from the Professionals table.", "We need to filter professionals based on the treatments they have administered, so we will join the Professionals table with the Treatments table on 'professional_id'.", "The condition requires us to find treatments with a cost below the average cost of treatments, so we will use a subquery to calculate the average treatment cost.", "The final query will select distinct first and last names of professionals who meet the cost condition."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT DISTINCT T1.first_name, T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id = T2.professional_id WHERE T2.cost_of_treatment < (SELECT avg(cost_of_treatment) FROM Treatments)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of professionals along with their cell numbers from the 'Professionals' table who have administered a specified number of treatments. The placeholder in the HAVING clause represents the minimum count of treatments that a professional must have administered.\",\n        \"virtual_table\": \"SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum allowable total treatment cost.\",\n        \"virtual_table\": \"select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["We need to list each owner's first name and last name, which are found in the Owners table.", "We also need the size of each owner's dog, which is found in the Sizes table.", "To get the size of the dog, we need to join the Dogs table with the Sizes table using the size_code foreign key.", "We will join the Owners table with the Dogs table using the owner_id foreign key to link each dog to its owner.", "The final query will select the first name and last name from the Owners table and the size description from the Sizes table."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers if needed.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    }\n}\n"}
{"sample_id": "dev.951", "db_id": "dog_kennels", "question": "What are each owner's first name, last name, and the size of their dog?", "rationale": ["Identify the required information: owner's first name, last name, and the size of their dog.", "Determine the relevant tables: Owners, Dogs, and Sizes.", "Establish the relationships between the tables: Owners are linked to Dogs via owner_id, and Dogs are linked to Sizes via size_code.", "Construct the SQL query to select the desired columns from the Owners table and the Sizes table, joining them through the Dogs table."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers if needed.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    }\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need the arriving and departing dates of dogs that have undergone treatment.", "The Dogs table contains the columns date_arrived and date_departed.", "The Treatments table links to the Dogs table through dog_id, indicating which dogs have received treatments.", "We can use a subquery to select dog_ids from the Treatments table, which will allow us to filter the Dogs table accordingly.", "The final SQL query selects the date_arrived and date_departed from the Dogs table where the dog_id is in the list of dog_ids from the Treatments table."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT date_arrived, date_departed FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum allowable total treatment cost.\",\n        \"virtual_table\": \"select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers if needed.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    }\n}\n"}
{"sample_id": "dev.961", "db_id": "dog_kennels", "question": "Who owns the youngest dog? Give me his or her last name.", "rationale": ["Identify the tables involved: Owners and Dogs.", "We need to find the youngest dog, which requires us to look at the age column in the Dogs table.", "To find the youngest dog, we will use a subquery to get the minimum age from the Dogs table.", "Join the Owners table with the Dogs table on the owner_id to get the last name of the owner of the youngest dog.", "Select the last name of the owner where the dog's age matches the minimum age found in the subquery."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id WHERE T2.age = (SELECT min(age) FROM Dogs)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers if needed.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["We need to find distinct combinations of breed types and size types for dogs.", "To do this, we will select the breed names from the Breeds table and the size descriptions from the Sizes table.", "We will join the Dogs table with the Breeds table on the breed_code to get the breed names.", "We will also join the Dogs table with the Sizes table on the size_code to get the size descriptions.", "Using SELECT DISTINCT will ensure that we only get unique combinations of breed names and size descriptions."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT B.breed_name, S.size_description \nFROM Dogs AS D \nJOIN Breeds AS B ON D.breed_code = B.breed_code \nJOIN Sizes AS S ON D.size_code = S.size_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers if needed.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )\"\n    }\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["Identify the tables needed: Professionals, Treatments, and Treatment_Types.", "Select the first name from the Professionals table and the treatment description from the Treatment_Types table.", "Join the Professionals table with the Treatments table on professional_id to link professionals to the treatments they have administered.", "Join the Treatments table with the Treatment_Types table on treatment_type_code to get the description of each treatment.", "Construct the SELECT statement to retrieve the desired fields: first name of the professional and the description of the treatment."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT P.first_name, TT.treatment_type_description \nFROM Professionals AS P \nJOIN Treatments AS T ON P.professional_id = T.professional_id \nJOIN Treatment_Types AS TT ON T.treatment_type_code = TT.treatment_type_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of professionals along with their cell numbers from the 'Professionals' table who have administered a specified number of treatments. The placeholder in the HAVING clause represents the minimum count of treatments that a professional must have administered.\",\n        \"virtual_table\": \"SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
