{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Course_Registrations'.", "It selects the 'course_name' from the 'Courses' table.", "A JOIN operation is performed to link courses with their registrations based on the course ID.", "The results are grouped by 'course_id' to aggregate the data for each course.", "The results are ordered by the count of registrations in descending order to highlight the most popular courses.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "description": "This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.", "virtual_table": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["The query is identifying the relevant table, which is 'Student_Course_Attendance'.", "Select the column to display, 'student_id'.", "No additional conditions or filters are applied in this query, so it retrieves all student identifiers from the attendance records."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "description": "This virtual table describes the identifiers of students who have attended courses from the 'Student_Course_Attendance' table. The placeholder in the SELECT clause represents the unique student identifiers.", "virtual_table": "SELECT student_id FROM student_course_attendance"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["The query is identifying the relevant table, which is 'Student_Course_Attendance'.", "Select the column to display, 'student_id', which represents the unique identifier for each student."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "description": "This virtual table describes the identifiers of students who have attended courses from the 'Student_Course_Attendance' table. The placeholder in the SELECT clause represents the unique identifier for each student.", "virtual_table": "SELECT student_id FROM student_course_attendance"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["The query identifies the relevant table, which is 'Candidate_Assessments'.", "It selects the 'candidate_id' column to display the IDs of candidates.", "The results are ordered by 'assessment_date' in descending order to show the most recent assessments first.", "A placeholder is used in the LIMIT clause to allow the user to specify how many candidate IDs to return."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "description": "This virtual table provides a list of candidate IDs from the 'Candidate_Assessments' table, ordered by the date of assessment in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of candidate IDs to retrieve.", "virtual_table": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.77", "db_id": "student_assessment", "question": "What is detail of the student who registered the most number of courses?", "rationale": ["The query identifies the relevant tables, 'Students' and 'Student_Course_Registrations'.", "It selects the 'student_details' column from the 'Students' table.", "A JOIN operation is performed to link students with their course registrations based on the 'student_id'.", "The results are grouped by 'student_id' to avoid duplicates and to count the number of registrations per student.", "The results are ordered by the count of registrations in descending order to prioritize students with the most registrations.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.", "virtual_table": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["The query identifies the relevant tables: 'Students', 'Student_Course_Registrations', and 'Courses'.", "It selects the 'course_name' from the 'Courses' table and counts the number of registrations.", "The join operation connects 'Students' to 'Student_Course_Registrations' using 'student_id', and then connects 'Student_Course_Registrations' to 'Courses' using 'course_id'.", "The results are grouped by 'course_id' to aggregate the count of students for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "description": "This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.", "virtual_table": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id"}
{"sample_id": "train.90", "db_id": "student_assessment", "question": "What are the ids of the students who registered for course 301 most recently?", "rationale": ["The query identifies the relevant table, which is 'Student_Course_Attendance'.", "It selects the 'student_id' column to display the identifiers of students who attended a specific course.", "A condition is added to filter the results based on the 'course_id' using a placeholder for numeric values.", "The results are ordered by 'date_of_attendance' in descending order to show the most recent attendance first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "description": "This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["The query identifies the relevant tables: 'Addresses', 'People_Addresses', and 'Students'.", "It selects distinct cities from the 'Addresses' table.", "The join conditions link the addresses to the people and then to the students, ensuring that only cities associated with students are included."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "description": "This virtual table provides a distinct list of cities where students are located, by joining the 'Addresses', 'People_Addresses', and 'Students' tables. The placeholders in the query represent the necessary identifiers for the relationships between these tables.", "virtual_table": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["The query identifies the relevant table, which is 'student_course_registrations'.", "It selects all columns from this table.", "A condition is added to filter out students who have attended any courses by using a subquery that checks for student IDs in the 'student_course_attendance' table."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "description": "This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records using a subquery that checks for student IDs in the 'student_course_attendance' table.", "virtual_table": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Course_Registrations'.", "It performs a JOIN operation to link the courses with their respective student registrations based on the course ID.", "The WHERE clause filters the results to include only those registrations for a specific course name, using a placeholder for the course name.", "Finally, the results are ordered by the registration date to show the sequence of student registrations."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "description": "This virtual table provides a list of student IDs from the 'Students' table who are registered for a specific course. The course is identified by its name, which is represented by a placeholder in the WHERE clause. The results are ordered by the date of registration, allowing for an organized view of when each student registered for the course.", "virtual_table": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = [PLACEHOLDER-TYPE:STRING] ORDER BY T2.registration_date"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Course_Registrations'.", "It performs a JOIN operation to link the courses with their respective student registrations based on the course ID.", "The WHERE clause filters the results to include only those registrations for a specific course name, using a placeholder for the course name.", "Finally, the results are ordered by the registration date to show the sequence of student registrations."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "description": "This virtual table provides a list of student IDs from the 'Students' table who are registered for a specific course. The course is identified by its name, which is represented by a placeholder in the WHERE clause. The results are ordered by the date of registration, allowing for an organized view of when each student registered for the course.", "virtual_table": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = [PLACEHOLDER-TYPE:STRING] ORDER BY T2.registration_date"}
{"sample_id": "train.123", "db_id": "bike_1", "question": "For each zip code, return the average mean temperature of August there.", "rationale": ["The query identifies the relevant table, which is 'weather'.", "Select the 'zip_code' and the average of 'mean_temperature_f' to display the average temperature for each zip code.", "Add a condition to filter the 'date' column for the specified date using a placeholder for string values.", "Group the results by 'zip_code' to get the average temperature for each unique zip code."], "gold_sql": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE '8/%' GROUP BY zip_code", "source_tables": ["weather"], "description": "This virtual table provides the average mean temperature in Fahrenheit for each zip code based on weather reports for a specific date. The placeholder in the WHERE clause represents the date for which the weather data is being queried.", "virtual_table": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY zip_code"}
{"sample_id": "train.135", "db_id": "bike_1", "question": "Which bike traveled the most often in zip code 94002?", "rationale": ["The query identifies the relevant table, which is 'trip'.", "Select the column to display, 'bike_id'.", "Add a condition to filter the 'zip_code' column for the specified zip code using a placeholder for numeric values.", "Group the results by 'bike_id' to aggregate the trips for each bike.", "Order the results by the count of trips in descending order to show the most frequently used bikes first.", "Limit the number of results returned based on a specified number using a placeholder."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "description": "This virtual table provides a list of bike identifiers from the 'trip' table for users who started their trips from a specific zip code. The results are grouped by bike identifier and ordered by the number of trips taken with each bike, allowing users to see which bikes are most frequently used in that area. The placeholders in the WHERE clause represent the zip code of interest and the limit on the number of results to return.", "virtual_table": "SELECT bike_id FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.136", "db_id": "bike_1", "question": "What is the id of the bike that traveled the most in 94002?", "rationale": ["The query identifies the relevant table, which is 'trip'.", "Select the column to display, 'bike_id'.", "Add a condition to filter the 'zip_code' column for the specified zip code using a placeholder for numeric values.", "Group the results by 'bike_id' to aggregate the trips for each bike.", "Order the results by the count of trips in descending order to show the most frequently used bikes first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "description": "This virtual table provides a list of bike identifiers from the 'trip' table for users who started their trips from a specific zip code. The results are grouped by bike identifier and ordered by the number of trips taken, allowing users to see which bikes are most frequently used in that area. The placeholders in the WHERE clause represent the zip code and the limit on the number of results to return.", "virtual_table": "SELECT bike_id FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.143", "db_id": "bike_1", "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?", "rationale": ["The query identifies the relevant tables, which are 'station' and 'status'.", "It selects the columns 'name' and 'id' from the 'station' table.", "The first part of the query joins the 'station' table with the 'status' table on the station ID, grouping by station ID and filtering for those with an average number of available bikes greater than a specified number using a placeholder.", "The second part of the query selects names and IDs from the 'station' table where the installation date matches a specified pattern using a placeholder."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "description": "This virtual table provides a list of bike stations along with their unique identifiers. It includes stations that have an average number of available bikes exceeding a specified threshold, as well as stations that were installed on a specific date. The first part of the query retrieves the names and IDs of stations from the 'station' table that are joined with the 'status' table, filtering based on the average number of bikes available. The second part of the query retrieves names and IDs of stations from the 'station' table based on the installation date, using a placeholder for the date format.", "virtual_table": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT name ,  id FROM station WHERE installation_date LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.144", "db_id": "bike_1", "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "rationale": ["The query identifies the relevant tables, which are 'station' and 'status'.", "It selects the 'name' and 'id' columns from the 'station' table.", "The first part of the query joins the 'station' and 'status' tables on the station ID, grouping by station ID and filtering for those with an average number of bikes available greater than a specified number using a placeholder.", "The second part of the query selects the 'name' and 'id' from the 'station' table where the installation date matches a specified string using a placeholder.", "The UNION operator combines the results from both parts of the query."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "description": "This virtual table provides a list of bike stations along with their unique identifiers. It includes stations that have an average number of available bikes exceeding a specified threshold, as well as stations that were installed on a specific date. The placeholders in the query allow users to specify the minimum average bikes available and the installation date criteria.", "virtual_table": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT name ,  id FROM station WHERE installation_date LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.145", "db_id": "bike_1", "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?", "rationale": ["The query identifies the relevant table, which is 'weather'.", "Select the column 'cloud_cover' to display the cloud cover data.", "Add a condition to filter the results based on the specified zip code using a placeholder for numeric values.", "Group the results by 'cloud_cover' to aggregate the data based on different cloud cover values.", "Order the results by the count of occurrences of each cloud cover value in descending order to show the most common conditions first.", "Limit the number of results returned based on a specified number using a placeholder."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "description": "This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area. The placeholders in the WHERE clause represent the zip code, and the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.161", "db_id": "bike_1", "question": "For each trip, return its ending station's installation date.", "rationale": ["The query identifies the relevant tables, which are 'trip' and 'station'.", "It selects the 'id' from the 'trip' table and 'installation_date' from the 'station' table.", "A JOIN operation is performed on the 'end_station_id' from the 'trip' table and the 'id' from the 'station' table to link trips to their respective stations."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "description": "This virtual table provides a list of trip identifiers along with the installation dates of the bike stations where the trips ended. The data is sourced from the 'trip' table and the 'station' table, linked by the end station identifier.", "virtual_table": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id"}
{"sample_id": "train.162", "db_id": "bike_1", "question": "What is the installation date for each ending station on all the trips?", "rationale": ["The query identifies the relevant tables, which are 'trip' and 'station'.", "It selects the 'id' from the 'trip' table and 'installation_date' from the 'station' table.", "A JOIN operation is performed on the 'end_station_id' from the 'trip' table and the 'id' from the 'station' table to link trips to their respective stations."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "description": "This virtual table provides a list of trip identifiers along with the installation dates of the bike stations where the trips ended. The data is sourced from the 'trip' table and the 'station' table, linked by the end station identifier.", "virtual_table": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id"}
{"sample_id": "train.163", "db_id": "bike_1", "question": "Which trip started from the station with the largest dock count? Give me the trip id.", "rationale": ["The query identifies the relevant tables, which are 'trip' and 'station'.", "It selects the unique identifiers from the 'trip' table (T1.id).", "A JOIN operation is performed to link trips to their starting stations based on the station ID.", "The results are ordered by the 'dock_count' from the 'station' table in descending order to prioritize stations with more docks.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "description": "This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip identifiers to return.", "virtual_table": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.165", "db_id": "bike_1", "question": "Count the number of trips that did not end in San Francisco city.", "rationale": ["The query identifies the relevant tables, which are 'trip' and 'station'.", "It uses a JOIN operation to connect the 'trip' table with the 'station' table based on the end station ID.", "The COUNT function is used to count the total number of trips that meet the specified condition.", "A condition is added to filter out trips that ended at stations in a specific city using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  'San Francisco'", "source_tables": ["trip", "station"], "description": "This virtual table counts the number of trips that ended at stations located in cities other than a specified city. The placeholder in the WHERE clause represents the name of the city to exclude from the count.", "virtual_table": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.166", "db_id": "bike_1", "question": "How many trips did not end in San Francisco?", "rationale": ["The query identifies the relevant tables, which are 'trip' and 'station'.", "It uses a JOIN operation to connect the 'trip' table with the 'station' table based on the end station ID.", "The SELECT statement counts the total number of trips that meet the specified condition.", "A condition is added to filter out trips that ended at stations in a specific city using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != 'San Francisco'", "source_tables": ["trip", "station"], "description": "This virtual table provides the count of trips that ended at stations located in cities other than a specified city. The placeholder in the WHERE clause represents the name of the city to exclude from the count.", "virtual_table": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.167", "db_id": "bike_1", "question": "In zip code 94107, on which day neither Fog nor Rain was not observed?", "rationale": ["The query identifies the relevant table, which is 'weather'.", "Select the 'date' column to display the dates of the weather reports.", "Add conditions to filter the results based on the specified zip code and to exclude certain weather events using placeholders for numeric and string values."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "description": "This virtual table provides the dates of weather reports from the 'weather' table for a specific zip code, excluding certain weather events. The placeholders in the WHERE clause represent the zip code and the types of weather events to be filtered out.", "virtual_table": "SELECT date FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] AND EVENTS != [PLACEHOLDER-TYPE:STRING] AND EVENTS != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.168", "db_id": "bike_1", "question": "On which day has it neither been foggy nor rained in the zip code of 94107?", "rationale": ["The query identifies the relevant table, which is 'weather'.", "Select the 'date' column to display the dates of the weather reports.", "Add conditions to filter the results based on the specified zip code and to exclude certain weather events using placeholders for numeric and string values."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "description": "This virtual table provides the dates of weather reports from the 'weather' table for a specific zip code, excluding certain weather events. The placeholders in the WHERE clause represent the zip code and the types of weather events to be filtered out.", "virtual_table": "SELECT date FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] AND EVENTS != [PLACEHOLDER-TYPE:STRING] AND EVENTS != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.183", "db_id": "bike_1", "question": "List all the cities in a decreasing order of each city's stations' highest latitude.", "rationale": ["The query identifies the relevant table, which is 'station'.", "It selects the 'city' column to display unique city names.", "The GROUP BY clause is used to ensure that each city is listed only once.", "The ORDER BY clause sorts the cities based on the maximum latitude of the stations, allowing for a geographical ordering from north to south."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "description": "This virtual table provides a list of unique cities where bike stations are located, sorted by the maximum latitude of the stations in each city. The placeholder in the ORDER BY clause indicates that the cities will be ordered based on their geographical position from north to south.", "virtual_table": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC"}
{"sample_id": "train.184", "db_id": "bike_1", "question": "For each city, list their names in decreasing order by their highest station latitude.", "rationale": ["The query identifies the relevant table, which is 'station'.", "It selects the 'city' column to display unique city names.", "The GROUP BY clause is used to ensure that each city is listed only once.", "The ORDER BY clause sorts the cities based on the maximum latitude of the stations in each city, using the max function on the 'lat' column."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "description": "This virtual table provides a list of unique cities where bike stations are located, sorted by the maximum latitude of the stations in each city. The placeholder in the ORDER BY clause indicates that the cities will be ordered based on their geographical position, specifically the highest latitude.", "virtual_table": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC"}
{"sample_id": "train.189", "db_id": "bike_1", "question": "For each station, return its longitude and the average duration of trips that started from the station.", "rationale": ["The query identifies the relevant tables, which are 'station' and 'trip'.", "It selects the 'name' and 'long' columns from the 'station' table, and calculates the average trip duration from the 'trip' table.", "A JOIN operation is performed on the 'id' of the 'station' table and the 'start_station_id' of the 'trip' table to link trips to their starting stations.", "The results are grouped by 'start_station_id' to compute the average duration for trips starting at each station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "description": "This virtual table provides the names and longitude coordinates of bike stations from the 'station' table, along with the average duration of trips that started at each station. The data is aggregated by the start station identifier, allowing users to see how long trips typically last from each location.", "virtual_table": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id"}
{"sample_id": "train.190", "db_id": "bike_1", "question": "For each start station id, what is its name, longitude and average duration of trips started there?", "rationale": ["The query identifies the relevant tables, which are 'station' and 'trip'.", "It selects the 'name' and 'long' columns from the 'station' table, and calculates the average trip duration from the 'trip' table.", "A JOIN operation is performed on the 'station' and 'trip' tables using the station ID to link trips to their starting stations.", "The results are grouped by the start station ID to compute the average duration for trips starting at each station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "description": "This virtual table provides the names and longitude coordinates of bike stations from the 'station' table, along with the average duration of trips that started at each station. The data is aggregated by the start station identifier, allowing users to see how long trips typically last from each location.", "virtual_table": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id"}
{"sample_id": "train.192", "db_id": "bike_1", "question": "For each end station id, what is its name, latitude, and minimum duration for trips ended there?", "rationale": ["The query identifies the relevant tables, which are 'station' and 'trip'.", "It selects the 'name' and 'lat' columns from the 'station' table (aliased as T1).", "It calculates the minimum trip duration from the 'trip' table (aliased as T2) for trips that ended at each station.", "The JOIN operation links the two tables on the condition that the 'id' of the station matches the 'end_station_id' of the trip.", "The results are grouped by the 'end_station_id' to ensure that the minimum duration is calculated for each station."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "description": "This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.", "virtual_table": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id"}
{"sample_id": "train.196", "db_id": "bike_1", "question": "What are all the different zip codes that have a maximum dew point that was always below 70?", "rationale": ["The query starts by selecting distinct zip codes from the 'weather' table.", "It uses the EXCEPT clause to exclude zip codes that have a maximum dew point greater than or equal to a specified value.", "The placeholder in the WHERE clause represents the maximum dew point threshold that the user can define."], "gold_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70", "source_tables": ["weather"], "description": "This virtual table provides a list of unique zip codes from the 'weather' table that do not have any recorded maximum dew point above a specified threshold. The placeholder in the query allows users to specify the maximum dew point value for filtering the results.", "virtual_table": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.205", "db_id": "bike_1", "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.", "rationale": ["The query is identifying relevant tables, which are 'weather' and 'trip'.", "It selects the 'zip_code' from the 'weather' table, grouping by 'zip_code' and applying a condition to filter those with an average mean humidity below a specified value using a placeholder for numeric values.", "It intersects this with a selection from the 'trip' table, grouping by 'zip_code' and applying a condition to filter those with a count of trips greater than or equal to a specified value, also using a placeholder for numeric values."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "description": "This virtual table identifies zip codes where the average mean humidity is below a specified threshold and where the number of trips originating from those zip codes meets or exceeds a certain count. The placeholders in the HAVING clauses represent the humidity threshold and the minimum trip count, respectively.", "virtual_table": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.206", "db_id": "bike_1", "question": "What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?", "rationale": ["The query is identifying relevant tables, which are 'weather' and 'trip'.", "It selects the 'zip_code' from the 'weather' table, grouping by 'zip_code' and applying a condition to filter those with an average mean humidity below a specified number using a placeholder.", "It intersects this with a selection from the 'trip' table, grouping by 'zip_code' and applying a condition to filter those with a count of trips greater than or equal to a specified number using another placeholder."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "description": "This virtual table identifies zip codes where the average mean humidity is below a specified threshold and where the number of trips originating from those zip codes meets or exceeds a certain count. The placeholders in the HAVING clauses represent the humidity threshold and the minimum trip count, respectively.", "virtual_table": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.304", "db_id": "product_catalog", "question": "What are the attribute data types with more than 3 attribute definitions?", "rationale": ["The query identifies the relevant table, which is 'Attribute_Definitions'.", "It selects the 'attribute_data_type' column to display the various data types.", "The GROUP BY clause is used to group the results by 'attribute_data_type'.", "The HAVING clause filters the groups to include only those with a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  3", "source_tables": ["attribute_definitions"], "description": "This virtual table provides a summary of the different data types defined in the 'Attribute_Definitions' table, specifically those that have more than a specified number of occurrences. The placeholder in the HAVING clause represents the minimum count of attributes required to be included in the results.", "virtual_table": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.316", "db_id": "product_catalog", "question": "Find the entry names of the catalog with the attribute that have the most entries.", "rationale": ["The query identifies the relevant tables, 'Catalog_Contents' and 'Catalog_Contents_Additional_Attributes'.", "It selects the 'catalog_entry_name' from 'Catalog_Contents'.", "A JOIN is performed on 'catalog_entry_id' to link the two tables based on the catalog entry.", "A subquery is used to find the most common 'attribute_value' from 'Catalog_Contents_Additional_Attributes', grouping by 'attribute_value' and ordering by count to get the top results.", "The placeholder in the LIMIT clause allows the user to specify how many top attribute values they want to retrieve."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "description": "This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have the most common attribute values associated with them. The placeholder in the LIMIT clause represents the number of top attribute values to consider.", "virtual_table": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.317", "db_id": "product_catalog", "question": "What is the entry name of the most expensive catalog (in USD)?", "rationale": ["The query identifies the relevant table, which is 'Catalog_Contents'.", "Select the column to display, 'catalog_entry_name'.", "Order the results by 'price_in_dollars' in descending order to show the most expensive items first.", "Use a placeholder in the LIMIT clause to allow the user to specify how many entries they want to retrieve."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1", "source_tables": ["catalog_contents"], "description": "This virtual table provides a list of catalog entry names from the 'Catalog_Contents' table, ordered by their price in dollars in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of entries to retrieve.", "virtual_table": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.330", "db_id": "product_catalog", "question": "What are the names of catalog entries with level number 8?", "rationale": ["The query identifies the relevant tables, 'Catalog_Contents' and 'Catalog_Contents_Additional_Attributes'.", "It selects the 'catalog_entry_name' from 'Catalog_Contents'.", "A JOIN operation is performed to link 'Catalog_Contents' with 'Catalog_Contents_Additional_Attributes' based on the 'catalog_entry_id'.", "A condition is added to filter the results based on 'catalog_level_number' using a placeholder for string values."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  '8'", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "description": "This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.", "virtual_table": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.331", "db_id": "product_catalog", "question": "Find the names of the products with length smaller than 3 or height greater than 5.", "rationale": ["The query identifies the relevant table, which is 'Catalog_Contents'.", "Select the column to display, 'catalog_entry_name'.", "Add conditions to filter the entries based on their length and width using placeholders for numeric values."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "description": "This virtual table describes the names of catalog entries from the 'Catalog_Contents' table where the length of the entry is less than a specified value or the width is greater than a specified value. The placeholders in the WHERE clause represent the numeric values for length and width.", "virtual_table": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  [PLACEHOLDER-TYPE:NUMBER] OR width  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.332", "db_id": "product_catalog", "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.", "rationale": ["The query identifies the relevant table, which is 'Catalog_Contents'.", "Select the column to display, 'catalog_entry_name'.", "Add a condition to filter the entries based on their 'length' and 'width' using placeholders for numeric values."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "description": "This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that meet specific dimensional criteria. The placeholders in the WHERE clause represent the maximum length and minimum width measurements for filtering the catalog entries.", "virtual_table": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  [PLACEHOLDER-TYPE:NUMBER] OR width  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.338", "db_id": "product_catalog", "question": "On which days more than one revisions were made on catalogs.", "rationale": ["The query identifies the relevant table, which is 'Catalogs'.", "It selects the 'date_of_latest_revision' column to display the latest revision dates.", "The results are grouped by 'date_of_latest_revision' to aggregate the data based on this column.", "The HAVING clause is used to filter the groups, ensuring only those with a count greater than the specified placeholder are included."], "gold_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1", "source_tables": ["catalogs"], "description": "This virtual table provides the latest revision dates of catalogs from the 'Catalogs' table, grouped by the revision date. The placeholder in the HAVING clause represents the minimum count of catalogs that must share the same revision date to be included in the results.", "virtual_table": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["The query is identifying the relevant table, which is 'Flight'.", "Select the column to display, 'origin'.", "Add a condition to filter the 'destination' column for the specified destination using a placeholder for string values."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "description": "This virtual table describes the origins of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.", "virtual_table": "SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "Select the columns to display, 'departure_date' and 'arrival_date'.", "Add conditions to filter the 'origin' and 'destination' columns for the specified locations using placeholders for string values."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "description": "This virtual table provides the scheduled departure and arrival dates of flights from the 'Flight' table that originate from a specific location and head to a specific destination. The placeholders in the WHERE clause represent the origin and destination locations.", "virtual_table": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING] AND destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "It selects the average of the 'price' column to compute the average ticket price.", "Conditions are added to filter the results based on the specified 'origin' and 'destination' using placeholders for string values."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "description": "This virtual table calculates the average ticket price for flights originating from a specific location and heading to a designated destination. The placeholders in the WHERE clause represent the origin and destination of the flights.", "virtual_table": "SELECT avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING] AND destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["The query identifies the relevant tables, which are 'Flight' and 'Aircraft'.", "It selects the 'name' column from the 'Aircraft' table and counts the number of flights associated with each aircraft.", "A JOIN operation is performed on the 'aid' column to link flights with their respective aircraft.", "The results are grouped by the 'aid' to aggregate the flight counts for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "description": "This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.", "virtual_table": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["The query identifies the relevant tables, which are 'Flight' and 'Aircraft'.", "It selects the 'name' column from the 'Aircraft' table and counts the number of flights associated with each aircraft.", "A JOIN operation is performed on the 'aid' column to link flights with their respective aircraft.", "The results are grouped by the 'aid' to aggregate the flight counts for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "description": "This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.", "virtual_table": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["The query identifies the relevant table, which is 'Employee'.", "It selects the 'name' column to display the names of employees.", "The EXCEPT clause is used to exclude employees who hold a certificate for a specific aircraft model.", "A JOIN operation is performed between 'Employee', 'Certificate', and 'Aircraft' to filter out employees based on the aircraft model using a placeholder for string values."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "description": "This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.", "virtual_table": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["The query identifies the relevant tables, which are 'Certificate' and 'Aircraft'.", "It selects the 'name' column from the 'Aircraft' table.", "The query performs a JOIN operation on the 'aid' column to link certificates to their respective aircraft.", "Results are grouped by 'aid' to aggregate the count of certificates for each aircraft.", "The results are ordered by the count of certificates in descending order to show the most certified aircraft first.", "A placeholder is included in the LIMIT clause to allow the user to specify how many results they want."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "description": "This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.432", "db_id": "flight_1", "question": "What are the names of the aircraft that the least people are certified to fly?", "rationale": ["The query identifies the relevant tables, which are 'Certificate' and 'Aircraft'.", "It selects the 'name' column from the 'Aircraft' table.", "The query performs a JOIN operation between 'Certificate' and 'Aircraft' on the aircraft ID to link certificates to their respective aircraft.", "It groups the results by the aircraft ID to aggregate the count of certificates for each aircraft.", "The results are ordered by the count of certificates in descending order to prioritize aircraft with the most certifications.", "A placeholder is included in the LIMIT clause to allow the user to specify how many aircraft names to return."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "description": "This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of aircraft names to return.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["The query identifies the relevant tables: 'Employee', 'Certificate', and 'Aircraft'.", "It selects the 'name' column from the 'Employee' table.", "The query joins the 'Employee' table with the 'Certificate' table on the employee ID, and then joins the 'Certificate' table with the 'Aircraft' table on the aircraft ID.", "A condition is added to filter aircraft based on their maximum travel distance using a placeholder for numeric values.", "The results are grouped by employee ID to count the number of certificates held by each employee.", "The results are ordered in descending order based on the count of certificates, and a limit is applied to restrict the number of results returned."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "description": "This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.", "virtual_table": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects distinct values from the 'allergy' column to avoid duplicates.", "A condition is added to filter the results based on the 'AllergyType' column using a placeholder for string values."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "description": "This virtual table provides a list of distinct allergies from the 'Allergy_Type' table that belong to a specific category of allergies. The placeholder in the WHERE clause represents the type of allergy being queried.", "virtual_table": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.452", "db_id": "allergy_1", "question": "How many animal type allergies exist?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects the count of records to determine how many allergies fall under a specific type.", "A condition is added to filter the 'AllergyType' column for the specified allergy type using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  'animal'", "source_tables": ["allergy_type"], "description": "This virtual table provides the count of different allergies categorized under a specific type from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the allergy type being queried.", "virtual_table": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects the 'allergytype' column to display the types of allergies.", "The query groups the results by 'allergytype' to aggregate the data.", "It orders the results by the count of occurrences in descending order to show the most common types first.", "The LIMIT clause uses a placeholder for numeric values to specify how many types to return."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "description": "This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.", "virtual_table": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects the 'allergytype' column to display the types of allergies.", "The results are grouped by 'allergytype' to aggregate similar types together.", "The results are ordered by the count of occurrences in ascending order to show the least common allergy types first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "description": "This virtual table provides a list of allergy types from the 'Allergy_Type' table, grouped by their category. The results are ordered by the count of occurrences in ascending order, with a limit set by a placeholder for numeric values.", "virtual_table": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'Fname' and 'Lname', which represent the first and last names of the students."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "description": "The virtual table describes the first and last names of students from the 'Student' table. The query does not include any filtering conditions, allowing for the retrieval of all students' names.", "virtual_table": "SELECT Fname ,  Lname FROM Student"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["The query is identifying the relevant table, which is 'Student'.", "Select the column to display, 'StuID', which is the unique identifier for each student.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "description": "This virtual table lists the unique identifiers of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT StuID FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the 'major' column to display.", "Group the results by 'major' to aggregate the data.", "Order the results by the count of students in each major in descending order to show the most popular majors first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of academic majors from the 'Student' table, grouped by the major name. The results are ordered by the number of students in each major in descending order, with a limit set by a placeholder for numeric values to specify how many top majors to return.", "virtual_table": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.502", "db_id": "allergy_1", "question": "Give the advisor with the most students.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the column to display, 'advisor'.", "Group the results by the 'advisor' column to aggregate the data.", "Order the results by the count of students associated with each advisor in descending order.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of academic advisors from the 'Student' table, grouped by the advisor's name. The results are ordered by the number of students assigned to each advisor in descending order, with a limit on the number of advisors returned, specified by a placeholder for numeric values.", "virtual_table": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["The query identifies the relevant table, which is 'Has_Allergy'.", "It selects the count of records to determine how many students have a specific allergy.", "A condition is added to filter the 'Allergy' column for the specified allergy using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "description": "This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.", "virtual_table": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["The query identifies the relevant table, which is 'Has_Allergy'.", "It selects the count of records to determine how many students have a specific allergy.", "A condition is added to filter the 'Allergy' column for the specified allergy using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "description": "This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.", "virtual_table": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["The query identifies the relevant tables, 'Has_Allergy' and 'Student', and uses a JOIN to combine them based on the student ID.", "It selects a count of records to determine how many students meet the criteria.", "The WHERE clause filters the results based on the gender of the students and the specific allergies, using placeholders for these values."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies being queried.", "virtual_table": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.514", "db_id": "allergy_1", "question": "Which allergy is the most common?", "rationale": ["The query identifies the relevant table, which is 'Has_Allergy'.", "It selects the 'Allergy' column to display the names of allergies.", "The GROUP BY clause is used to group the results by the 'Allergy' name.", "The ORDER BY clause sorts the results based on the count of occurrences in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many results they want to see."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "description": "This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.", "virtual_table": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'LName' and 'Age'.", "Add a condition to filter students based on their allergies using a subquery that checks for students with both specified allergies using the INTERSECT operator. The placeholders represent the names of the allergies."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.", "virtual_table": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'lname' and 'age'.", "Add a condition to filter students based on their allergies using a subquery that checks for students with both specified allergies using the INTERSECT operator. The placeholders represent the names of the allergies."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.", "virtual_table": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.523", "db_id": "allergy_1", "question": "Find the first name and gender of the student who has allergy to milk but not cat.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'sex'.", "Use a subquery to filter students based on their allergies from the 'Has_Allergy' table.", "The first part of the subquery selects students with a specific allergy using a placeholder for string values.", "The second part of the subquery excludes students with another specified allergy using another placeholder for string values."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.", "virtual_table": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.524", "db_id": "allergy_1", "question": "What are the first name and gender of the students who have allergy to milk but can put up with cats?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'sex'.", "Use a subquery to filter students based on their allergies from the 'Has_Allergy' table.", "The first part of the subquery selects students with a specific allergy using a placeholder for string values.", "The second part of the subquery excludes students with another specified allergy using another placeholder for string values."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.", "virtual_table": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["The query identifies the relevant table, which is 'Student', to calculate the average age.", "It uses a subquery to find students who have allergies of a specific type by joining 'Has_Allergy' and 'Allergy_Type'.", "The INTERSECT operator is used to ensure that only students with both specified allergy types are considered.", "Finally, the average age is calculated for the filtered list of students."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.", "virtual_table": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'lname'.", "Add a condition to filter out students whose IDs are in a subquery.", "The subquery selects student IDs from 'Has_Allergy' joined with 'Allergy_Type' where the allergy type matches the specified placeholder."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.", "virtual_table": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It counts the total number of students that meet certain criteria.", "The first condition filters students based on their gender using a placeholder for string values.", "The second condition checks if the student's ID is in a subquery that joins 'Has_Allergy' and 'Allergy_Type' to filter allergies by a specific type, using another placeholder for string values."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.", "virtual_table": "SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["The query identifies the relevant tables, which are 'Student' and 'Has_Allergy'.", "It selects distinct values for the 'fname' and 'city_code' columns from the 'Student' table.", "A JOIN operation is performed between 'Student' and 'Has_Allergy' on the 'StuID' column to link students with their allergies.", "The WHERE clause filters the results based on the specified allergies using placeholders for string values."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.", "virtual_table": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["The query identifies the relevant tables, which are 'Student' and 'Has_Allergy'.", "It selects the distinct first names and city codes from the 'Student' table.", "A JOIN operation is performed between 'Student' and 'Has_Allergy' on the student ID to link students with their allergies.", "The WHERE clause filters the results to include only those students who have one of the specified allergies, using placeholders for the allergy names."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides a distinct list of first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies that are being queried.", "virtual_table": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_country' and calculates the average of the 'total' column.", "The results are grouped by 'billing_country' to get the average total for each country.", "The results are ordered in descending order based on the average total amount.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "description": "This virtual table provides the average total amount of invoices grouped by billing country. The results are ordered in descending order based on the average total, and a placeholder is included to limit the number of results returned.", "virtual_table": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' column and counts the number of invoices for each state.", "A condition is added to filter the results based on the 'billing_country' using a placeholder for string values.", "The results are grouped by 'billing_state' to provide a count of invoices per state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "description": "This virtual table summarizes the number of invoices issued in each state for a specific country. The placeholder in the WHERE clause represents the name of the country for which the invoice data is being aggregated.", "virtual_table": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state;"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' and counts the number of invoices for each state.", "A condition is added to filter the results based on the specified 'billing_country' using a placeholder for string values.", "The results are grouped by 'billing_state' to aggregate the counts.", "The results are ordered by the count of invoices in descending order to show the states with the most invoices first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "description": "This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country for which the invoice counts are being aggregated, while the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.", "virtual_table": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.568", "db_id": "store_1", "question": "What is the number of invoices and total money billed in them from CA?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' column, counts the number of invoices, and sums the total amount for those invoices.", "A condition is added to filter the results based on the specified billing state using a placeholder for string values."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "description": "This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.", "virtual_table": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["The query is identifying the relevant table, which is 'customers'.", "Select the columns to display, 'email' and 'phone'.", "Add a condition to filter the 'first_name' and 'last_name' columns for the specified customer using placeholders for string values."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "description": "This virtual table describes the email addresses and phone numbers of customers from the 'customers' table who have a specific first and last name. The placeholders in the WHERE clause represent the customer's first and last names.", "virtual_table": "SELECT email ,  phone FROM customers WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["The query identifies the relevant table, which is 'customers'.", "It counts the total number of entries using count(*).", "A condition is added to filter the results based on the 'state' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "description": "This virtual table provides the total number of customers from the 'customers' table who reside in a specific state. The placeholder in the WHERE clause represents the state name.", "virtual_table": "SELECT count(*) FROM customers WHERE state = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'customers'.", "It selects the 'first_name' and 'last_name' columns from the 'employees' table, aliased as T1.", "A JOIN operation is performed between 'employees' and 'customers' on the condition that the employee's ID matches the support representative ID in the customers table.", "The results are grouped by the employee's ID to aggregate the number of customers they support.", "The results are ordered by the count of customers in descending order to show the most supported employees first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "description": "This virtual table provides the first and last names of employees who serve as support representatives for customers. The results are grouped by the employee's unique identifier and ordered by the number of customers they support in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["The query identifies the relevant tables, which are 'customers' and 'invoices'.", "It uses a JOIN operation to link the 'customers' table with the 'invoices' table based on the customer ID.", "The SELECT statement counts the total number of invoices for the specified customer.", "The WHERE clause filters the results based on the customer's first and last name using placeholders for string values."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "description": "This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.", "virtual_table": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["The query identifies the relevant tables, which are 'albums' and 'tracks'.", "It selects the 'title' column from the 'albums' table.", "A JOIN is performed between 'albums' and 'tracks' on the condition that the album's ID matches the genre ID of the track, which is likely a mistake since it should match the album ID instead.", "A condition is added to filter the tracks by their name using a placeholder for string values."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "description": "This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.", "virtual_table": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.626", "db_id": "store_1", "question": "What is the name of all tracks in the album named Balls to the Wall?", "rationale": ["The query identifies the relevant tables, which are 'albums' and 'tracks'.", "It selects the 'name' column from the 'tracks' table.", "A JOIN operation is performed on the 'albums' and 'tracks' tables using the album's ID and the genre ID.", "A condition is added to filter the results based on the specified album title using a placeholder for string values."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "description": "This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.", "virtual_table": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.630", "db_id": "store_1", "question": "What are the names of all Rock tracks that are stored on MPEG audio files?", "rationale": ["The query identifies the relevant tables: 'genres', 'tracks', and 'media_types'.", "It selects the 'name' column from the 'tracks' table.", "The JOIN operations link the 'tracks' table to the 'genres' and 'media_types' tables based on their respective foreign keys.", "Conditions are added to filter the results based on the specified genre and media type using placeholders for string values."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "description": "This virtual table describes the names of tracks from the 'tracks' table that belong to a specific genre and media type. The placeholders in the WHERE clause represent the genre's name and the media type's name.", "virtual_table": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = [PLACEHOLDER-TYPE:STRING] AND T3.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["The query identifies the relevant tables: 'genres', 'tracks', and 'media_types'.", "It selects the 'name' column from the 'tracks' table (aliased as T2).", "It joins the 'genres' table (aliased as T1) on the genre ID to filter tracks by genre.", "It also joins the 'media_types' table (aliased as T3) on the media type ID to filter tracks by media type.", "The WHERE clause includes conditions to filter by the specified genre name or media type name using placeholders for string values."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "description": "This virtual table describes the names of tracks from the 'tracks' table that belong to a specific genre or media type. The placeholders in the WHERE clause represent the genre's name and the media type's name.", "virtual_table": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = [PLACEHOLDER-TYPE:STRING] OR T3.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["The query identifies the relevant tables: 'tracks', 'invoice_lines', 'invoices', and 'customers'.", "It selects the 'name' column from the 'tracks' table.", "The query uses JOIN operations to connect 'tracks' with 'invoice_lines', 'invoices', and 'customers' based on their respective identifiers.", "A condition is added to filter the results based on the customer's first and last names using placeholders for string values."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "description": "This virtual table describes the names of tracks from the 'tracks' table that have been purchased by a specific customer. The query joins multiple tables to filter the results based on the customer's first and last names, represented by placeholders in the WHERE clause.", "virtual_table": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = [PLACEHOLDER-TYPE:STRING] AND T4.last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.686", "db_id": "customers_card_transactions", "question": "What are the full names of customers who do not have any accounts?", "rationale": ["The query identifies the relevant table, which is 'Customers', to select customer names.", "It uses the EXCEPT clause to filter out customers who have accounts by joining 'Customers' with 'Accounts' on 'customer_id'.", "The selected columns are 'customer_first_name' and 'customer_last_name' from the 'Customers' table."], "gold_sql": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "description": "This virtual table provides a list of customers who do not have any associated accounts. It selects the first and last names of customers from the 'Customers' table and excludes those who have accounts by performing an EXCEPT operation with a subquery that joins the 'Customers' table with the 'Accounts' table based on the customer ID.", "virtual_table": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id"}
{"sample_id": "train.688", "db_id": "customers_card_transactions", "question": "What are the full names of customers who have accounts?", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Accounts'.", "It selects distinct values for 'customer_first_name' and 'customer_last_name' to avoid duplicates.", "A JOIN operation is performed on the 'customer_id' to link customers with their accounts, ensuring that only customers with accounts are included."], "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "description": "This virtual table provides a distinct list of first and last names of customers from the 'Customers' table who have associated accounts in the 'Accounts' table. The join condition links the customer to their respective account using the customer identifier.", "virtual_table": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id"}
{"sample_id": "train.704", "db_id": "customers_card_transactions", "question": "Return the full name and phone of the customer who has card number 4560596484842.", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customers_Cards'.", "It selects the columns to display: 'customer_first_name', 'customer_last_name', and 'customer_phone'.", "A JOIN operation is performed to link 'Customers_Cards' with 'Customers' based on the 'customer_id'.", "A condition is added to filter the 'card_number' column for the specified card number using a placeholder for string values."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.card_number  =  '4560596484842'", "source_tables": ["customers", "customers_cards"], "description": "This virtual table describes the first and last names, as well as the phone number of customers associated with a specific card number from the 'Customers' and 'Customers_Cards' tables. The placeholder in the WHERE clause represents the card number being queried.", "virtual_table": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.card_number  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.717", "db_id": "customers_card_transactions", "question": "What is the customer id, first and last name with least number of accounts.", "rationale": ["The query identifies the relevant tables, 'Customers_cards' and 'Customers'.", "It selects the 'customer_id', 'customer_first_name', and 'customer_last_name' columns to display.", "A JOIN operation is performed to link 'Customers_cards' with 'Customers' based on the 'customer_id'.", "The results are grouped by 'customer_id' to aggregate the data accordingly.", "The results are ordered by the count of associated cards in ascending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "description": "This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have associated cards in the 'Customers_Cards' table. The results are grouped by customer ID and ordered by the count of associated cards in ascending order, with a limit on the number of results returned as specified by the placeholder.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.718", "db_id": "customers_card_transactions", "question": "Return the id and full name of the customer who has the fewest accounts.", "rationale": ["The query identifies the relevant tables, 'Customers_cards' and 'Customers'.", "It selects the 'customer_id', 'customer_first_name', and 'customer_last_name' columns to display.", "A JOIN operation is performed on 'customer_id' to link the two tables together.", "The results are grouped by 'customer_id' to aggregate the data based on the number of cards each customer has.", "The results are ordered by the count of associated cards in ascending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "description": "This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, based on the associated cards in the 'Customers_Cards' table. The results are grouped by customer ID and ordered by the count of associated cards in ascending order, with a limit specified by a placeholder for numeric values.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.721", "db_id": "customers_card_transactions", "question": "What is the card type code with most number of cards?", "rationale": ["The query identifies the relevant table, which is 'Customers_Cards'.", "It selects the 'card_type_code' to display the types of cards.", "The GROUP BY clause is used to aggregate the results by 'card_type_code'.", "The ORDER BY clause sorts the results based on the count of each card type in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many card types to return."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "description": "This virtual table summarizes the different types of cards issued to customers by counting the occurrences of each card type. The placeholder in the LIMIT clause allows the user to specify the maximum number of card types to retrieve, sorted by the most common types first.", "virtual_table": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.735", "db_id": "customers_card_transactions", "question": "Show the number of transaction types.", "rationale": ["The query identifies the relevant table, which is 'Financial_Transactions'.", "It selects a count of distinct values from the 'transaction_type' column to determine the number of unique transaction types.", "The use of the DISTINCT keyword ensures that only unique transaction types are counted."], "gold_sql": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions", "source_tables": ["financial_transactions"], "description": "This virtual table provides a count of distinct transaction types recorded in the 'Financial_Transactions' table. The result will indicate how many unique types of transactions (such as debit or credit) have been made.", "virtual_table": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions"}
{"sample_id": "train.743", "db_id": "customers_card_transactions", "question": "What is the transaction type that has processed the greatest total amount in transactions?", "rationale": ["The query identifies the relevant table, which is 'Financial_Transactions'.", "It selects the 'transaction_type' column to display the different types of transactions.", "The results are grouped by 'transaction_type' to aggregate the data accordingly.", "The ordering is done based on the sum of 'transaction_amount' in descending order to show the most significant transaction types first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1", "source_tables": ["financial_transactions"], "description": "This virtual table summarizes the types of transactions recorded in the 'Financial_Transactions' table, grouping them by their type and ordering the results by the total amount of each transaction type in descending order. The placeholder in the LIMIT clause represents the maximum number of transaction types to display.", "virtual_table": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.893", "db_id": "insurance_fnol", "question": "What are the customer phone numbers under the policy \"Life Insurance\"?", "rationale": ["The query is identifying the relevant table, which is 'Available_Policies'.", "Select the column to display, 'Customer_Phone'.", "Add a condition to filter the 'policy_type_code' column for the specified policy type using a placeholder for string values."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "description": "This virtual table describes the contact phone numbers of customers from the 'Available_Policies' table who have a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code.", "virtual_table": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.895", "db_id": "insurance_fnol", "question": "Which policy type has the most records in the database?", "rationale": ["The query identifies the relevant table, which is 'Available_Policies'.", "It selects the 'policy_type_code' column to display the types of policies.", "The query groups the results by 'policy_type_code' to aggregate similar types together.", "It orders the grouped results by their count in descending order to show the most common types first.", "The LIMIT clause is used to restrict the number of results returned, with a placeholder for the maximum number of types to display."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "description": "This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.", "virtual_table": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.897", "db_id": "insurance_fnol", "question": "What are all the customer phone numbers under the most popular policy type?", "rationale": ["The query identifies the relevant table, which is 'Available_Policies'.", "It selects the 'customer_phone' column to display the contact information.", "A subquery is used to find the most common 'policy_type_code' by grouping and counting occurrences, with a limit specified by a placeholder for numeric values."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "description": "This virtual table retrieves the contact phone numbers of customers from the 'Available_Policies' table who have the most common type of insurance policy. The placeholder in the subquery represents the limit for the number of policy types to consider, allowing users to specify how many of the top policy types they want to retrieve phone numbers for.", "virtual_table": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.898", "db_id": "insurance_fnol", "question": "Find the phone numbers of customers using the most common policy type among the available policies.", "rationale": ["The query identifies the relevant table, which is 'Available_Policies'.", "It selects the 'customer_phone' column to display the contact numbers of customers.", "A subquery is used to find the most common policy type by grouping the 'policy_type_code' and ordering them by their count in descending order.", "The placeholder in the LIMIT clause allows the user to specify how many of the top policy types to consider."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "description": "The virtual table describes the contact phone numbers of customers associated with the most common type of insurance policy from the 'Available_Policies' table. The placeholder in the subquery represents the limit for the number of policy types to consider, allowing the user to specify how many of the top policy types they want to retrieve.", "virtual_table": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.1060", "db_id": "match_season", "question": "Show the players from college UCLA.", "rationale": ["The query is identifying the relevant table, which is 'match_season'.", "Select the column to display, 'Player'.", "Add a condition to filter the 'College' column for the specified college using a placeholder for string values."], "gold_sql": "SELECT Player FROM match_season WHERE College  =  'UCLA'", "source_tables": ["match_season"], "description": "This virtual table describes the players who participated in matches during a specific season and attended a particular college. The placeholder in the WHERE clause represents the name of the college.", "virtual_table": "SELECT Player FROM match_season WHERE College  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1082", "db_id": "match_season", "question": "Show the season, the player, and the name of the team that players belong to.", "rationale": ["The query identifies the relevant tables, 'match_season' and 'team'.", "It selects the columns 'Season' and 'Player' from the 'match_season' table (aliased as T1) and 'Name' from the 'team' table (aliased as T2).", "A JOIN operation is performed on the 'Team' column from 'match_season' and 'Team_id' from 'team' to link players with their respective teams."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "description": "This virtual table provides a summary of match seasons, including the season name, player names, and their corresponding team names. The data is retrieved from the 'match_season' table, which is joined with the 'team' table to associate players with their teams.", "virtual_table": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id"}
{"sample_id": "train.1092", "db_id": "match_season", "question": "Show the country names and the corresponding number of players.", "rationale": ["The query identifies the relevant tables, which are 'country' and 'match_season'.", "It selects the 'Country_name' from the 'country' table and counts the number of matches from the 'match_season' table.", "A JOIN operation is performed on the 'Country_id' from the 'country' table and the 'Country' from the 'match_season' table to link the data.", "The results are grouped by 'Country_name' to provide a count of matches for each country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "description": "This virtual table provides a count of matches played by players from each country, by joining the 'country' table with the 'match_season' table. The placeholder in the SELECT clause represents the country names, and the COUNT function aggregates the number of matches for each country.", "virtual_table": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name"}
{"sample_id": "train.1098", "db_id": "match_season", "question": "Show the top 3 most common colleges of players in match seasons.", "rationale": ["The query identifies the relevant table, which is 'match_season'.", "Select the 'College' column to display the colleges of players.", "Group the results by 'College' to aggregate the data based on the number of players from each college.", "Order the results by the count of players in descending order to show the most represented colleges first.", "Limit the number of results returned based on a specified number using a placeholder for numeric values."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "description": "This virtual table provides a list of colleges from which players have participated in matches during a specific season. The results are grouped by college and ordered by the number of players associated with each college, with a limit on the number of colleges returned as specified by the placeholder.", "virtual_table": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1099", "db_id": "match_season", "question": "What are the three colleges from which the most players are from?", "rationale": ["The query identifies the relevant table, which is 'match_season'.", "It selects the 'College' column to display the colleges of players.", "The results are grouped by 'College' to aggregate the data.", "The results are ordered by the count of players associated with each college in descending order.", "A limit is applied to restrict the number of colleges returned based on a placeholder for numeric values."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "description": "This virtual table provides a list of colleges from which players have participated in matches during a specific season. The results are grouped by college and ordered by the number of players associated with each college, with a limit on the number of colleges returned based on the specified number.", "virtual_table": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1107", "db_id": "match_season", "question": "Return the names of countries that have players that play the Forward position, as well as players who play the Defender position.", "rationale": ["The query is identifying the relevant tables, which are 'country' and 'match_season'.", "It selects the 'Country_name' from the 'country' table.", "The join condition links the 'Country_id' from the 'country' table to the 'Country' in the 'match_season' table.", "The query filters the results based on the 'Position' column in the 'match_season' table using a placeholder for string values.", "The use of INTERSECT allows for the selection of countries where players have the same specified position in two different instances."], "gold_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "description": "This virtual table identifies the names of countries represented by players who occupy a specific position in matches. It uses an intersection to find countries where players have the same position, allowing for a comparison of two different instances of that position. The placeholders in the query represent the position of the players being filtered.", "virtual_table": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1109", "db_id": "match_season", "question": "Return the colleges that have players who play the Midfielder position, as well as players who play the Defender position.", "rationale": ["The query identifies the relevant table, which is 'match_season'.", "It selects the 'College' column to display the colleges attended by players.", "The INTERSECT operator is used to find common colleges attended by players in two different positions, with placeholders for the positions specified in the WHERE clause."], "gold_sql": "SELECT College FROM match_season WHERE POSITION  =  'Midfielder' INTERSECT SELECT College FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "description": "This virtual table retrieves the colleges attended by players who have played in two different positions during the match season. The placeholders in the WHERE clause represent the specific positions of the players being compared.", "virtual_table": "SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1222", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with type code \"Duplex\"?", "rationale": ["The query identifies the relevant tables, 'Apartment_Bookings' and 'Apartments'.", "It selects the 'booking_start_date' from the 'Apartment_Bookings' table.", "A JOIN is performed on the 'apt_id' to link bookings to their respective apartments.", "A condition is added to filter the results based on the 'apt_type_code' using a placeholder for string values."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  'Duplex'", "source_tables": ["apartment_bookings", "apartments"], "description": "This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments of a specific type. The placeholder in the WHERE clause represents the apartment type code.", "virtual_table": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1224", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with more than 2 bedrooms?", "rationale": ["The query identifies the relevant tables, 'Apartment_Bookings' and 'Apartments'.", "It selects the 'booking_start_date' from the 'Apartment_Bookings' table.", "A JOIN operation is performed to link 'Apartment_Bookings' with 'Apartments' based on the apartment ID.", "A condition is added to filter the results based on the number of bedrooms in the 'Apartments' table using a placeholder for numeric values."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "description": "This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments being queried.", "virtual_table": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1225", "db_id": "apartment_rentals", "question": "Find the booking start date and end date for the apartments that have more than two bedrooms.", "rationale": ["The query identifies the relevant tables, 'Apartment_Bookings' and 'Apartments'.", "It selects the 'booking_start_date' from the 'Apartment_Bookings' table.", "A JOIN operation is performed to link 'Apartment_Bookings' with 'Apartments' based on the apartment ID.", "A condition is added to filter the results based on the number of bedrooms in the 'Apartments' table using a placeholder for numeric values."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "description": "This virtual table provides the start dates of apartment bookings from the 'Apartment_Bookings' table for apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments being queried.", "virtual_table": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1229", "db_id": "apartment_rentals", "question": "Which apartments have bookings with status code \"Confirmed\"? Return their apartment numbers.", "rationale": ["The query identifies the relevant tables, 'Apartment_Bookings' and 'Apartments'.", "It uses a JOIN operation to link the two tables based on the apartment ID.", "The SELECT DISTINCT clause is used to ensure that only unique apartment numbers are returned.", "A condition is added to filter the results based on the booking status code using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  'Confirmed'", "source_tables": ["apartment_bookings", "apartments"], "description": "This virtual table provides a list of unique apartment numbers from the 'Apartments' table that are associated with bookings having a specific status. The placeholder in the WHERE clause represents the booking status code.", "virtual_table": "SELECT DISTINCT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1232", "db_id": "apartment_rentals", "question": "Show the guest first names, start dates, and end dates of all the apartment bookings.", "rationale": ["The query identifies the relevant tables, 'Apartment_Bookings' and 'Guests'.", "It selects the 'guest_first_name' from the 'Guests' table and 'booking_start_date' from the 'Apartment_Bookings' table.", "A JOIN operation is performed on the 'guest_id' to link the bookings with the corresponding guests, allowing us to retrieve guest information related to their bookings."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "description": "This virtual table provides the first names of guests along with the start dates of their apartment bookings. The placeholders in the query allow for filtering or additional conditions to be applied as needed.", "virtual_table": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id"}
{"sample_id": "train.1234", "db_id": "apartment_rentals", "question": "Show the start dates and end dates of all the apartment bookings made by guests with gender code \"Female\".", "rationale": ["The query identifies the relevant tables, which are 'Apartment_Bookings' and 'Guests'.", "It selects the 'booking_start_date' and 'booking_end_date' columns from the 'Apartment_Bookings' table.", "A JOIN operation is performed between 'Apartment_Bookings' and 'Guests' on the 'guest_id' to link bookings to guests.", "A condition is added to filter the results based on the 'gender_code' of the guests using a placeholder for string values."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  'Female'", "source_tables": ["apartment_bookings", "guests"], "description": "This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.", "virtual_table": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1238", "db_id": "apartment_rentals", "question": "Show the facility codes of apartments with more than 4 bedrooms.", "rationale": ["The query identifies the relevant tables, which are 'Apartment_Facilities' and 'Apartments'.", "It selects the 'facility_code' from the 'Apartment_Facilities' table.", "A JOIN operation is performed between 'Apartment_Facilities' and 'Apartments' on the 'apt_id' to link facilities to their respective apartments.", "A condition is added to filter the results based on the 'bedroom_count' in the 'Apartments' table, using a placeholder for numeric values."], "gold_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "source_tables": ["apartments", "apartment_facilities"], "description": "This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.", "virtual_table": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1256", "db_id": "apartment_rentals", "question": "Show the top 3 apartment type codes sorted by the average number of rooms in descending order.", "rationale": ["The query identifies the relevant table, which is 'Apartments'.", "It selects the 'apt_type_code' to show the different types of apartments.", "The results are grouped by 'apt_type_code' to aggregate the data based on apartment types.", "The average number of rooms is calculated using 'avg(room_count)' to order the types by their spaciousness.", "The LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "source_tables": ["apartments"], "description": "This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments are more spacious on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to be displayed.", "virtual_table": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1258", "db_id": "apartment_rentals", "question": "Show the apartment type code that has the largest number of total rooms, together with the number of bathrooms and number of bedrooms.", "rationale": ["The query identifies the relevant table, which is 'Apartments'.", "Selects the columns 'apt_type_code', 'bathroom_count', and 'bedroom_count' to display.", "Groups the results by 'apt_type_code' to aggregate data for each type of apartment.", "Orders the results by the sum of 'room_count' in descending order to prioritize types with more rooms.", "Limits the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "source_tables": ["apartments"], "description": "This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1261", "db_id": "apartment_rentals", "question": "Which apartment type code appears the most often?", "rationale": ["The query identifies the relevant table, which is 'Apartments'.", "It selects the 'apt_type_code' to show the different types of apartments.", "The GROUP BY clause is used to group the results by 'apt_type_code'.", "The ORDER BY clause sorts the grouped results by the count of apartments in each type in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many types of apartments they want to see."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "description": "This virtual table provides a summary of the different types of apartments available in the 'Apartments' table. It groups the apartments by their type code and orders them by the number of apartments of each type in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of apartment types to retrieve.", "virtual_table": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1262", "db_id": "apartment_rentals", "question": "Show the most common apartment type code among apartments with more than 1 bathroom.", "rationale": ["The query identifies the relevant table, which is 'Apartments'.", "It selects the 'apt_type_code' to display the types of apartments.", "A condition is added to filter the results based on the number of bathrooms using a placeholder for numeric values.", "The results are grouped by 'apt_type_code' to aggregate the counts of each type.", "The results are ordered by the count of apartments in descending order to show the most common types first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "description": "This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count criteria. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.", "virtual_table": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1272", "db_id": "apartment_rentals", "question": "Show the apartment numbers of apartments with unit status availability of both 0 and 1.", "rationale": ["The query identifies the relevant tables, which are 'Apartments' and 'View_Unit_Status'.", "It selects the 'apt_number' column from the 'Apartments' table.", "The JOIN operation links the two tables on the 'apt_id' column to combine their data.", "The WHERE clause filters the results based on the availability status using a placeholder for numeric values.", "The INTERSECT operation is used to find common apartment numbers that meet the availability criteria in both parts of the query."], "gold_sql": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1", "source_tables": ["view_unit_status", "apartments"], "description": "This virtual table describes the apartment numbers from the 'Apartments' table that are available based on a specific availability status. The query uses an INTERSECT operation to find common apartment numbers that meet the availability criteria specified by the placeholders.", "virtual_table": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1294", "db_id": "soccer_1", "question": "How many leagues are there in England?", "rationale": ["The query identifies the relevant tables, which are 'Country' and 'League'.", "It uses a JOIN operation to connect the 'Country' table with the 'League' table based on the country ID.", "The SELECT statement counts the number of leagues that match the specified country name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Country AS T1 JOIN League AS T2 ON T1.id  =  T2.country_id WHERE T1.name  =  'England'", "source_tables": ["country", "league"], "description": "This virtual table provides the count of leagues associated with a specific country from the 'Country' and 'League' tables. The placeholder in the WHERE clause represents the name of the country for which the league count is being queried.", "virtual_table": "SELECT count(*) FROM Country AS T1 JOIN League AS T2 ON T1.id  =  T2.country_id WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1303", "db_id": "soccer_1", "question": "List all of the player ids with a height of at least 180cm and an overall rating higher than 85.", "rationale": ["The query starts by selecting the 'player_api_id' from the 'Player' table.", "It applies a condition to filter players whose height is greater than or equal to a specified number using a placeholder for numeric values.", "Next, it selects 'player_api_id' from the 'Player_Attributes' table, filtering for players with an overall rating greater than a specified number, again using a placeholder for numeric values.", "The INTERSECT operator is used to find players that meet both criteria, ensuring that only those who are both tall and highly rated are included in the result."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE overall_rating  >  85", "source_tables": ["player_attributes", "player"], "description": "This virtual table identifies players from the 'Player' table who meet specific physical and skill criteria. The first part of the query filters players based on their height, while the second part filters players based on their overall skill rating. The intersection of these two sets of players is returned, represented by the player_api_id.", "virtual_table": "SELECT player_api_id FROM Player WHERE height  >=  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT player_api_id FROM Player_Attributes WHERE overall_rating  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1304", "db_id": "soccer_1", "question": "List all of the ids for left-footed players with a height between 180cm and 190cm.", "rationale": ["The query starts by selecting the 'player_api_id' from the 'Player' table where the height is within a specified range using placeholders for numeric values.", "Next, it selects 'player_api_id' from the 'Player_Attributes' table where the 'preferred_foot' matches a specified value using a placeholder for string values.", "The INTERSECT operator is used to find common 'player_api_id' values from both selections, ensuring that only players who meet both criteria are returned."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 AND height  <=  190 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE preferred_foot  =  'left'", "source_tables": ["player_attributes", "player"], "description": "This virtual table identifies players based on their height and preferred foot. It retrieves the API identifiers of players from the 'Player' table whose height falls within a specified range and intersects this with players from the 'Player_Attributes' table who have a specific preferred foot. The placeholders in the query represent the height range and the preferred foot of the players.", "virtual_table": "SELECT player_api_id FROM Player WHERE height  >=  [PLACEHOLDER-TYPE:NUMBER] AND height  <=  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT player_api_id FROM Player_Attributes WHERE preferred_foot  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1306", "db_id": "soccer_1", "question": "List the names and birthdays of the top five players in terms of potential.", "rationale": ["The query identifies the relevant tables, 'Player' and 'Player_Attributes'.", "It selects distinct player names and birthdays from the 'Player' table.", "A join is performed on the 'player_api_id' to combine player data with their attributes.", "The results are ordered by the 'potential' column in descending order to prioritize players with higher potential.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT 5", "source_tables": ["player_attributes", "player"], "description": "This virtual table provides a list of unique player names and their birthdays from the 'Player' table, joined with the 'Player_Attributes' table to include only those players with their corresponding attributes. The results are ordered by the potential skill rating in descending order, and the number of results returned is limited by a specified placeholder for numeric values.", "virtual_table": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1511", "db_id": "insurance_and_eClaims", "question": "Which type of policy is most frequently used? Give me the policy type code.", "rationale": ["The query identifies the relevant table, which is 'Policies'.", "It selects the 'policy_type_code' column to display the types of insurance policies.", "The GROUP BY clause is used to group the results by 'policy_type_code'.", "The ORDER BY clause sorts the grouped results by their count in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many policy types to return."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"], "description": "This virtual table summarizes the different types of insurance policies from the 'Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.", "virtual_table": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1513", "db_id": "insurance_and_eClaims", "question": "Find all the policy types that are used by more than 2 customers.", "rationale": ["The query identifies the relevant table, which is 'Policies'.", "It selects the 'policy_type_code' to display unique policy types.", "The GROUP BY clause is used to group the results by 'policy_type_code'.", "The HAVING clause filters the groups to include only those with a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"], "description": "This virtual table provides a list of unique insurance policy types from the 'Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.", "virtual_table": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["The query identifies the relevant table, which is 'Claim_Headers'.", "It selects the sum and average of the 'amount_paid' column to provide a summary of the payments made on claims."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "description": "This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the total and average of the 'amount_paid' column.", "virtual_table": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers"}
{"sample_id": "train.1518", "db_id": "insurance_and_eClaims", "question": "How much amount in total were claimed in the most recently created document?", "rationale": ["The query identifies the relevant tables, 'Claim_Headers' and 'Claims_Documents'.", "It uses a JOIN to link the two tables based on the claim identifier.", "The SELECT statement sums the 'amount_claimed' from 'Claim_Headers'.", "A WHERE clause filters the results to include only those claims that have documents created on a specific date, determined by a subquery that selects the created date with a limit placeholder."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "description": "This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.", "virtual_table": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["The query identifies the relevant tables: 'Claim_Headers', 'Policies', and 'Customers'.", "It selects the 'customer_details' from the 'Customers' table.", "The query uses JOINs to connect 'Claim_Headers' to 'Policies' via 'policy_id', and 'Policies' to 'Customers' via 'customer_id'.", "A subquery is used to find the maximum 'amount_claimed' from the 'Claim_Headers' table, which serves as a filter in the WHERE clause."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "description": "This virtual table retrieves the detailed information about the customer associated with the claim that has the highest amount claimed. The query joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins the 'Customers' table to get the customer details. The placeholder in the WHERE clause represents the maximum amount claimed across all claims.", "virtual_table": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)"}
{"sample_id": "train.1521", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the minimum amount of payment in one claim?", "rationale": ["The query identifies the relevant tables: 'Claim_Headers', 'Policies', and 'Customers'.", "It selects the 'customer_details' from the 'Customers' table.", "The query uses JOINs to connect 'Claim_Headers' to 'Policies' via 'policy_id', and 'Policies' to 'Customers' via 'customer_id'.", "A subquery is used to find the minimum 'amount_paid' from 'Claim_Headers', which is used as a condition in the WHERE clause."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "description": "This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.", "virtual_table": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)"}
{"sample_id": "train.1531", "db_id": "insurance_and_eClaims", "question": "Find the names of the customers who have an deputy policy.", "rationale": ["The query identifies the relevant tables, which are 'Policies' and 'Customers'.", "It uses a JOIN operation to link the 'Policies' table with the 'Customers' table based on the 'Customer_ID'.", "The SELECT DISTINCT statement is used to ensure that only unique customer details are retrieved.", "A condition is added to filter the results based on the 'Policy_Type_Code' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy'", "source_tables": ["policies", "customers"], "description": "This virtual table provides a list of unique customer details from the 'Customers' table for those customers who hold a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code that is being queried.", "virtual_table": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1533", "db_id": "insurance_and_eClaims", "question": "Find the names of customers who either have an deputy policy or uniformed policy.", "rationale": ["The query identifies the relevant tables, which are 'Policies' and 'Customers'.", "It selects distinct customer details from the 'Customers' table.", "A JOIN operation is performed on the 'customer_id' to link policies to customers.", "The WHERE clause filters the results based on specific policy type codes using placeholders for string values."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy' OR t1.policy_type_code  =  'Uniform'", "source_tables": ["policies", "customers"], "description": "This virtual table provides a list of distinct customer details from the 'Customers' table for customers who hold insurance policies of specific types. The placeholders in the WHERE clause represent the policy type codes that are being queried.", "virtual_table": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING] OR t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["The query identifies the relevant tables, which are 'Policies' and 'Customers'.", "It selects the 'Customer_Details' from the 'Customers' table.", "A JOIN operation is performed on 'Policies' and 'Customers' using the 'Customer_ID' to link them.", "The WHERE clause filters the results to only include the customer details for the policy that has the maximum start date, using a subquery to find this date."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "description": "This virtual table retrieves the detailed information about customers who have the most recently started insurance policy from the 'Policies' table. The placeholder in the WHERE clause represents the condition to find the latest start date of the policy.", "virtual_table": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["The query identifies the relevant tables, which are 'Accounts' and 'Customers'.", "It selects the columns to display from the 'Accounts' table: 'account_id', 'date_account_opened', 'account_name', and 'other_account_details'.", "A JOIN operation is performed between 'Accounts' and 'Customers' on the 'customer_id' to link accounts to their respective customers.", "A condition is added to filter the results based on the 'customer_first_name' from the 'Customers' table using a placeholder for string values."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "description": "This virtual table provides details about customer accounts from the 'Accounts' table, including the account ID, the date the account was opened, the account name, and any additional account details. The results are filtered based on the first name of the customer from the 'Customers' table, represented by a placeholder for string values.", "virtual_table": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["The query identifies the relevant tables, which are 'Accounts' and 'Customers'.", "It selects the columns to display, 'account_name' and 'other_account_details' from the 'Accounts' table.", "A JOIN operation is performed to link 'Accounts' with 'Customers' based on the 'customer_id'.", "Conditions are added to filter the results based on the specified first and last names of the customer using placeholders for string values."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "description": "This virtual table describes the account names and additional details of accounts associated with customers from the 'Accounts' table, filtered by the first and last names of the customers. The placeholders in the WHERE clause represent the customer's first and last names.", "virtual_table": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.customer_last_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["The query identifies the relevant tables, which are 'Accounts' and 'Customers'.", "It selects the columns to display, 'customer_first_name' and 'customer_last_name'.", "A JOIN operation is performed on 'customer_id' to link the two tables based on the relationship defined in the schema.", "A condition is added to filter the 'account_name' column for the specified account using a placeholder for string values."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "description": "This virtual table describes the first and last names of customers associated with a specific account from the 'Accounts' and 'Customers' tables. The placeholder in the WHERE clause represents the name of the account.", "virtual_table": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1568", "db_id": "customers_and_invoices", "question": "Return the id and full name of the customer with the most accounts.", "rationale": ["The query identifies the relevant tables, 'Accounts' and 'Customers'.", "It selects the 'customer_id', 'customer_first_name', and 'customer_last_name' columns to display.", "A JOIN operation is performed between 'Accounts' and 'Customers' on the 'customer_id' to link accounts to their respective customers.", "The results are grouped by 'customer_id' to aggregate the data for each customer.", "The results are ordered by the count of accounts in descending order to show the customers with the most accounts first.", "A LIMIT clause is included to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["accounts", "customers"], "description": "This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1579", "db_id": "customers_and_invoices", "question": "How many transaction does each account have? Show the number and account id.", "rationale": ["The query identifies the relevant table, which is 'Financial_Transactions'.", "It selects a count of all transactions and groups them by 'account_id'.", "The use of count(*) allows for the aggregation of transaction records associated with each account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "description": "This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.", "virtual_table": "SELECT count(*) ,  account_id FROM Financial_transactions"}
{"sample_id": "train.1589", "db_id": "customers_and_invoices", "question": "Show the account name, id and the number of transactions for each account.", "rationale": ["The query identifies the relevant tables, which are 'Financial_Transactions' and 'Accounts'.", "It selects the 'account_name' and 'account_id' from the 'Accounts' table.", "It counts the number of transactions for each account from the 'Financial_Transactions' table.", "The JOIN operation links the two tables based on the 'account_id' to ensure that the data corresponds correctly.", "Finally, the results are grouped by 'account_id' to aggregate the transaction counts for each account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "description": "This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.", "virtual_table": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id"}
{"sample_id": "train.1599", "db_id": "customers_and_invoices", "question": "Show the invoice number and the number of transactions for each invoice.", "rationale": ["The query identifies the relevant table, which is 'Financial_Transactions'.", "Select the column 'invoice_number' to display the invoice associated with the transactions.", "Use the count function to aggregate the number of transactions for each invoice.", "Group the results by 'invoice_number' to get the count of transactions for each unique invoice."], "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"], "description": "This virtual table summarizes the total number of financial transactions associated with each invoice from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the invoice number, and the count function aggregates the number of transactions per invoice.", "virtual_table": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number"}
{"sample_id": "train.1602", "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?", "rationale": ["The query identifies the relevant tables, 'Financial_Transactions' and 'Invoices'.", "It selects the columns 'invoice_number' and 'invoice_date' from the 'Invoices' table.", "A JOIN operation is performed on the 'invoice_number' to link financial transactions with invoices.", "The results are grouped by 'invoice_number' to aggregate the count of transactions for each invoice.", "The results are ordered by the count of transactions in descending order to prioritize invoices with the most transactions.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"], "description": "This virtual table provides a list of invoice numbers and their corresponding invoice dates from the 'Invoices' table, filtered by the number of financial transactions associated with each invoice. The placeholder in the LIMIT clause represents the maximum number of records to return.", "virtual_table": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["The query identifies the relevant table, which is 'Order_Items'.", "Select the 'order_id' to group the results by each order.", "Use the count function to calculate the total number of items for each order, grouping the results by 'order_id' to get a summary of item counts per order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "description": "This virtual table summarizes the total number of items in each order from the 'Order_Items' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function calculates the total number of items associated with each order.", "virtual_table": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id"}
{"sample_id": "train.2049", "db_id": "party_people", "question": "Show all ministers who do not belong to Progress Party.", "rationale": ["The query identifies the relevant table, which is 'party'.", "Select the column to display, 'minister'.", "Add a condition to filter the 'party_name' column to exclude a specific party using a placeholder for string values."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "description": "This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.", "virtual_table": "SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2058", "db_id": "party_people", "question": "How many members are in each party?", "rationale": ["The query identifies the relevant tables, which are 'Member' and 'Party'.", "It selects the 'party_name' from the 'Party' table and counts the number of members from the 'Member' table.", "A JOIN operation is performed on the 'party_id' to link members to their respective parties.", "The results are grouped by 'party_id' to aggregate the count of members for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "description": "This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement allows for the retrieval of the party name and the count of members belonging to that party.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2071", "db_id": "party_people", "question": "Show party names and the number of events for each party.", "rationale": ["The query identifies the relevant tables, which are 'party_events' and 'party'.", "It uses a JOIN operation to connect 'party_events' with 'party' based on the 'party_id'.", "The SELECT statement retrieves the 'party_name' from the 'party' table and counts the number of events from the 'party_events' table.", "The GROUP BY clause is used to group the results by 'party_id' to get the count of events for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "description": "This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT statement represents the party name, while the count function aggregates the total number of events for each party.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["The query identifies the relevant tables: 'region', 'party', and 'party_events'.", "It uses JOIN operations to connect these tables based on their foreign key relationships: 'region_id' from 'party' and 'party_id' from 'party_events'.", "The SELECT statement counts the total number of events that match the specified criteria.", "The WHERE clause filters the results based on the 'region_name' and 'Event_Name', using placeholders for these string values."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "description": "This virtual table provides a count of party events associated with a specific region and event name. It joins the 'region', 'party', and 'party_events' tables to filter the results based on the specified region name and event name. The placeholders in the WHERE clause represent the region's name and the event's name.", "virtual_table": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2176", "db_id": "formula_1", "question": "What are the names and years of all races that had a driver with the last name Lewis?", "rationale": ["The query identifies the relevant tables: 'results', 'races', and 'drivers'.", "It selects the 'name' and 'year' columns from the 'races' table.", "The JOIN operation connects the 'results' table with the 'races' table using the 'raceId' and with the 'drivers' table using the 'driverId'.", "A condition is added to filter the results based on the driver's first name using a placeholder for string values."], "gold_sql": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = 'Lewis'", "source_tables": ["results", "drivers", "races"], "description": "This virtual table describes the names and years of races from the 'races' table that a specific driver participated in. The placeholder in the WHERE clause represents the driver's first name.", "virtual_table": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["The query identifies the relevant tables: 'races', 'results', and 'drivers'.", "It selects the 'forename' and 'surname' columns from the 'drivers' table.", "The JOIN operations link the 'races' table to the 'results' table and the 'results' table to the 'drivers' table based on their respective IDs.", "The first part of the query filters drivers based on the name of a specific race using a placeholder for string values.", "The EXCEPT clause is used to exclude drivers who participated in another specified race, which is also filtered by a placeholder for string values."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.", "virtual_table": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2183", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who was in position 1 as standing and won?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'driverStandings'.", "It selects distinct first names from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'driverStandings' on the driver ID to correlate driver information with their standings.", "Conditions are added to filter the results based on the specified position and number of wins using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "description": "This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2185", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'driverStandings'.", "It selects distinct first names from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'driverStandings' on the driver ID to combine relevant data.", "Conditions are added to filter results based on the driver's position, number of wins, and points using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "description": "This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the standings, a certain number of wins, and more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2186", "db_id": "formula_1", "question": "What are the first names of the different drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'driverStandings'.", "It selects distinct first names from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'driverStandings' on the driver ID to combine relevant data.", "Conditions are added to filter results based on the driver's position, number of wins, and points scored, using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "description": "This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the standings, a certain number of wins, and have scored more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2189", "db_id": "formula_1", "question": "What are the numbers of races for each constructor id?", "rationale": ["The query is identifying the relevant table, which is 'constructorStandings'.", "The SELECT statement is counting the number of entries for each constructor using 'count(*)'.", "The GROUP BY clause is used to aggregate the results by 'constructorid', allowing us to see the total standings for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "description": "This virtual table provides a count of the total number of constructor standings for each constructor from the 'constructorStandings' table. The placeholder in the SELECT statement represents the constructor's identifier, which is grouped to show the total standings for each constructor.", "virtual_table": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["The query identifies the relevant tables, which are 'constructors' and 'constructorStandings'.", "It selects the 'name' column from the 'constructors' table.", "A JOIN operation is performed between 'constructors' and 'constructorStandings' on the 'constructorId' to link constructors with their standings.", "Conditions are added to filter constructors by their nationality using a placeholder for string values and by their points using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "description": "This virtual table lists the names of constructors from the 'constructors' table who have a specific nationality and have scored more than a certain number of points in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.", "virtual_table": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = [PLACEHOLDER-TYPE:STRING] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It joins the 'races' table with the 'results' table on the race identifier to correlate race data with results.", "The SELECT statement computes the average of the 'fastestLapSpeed' from the 'results' table.", "A condition is added to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.", "virtual_table": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2221", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It selects the maximum value of 'fastestLapSpeed' from the 'results' table.", "A JOIN operation is performed between 'races' and 'results' on the 'raceId' to correlate race details with their results.", "Conditions are added to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "This virtual table provides the maximum fastest lap speed recorded during races held in a specific year and with a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.", "virtual_table": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It selects the maximum value of 'fastestLapSpeed' from the 'results' table.", "A JOIN operation is performed between 'races' and 'results' on the 'raceId' to correlate race details with results.", "Conditions are added to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "This virtual table provides the maximum fastest lap speed recorded during races in a specific year and for a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.", "virtual_table": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It selects the maximum fastest lap speed from the 'results' table and the race name and year from the 'races' table.", "A JOIN operation is performed on the raceId to combine data from both tables.", "A condition is added to filter races that occurred after a specified year using a placeholder for numeric values.", "The results are grouped by race name to ensure unique entries for each race, and ordered by year to present the data chronologically."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "description": "This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.", "virtual_table": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year"}
{"sample_id": "train.2225", "db_id": "formula_1", "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["The query identifies the relevant tables, 'races' and 'results'.", "It selects the average fastest lap speed from the 'results' table and the race name and year from the 'races' table.", "A JOIN operation is performed on the raceId to combine data from both tables.", "A condition is added to filter the results based on the year using a placeholder for numeric values.", "The results are grouped by race name and ordered by year."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "description": "This virtual table provides the average fastest lap speed of races from the 'races' table, grouped by the race name and year. The placeholder in the WHERE clause represents the year threshold, allowing users to filter races that occurred after a specific year.", "virtual_table": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year"}
{"sample_id": "train.2226", "db_id": "formula_1", "question": "What is the average fastest lap speed for races held after 2004, for each race, ordered by year?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It selects the average fastest lap speed from the 'results' table and the race name and year from the 'races' table.", "A JOIN operation is performed on the raceId to combine data from both tables.", "A condition is added to filter the results for races that occurred after a specified year using a placeholder for numeric values.", "The results are grouped by race name and ordered by year."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "description": "This virtual table provides the average fastest lap speed of races from the 'races' table, grouped by the race name and year. The placeholder in the WHERE clause represents a specific year, allowing users to filter for races that occurred after that year.", "virtual_table": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year"}
{"sample_id": "train.2243", "db_id": "machine_repair", "question": "What is the starting year of the oldest technicians?", "rationale": ["The query identifies the relevant table, which is 'technician'.", "Select the column to display, 'Starting_Year'.", "Order the results by the 'Age' column in descending order to show the oldest technicians first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "source_tables": ["technician"], "description": "This virtual table provides the starting years of technicians from the 'technician' table, ordered by their age in descending order. The placeholder in the LIMIT clause represents the maximum number of records to return.", "virtual_table": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2248", "db_id": "machine_repair", "question": "What are the teams with the most technicians?", "rationale": ["The query identifies the relevant table, which is 'technician'.", "It selects the 'Team' column to display the teams of technicians.", "The GROUP BY clause is used to group the results by the 'Team' column.", "The ORDER BY clause sorts the teams based on the count of technicians in each team in descending order.", "The LIMIT clause uses a placeholder to specify how many teams to return."], "gold_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["technician"], "description": "This virtual table provides a list of technician teams from the 'technician' table, grouped by team and ordered by the number of technicians in each team. The placeholder in the LIMIT clause allows for specifying the maximum number of teams to display.", "virtual_table": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2258", "db_id": "machine_repair", "question": "What are the names of the technicians  and how many machines are they assigned to repair?", "rationale": ["The query identifies the relevant tables, which are 'repair_assignment' and 'technician'.", "It selects the 'Name' column from the 'technician' table and counts the number of repair assignments for each technician.", "The JOIN operation connects the 'repair_assignment' table with the 'technician' table based on the technician's ID.", "The GROUP BY clause is used to aggregate the results by technician's name, allowing for the count of tasks per technician."], "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name", "source_tables": ["repair_assignment", "technician"], "description": "This virtual table provides the names of technicians along with the count of repair tasks they have been assigned to. The data is aggregated from the 'repair_assignment' table, which links technicians to their respective repair tasks, and the 'technician' table, which contains the details of each technician.", "virtual_table": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name"}
{"sample_id": "train.2328", "db_id": "csu_1", "question": "Find all the campuses opened in 1958.", "rationale": ["The query is identifying the relevant table, which is 'Campuses'.", "Select the column to display, 'Campus'.", "Add a condition to filter the 'Year' column for the specified year using a placeholder for numeric values."], "gold_sql": "SELECT campus FROM campuses WHERE YEAR  =  1958", "source_tables": ["campuses"], "description": "This virtual table describes the names of campuses from the 'Campuses' table that have records for a specific year. The placeholder in the WHERE clause represents the year for which the campus data is being queried.", "virtual_table": "SELECT campus FROM campuses WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2334", "db_id": "csu_1", "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.", "rationale": ["The query identifies the relevant table, which is 'Campuses'.", "It selects the 'Campus' column to display the names of the campuses.", "The query includes conditions to filter the 'Location' and 'County' columns for specified values using placeholders for string values.", "The UNION operator is used to combine results from two identical selections, allowing for flexibility in filtering."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "description": "This virtual table retrieves the names of campuses located in a specific geographical location and county. The query combines results from two identical selections, allowing for the possibility of filtering by different criteria in the future. The placeholders in the WHERE clauses represent the location and county names.", "virtual_table": "SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2350", "db_id": "csu_1", "question": "Which campus has the most faculties in year 2003?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'faculty'.", "It selects the 'campus' column from the 'Campuses' table.", "A JOIN operation is performed between 'Campuses' and 'faculty' on the campus identifier to combine data from both tables.", "A condition is added to filter the results based on the specified year using a placeholder for numeric values.", "The results are ordered by the number of faculty members in descending order.", "A LIMIT clause is included to restrict the number of returned campuses based on a specified number."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "description": "This virtual table lists the campuses from the 'Campuses' table that have faculty data for a specific year. The campuses are ordered by the number of faculty members in descending order, and the result is limited to a specified number of campuses. The placeholders in the WHERE clause and LIMIT clause represent the year of the faculty data and the maximum number of campuses to return, respectively.", "virtual_table": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2356", "db_id": "csu_1", "question": "report the total number of degrees granted between 1998 and 2002.", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'campus' from the 'Campuses' table and sums the 'degrees' from the 'degrees' table.", "A JOIN operation is performed on the 'Campus' identifier to link the two tables.", "The WHERE clause filters the results based on a specified range of years using placeholders for numeric values.", "The results are grouped by 'campus' to provide a total count of degrees awarded per campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "description": "This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.", "virtual_table": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'campus' from the 'Campuses' table and sums the 'degrees' from the 'degrees' table.", "A JOIN operation is performed on the 'Campus' identifier to link the two tables.", "Conditions are added to filter the results based on the specified county and the year using placeholders for string and numeric values.", "The results are grouped by campus to aggregate the total degrees awarded."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "description": "This virtual table summarizes the total number of degrees awarded by each campus located in a specific county, filtering for degrees awarded from a certain year onwards. The placeholders in the WHERE clause represent the county name and the year threshold.", "virtual_table": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["The query identifies the relevant tables, which are 'Campuses' and 'enrollments'.", "It selects the 'campus' column from the 'Campuses' table.", "A JOIN operation is performed between 'Campuses' and 'enrollments' on the campus identifier.", "Conditions are added to filter the results based on the specified year, total enrollment, and full-time equivalent enrollment using placeholders for numeric values."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "description": "This virtual table identifies campuses from the 'Campuses' table that have a specific number of total enrollments and full-time equivalent enrollments for a given academic year. The placeholders in the WHERE clause represent the year, total enrollment threshold, and full-time equivalent enrollment threshold.", "virtual_table": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] AND totalenrollment_ay  >  [PLACEHOLDER-TYPE:NUMBER] AND FTE_AY  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2363", "db_id": "csu_1", "question": "What campus started in year 1956, has more than 200 full time students, and more than 400 students enrolled?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'enrollments'.", "It selects the 'campus' column from the 'Campuses' table.", "A JOIN operation is performed between 'Campuses' and 'enrollments' on the campus identifier.", "Conditions are added to filter the results based on the specified year and thresholds for total and full-time equivalent enrollments using placeholders for numeric values."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "description": "This virtual table lists the campuses from the 'Campuses' table that have total enrollments exceeding a specified number and full-time equivalent enrollments exceeding another specified number for a given academic year. The placeholders in the WHERE clause represent the year, total enrollment threshold, and full-time equivalent enrollment threshold.", "virtual_table": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] AND totalenrollment_ay  >  [PLACEHOLDER-TYPE:NUMBER] AND FTE_AY  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2366", "db_id": "csu_1", "question": "List the campuses in Los Angeles county.", "rationale": ["The query is identifying the relevant table, which is 'Campuses'.", "Select the column to display, 'campus'.", "Add a condition to filter the 'county' column for the specified county using a placeholder for string values."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "description": "This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.", "virtual_table": "SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'Degrees' column from the 'degrees' table.", "A JOIN operation is performed to link 'Campuses' and 'degrees' based on the campus identifier.", "Conditions are added to filter results for a specific campus and year using placeholders for string and numeric values."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "description": "This virtual table describes the types of degrees awarded at a specific campus for a given year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.", "virtual_table": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2374", "db_id": "csu_1", "question": "What is the number of faculty lines in campus \"Long Beach State University\" in 2002?", "rationale": ["The query identifies the relevant tables, which are 'faculty' and 'campuses'.", "It selects the 'faculty' column to display the number of faculty members.", "A JOIN operation is performed to link the 'faculty' table with the 'campuses' table based on the campus identifier.", "Conditions are added to filter the results by a specific year and campus name using placeholders for numeric and string values."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2002 AND T2.campus  =  'Long Beach State University'", "source_tables": ["faculty", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.", "virtual_table": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2376", "db_id": "csu_1", "question": "How many faculty lines are there in \"San Francisco State University\" in year 2004?", "rationale": ["The query identifies the relevant tables, which are 'faculty' and 'campuses'.", "It selects the 'faculty' column to display the number of faculty members.", "A JOIN operation is performed to link the 'faculty' table with the 'campuses' table based on the campus identifier.", "Conditions are added to filter the results by a specific year and campus name using placeholders for numeric and string values."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.", "virtual_table": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["The query identifies the relevant tables, which are 'faculty' and 'campuses'.", "It selects the 'faculty' column to display the number of faculty members.", "A JOIN operation is performed to link the 'faculty' table with the 'campuses' table based on the campus identifier.", "Conditions are added to filter the results by a specific year and campus name using placeholders for numeric and string values."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.", "virtual_table": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2381", "db_id": "csu_1", "question": "How many faculty members did the university that conferred the most degrees in 2002 have?", "rationale": ["The query identifies the relevant tables: 'campuses', 'faculty', and 'degrees'.", "It selects the 'faculty' column from the 'faculty' table.", "The query joins the 'campuses' table with the 'faculty' table on the campus identifier to link faculty data to the respective campus.", "It also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded.", "A condition is added to filter the results by a specific year using a placeholder for numeric values.", "The results are ordered by the number of degrees awarded in descending order and limited to a specified number of records using placeholders."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate each faculty record with its corresponding campus and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The results are ordered by the number of degrees awarded in descending order, and the output is limited to a specified number of records.", "virtual_table": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2382", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the least number of degrees in year 2001?", "rationale": ["The query identifies the relevant tables: 'campuses', 'faculty', and 'degrees'.", "It selects the 'faculty' column from the 'faculty' table.", "The query joins the 'campuses' table with the 'faculty' table on the campus identifier and also joins with the 'degrees' table to ensure that the faculty data corresponds to the year when degrees were awarded.", "A condition is added to filter the results based on a specific year using a placeholder for numeric values.", "The results are ordered by the 'degrees' column and limited to a specified number of results using a placeholder."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.", "virtual_table": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["The query identifies the relevant tables: 'campuses', 'faculty', and 'degrees'.", "It selects the 'faculty' column from the 'faculty' table.", "The query joins the 'campuses' table with the 'faculty' table on the campus identifier, and also joins with the 'degrees' table to ensure the year matches.", "A condition is added to filter the results based on a specific year using a placeholder for numeric values.", "The results are ordered by the 'degrees' column and limited to a specified number using a placeholder."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.", "virtual_table": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["The query identifies the relevant tables, 'discipline_enrollments' and 'campuses'.", "It uses a JOIN operation to combine data from both tables based on the campus identifier.", "The SUM function is applied to the 'undergraduate' column to calculate the total number of undergraduate enrollments.", "Conditions are added to filter the results by the specified year and campus name using placeholders for numeric and string values."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "description": "This virtual table calculates the total number of undergraduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the WHERE clause represent the year of enrollment and the name of the campus.", "virtual_table": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND t2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2397", "db_id": "candidate_poll", "question": "Return the poll resource associated with the most candidates.", "rationale": ["The query identifies the relevant table, which is 'candidate'.", "It selects the 'poll_source' column to display the different sources of poll data.", "The GROUP BY clause is used to group the results by 'poll_source'.", "The ORDER BY clause sorts the grouped results by their count in descending order to show the most common sources first.", "The LIMIT clause includes a placeholder to allow the user to specify how many poll sources they want to retrieve."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "description": "This virtual table provides a list of poll sources from the 'candidate' table, grouped by the source and ordered by the number of occurrences. The placeholder in the LIMIT clause allows the user to specify the maximum number of poll sources to retrieve.", "virtual_table": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2405", "db_id": "candidate_poll", "question": "Return the poll source corresponding to the candidate who has the oppose rate.", "rationale": ["The query identifies the relevant table, which is 'candidate'.", "Select the column to display, 'poll_source'.", "Add an ORDER BY clause to sort the results based on 'oppose_rate' in descending order.", "Include a LIMIT clause with a placeholder to specify the maximum number of results to return."], "gold_sql": "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1", "source_tables": ["candidate"], "description": "This virtual table provides a list of poll sources from the 'candidate' table, ordered by the opposition rate in descending order. The placeholder in the LIMIT clause indicates the maximum number of poll sources to return.", "virtual_table": "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2417", "db_id": "candidate_poll", "question": "For each sex, what is the name and sex of the candidate with the oppose rate for their sex?", "rationale": ["The query identifies the relevant tables, 'people' and 'candidate', and establishes a join between them based on the 'People_ID'.", "It selects the 'name' and 'sex' from the 'people' table and calculates the minimum 'oppose_rate' from the 'candidate' table.", "The results are grouped by 'sex' to provide the minimum opposition rate for each gender."], "gold_sql": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex", "source_tables": ["candidate", "people"], "description": "This virtual table provides the names and genders of individuals from the 'people' table, along with the minimum opposition rate from the 'candidate' table for each gender. The data is aggregated by gender, allowing for a comparison of the lowest opposition rates among different genders.", "virtual_table": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex"}
{"sample_id": "train.2434", "db_id": "movie_1", "question": "Find the titles of all movies directed by steven spielberg.", "rationale": ["The query identifies the relevant table, which is 'Movie'.", "Select the column to display, 'title'.", "Add a condition to filter the 'director' column for the specified director using a placeholder for string values."], "gold_sql": "SELECT title FROM Movie WHERE director = 'Steven Spielberg'", "source_tables": ["movie"], "description": "This virtual table describes the titles of movies from the 'Movie' table that were directed by a specific director. The placeholder in the WHERE clause represents the director's name.", "virtual_table": "SELECT title FROM Movie WHERE director = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2461", "db_id": "movie_1", "question": "What are the different names of all reviewers whose ratings do not have a date field?", "rationale": ["The query identifies the relevant tables, which are 'Reviewer' and 'Rating'.", "It selects distinct names from the 'Reviewer' table to avoid duplicates.", "The join condition links the 'Reviewer' table to the 'Rating' table using the reviewer's ID.", "A condition is added to filter the results based on the 'ratingDate' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  'null'", "source_tables": ["rating", "reviewer"], "description": "This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.", "virtual_table": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2476", "db_id": "movie_1", "question": "Find the names of all reviewers who rated Gone with the Wind.", "rationale": ["The query identifies the relevant tables: 'Rating', 'Movie', and 'Reviewer'.", "It selects distinct reviewer names from the 'Reviewer' table.", "The JOIN operations link the 'Rating' table to the 'Movie' table using the movie ID, and to the 'Reviewer' table using the reviewer ID.", "A condition is added to filter the results based on the specified movie title using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  'Gone with the Wind'", "source_tables": ["rating", "movie", "reviewer"], "description": "This virtual table lists the distinct names of reviewers who have rated a specific movie from the 'Movie' table. The placeholder in the WHERE clause represents the title of the movie.", "virtual_table": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2483", "db_id": "movie_1", "question": "What are the names of all the reviewers and movie names?", "rationale": ["The query identifies the relevant tables, which are 'Reviewer' and 'Movie'.", "It selects the 'name' column from the 'Reviewer' table and the 'title' column from the 'Movie' table.", "The UNION operator is used to combine the results from both SELECT statements into a single result set."], "gold_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "source_tables": ["movie", "reviewer"], "description": "This virtual table combines the names of reviewers and the titles of movies from the 'Reviewer' and 'Movie' tables, respectively. The use of UNION allows for a single list that includes both reviewers and movie titles.", "virtual_table": "SELECT name FROM Reviewer UNION SELECT title FROM Movie"}
{"sample_id": "train.2495", "db_id": "movie_1", "question": "For each director, how many reviews have they received?", "rationale": ["The query identifies the relevant tables, which are 'Movie' and 'Rating'.", "It selects the count of ratings and the director's name from the 'Movie' table.", "A JOIN operation is performed on the 'mID' to link the 'Movie' and 'Rating' tables.", "The results are grouped by the director's name to aggregate the count of ratings for each director."], "gold_sql": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director", "source_tables": ["rating", "movie"], "description": "This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the count of ratings, while the grouping is done by the director's name.", "virtual_table": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director"}
{"sample_id": "train.2500", "db_id": "movie_1", "question": "What are the names and years of the movies that has the top 3 highest rating star?", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Movie'.", "It selects the 'title' and 'year' columns from the 'Movie' table.", "A JOIN operation is performed between 'Rating' and 'Movie' on the movie identifier 'mID' to link ratings to their respective movies.", "The results are ordered by the 'stars' column from the 'Rating' table in descending order to show the highest-rated movies first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.title ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID ORDER BY T1.stars DESC LIMIT 3", "source_tables": ["rating", "movie"], "description": "This virtual table provides a list of movie titles and their release years from the 'Movie' table, ordered by the number of stars given in ratings from the 'Rating' table. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.", "virtual_table": "SELECT T2.title ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID ORDER BY T1.stars DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2502", "db_id": "movie_1", "question": "For each director, return the director's name together with the title of the movie they directed that received the highest rating among all of their movies, and the value of that rating. Ignore movies whose director is NULL.", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Movie'.", "It selects the columns to display: 'title' from the 'Movie' table, 'stars' from the 'Rating' table, and 'director' from the 'Movie' table.", "The JOIN operation links the 'Rating' table to the 'Movie' table using the movie identifier 'mID'.", "A condition is added to filter out movies directed by a specified director using a placeholder for string values.", "The results are grouped by the director to aggregate the maximum stars given for each director's movies."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "description": "This virtual table provides a summary of movie ratings, showing the title of the movie, the number of stars given, and the director's name, while excluding movies directed by a specific individual. The placeholder in the WHERE clause represents the name of the director to be excluded from the results.", "virtual_table": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != [PLACEHOLDER-TYPE:STRING] GROUP BY director"}
{"sample_id": "train.2503", "db_id": "movie_1", "question": "For each director, what are the titles and ratings for all the movies they reviewed?", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Movie'.", "It selects the columns to display: 'title' from the 'Movie' table, 'stars' from the 'Rating' table, and 'director' from the 'Movie' table.", "The query uses a JOIN to combine data from the 'Rating' and 'Movie' tables based on the movie identifier (mID).", "A condition is added to filter out movies directed by a specified director using a placeholder for string values.", "The results are grouped by the director to aggregate the maximum stars given for each director's movies."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "description": "This virtual table provides a summary of movie ratings, showing the title of the movie, the number of stars given, and the director's name, while excluding movies directed by a specific individual. The placeholder in the WHERE clause represents the director's name that should be excluded from the results.", "virtual_table": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != [PLACEHOLDER-TYPE:STRING] GROUP BY director"}
{"sample_id": "train.2505", "db_id": "movie_1", "question": "For each reviewer id, what is the title and rating for the movie with the smallest rating?", "rationale": ["The query identifies the relevant tables, 'Rating' and 'Movie', and uses a JOIN to combine them based on the movie identifier (mID).", "It selects the movie title from the 'Movie' table and the reviewer ID, stars given, and calculates the minimum stars from the 'Rating' table.", "The GROUP BY clause is used to aggregate the results by reviewer ID, allowing for the minimum stars to be calculated for each reviewer."], "gold_sql": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID", "source_tables": ["rating", "movie"], "description": "This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer for the movies they rated. The placeholders in the query allow for dynamic filtering based on specific reviewer IDs and movie titles.", "virtual_table": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID"}
{"sample_id": "train.2507", "db_id": "movie_1", "question": "For each director, what is the title and score of their most poorly rated movie?", "rationale": ["The query identifies the relevant tables, 'Rating' and 'Movie', and uses a JOIN to combine them based on the movie identifier (mID).", "It selects the movie title, the stars given in the rating, and the director's name.", "The query also calculates the minimum star rating for each director using the MIN function.", "Finally, it groups the results by the director to provide a summary of ratings for each director's movies."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director", "source_tables": ["rating", "movie"], "description": "This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given in the rating, the director of the movie, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.", "virtual_table": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director"}
{"sample_id": "train.2508", "db_id": "movie_1", "question": "What is the name of the movie that is rated by most of times?", "rationale": ["The query identifies the relevant tables, 'Rating' and 'Movie'.", "It selects the 'title' from the 'Movie' table and the 'mID' from the 'Rating' table.", "A JOIN operation is performed to link the 'Rating' and 'Movie' tables based on the movie identifier 'mID'.", "The results are grouped by 'mID' to aggregate the ratings for each movie.", "The ORDER BY clause sorts the movies based on the count of ratings in descending order.", "The LIMIT clause restricts the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "description": "This virtual table provides a list of movie titles along with their unique identifiers from the 'Movie' table. The results are filtered based on the number of ratings received, showing only the top-rated movies. The placeholder in the LIMIT clause represents the maximum number of movies to display.", "virtual_table": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2509", "db_id": "movie_1", "question": "What is the name of the movie that has been reviewed the most?", "rationale": ["The query identifies the relevant tables, 'Rating' and 'Movie'.", "It selects the 'title' from the 'Movie' table and the 'mID' from the 'Rating' table.", "A JOIN operation is performed on the 'mID' to link ratings to their respective movies.", "The results are grouped by 'mID' to aggregate the ratings for each movie.", "The results are ordered by the count of ratings in descending order to show the most rated movies first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "description": "This virtual table provides a list of movie titles along with their unique identifiers from the 'Movie' table. The results are filtered based on the number of ratings each movie has received, sorted in descending order, and limited to a specified number of top-rated movies. The placeholder in the LIMIT clause represents the maximum number of movies to return.", "virtual_table": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2517", "db_id": "movie_1", "question": "What are the ids of all moviest hat have not been reviewed by Britanny Harris?", "rationale": ["The query starts by selecting the unique movie identifiers (mID) from the 'Rating' table.", "It uses the EXCEPT clause to exclude movies that have been rated by a specific reviewer.", "To find the movies rated by the specified reviewer, a JOIN operation is performed between the 'Rating' and 'Reviewer' tables based on the reviewer ID (rID).", "The condition in the WHERE clause filters the results to only include ratings from the reviewer with the specified name, which is represented by a placeholder for string values."], "gold_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris'", "source_tables": ["rating", "reviewer"], "description": "This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that individual.", "virtual_table": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2518", "db_id": "movie_1", "question": "Find the average rating star for each movie that received at least 2 ratings.", "rationale": ["The query identifies the relevant table, which is 'Rating'.", "It selects the 'mID' and calculates the average of the 'stars' column.", "The results are grouped by 'mID' to aggregate ratings for each movie.", "A condition is added to filter the results to include only those movies that have received a specified minimum number of ratings using a placeholder for numeric values."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2", "source_tables": ["rating"], "description": "This virtual table provides the unique movie identifiers along with the average star ratings from the 'Rating' table. It filters the results to include only those movies that have received a minimum number of ratings, as specified by the placeholder.", "virtual_table": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2528", "db_id": "movie_1", "question": "What are the names of reviewers who had rated 3 star and 4 star?", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Reviewer'.", "It selects the 'name' column from the 'Reviewer' table.", "The JOIN operation links the 'Rating' table to the 'Reviewer' table using the reviewer ID (rID).", "The WHERE clause filters the ratings based on the specified number of stars using a placeholder for numeric values.", "The INTERSECT operation is used to find common reviewers who rated two different movies with the same star rating."], "gold_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4", "source_tables": ["rating", "reviewer"], "description": "This virtual table describes the names of reviewers who have given a specific number of stars to movies. The query uses an INTERSECT operation to find reviewers who rated two different movies with the same star rating. The placeholders in the WHERE clause represent the number of stars given in the ratings.", "virtual_table": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2530", "db_id": "movie_1", "question": "What are the names of movies that get 3 star and 4 star?", "rationale": ["The query identifies the relevant tables, which are 'Rating' and 'Movie'.", "It selects the 'title' column from the 'Movie' table.", "The query uses a JOIN to link the 'Rating' table with the 'Movie' table based on the movie identifier (mID).", "It applies a condition to filter the ratings based on the specified number of stars using placeholders for numeric values.", "The INTERSECT operator is used to find titles that meet the star rating criteria from both instances of the query."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "source_tables": ["rating", "movie"], "description": "This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.", "virtual_table": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2576", "db_id": "inn_1", "question": "Find the most popular room in the hotel. The most popular room is the room that had seen the largest number of reservations.", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms'.", "It performs a JOIN operation to link the reservations to their corresponding room names using the foreign key relationship.", "The query groups the results by room to count the number of reservations for each room.", "It orders the results in descending order based on the count of reservations, ensuring the most popular rooms are listed first.", "The LIMIT clause uses a placeholder to specify how many room names to return."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides the names of the most frequently reserved rooms from the 'Rooms' table based on the reservations made in the 'Reservations' table. The placeholder in the LIMIT clause represents the maximum number of room names to return.", "virtual_table": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2577", "db_id": "inn_1", "question": "Which room has the largest number of reservations?", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms'.", "It performs a JOIN operation to link the reservations to their corresponding room names using the foreign key relationship.", "The GROUP BY clause is used to group the results by room, allowing for counting the number of reservations per room.", "The ORDER BY clause sorts the results in descending order based on the count of reservations, ensuring the most reserved rooms appear first.", "The LIMIT clause uses a placeholder to specify how many room names to return."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides the names of the most frequently reserved rooms from the 'Rooms' table based on the reservations made in the 'Reservations' table. The placeholder in the LIMIT clause represents the maximum number of room names to return.", "virtual_table": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2578", "db_id": "inn_1", "question": "How many kids stay in the rooms reserved by ROY SWEAZY?", "rationale": ["The query identifies the relevant table, which is 'Reservations'.", "Select the column to display, 'Kids'.", "Add conditions to filter the 'FirstName' and 'LastName' columns for the specified guest using placeholders for string values."], "gold_sql": "SELECT kids FROM Reservations WHERE FirstName = 'ROY' AND LastName  =  'SWEAZY';", "source_tables": ["reservations"], "description": "This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.", "virtual_table": "SELECT kids FROM Reservations WHERE FirstName = [PLACEHOLDER-TYPE:STRING] AND LastName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2582", "db_id": "inn_1", "question": "Which room has the highest rate? List the room's full name, rate, check in and check out date.", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms', and uses a JOIN to combine them based on the room identifier.", "It selects the columns 'roomName' from the Rooms table and 'Rate', 'CheckIn', and 'CheckOut' from the Reservations table.", "The results are grouped by the room to avoid duplicates and ordered by the reservation rate in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides a list of room names along with their corresponding reservation rates, check-in, and check-out dates. The data is sourced from the 'Reservations' and 'Rooms' tables, where the room identifier in reservations is linked to the unique room identifier in the rooms table. The results are grouped by room to ensure unique entries and are ordered by the reservation rate in descending order, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2583", "db_id": "inn_1", "question": "Return the name, rate, check in and check out date for the room with the highest rate.", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms', and uses a JOIN to combine them based on the room identifier.", "It selects the columns 'roomName' from the Rooms table and 'Rate', 'CheckIn', and 'CheckOut' from the Reservations table.", "The GROUP BY clause is used to group the results by the room to avoid duplicates.", "The ORDER BY clause sorts the results by the 'Rate' in descending order to show the highest rates first.", "The LIMIT clause restricts the number of results returned to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides a list of room names along with their corresponding reservation rates, check-in, and check-out dates. The data is sourced from the 'Reservations' and 'Rooms' tables, where the room identifier in reservations is linked to the unique room identifier in the rooms table. The results are grouped by room to ensure each room appears only once, sorted by the reservation rate in descending order, and limited to a specified number of entries.", "virtual_table": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2589", "db_id": "inn_1", "question": "Find the total number of king beds available.", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "It selects the sum of the 'beds' column to calculate the total number of beds.", "A condition is added to filter the results based on the 'bedType' column using a placeholder for string values."], "gold_sql": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  'King';", "source_tables": ["rooms"], "description": "This virtual table calculates the total number of beds available in rooms of a specific bed type from the 'Rooms' table. The placeholder in the WHERE clause represents the type of beds being queried.", "virtual_table": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2590", "db_id": "inn_1", "question": "List the names and decor of rooms that have a king bed. Sort the list by their price.", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "Select the columns to display, 'roomName' and 'decor'.", "Add a condition to filter the 'bedType' column for the specified bed type using a placeholder for string values.", "Order the results by 'basePrice' to sort the rooms based on their pricing."], "gold_sql": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;", "source_tables": ["rooms"], "description": "This virtual table describes the names and decor of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the bed type being queried, and the results are ordered by the base price of the rooms.", "virtual_table": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;"}
{"sample_id": "train.2594", "db_id": "inn_1", "question": "What is the decor of room Recluse and defiance?", "rationale": ["The query is identifying the relevant table, which is 'Rooms'.", "Select the column to display, 'decor'.", "Add a condition to filter the 'roomName' column for the specified room using a placeholder for string values."], "gold_sql": "SELECT decor FROM Rooms WHERE roomName  =  'Recluse and defiance';", "source_tables": ["rooms"], "description": "This virtual table describes the decor of a specific room from the 'Rooms' table based on the room's name. The placeholder in the WHERE clause represents the name of the room being queried.", "virtual_table": "SELECT decor FROM Rooms WHERE roomName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2604", "db_id": "inn_1", "question": "Find the first and last names of people who payed more than the rooms' base prices.", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms', and establishes a join condition based on the foreign key relationship between them.", "It selects the 'FirstName' and 'LastName' columns from the 'Reservations' table, aliased as T1.", "The join condition links the 'Room' column in 'Reservations' to the 'RoomId' column in 'Rooms'.", "A condition is added to filter results where the difference between the 'Rate' in 'Reservations' and the 'basePrice' in 'Rooms' exceeds a specified numeric value using a placeholder."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.", "virtual_table": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2609", "db_id": "inn_1", "question": "How many rooms have a king bed?", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "It selects the count of all rooms that match a specific condition.", "A condition is added to filter the 'bedType' column for the specified type of bed using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Rooms WHERE bedType  =  'King';", "source_tables": ["rooms"], "description": "This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.", "virtual_table": "SELECT count(*) FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2612", "db_id": "inn_1", "question": "Find the name of the room with the maximum occupancy.", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "Select the column to display, 'roomName'.", "Order the results by 'maxOccupancy' in descending order to show the rooms with the highest capacity first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;", "source_tables": ["rooms"], "description": "This virtual table lists the names of rooms from the 'Rooms' table, ordered by their maximum occupancy in descending order. The placeholder in the LIMIT clause represents the maximum number of room names to be displayed.", "virtual_table": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.2621", "db_id": "inn_1", "question": "What is the average minimum and price of the rooms for each different decor.", "rationale": ["The query identifies the relevant table, which is 'Rooms'.", "Select the 'decor' column to group the results by room decor.", "Calculate the average and minimum of the 'basePrice' column for each decor group using aggregate functions.", "Group the results by the 'decor' column to provide a summary for each unique decor type."], "gold_sql": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;", "source_tables": ["rooms"], "description": "This virtual table provides a summary of the average and minimum base prices of rooms, grouped by their decor descriptions. The placeholders represent the decor type and pricing information.", "virtual_table": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;"}
{"sample_id": "train.2628", "db_id": "inn_1", "question": "List the name of rooms with king or queen bed.", "rationale": ["The query is identifying the relevant table, which is 'Rooms'.", "Select the column to display, 'roomName'.", "Add a condition to filter the 'bedType' column for the specified bed types using placeholders for string values. The condition uses an OR operator to allow for multiple bed types."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "description": "This virtual table describes the names of rooms from the 'Rooms' table that have a specific type of bed. The placeholders in the WHERE clause represent the types of beds being queried.", "virtual_table": "SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["The query identifies the relevant tables, 'Reservations' and 'Rooms'.", "It selects the 'roomName' from the 'Rooms' table and counts the number of reservations from the 'Reservations' table.", "A JOIN operation is performed on the 'Room' column from 'Reservations' and 'RoomId' from 'Rooms' to link the two tables.", "The results are grouped by the room identifier to aggregate the count of reservations for each room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "description": "This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.", "virtual_table": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["The query identifies the relevant table, which is 'Trucks'.", "Select the column to display, 'truck_details'.", "Order the results by 'truck_licence_number' to sort the trucks based on their license numbers."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "description": "The virtual table provides details about trucks from the 'Trucks' table, specifically focusing on the truck's detailed information. The results are ordered by the truck's license number to facilitate easy identification and sorting of the trucks.", "virtual_table": "SELECT truck_details FROM trucks ORDER BY truck_licence_number"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'customer_name' column to display the names of customers.", "The EXCEPT clause is used to exclude customers who have an address in a specified state, province, or county.", "To achieve this, a JOIN is performed between 'Customers', 'Customer_Addresses', and 'Addresses' tables to filter based on the 'state_province_county' column using a placeholder for string values."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "description": "This virtual table provides a list of customer names from the 'Customers' table who do not have an address in a specific state, province, or county. The placeholder in the WHERE clause represents the name of the state, province, or county to filter out customers with addresses in that location.", "virtual_table": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["The query identifies the relevant tables, which are 'Delivery_Routes' and 'Delivery_Route_Locations'.", "It selects the 'route_name' from 'Delivery_Routes' and joins it with 'Delivery_Route_Locations' on the 'route_id'.", "The results are grouped by 'route_id' to aggregate the delivery locations associated with each route.", "The results are ordered by the count of delivery locations in descending order to highlight the most popular routes.", "A placeholder is included in the LIMIT clause to specify the maximum number of routes to return."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "description": "This virtual table provides a list of delivery route names from the 'Delivery_Routes' table, grouped by their unique identifiers. The results are ordered by the number of associated delivery locations in descending order, allowing users to see the most utilized routes. The placeholder in the LIMIT clause represents the maximum number of routes to be displayed.", "virtual_table": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3175", "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["The query identifies the relevant table, which is 'CLASS'.", "It counts the distinct 'PROF_NUM' to determine the number of unique professors.", "A condition is added to filter the results based on the 'CRS_CODE' using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "description": "This virtual table provides the count of distinct professors teaching classes associated with a specific course code from the 'CLASS' table. The placeholder in the WHERE clause represents the course code being queried.", "virtual_table": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["The query identifies the relevant table, which is 'CLASS'.", "It counts the distinct 'PROF_NUM' to determine the number of unique professors.", "A condition is added to filter the results based on the 'CRS_CODE' using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "description": "This virtual table provides the count of distinct professors teaching classes associated with a specific course code from the 'CLASS' table. The placeholder in the WHERE clause represents the course code being queried.", "virtual_table": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["The query identifies the relevant tables, which are 'employee' and 'CLASS'.", "It selects the columns to display, which are 'EMP_FNAME' and 'EMP_DOB' from the 'employee' table.", "A JOIN operation is performed between 'employee' and 'CLASS' on the condition that the professor's identifier matches the professor number in the class.", "A condition is added to filter the results based on the specified course code using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "description": "This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.", "virtual_table": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3188", "db_id": "college_1", "question": "Where is the history department?", "rationale": ["The query identifies the relevant table, which is 'DEPARTMENT'.", "Select the column to display, 'dept_address'.", "Add a condition to filter the 'dept_name' column for the specified department using a placeholder for string values."], "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"], "description": "This virtual table provides the physical address of a department from the 'DEPARTMENT' table based on the specified department name. The placeholder in the WHERE clause represents the name of the department being queried.", "virtual_table": "SELECT dept_address FROM department WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["The query identifies the relevant table, which is 'DEPARTMENT'.", "It selects a count of distinct values from the 'dept_address' column.", "A condition is added to filter the results based on the 'school_code' using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "description": "This virtual table counts the distinct addresses of departments from the 'DEPARTMENT' table that belong to a specific school. The placeholder in the WHERE clause represents the school code.", "virtual_table": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["The query identifies the relevant table, which is 'COURSE'.", "It selects the sum of 'CRS_CREDIT' to calculate the total credit hours.", "The 'DEPT_CODE' is included to group the results by department, allowing for a summary of credit hours per department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "description": "This virtual table summarizes the total credit hours offered by each department from the 'COURSE' table. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause groups the results by department code.", "virtual_table": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code"}
{"sample_id": "train.3202", "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["The query identifies the relevant table, which is 'COURSE'.", "It selects the sum of 'crs_credit' to calculate the total credit hours for each department.", "The query groups the results by 'dept_code' to provide a summary for each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "description": "This virtual table summarizes the total credit hours for courses grouped by their respective department codes from the 'COURSE' table. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.", "virtual_table": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["The query identifies the relevant tables, which are 'department' and 'professor'.", "It selects the 'school_code' from the 'department' table.", "A JOIN operation is performed between 'department' and 'professor' on the 'dept_code' to associate professors with their respective departments.", "The results are grouped by 'school_code' to aggregate the data based on the number of professors per school.", "The results are ordered by the count of professors in descending order to prioritize schools with more professors.", "A LIMIT clause is included to allow the user to specify how many school codes they want to retrieve."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "description": "This virtual table provides a list of school codes from the 'department' table, grouped by school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.", "virtual_table": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3215", "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["The query identifies the relevant table, which is 'professor'.", "It selects a count of professors and groups the results by 'dept_code'.", "A condition is added to filter the results based on the 'prof_high_degree' column using a placeholder for string values."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "description": "This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.", "virtual_table": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the count of students and groups the results by 'dept_code'.", "The use of count(*) allows for the aggregation of student records based on their department code."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table provides a count of students grouped by their respective department codes from the 'student' table. The placeholder in the SELECT statement represents the total number of students in each department.", "virtual_table": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the sum of 'stu_hrs' to calculate the total credit hours for each department.", "The GROUP BY clause is used to aggregate the results based on 'dept_code', allowing for a summary of credit hours per department."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.", "virtual_table": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["The query identifies the relevant tables: 'COURSE', 'CLASS', and 'DEPARTMENT'.", "It joins these tables based on their foreign key relationships to link courses to their respective departments.", "The SELECT statement retrieves the 'dept_name' from the 'DEPARTMENT' table.", "The GROUP BY clause groups the results by 'dept_code' to aggregate the total credit hours for each department.", "The ORDER BY clause sorts the departments based on the sum of their credit hours in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many department names to return."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "description": "This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE', 'CLASS', and 'DEPARTMENT' tables to aggregate the total credit hours for each department, ordering the results in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of department names to retrieve.", "virtual_table": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["The query identifies the relevant tables: 'CLASS', 'ENROLL', and 'STUDENT'.", "It selects the 'stu_fname' column from the 'STUDENT' table to display the first names of students.", "The JOIN operations link the 'CLASS' table to the 'ENROLL' table using 'class_code', and the 'ENROLL' table to the 'STUDENT' table using 'stu_num'.", "A condition is added to filter the results based on the 'crs_code' from the 'CLASS' table using a placeholder for string values."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "description": "This virtual table describes the first names of students enrolled in classes associated with a specific course code from the 'CLASS', 'ENROLL', and 'STUDENT' tables. The placeholder in the WHERE clause represents the course code.", "virtual_table": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["The query identifies the relevant tables: CLASS, ENROLL, and STUDENT.", "It selects the 'stu_fname' column from the STUDENT table.", "The JOIN operations link the CLASS table to the ENROLL table using 'class_code', and the ENROLL table to the STUDENT table using 'stu_num'.", "Conditions are added to filter the results based on the specified course code and the grade received, using placeholders for string values."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "description": "This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.", "virtual_table": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["The query identifies the relevant tables: 'CLASS', 'ENROLL', 'COURSE', and 'DEPARTMENT'.", "It joins these tables based on their foreign key relationships to connect classes with their respective courses and departments.", "The SELECT statement retrieves the 'dept_name' from the 'DEPARTMENT' table.", "The GROUP BY clause groups the results by department code to count the number of classes per department.", "The ORDER BY clause sorts the results in descending order based on the count of classes, allowing the most populated departments to appear first.", "The LIMIT clause restricts the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "description": "This virtual table provides a list of department names from the 'DEPARTMENT' table that are associated with classes in the 'CLASS' table. The query joins multiple tables to aggregate the number of classes per department, allowing users to see which departments have the most classes offered. The placeholder in the LIMIT clause represents the maximum number of department names to return.", "virtual_table": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3257", "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["The query is identifying the relevant table, which is 'CLASS'.", "Select the column to display, 'class_code'.", "Add a condition to filter the 'class_room' column for the specified room using a placeholder for string values."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "description": "This virtual table describes the unique class codes from the 'CLASS' table for classes held in a specific room. The placeholder in the WHERE clause represents the room's identifier.", "virtual_table": "SELECT class_code FROM CLASS WHERE class_room  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["The query identifies the relevant table, which is 'CLASS'.", "Select the column to display, 'class_code'.", "Add a condition to filter the 'class_room' column for the specified room using a placeholder for string values."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "description": "This virtual table describes the unique class codes from the 'CLASS' table that are held in a specific classroom. The placeholder in the WHERE clause represents the room where the class is conducted.", "virtual_table": "SELECT class_code FROM CLASS WHERE class_room  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["The query identifies the relevant tables, which are 'student' and 'enroll'.", "It selects the distinct first names of students from the 'student' table.", "A JOIN operation is performed between 'student' and 'enroll' on the student number to link students with their enrollments.", "A condition is added to filter the results based on the grade received by the students using a placeholder for string values."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "description": "This virtual table provides a list of distinct first names of students who have received a specific grade in their enrolled classes. The placeholder in the WHERE clause represents the grade that the user wants to filter by.", "virtual_table": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["The query identifies the relevant table, which is 'employee'.", "Select the column to display, 'emp_fname'.", "Add a condition to filter the 'emp_jobcode' column for the specified job code using a placeholder for string values.", "Use the EXCEPT clause to exclude first names of employees who are professors by joining the 'employee' table with the 'CLASS' table on the professor's identifier."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "description": "This virtual table describes the first names of employees from the 'employee' table who hold a specific job code, excluding those who are professors teaching any class. The placeholder in the WHERE clause represents the job code of the employees.", "virtual_table": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["The query identifies the relevant table, which is 'employee'.", "Select the column to display, 'emp_fname'.", "Add a condition to filter the 'emp_jobcode' column for the specified job code using a placeholder for string values.", "Use the EXCEPT clause to exclude first names of employees who are professors by joining the 'employee' table with the 'class' table on the professor's identifier."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "description": "This virtual table describes the first names of employees from the 'employee' table who hold a specific job code, excluding those who are professors teaching any class. The placeholder in the WHERE clause represents the job code of the employees.", "virtual_table": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["The query identifies the relevant table, which is 'professor'.", "It uses the COUNT function to count the number of records that meet the specified criteria.", "The WHERE clause filters the results based on the 'prof_high_degree' column, allowing for two different degree values using placeholders for string values."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "description": "This virtual table counts the number of professors from the 'professor' table who have a specific highest degree. The placeholders in the WHERE clause represent the degrees being queried.", "virtual_table": "SELECT count(*) FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] OR prof_high_degree  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["The query identifies the relevant tables, which are 'employee' and 'class'.", "It selects the 'emp_fname' column from the 'employee' table, which contains the first names of professors.", "The JOIN operation links the 'employee' table to the 'class' table based on the professor's identifier.", "The WHERE clause filters the results based on the specified course code using a placeholder for string values.", "The INTERSECT operation is used to find common results from two identical queries, ensuring that only professors teaching the same course code are returned."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "description": "This virtual table describes the first names of professors who are teaching a specific course, identified by its course code. The query uses an INTERSECT operation to find professors who are associated with the same course code in two different instances, ensuring that only those professors who meet both conditions are returned. The placeholders in the WHERE clause represent the course code being queried.", "virtual_table": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["The query identifies the relevant tables: 'student', 'enroll', 'class', 'course', and 'department'.", "It selects the 'stu_fname' column from the 'student' table.", "The JOIN operations link the tables based on their foreign key relationships to ensure that only students enrolled in the specified classes are considered.", "The WHERE clause filters the results based on the department name, using a placeholder for string values.", "The INTERSECT operation is used to find students who are enrolled in classes from the same department in two separate queries, ensuring that only those students who meet both conditions are included."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "description": "This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.", "virtual_table": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3308", "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["The query identifies the relevant tables: 'employee', 'professor', and 'department'.", "It selects the 'emp_fname' from the 'employee' table and 'prof_office' from the 'professor' table.", "The join condition links the 'employee' and 'professor' tables through the 'emp_num' field, ensuring we get the correct professor for each employee.", "Another join is made with the 'department' table to filter based on the department name.", "The WHERE clause includes conditions to filter by the specified department name and the highest degree of the professors, using placeholders for string values."], "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"], "description": "This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.", "virtual_table": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3319", "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["The query identifies the relevant tables, which are 'student' and 'enroll'.", "It selects the columns to display, 'stu_fname' and 'stu_lname' from the 'student' table.", "A JOIN operation is performed between 'student' and 'enroll' on the 'stu_num' column to link students with their enrollments.", "Conditions are added to filter the results based on the 'enroll_grade' column for the specified grades using placeholders for string values."], "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"], "description": "This virtual table describes the first and last names of students from the 'student' table who have received specific grades in their enrolled classes. The placeholders in the WHERE clause represent the grades being queried.", "virtual_table": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING] OR T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["The query identifies the relevant tables: 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT'.", "It selects distinct first names of employees and their highest degrees.", "The join conditions link the professor to their respective employee and department, ensuring the correct relationships are maintained.", "A condition is added to filter results based on the department name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "description": "This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.", "virtual_table": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["The query identifies the relevant tables, which are 'course' and 'department'.", "It selects the 'dept_name' column from the 'department' table.", "A JOIN operation is performed on the 'dept_code' to link courses with their respective departments.", "A condition is added to filter the courses based on their description using a placeholder for string values."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "description": "This virtual table provides the names of departments that offer courses matching a specific description. The query joins the 'course' table with the 'department' table based on the department code, filtering the results to include only those courses whose descriptions contain a specified string.", "virtual_table": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["The query identifies the relevant table, which is 'competition'.", "Select the columns to display, 'Competition_type' and 'Country'.", "No filtering conditions are applied, so all records from the 'competition' table will be retrieved."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "description": "This virtual table describes the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.", "virtual_table": "SELECT Competition_type ,  Country FROM competition"}
{"sample_id": "train.3355", "db_id": "sports_competition", "question": "Please show the names and the players of clubs.", "rationale": ["The query identifies the relevant tables, which are 'club' and 'player'.", "It selects the 'name' column from the 'club' table and the 'Player_ID' column from the 'player' table.", "A JOIN operation is performed on the 'Club_ID' column to link players to their respective clubs, ensuring that only players belonging to the selected clubs are included in the results."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "description": "This virtual table describes the names of clubs along with the unique identifiers of players associated with those clubs. The join operation links the 'club' table and the 'player' table based on the common 'Club_ID' field, allowing for the retrieval of player information for each club.", "virtual_table": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["The query identifies the relevant table, which is 'player'.", "It selects the 'Position' column to display the playing positions of players.", "The GROUP BY clause is used to group the results by player name to calculate the average points.", "The HAVING clause filters the results to include only those players whose average points meet or exceed the specified threshold using a placeholder for numeric values."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "description": "This virtual table provides the playing positions of players from the 'player' table who have an average score of points greater than or equal to a specified threshold. The placeholder in the HAVING clause represents the minimum average points required.", "virtual_table": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["The query identifies the relevant table, which is 'player'.", "It selects the 'Position' column to display the playing positions of players.", "The INTERSECT operator is used to find positions of players whose points are greater than a specified lower bound and less than a specified upper bound, using placeholders for numeric values."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "description": "This virtual table describes the playing positions of players from the 'player' table who have a total points score that falls between two specified numeric values. The placeholders in the query represent the lower and upper bounds for the points scored by the players.", "virtual_table": "SELECT POSITION FROM player WHERE Points  >  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT POSITION FROM player WHERE Points  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["The query identifies the relevant table, which is 'competition'.", "It selects the 'country' column to display the countries where competitions are held.", "A condition is added to filter the results based on the 'competition_type' using a placeholder for string values.", "The results are grouped by 'country' to aggregate the data accordingly.", "The results are ordered by the count of competitions in descending order to show the most frequent countries first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "description": "This virtual table provides a list of countries where competitions of a specific type have taken place. The results are grouped by country and ordered by the number of competitions, allowing users to see which countries host the most events of that type. The placeholders in the query represent the competition type and the limit on the number of results returned.", "virtual_table": "SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3384", "db_id": "sports_competition", "question": "what is the name of the country that participated in the most tournament competitions?", "rationale": ["The query identifies the relevant table, which is 'competition'.", "It selects the 'country' column to display the countries where competitions are held.", "A condition is added to filter the results based on the 'competition_type' using a placeholder for string values.", "The results are grouped by 'country' to aggregate the data.", "The results are ordered by the count of occurrences in descending order to show the most frequent countries first.", "A limit is applied to restrict the number of countries returned, using a placeholder for numeric values."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "description": "This virtual table provides a list of countries where competitions of a specific type have taken place. The results are grouped by country and ordered by the number of occurrences, allowing users to see which countries host the most competitions of that type. The placeholders in the query represent the competition type and the limit on the number of countries to return.", "virtual_table": "SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3388", "db_id": "sports_competition", "question": "What are the countries that have never participated in any friendly-type competitions?", "rationale": ["The query identifies the relevant table, which is 'competition'.", "It selects the 'country' column to display the countries where competitions took place.", "The EXCEPT clause is used to exclude countries that hosted competitions of a specific type, with a placeholder for the competition type in the WHERE clause."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "description": "This virtual table lists the countries where competitions were held, excluding those countries that hosted competitions of a specific type. The placeholder in the WHERE clause represents the type of competition to be excluded.", "virtual_table": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["The query is identifying the relevant table, which is 'employees'.", "Select the columns to display, 'first_name', 'last_name', and 'salary'.", "Add a condition to filter the 'salary' column for employees earning less than the specified amount using a placeholder for numeric values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "description": "This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display: 'first_name', 'last_name', 'hire_date', 'salary', and 'department_id'.", "Adds a condition to filter out employees whose first names do not match a specified pattern using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "description": "This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern to filter out certain first names.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display: 'first_name', 'last_name', 'hire_date', 'salary', and 'department_id'.", "Adds a condition to filter out employees whose first names match a specific pattern using a placeholder for string values.", "Orders the results by 'department_id' to group employees by their respective departments."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "description": "This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY department_id"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display: 'first_name', 'last_name', 'hire_date', 'salary', and 'department_id'.", "Adds a condition to filter out employees whose first names match a specified pattern using a placeholder for string values.", "Orders the results by 'department_id' to group employees by their respective departments."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "description": "This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY department_id"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["The query identifies the relevant table, which is 'jobs'.", "Select the column to display, 'job_title'.", "Add a condition to filter the 'min_salary' column for values greater than the specified amount using a placeholder for numeric values."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "description": "This virtual table lists the job titles from the 'jobs' table where the minimum salary exceeds a specified amount. The placeholder in the WHERE clause represents the minimum salary threshold.", "virtual_table": "SELECT job_title FROM jobs WHERE min_salary  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["The query identifies the relevant table, which is 'jobs'.", "Select the columns to display, 'job_title' and the calculated difference between 'max_salary' and 'min_salary'.", "Add a condition to filter the 'max_salary' column to ensure it falls within the specified range using placeholders for numeric values."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "description": "This virtual table provides the job titles along with the salary range (calculated as the difference between maximum and minimum salary) for jobs in the 'jobs' table that have a maximum salary falling within a specified range. The placeholders in the WHERE clause represent the lower and upper limits of the salary range.", "virtual_table": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["The query identifies the relevant table, which is 'job_history'.", "Select the column 'employee_id' to display the unique identifier for each employee.", "Use the MAX function to find the latest 'end_date' for each employee's job history.", "Group the results by 'employee_id' to ensure that the maximum end date is calculated for each individual employee."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "description": "This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the unique identifier for each employee, while the MAX function is used to retrieve the latest end date for their job history.", "virtual_table": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the 'department_id' and calculates the average salary using the AVG function.", "A condition is added to filter out employees with a null commission percentage using a placeholder for string values.", "The results are grouped by 'department_id' to provide the average salary for each department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table provides the average salary of employees grouped by their department. The placeholder in the WHERE clause indicates that only employees with a non-null commission percentage are considered in the calculation.", "virtual_table": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the 'department_id' and calculates the average salary using the AVG function.", "A condition is added to filter out employees with a null commission percentage using a placeholder for string values.", "The results are grouped by 'department_id' to provide the average salary for each department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table provides the average salary of employees grouped by their department. The placeholder in the WHERE clause indicates that only departments with employees who have a non-null commission percentage are included in the results.", "virtual_table": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["The query identifies the relevant table, which is 'locations'.", "It selects the 'country_id' to group the results by each country.", "The COUNT function is used to count the number of locations for each country, and the results are grouped by 'country_id' to provide a summary of locations per country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "description": "This virtual table summarizes the number of locations associated with each country in the 'locations' table. The placeholder in the SELECT clause represents the unique identifier for each country, while the COUNT function aggregates the total number of locations per country.", "virtual_table": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["The query identifies the relevant table, which is 'locations'.", "It selects the 'country_id' to group the results by each country.", "The COUNT function is used to count the number of locations for each country, and the results are grouped by 'country_id' to provide a summary of locations per country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "description": "This virtual table summarizes the number of locations associated with each country from the 'locations' table. The placeholder in the SELECT clause represents the unique identifier for each country, while the COUNT function aggregates the total number of locations per country.", "virtual_table": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["The query identifies the relevant tables, which are 'job_history' and 'employees'.", "It selects all columns from the joined tables using the wildcard '*'.", "The JOIN operation is performed on the employee identifier to link job history with employee details.", "A condition is added to filter employees based on their salary using a placeholder for numeric values."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "description": "This virtual table provides a comprehensive view of the job history of employees who have a salary greater than or equal to a specified amount. It combines data from the 'job_history' and 'employees' tables, linking them through the employee identifier. The placeholder in the WHERE clause represents the minimum salary threshold for filtering the results.", "virtual_table": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It performs a JOIN operation on the 'department_id' to link employees with their respective departments.", "The WHERE clause filters the results to include only those employees whose 'employee_id' matches the 'manager_id' in the departments table."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "description": "This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that each employee-manager pair is unique.", "virtual_table": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects distinct 'department_id' to ensure unique entries.", "The results are grouped by 'department_id' and 'manager_id' to aggregate the data accordingly.", "A HAVING clause is used to filter groups based on the count of 'employee_id', ensuring only departments with a specified minimum number of employees are included, using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "description": "This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.", "virtual_table": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects distinct 'department_id' to ensure unique departments are listed.", "The results are grouped by 'department_id' and 'manager_id' to aggregate employee counts per department and manager.", "The HAVING clause is used to filter groups based on the count of 'employee_id', ensuring only departments with a specified minimum number of employees are included, using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "description": "This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees. The placeholder in the HAVING clause represents the minimum count of employees required for a department to be included in the results.", "virtual_table": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects all columns from the 'employees' table.", "A condition is added to filter employees based on their salary, using a subquery to find the minimum salary and a placeholder for the upper limit of the salary range."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "description": "This virtual table retrieves all employee records from the 'employees' table whose salary falls within a specified range. The lower limit of the salary range is dynamically determined by selecting the minimum salary from the same table, while the upper limit is represented by a placeholder for numeric values.", "virtual_table": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'hire_date'.", "Add a condition to filter the 'department_id' by using a subquery that retrieves the 'department_id' of an employee based on their first name, with a placeholder for the first name value."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "description": "This virtual table provides the first names, last names, and hire dates of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the subquery represents the first name of the employee whose department is being queried.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'hire_date'.", "Add a condition to filter the 'department_id' by using a subquery that finds the department of a specified employee based on their first name.", "Include an additional condition to exclude the specified employee's first name from the results."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "description": "This virtual table provides the first names, last names, and hire dates of employees from the 'employees' table who belong to the same department as a specified employee, while excluding the specified employee's name. The placeholders in the WHERE clause represent the first name of the employee to find the department and the first name to exclude.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  [PLACEHOLDER-TYPE:STRING]) AND first_name != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', and 'last_name'.", "Add a condition to filter the 'department_id' using a subquery that selects 'department_id' from the 'employees' table where the 'first_name' matches a specified value, using a placeholder for string values."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "description": "This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause represents the first name of the employee whose department is being queried.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display, 'employee_id' and 'job_id'.", "Add a condition to filter employees whose salary is less than a certain value.", "The subquery retrieves the minimum salary for a specified job using a placeholder for the job identifier."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "description": "This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.", "virtual_table": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the 'department_id' and calculates the total salary using SUM(salary).", "The results are grouped by 'department_id' to aggregate the salaries for each department.", "A condition is added in the HAVING clause to filter departments based on the number of employees, using a placeholder for numeric values."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "description": "This virtual table summarizes the total salary of employees grouped by their department. It includes only those departments that have a minimum number of employees, as specified by the placeholder in the HAVING clause.", "virtual_table": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display: 'first_name', 'last_name', 'salary', and 'department_id'.", "Uses the MAX function to find the highest salary within each department.", "Groups the results by 'department_id' to aggregate the data accordingly."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.", "virtual_table": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', and 'locations'.", "It selects the 'first_name' and 'last_name' from the 'employees' table and 'city' from the 'locations' table.", "A JOIN operation is performed between 'employees' and 'departments' on 'department_id', and between 'departments' and 'locations' on 'location_id'.", "A condition is added to filter the results based on the 'first_name' using a placeholder for string values."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "description": "This virtual table provides the first and last names of employees along with the city of their department's location. The data is sourced from the 'employees', 'departments', and 'locations' tables, with a filter applied to the first name of the employees using a placeholder for string values.", "virtual_table": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', 'locations', and 'countries'.", "It selects the 'first_name', 'last_name', and 'employee_id' from the 'employees' table (aliased as T1).", "It joins the 'departments' table (T2) on the 'department_id' to associate employees with their departments.", "It further joins the 'locations' table (T3) on 'location_id' to link departments to their locations.", "Finally, it joins the 'countries' table (T4) on 'country_id' to retrieve the country names associated with the locations."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "description": "This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.", "virtual_table": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It selects the 'department_name' from the 'departments' table and counts the number of employees from the 'employees' table.", "A JOIN operation is performed on the 'department_id' to link employees to their respective departments.", "The results are grouped by 'department_name' to provide a count of employees per department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "description": "This virtual table provides a summary of the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement allows for the retrieval of the department name along with the count of employees in that department.", "virtual_table": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It selects the 'department_name' from the 'departments' table and counts the number of employees in each department.", "A JOIN operation is performed on the 'department_id' to link employees to their respective departments.", "The results are grouped by 'department_name' to provide a count of employees per department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "description": "This virtual table provides a count of employees grouped by their respective department names from the 'employees' and 'departments' tables. The placeholder in the COUNT function allows for dynamic counting of employees in each department.", "virtual_table": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', and 'locations'.", "It selects the columns to display: 'first_name', 'last_name', and 'salary'.", "It joins the 'employees' table with the 'departments' table on the 'department_id' column.", "It further joins the 'departments' table with the 'locations' table on the 'location_id' column.", "A condition is added to filter the results based on the 'city' column in the 'locations' table using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "description": "This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', and 'locations'.", "It selects the columns to display: 'first_name', 'last_name', and 'salary'.", "It joins the 'employees' table with the 'departments' table on the 'department_id' column.", "It further joins the 'departments' table with the 'locations' table on the 'location_id' column.", "A condition is added to filter the results based on the 'city' column in the 'locations' table using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "description": "This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3532", "db_id": "music_1", "question": "Find the id of the song that lasts the longest.", "rationale": ["The query identifies the relevant table, which is 'files'.", "It selects the 'f_id' column to display the unique identifiers of the files.", "The results are ordered by the 'duration' column in descending order to show the longest files first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "description": "This virtual table provides a list of file identifiers from the 'files' table, ordered by the duration of the audio files in descending order. The placeholder in the LIMIT clause indicates the maximum number of file identifiers to return.", "virtual_table": "SELECT f_id FROM files ORDER BY duration DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["The query identifies the relevant tables, 'song' and 'files', and uses a JOIN to combine them based on the matching 'f_id'.", "It selects the 'artist_name' from the 'song' table (aliased as T1).", "The JOIN condition ensures that only songs with corresponding files are included.", "The results are ordered by the 'duration' from the 'files' table (aliased as T2).", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "description": "This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.", "virtual_table": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["The query identifies the relevant table, which is 'files'.", "It selects a count of all records that meet a certain condition.", "The condition filters the records based on the 'duration' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "description": "This virtual table provides a count of audio files from the 'files' table that match a specific duration pattern. The placeholder in the WHERE clause represents the duration criteria to filter the files.", "virtual_table": "SELECT count(*) FROM files WHERE duration LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3549", "db_id": "music_1", "question": "What is the average rating of songs produced by female artists?", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It uses a JOIN operation to connect these tables based on the 'artist_name' column.", "The SELECT statement calculates the average of the 'rating' column from the 'song' table.", "A WHERE clause is added to filter the results based on the 'gender' column from the 'artist' table, using a placeholder for string values."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "description": "This virtual table calculates the average rating of songs performed by artists of a specific gender. It joins the 'artist' and 'song' tables based on the artist's name, filtering the results to include only those artists whose gender matches the specified placeholder.", "virtual_table": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["The query identifies the relevant table, which is 'files'.", "Select the 'formats' column to display the different audio file formats.", "Group the results by 'formats' to aggregate the data based on format type.", "Order the results by the count of files in each format in descending order to show the most common formats first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "description": "This virtual table provides a list of audio file formats from the 'files' table, grouped by format type. The results are ordered by the count of files in each format, allowing users to see the most common formats used. The placeholder in the LIMIT clause represents the maximum number of formats to return.", "virtual_table": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3556", "db_id": "music_1", "question": "What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?", "rationale": ["The query is identifying the relevant tables, which are 'files' and 'song'.", "Select the column to display, 'f_id', which is the unique identifier for the file.", "Add a condition to filter the 'formats' column in the 'files' table for the specified format using a placeholder for string values.", "Use an INTERSECT to find common 'f_id' values between the two tables based on the specified conditions.", "Add a condition to filter the 'resolution' column in the 'song' table for values less than the specified number using a placeholder for numeric values."], "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"], "description": "This virtual table identifies the unique file identifiers from the 'files' table that are available in a specific format and also exist in the 'song' table with a resolution lower than a specified value. The placeholders in the WHERE clauses represent the format of the file and the maximum resolution allowed.", "virtual_table": "SELECT f_id FROM files WHERE formats  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT f_id FROM song WHERE resolution  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["The query identifies the relevant tables, 'artist' and 'song', and establishes a join condition based on the 'artist_name' column.", "It selects the 'country' column from the 'artist' table.", "The WHERE clause filters the results based on the specified gender of the artist and the languages of the songs, using placeholders for these values."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "description": "This virtual table provides a list of countries from which artists originate, filtered by the gender of the artist and the languages in which their songs are available. The placeholders in the WHERE clause represent the specific gender and language criteria.", "virtual_table": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING] AND T2.languages  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["The query identifies the relevant tables, 'artist' and 'song', and establishes a join condition based on the artist's name.", "It selects the 'country' column from the 'artist' table.", "The WHERE clause filters the results based on the artist's gender and the languages of the songs, using placeholders for these criteria."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "description": "This virtual table provides a list of countries from which artists originate, filtered by the gender of the artist and the languages in which their songs are available. The placeholders in the WHERE clause represent the specific gender and language criteria.", "virtual_table": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING] AND T2.languages  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It selects the 'gender' and 'artist_name' columns from the 'artist' table (aliased as T1).", "A JOIN operation is performed between the 'artist' table and the 'song' table based on the 'artist_name' column to link artists with their songs.", "The results are ordered by the 'resolution' column from the 'song' table (aliased as T2).", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "description": "This virtual table provides a list of artists along with their gender from the 'artist' table, specifically for those artists who have songs in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3567", "db_id": "music_1", "question": "For each file format, return the number of artists who released songs in that format.", "rationale": ["The query identifies the relevant table, which is 'files'.", "It selects the count of files and groups the results by the 'formats' column.", "The use of count(*) allows us to aggregate the number of files for each unique format available."], "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"], "description": "This virtual table provides a count of audio files grouped by their available formats from the 'files' table. The placeholder in the SELECT clause represents the count of files for each format.", "virtual_table": "SELECT count(*) ,  formats FROM files GROUP BY formats"}
{"sample_id": "train.3576", "db_id": "music_1", "question": "What are the names and genders of all artists who released songs in the month of March?", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It selects the columns to display, 'artist_name' and 'gender' from the 'artist' table.", "A JOIN operation is performed on the 'artist' and 'song' tables based on the 'artist_name' column to link the two tables.", "A condition is added to filter the results based on the 'releasedate' column from the 'song' table using a placeholder for string values."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "description": "This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.", "virtual_table": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["The query identifies the relevant table, which is 'song'.", "It selects the 'languages' column to display.", "The results are grouped by 'languages' to aggregate the data.", "The results are ordered by the count of songs in each language in descending order.", "A limit is applied to restrict the number of languages returned, using a placeholder for numeric values."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "description": "This virtual table provides a list of languages in which songs are available, grouped by language and ordered by the number of songs in each language. The placeholder in the LIMIT clause allows the user to specify the maximum number of languages to retrieve.", "virtual_table": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3590", "db_id": "music_1", "question": "What are the names of all male British artists?", "rationale": ["The query is identifying the relevant table, which is 'artist'.", "Select the column to display, 'artist_name'.", "Add conditions to filter the 'country' and 'gender' columns for the specified values using placeholders for string values."], "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"], "description": "This virtual table describes the names of artists from the 'artist' table who are from a specific country and belong to a specific gender. The placeholders in the WHERE clause represent the country and gender of the artists.", "virtual_table": "SELECT artist_name FROM artist WHERE country  =  [PLACEHOLDER-TYPE:STRING] AND gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3598", "db_id": "music_1", "question": "What is the average rating and resolution of all bangla songs?", "rationale": ["The query identifies the relevant table, which is 'song'.", "It selects the average of the 'rating' and 'resolution' columns to provide aggregated data.", "A condition is added to filter the songs based on the specified language using a placeholder for string values."], "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"], "description": "This virtual table calculates the average rating and average resolution of songs from the 'song' table that are available in a specific language. The placeholder in the WHERE clause represents the language of the songs.", "virtual_table": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3599", "db_id": "music_1", "question": "What are the maximum and minimum resolution of songs whose duration is 3 minutes?", "rationale": ["The query identifies the relevant tables, which are 'files' and 'song'.", "It uses a JOIN operation to connect these tables based on the foreign key relationship between 'files.f_id' and 'song.f_id'.", "The SELECT statement retrieves the maximum and minimum values of the 'resolution' column from the 'song' table.", "A condition is added to filter the results based on the 'duration' column from the 'files' table using a placeholder for string values."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "description": "This virtual table provides the maximum and minimum audio resolutions of songs from the 'song' table, filtered by the duration of the associated files in the 'files' table. The placeholder in the WHERE clause represents the specific duration pattern to match.", "virtual_table": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["The query identifies the relevant tables, 'files' and 'song', and uses a JOIN to connect them based on the foreign key relationship between 'f_id'.", "It selects the maximum duration from the 'files' table and the maximum resolution from the 'song' table, along with the languages from the 'song' table.", "The results are grouped by languages to provide a summary for each language category, and ordered by languages for better readability."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "description": "This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.", "virtual_table": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["The query identifies the relevant tables, which are 'files' and 'song'.", "It selects the minimum duration from the 'files' table and the minimum rating from the 'song' table, along with the genre of the song.", "The JOIN operation links the two tables based on the file identifier, ensuring that the data corresponds correctly between audio files and songs.", "The results are grouped by the genre of the song to aggregate the data accordingly, and ordered by the genre for better readability."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "description": "This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.", "virtual_table": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is"}
{"sample_id": "train.3607", "db_id": "music_1", "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It selects the columns 'artist_name' and 'country' from the 'artist' table.", "A JOIN operation is performed between 'artist' and 'song' on the 'artist_name' column to combine relevant data.", "A condition is added to filter songs based on their resolution using a placeholder for numeric values.", "The results are grouped by 'artist_name' to aggregate the data for each artist.", "A HAVING clause is used to filter the grouped results to include only those artists with a count of songs that meets the specified threshold."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"], "description": "This virtual table provides the names and countries of artists from the 'artist' table who have songs in the 'song' table with a resolution greater than a specified value. The results are grouped by artist name, and only those artists with a count of songs meeting the resolution criteria that is greater than or equal to a specified number are included.", "virtual_table": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.artist_name HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3619", "db_id": "music_1", "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.", "rationale": ["The query identifies the relevant tables, which are 'artist' and 'song'.", "It selects the 'artist_name' from the 'artist' table.", "A JOIN operation is performed on the 'artist_name' column to link the two tables.", "A condition is added to filter the songs based on the specified language using a placeholder for string values.", "The results are grouped by 'artist_name' to aggregate the data.", "The results are ordered by the count of songs in descending order to show the most prolific artists first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "description": "This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.", "virtual_table": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3623", "db_id": "music_1", "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?", "rationale": ["The query identifies the relevant tables, 'files' and 'song', and uses a JOIN to connect them based on the file identifier 'f_id'.", "It selects the columns 'duration', 'file_size', and 'formats' from the 'files' table.", "A condition is added to filter the results based on the genre of the songs using a placeholder for string values.", "The results are ordered by the song name for better organization."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "description": "This virtual table provides information about the duration, file size, and available formats of audio files associated with songs from a specific genre. The placeholder in the WHERE clause represents the genre of the songs being queried.", "virtual_table": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T2.song_name"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["The query identifies the relevant tables, 'files' and 'song', and uses a JOIN to connect them based on the file identifier 'f_id'.", "It selects the columns 'duration', 'file_size', and 'formats' from the 'files' table.", "A condition is added to filter the results based on the genre of the song using a placeholder for string values.", "The results are ordered by the song name for better organization."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "description": "This virtual table provides information about the duration, file size, and available formats of audio files associated with songs from a specific genre. The placeholder in the WHERE clause represents the genre of interest.", "virtual_table": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T2.song_name"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["The query identifies the relevant tables, which are 'salary' and 'team'.", "It selects the average salary from the 'salary' table.", "A join is performed between the 'salary' table and the 'team' table using the team identifier to ensure the correct team is referenced.", "A condition is added to filter the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "description": "This virtual table calculates the average salary of players from a specific team. It joins the 'salary' table with the 'team' table based on the team identifier, filtering the results to include only the team with the specified name.", "virtual_table": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["The query identifies the relevant table, which is 'player'.", "It selects the 'birth_country' column to display the countries of birth.", "The GROUP BY clause is used to group the results by 'birth_country'.", "The ORDER BY clause sorts the results by the count of players from each country in ascending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many countries to return."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "description": "This virtual table provides a list of countries where players were born, grouped by country and ordered by the number of players from each country in ascending order. The placeholder in the LIMIT clause allows for specifying the maximum number of countries to return.", "virtual_table": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["The query identifies the relevant tables, which are 'team' and 'salary'.", "It selects the 'name' and 'team_id' from the 'team' table and the maximum salary from the 'salary' table.", "A JOIN operation is performed on the 'team_id' to link the two tables based on the team identifier.", "The results are grouped by 'team_id' to ensure that each team appears only once with its maximum salary."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "description": "This virtual table provides the names and identifiers of teams along with their highest recorded salary from the 'salary' table. The data is grouped by team identifiers to ensure that each team is represented only once with its maximum salary.", "virtual_table": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;"}
{"sample_id": "train.3658", "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["The query identifies the relevant tables, which are 'team' and 'salary'.", "It selects the 'name' and 'team_id' from the 'team' table and the maximum salary from the 'salary' table.", "A JOIN operation is performed on the 'team_id' to link the two tables based on the team identifier.", "The results are grouped by 'team_id' to ensure that each team appears only once with its maximum salary."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "description": "This virtual table provides the names and identifiers of teams along with their highest recorded salary from the 'salary' table. The data is grouped by team identifiers to ensure that each team is represented only once with its maximum salary.", "virtual_table": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["The query identifies the relevant tables, 'team' and 'salary'.", "It selects the 'name' and 'team_id' from the 'team' table (aliased as T1).", "It joins the 'team' table with the 'salary' table (aliased as T2) on the 'team_id' column to associate teams with their players' salaries.", "The results are grouped by 'team_id' to calculate the average salary for each team.", "The results are ordered by the average salary in ascending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "description": "This virtual table provides a list of team names and their corresponding team IDs from the 'team' table, along with the average salary of players from each team. The results are ordered by the average salary in ascending order, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["The query starts by selecting the first and last names of players from the 'player' table, aliased as T1.", "It joins the 'player_award' table, aliased as T2, to filter players based on the year of the award.", "The first part of the query specifies a year using a placeholder for numeric values.", "The INTERSECT operator is used to find players who also received awards in a second specified year, again using a placeholder for numeric values."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "description": "This virtual table identifies players who received awards in two different years. It selects the first and last names of players from the 'player' table who have awards recorded in the 'player_award' table for the specified years. The use of INTERSECT ensures that only players who received awards in both years are included in the results.", "virtual_table": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3663", "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["The query identifies the relevant table, which is 'player'.", "Select the columns to display, 'name_first' and 'name_last'.", "Add conditions to filter the 'weight' and 'height' columns using placeholders for numeric values."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "description": "This virtual table describes the first and last names of players from the 'player' table who either weigh more than a specified amount or are shorter than a specified height. The placeholders in the WHERE clause represent the weight and height criteria.", "virtual_table": "SELECT name_first ,  name_last FROM player WHERE weight  >  [PLACEHOLDER-TYPE:NUMBER] OR height  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3664", "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["The query identifies the relevant table, which is 'player'.", "Select the columns to display, 'name_first' and 'name_last'.", "Add a condition to filter the 'weight' column for values greater than a specified number and the 'height' column for values less than a specified number using placeholders for numeric values."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "description": "This virtual table describes the first and last names of players from the 'player' table who either weigh more than a specified amount or are shorter than a specified height. The placeholders in the WHERE clause represent the weight and height criteria.", "virtual_table": "SELECT name_first ,  name_last FROM player WHERE weight  >  [PLACEHOLDER-TYPE:NUMBER] OR height  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the maximum wins from the 'postseason' table.", "A JOIN is performed between 'postseason' and 'team' on the winning team identifier to link the team name.", "A condition is added to filter the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "description": "This virtual table calculates the maximum number of wins achieved by any team in the postseason from the 'postseason' table, specifically for the team identified by its name in the 'team' table. The placeholder in the WHERE clause represents the name of the team being queried.", "virtual_table": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the maximum wins from the 'postseason' table.", "A JOIN operation is performed to link the winning team from the 'postseason' table with the corresponding team name from the 'team' table.", "A condition is added to filter the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "description": "This virtual table calculates the maximum number of wins achieved by any team in the postseason, specifically for a team identified by its name. The placeholder in the WHERE clause represents the name of the team being queried.", "virtual_table": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3672", "db_id": "baseball_1", "question": "For each year, return the year and the number of times the team Boston Red Stockings won in the postseasons.", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the count of wins and the year from the 'postseason' table.", "A JOIN is performed between 'postseason' and 'team' on the winning team identifier.", "A condition is added to filter results based on the specified team name using a placeholder for string values.", "The results are grouped by year to provide a count of wins per year."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "description": "This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.", "virtual_table": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year"}
{"sample_id": "train.3677", "db_id": "baseball_1", "question": "What is the total salary paid by team Boston Red Stockings in 2010?", "rationale": ["The query identifies the relevant tables, 'salary' and 'team'.", "It selects the sum of salaries from the 'salary' table (aliased as T1).", "A join is performed between the 'salary' table and the 'team' table on the team_id to link salary records to the respective teams.", "Conditions are added to filter the results based on the specified team name and year using placeholders for string and numeric values."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "description": "This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.", "virtual_table": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["The query identifies the relevant table, which is 'salary'.", "Select the 'salary' column to display the salary amounts.", "Add a condition to filter the records for a specific year using a placeholder for numeric values.", "Sort the results in descending order based on salary.", "Limit the number of records returned using a placeholder for numeric values."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "description": "This virtual table provides the salary records from the 'salary' table for a specific year, sorted in descending order. The placeholders represent the year for which the salary data is requested and the limit on the number of records to return.", "virtual_table": "SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY salary DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3682", "db_id": "baseball_1", "question": "How much salary did the top 3 well-paid players get in 2001?", "rationale": ["The query identifies the relevant table, which is 'salary'.", "It selects the 'salary' column to display the salary amounts.", "A condition is added to filter the records for a specific year using a placeholder for numeric values.", "The results are ordered by salary in descending order to show the highest salaries first.", "A limit is applied to restrict the number of records returned, using a placeholder for numeric values."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "description": "This virtual table provides the salary records from the 'salary' table for a specific year, sorted in descending order. The placeholders represent the year for which the salary data is requested and the limit on the number of records to return.", "virtual_table": "SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY salary DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3683", "db_id": "baseball_1", "question": "What were all the salary values of players in 2010 and 2001?", "rationale": ["The query identifies the relevant table, which is 'salary'.", "It selects the 'salary' column to display the salary amounts.", "The WHERE clause filters the records for two specific years using placeholders for numeric values.", "The UNION operator combines the results from both years into a single result set."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "description": "This virtual table retrieves the salary records for players in two specific years from the 'salary' table. The placeholders represent the years for which the salary data is being queried.", "virtual_table": "SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["The query identifies the relevant table, which is 'hall_of_fame'.", "It selects the 'yearid' column to display the years of induction.", "The results are grouped by 'yearid' to aggregate the data by year.", "The results are ordered by the count of inductees in ascending order to show the years with fewer inductees first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "description": "This virtual table provides a list of years in which players were inducted into the Hall of Fame, grouped by year. The results are ordered by the number of inductees in ascending order, with a limit set by a placeholder for numeric values to specify how many years to return.", "virtual_table": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["The query identifies the relevant table, which is 'hall_of_fame'.", "It selects the 'yearid' column to display the years of induction.", "The results are grouped by 'yearid' to aggregate the data for each year.", "The results are ordered by the count of inductees in ascending order to show the years with fewer inductees first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "description": "This virtual table provides a list of years in which players were inducted into the Hall of Fame, grouped by year. The results are ordered by the number of inductees in ascending order, with a limit set by a placeholder for numeric values.", "virtual_table": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It uses a JOIN operation to connect these tables based on the park identifier.", "The SELECT statement counts the total number of home games.", "The WHERE clause filters the results by the specified year and park name using placeholders for numeric and string values."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "description": "This virtual table provides the total count of home games played in a specific year at a designated park. The placeholders represent the year of the games and the name of the park.", "virtual_table": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T2.park_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It uses a JOIN operation to connect these tables based on the park identifier.", "The SELECT statement counts the total number of home games.", "The WHERE clause filters the results by the specified year and park name using placeholders for numeric and string values."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "description": "This virtual table provides the total count of home games played in a specific year at a designated park. The placeholders represent the year of the games and the name of the park.", "virtual_table": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T2.park_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It selects the count of home games by using the count(*) function.", "A JOIN operation is performed between 'home_game' and 'park' on the park_id to link the games to their respective parks.", "A WHERE clause is added to filter the results based on the specified year and city, using placeholders for the year and city values."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "description": "This virtual table provides the total count of home games played in a specific year at parks located in a specified city. The placeholders represent the year of the home games and the city where the park is situated.", "virtual_table": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.city  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It selects the count of home games by using the count(*) function.", "A JOIN operation is performed between 'home_game' and 'park' on the park_id to link the games with their respective parks.", "A WHERE clause is added to filter the results based on the specified year and city, using placeholders for the year and city values."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "description": "This virtual table provides the total count of home games played in a specific year at parks located in a specified city. The placeholders represent the year of the home games and the city where the park is situated.", "virtual_table": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.city  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3693", "db_id": "baseball_1", "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the sum of the 'attendance' column from the 'home_game' table.", "A join is performed between 'home_game' and 'team' on the 'team_id_br' to link the attendance data to the specific team.", "A condition is added to filter by the team's name using a placeholder for string values.", "Another condition is included to filter the years using placeholders for numeric values."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "description": "This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.", "virtual_table": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3698", "db_id": "baseball_1", "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?", "rationale": ["The query identifies the relevant tables: 'salary', 'player', and 'team'.", "It selects the 'name_first' and 'name_last' columns from the 'player' table.", "The query joins the 'salary' table with the 'player' table using 'player_id' to link salary records to players.", "It also joins the 'team' table using 'team_id_br' to filter players based on the team they were associated with.", "The WHERE clause includes placeholders for the year and team name to filter the results accordingly."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "description": "This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the WHERE clause represent the year and the team's name.", "virtual_table": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the 'name' column from the 'team' table, which contains the names of the teams.", "A JOIN operation is performed between 'home_game' and 'team' on the 'team_id' to link home games with their respective teams.", "A condition is added to filter the results based on the specified year using a placeholder for numeric values.", "The results are ordered by the 'attendance' column in ascending order and limited to a specified number of results using placeholders."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "description": "This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.", "virtual_table": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3709", "db_id": "baseball_1", "question": "Which park had most attendances in 2008?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It selects the 'park_name' from the 'park' table.", "A join is performed between 'home_game' and 'park' on the 'park_id' to link home games to their respective parks.", "A condition is added to filter the results for a specific year using a placeholder for numeric values.", "The results are ordered by attendance in descending order and limited to a specified number using placeholders."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "description": "This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.", "virtual_table": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3857", "db_id": "insurance_policies", "question": "Find the settlement amount of the claim with the largest claim amount. Show both the settlement amount and claim amount.", "rationale": ["The query identifies the relevant table, which is 'Claims'.", "Selects the columns 'Amount_Settled' and 'Amount_Claimed' to display the financial details of the claims.", "Orders the results by 'Amount_Claimed' in descending order to show the highest claims first.", "Includes a limit on the number of records returned, using a placeholder for numeric values."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"], "description": "This virtual table provides a summary of the amounts claimed and settled for insurance claims from the 'Claims' table. The results are ordered by the claimed amount in descending order, and the placeholder allows for limiting the number of records returned.", "virtual_table": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3862", "db_id": "insurance_policies", "question": "Among all the claims, which settlements have a claimed amount that is no more than the average? List the claim start date.", "rationale": ["The query identifies the relevant table, which is 'Claims'.", "Select the column 'Date_Claim_Made' to display the dates of claims.", "Add a condition to filter the claims where 'Amount_Settled' is less than or equal to the average settled amount, using a subquery to calculate the average settled amount from the 'Claims' table."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "description": "This virtual table provides the dates when claims were made for those claims that have a settled amount less than or equal to the average settled amount across all claims. The placeholder in the subquery represents the average amount settled for comparison.", "virtual_table": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )"}
{"sample_id": "train.3863", "db_id": "insurance_policies", "question": "Return the claim start date for the claims whose claimed amount is no more than the average", "rationale": ["The query identifies the relevant table, which is 'Claims'.", "It selects the 'Date_Claim_Made' column to display the dates of claims.", "A condition is added to filter claims where 'Amount_Settled' is less than or equal to the average settled amount, which is calculated using a subquery that selects the average from the 'Amount_Settled' column in the 'Claims' table."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "description": "This virtual table provides the dates when claims were made for those claims that have a settled amount less than or equal to the average settled amount across all claims. The placeholder in the subquery represents the average settled amount calculated from the Claims table.", "virtual_table": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )"}
{"sample_id": "train.3868", "db_id": "insurance_policies", "question": "How many settlements were made on the claim with the most recent claim settlement date? List the number and the claim id.", "rationale": ["The query identifies the relevant tables, which are 'Claims' and 'Settlements'.", "It selects the count of claims and the claim ID from the 'Claims' table.", "A JOIN operation is performed on the claim ID to link claims with their corresponding settlements.", "The results are grouped by the claim ID to aggregate the count of claims for each unique claim.", "The results are ordered by the date the claims were settled in descending order to show the most recent settlements first.", "A placeholder is included in the LIMIT clause to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "description": "This virtual table provides a count of claims along with their unique identifiers from the 'Claims' table, joined with the 'Settlements' table. The results are grouped by the claim ID and ordered by the date the claims were settled in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3869", "db_id": "insurance_policies", "question": "Find the claim id and the number of settlements made for the claim with the most recent settlement date.", "rationale": ["The query identifies the relevant tables, which are 'Claims' and 'Settlements'.", "It selects the count of claims and the claim ID from the 'Claims' table.", "A JOIN operation is performed on the claim ID to link claims with their corresponding settlements.", "The results are grouped by the claim ID to aggregate the count of claims for each unique claim.", "The results are ordered by the date the claims were settled in descending order to show the most recent settlements first.", "A placeholder is included in the LIMIT clause to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "description": "This virtual table provides a count of claims along with their unique identifiers from the 'Claims' table, joined with the 'Settlements' table. The results are grouped by the claim ID and ordered by the date the claims were settled in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3878", "db_id": "insurance_policies", "question": "What is the most popular payment method?", "rationale": ["The query identifies the relevant table, which is 'Payments'.", "It selects the 'Payment_Method_Code' column to display the different payment methods.", "The results are grouped by 'Payment_Method_Code' to aggregate the data based on unique payment methods.", "The results are ordered by the count of each payment method in descending order to show the most frequently used methods first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "description": "This virtual table provides a summary of the different payment methods used in the 'Payments' table, grouped by the payment method code. The results are ordered by the frequency of each payment method, allowing users to see the most commonly used methods. The placeholder in the LIMIT clause represents the maximum number of payment methods to return.", "virtual_table": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3879", "db_id": "insurance_policies", "question": "Which payment method is used the most often?", "rationale": ["The query identifies the relevant table, which is 'Payments'.", "It selects the 'Payment_Method_Code' column to display the different payment methods.", "The query groups the results by 'Payment_Method_Code' to aggregate the data based on unique payment methods.", "It orders the results by the count of each payment method in descending order to show the most frequently used methods first.", "The LIMIT clause uses a placeholder to allow the user to specify how many payment methods they want to retrieve."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "description": "This virtual table provides a summary of the different payment methods used in the 'Payments' table, grouped by the payment method code. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve, sorted by the frequency of their usage in descending order.", "virtual_table": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3880", "db_id": "insurance_policies", "question": "With which kind of payment method were the least number of payments processed?", "rationale": ["The query identifies the relevant table, which is 'Payments'.", "It selects the 'Payment_Method_Code' column to display unique payment methods.", "The GROUP BY clause is used to group the results by 'Payment_Method_Code'.", "The ORDER BY clause sorts the grouped results by their count in ascending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many unique payment methods they want to retrieve."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"], "description": "This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the payment method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.", "virtual_table": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3886", "db_id": "insurance_policies", "question": "Which kind of policy type was chosen by the most customers?", "rationale": ["The query identifies the relevant table, which is 'Customer_Policies'.", "It selects the 'Policy_Type_Code' to display the different types of insurance policies.", "The GROUP BY clause is used to group the results by 'Policy_Type_Code'.", "The ORDER BY clause sorts the grouped results by their count in descending order to show the most common policy types first.", "The LIMIT clause includes a placeholder to allow the user to specify how many policy types they want to retrieve."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "description": "This virtual table summarizes the different types of insurance policies from the 'Customer_Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.", "virtual_table": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3893", "db_id": "insurance_policies", "question": "Which customers do not have any policies? Find the details of these customers.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'customer_details' column to display.", "The EXCEPT clause is used to exclude customer details that are linked to any policies by joining 'Customers' with 'Customer_Policies' on 'Customer_ID' to filter out those customers."], "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"], "description": "This virtual table provides a list of customer details from the 'Customers' table, excluding those customers who have associated insurance policies. The query uses an EXCEPT clause to filter out customers that are linked to any policies in the 'Customer_Policies' table.", "virtual_table": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id"}
{"sample_id": "train.3895", "db_id": "insurance_policies", "question": "Which claims had exactly one settlement? For each, tell me the the date the claim was made, the date it was settled and the amount settled.", "rationale": ["The query identifies the relevant tables, which are 'Claims' and 'Settlements'.", "It selects the columns to display: 'claim_id', 'date_claim_made', and 'Date_Claim_Settled' from the 'Claims' table.", "A JOIN operation is performed to link claims with their corresponding settlements based on the 'Claim_id'.", "The results are grouped by 'claim_id' to aggregate the data for each claim.", "The HAVING clause is used to filter the results based on the count of settlements associated with each claim, using a placeholder for numeric values."], "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"], "description": "This virtual table provides a summary of claims from the 'Claims' table that have been linked to settlements in the 'Settlements' table. It displays the claim ID, the date the claim was made, and the date the claim was settled. The placeholder in the HAVING clause represents the number of settlements associated with each claim, allowing users to filter claims based on their settlement count.", "virtual_table": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["The query identifies the relevant table, which is 'Department'.", "It selects the 'name' column to display the names of the departments.", "The results are grouped by 'departmentID' to aggregate the data based on unique department identifiers.", "The results are ordered by the count of 'departmentID' in descending order to prioritize the most referenced departments.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "description": "This virtual table provides a list of department names from the 'Department' table, grouped by their unique identifiers. The results are ordered by the count of occurrences of each department ID in descending order, allowing users to see the most frequently referenced departments. The placeholder in the LIMIT clause represents the maximum number of department names to return.", "virtual_table": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["The query identifies the relevant table, which is 'Department'.", "It selects the 'name' column to display the names of the departments.", "The results are grouped by 'DepartmentID' to aggregate the data based on unique department identifiers.", "The results are ordered by the count of 'DepartmentID' in descending order to prioritize the most referenced departments.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "description": "This virtual table provides a list of department names from the 'Department' table, grouped by their unique identifiers. The results are ordered by the count of occurrences of each department ID in descending order, allowing users to see the most frequently referenced departments. The placeholder in the LIMIT clause represents the maximum number of department names to return.", "virtual_table": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3901", "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["The query identifies the relevant table, which is 'Department'.", "It selects the 'head' column to display the heads of the departments.", "The results are grouped by 'DepartmentID' to ensure unique department heads are listed.", "The results are ordered by the count of 'DepartmentID' to prioritize departments with more occurrences.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "description": "This virtual table provides a list of department heads from the 'Department' table, grouped by their department IDs. The result is ordered by the count of departments, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["The query identifies the relevant tables, which are 'Department' and 'Physician'.", "It selects the 'name' and 'position' columns from the 'Physician' table (aliased as T2).", "A JOIN operation is performed between 'Department' (aliased as T1) and 'Physician' (T2) on the condition that the head of the department matches the physician's EmployeeID.", "The results are grouped by 'departmentID' to aggregate the data appropriately.", "The results are ordered by the count of 'departmentID' to prioritize departments with more heads, and a limit is applied to restrict the number of results based on a placeholder for numeric values."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "description": "This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results by the count of departments, limited to a specified number of results.", "virtual_table": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3903", "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["The query identifies the relevant tables, which are 'Department' and 'Physician'.", "It selects the 'name' and 'position' columns from the 'Physician' table (aliased as T2).", "A JOIN operation is performed between 'Department' (aliased as T1) and 'Physician' (T2) on the condition that the head of the department matches the physician's EmployeeID.", "The results are grouped by 'departmentID' to aggregate the data appropriately.", "The results are ordered by the count of 'departmentID' to prioritize departments with more heads, and a limit is applied to restrict the number of results based on a placeholder for numeric values."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "description": "This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results by the count of departments, limited to a specified number of results.", "virtual_table": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["The query identifies the relevant tables, which are 'Appointment' and 'Patient'.", "It selects the 'name' column from the 'Patient' table.", "A join is performed between the 'Appointment' table and the 'Patient' table using the patient identifier and Social Security Number, respectively."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "description": "This virtual table provides the names of patients associated with their appointments from the 'Appointment' and 'Patient' tables. The join condition links the patient identifier in the 'Appointment' table to the Social Security Number in the 'Patient' table.", "virtual_table": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["The query identifies the relevant tables: 'Physician', 'Affiliated_With', and 'Department'.", "It selects the 'Name' column from both the 'Physician' and 'Department' tables.", "The join condition connects the 'Physician' table to the 'Affiliated_With' table using the 'EmployeeID' and 'Physician' columns.", "Another join connects the 'Affiliated_With' table to the 'Department' table using the 'Department' and 'DepartmentID' columns.", "A condition is added to filter the results based on whether the affiliation is primary, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "description": "This virtual table describes the names of physicians and their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.", "virtual_table": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3928", "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Patient'.", "It selects the 'Name' column from the 'Physician' table and counts the number of patients associated with each physician.", "A JOIN operation is performed on the 'EmployeeID' from the 'Physician' table and the 'PCP' from the 'Patient' table to establish the relationship.", "The results are grouped by the physician's unique identifier to count the number of patients for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "description": "This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician. The data is sourced from the 'Physician' and 'Patient' tables, where the relationship is established through the primary care physician identifier. The grouping is done by the physician's unique identifier to aggregate the patient counts accordingly.", "virtual_table": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["The query identifies the relevant tables, 'Physician' and 'Patient'.", "It selects the 'Name' column from the 'Physician' table, aliased as T1.", "A JOIN operation is performed between 'Physician' and 'Patient' on the condition that the physician's EmployeeID matches the patient's PCP identifier.", "The results are grouped by the physician's EmployeeID to aggregate the patient counts.", "The HAVING clause filters the results to include only those physicians who have more than a specified number of patients, using a placeholder for the numeric value."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "description": "This virtual table lists the names of physicians who are primary care physicians (PCP) for patients, specifically those who have more than a specified number of patients assigned to them. The placeholder in the HAVING clause represents the minimum count of patients a physician must have to be included in the results.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3940", "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["The query identifies the relevant tables: 'Physician', 'Prescribes', and 'Medication'.", "It selects distinct names from the 'Physician' table (aliased as T1).", "The JOIN operation connects 'Physician' with 'Prescribes' on the physician's identifier, and then with 'Medication' on the medication code.", "A condition is added to filter the results based on the medication name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "description": "This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.", "virtual_table": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3941", "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["The query identifies the relevant tables: 'Physician', 'Prescribes', and 'Medication'.", "It selects distinct names from the 'Physician' table (aliased as T1).", "The JOIN operation connects 'Physician' with 'Prescribes' on the physician's identifier, and 'Prescribes' with 'Medication' on the medication code.", "A condition is added to filter the results based on the medication name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "description": "This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.", "virtual_table": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["The query identifies the relevant tables, which are 'medication' and 'prescribes'.", "It selects a count of prescriptions and the name of the medication from the 'medication' table.", "The JOIN operation links the two tables based on the medication code, ensuring that only prescribed medications are counted.", "The GROUP BY clause organizes the results by the brand of the medication, allowing for a summary count per brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "description": "This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.", "virtual_table": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand"}
{"sample_id": "train.3948", "db_id": "hospital_1", "question": "Find the patient who has the most recent undergoing treatment?", "rationale": ["The query identifies the relevant table, which is 'Undergoes'.", "Select the 'patient' column to display the patients who have undergone procedures.", "Order the results by 'dateundergoes' to sort the patients based on when the procedures were performed.", "Use a placeholder in the LIMIT clause to allow the user to specify how many patient records to return."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "description": "This virtual table provides a list of patients who have undergone medical procedures, sorted by the date of the procedures. The placeholder in the LIMIT clause allows for specifying the maximum number of patients to retrieve.", "virtual_table": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3949", "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["The query identifies the relevant table, which is 'Undergoes'.", "Select the 'patient' column to display the patients who have undergone procedures.", "Order the results by 'dateundergoes' to sort the patients based on when the procedures were performed.", "Use a placeholder in the LIMIT clause to allow the user to specify how many patient records to return."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "description": "This virtual table provides a list of patients who have undergone medical procedures, sorted by the date of the procedures. The placeholder in the LIMIT clause allows for specifying the maximum number of patients to retrieve.", "virtual_table": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Prescribes'.", "It selects the 'Name' column from the 'Physician' table, aliased as T1.", "A JOIN operation is performed between 'Physician' (T1) and 'Prescribes' (T2) on the condition that the 'EmployeeID' from 'Physician' matches the 'Physician' identifier in 'Prescribes'.", "The results are ordered by the 'Dose' column from the 'Prescribes' table in descending order to prioritize higher dosages.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "description": "This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["The query identifies the relevant table, which is 'Affiliated_With'.", "Select the columns to display, 'physician' and 'department'.", "Add a condition to filter the 'primaryaffiliation' column for the specified status using a placeholder for numeric values."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "description": "This virtual table provides a list of physicians along with their associated departments from the 'Affiliated_With' table, filtered by whether the affiliation is marked as primary. The placeholder in the WHERE clause represents the primary affiliation status.", "virtual_table": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["The query identifies the relevant table, which is 'Procedures'.", "Select the column to display, 'name', which represents the names of the procedures.", "Order the results by the 'cost' column to sort the procedures based on their costs.", "Use a placeholder in the LIMIT clause to allow the user to specify how many procedure names they want to retrieve."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "description": "This virtual table lists the names of medical procedures from the 'Procedures' table, ordered by their associated costs. The placeholder in the LIMIT clause allows the user to specify the maximum number of procedure names to retrieve.", "virtual_table": "SELECT name FROM procedures ORDER BY cost LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3972", "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["The query identifies the relevant tables: 'Physician', 'Trained_In', and 'Procedures'.", "It selects the 'Name' column from the 'Physician' table.", "The JOIN operation connects 'Physician' with 'Trained_In' based on the physician's identifier.", "Another JOIN connects 'Trained_In' with 'Procedures' based on the procedure code.", "A condition is added to filter the procedures based on their cost using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "description": "This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["The query identifies the relevant tables: 'Physician', 'Trained_In', and 'Procedures'.", "It selects the 'Name' column from the 'Physician' table (aliased as T1).", "It joins the 'Trained_In' table (aliased as T2) on the 'EmployeeID' of the physician to find their training records.", "It further joins the 'Procedures' table (aliased as T3) on the 'Code' of the procedure to access the cost information.", "The results are ordered by the 'Cost' column from the 'Procedures' table in descending order to prioritize more expensive procedures.", "The LIMIT clause is used to restrict the number of results returned, with a placeholder for the user to specify the desired number."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "description": "This virtual table lists the names of physicians who are trained in specific medical procedures, ordered by the cost of those procedures in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3980", "db_id": "hospital_1", "question": "Find all procedures which cost more than 1000 or which physician John Wen was trained in.", "rationale": ["The query identifies the relevant tables: 'Procedures', 'Physician', and 'Trained_In'.", "It selects the 'name' column from the 'Procedures' table where the 'cost' exceeds a specified number using a placeholder.", "It uses a UNION to combine results with another SELECT statement that retrieves procedure names based on the physician's training.", "The second part of the query joins 'Physician' and 'Trained_In' on the physician's identifier, and then joins with 'Procedures' to get the names of procedures the physician is trained in.", "The placeholders are used for the cost and the physician's name to allow for dynamic querying."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "description": "This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.", "virtual_table": "SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3993", "db_id": "hospital_1", "question": "How many patients are not using Procrastin-X as medication?", "rationale": ["The query identifies the relevant table, which is 'Patient'.", "It uses a subquery to find patients who have been prescribed a specific medication by joining 'Prescribes' and 'Medication' tables.", "The main query counts the patients whose SSN is not in the list of patients returned by the subquery, effectively filtering out those who have received the medication."], "gold_sql": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )", "source_tables": ["patient", "prescribes", "medication"], "description": "This virtual table counts the number of patients who have not been prescribed a specific medication. It filters the patients based on their Social Security Number (SSN) and checks against a subquery that retrieves the patients who have received the specified medication. The placeholder in the subquery represents the name of the medication.", "virtual_table": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4256", "db_id": "club_1", "question": "What are the first names of all the students?", "rationale": ["The query is identifying the relevant table, which is 'Student'.", "Select the column to display, 'Fname', and use DISTINCT to ensure that only unique first names are returned."], "gold_sql": "SELECT DISTINCT fname FROM student", "source_tables": ["student"], "description": "The virtual table describes the distinct first names of students from the 'Student' table. The query retrieves unique first names to avoid duplicates.", "virtual_table": "SELECT DISTINCT fname FROM student"}
{"sample_id": "train.4271", "db_id": "club_1", "question": "Give me the first name and last name for all the female members of the club \"Bootup Baltimore\".", "rationale": ["The query identifies the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "It selects the columns to display, which are 'fname' and 'lname' from the 'Student' table.", "The query joins the 'Club' table with the 'Member_of_club' table on 'ClubID' and then joins the 'Member_of_club' table with the 'Student' table on 'StuID'.", "Conditions are added to filter the results based on the specified club name and the gender of the students using placeholders for string values."], "gold_sql": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  'Bootup Baltimore' AND t3.sex  =  'F'", "source_tables": ["club", "member_of_club", "student"], "description": "This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.", "virtual_table": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  [PLACEHOLDER-TYPE:STRING] AND t3.sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4277", "db_id": "club_1", "question": "Find the club which has the largest number of members majoring in \"600\".", "rationale": ["The query identifies the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "It selects the 'clubname' from the 'Club' table.", "The JOIN operations link the 'Member_of_club' table to the 'Club' and 'Student' tables based on their respective IDs.", "A condition is added to filter the results based on the specified major of the students using a placeholder for string values.", "The results are grouped by 'clubname' to aggregate the data.", "The results are ordered by the count of members in each club in descending order.", "A limit is applied to restrict the number of clubs returned using a placeholder for numeric values."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  '600' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "description": "This virtual table lists the names of clubs that students, majoring in a specific field of study, are members of. The clubs are grouped by their names and ordered by the number of members in descending order, with a limit on the number of clubs returned. The placeholders in the WHERE clause and LIMIT clause represent the major of the students and the maximum number of clubs to display, respectively.", "virtual_table": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4278", "db_id": "club_1", "question": "Find the name of the club that has the most female students.", "rationale": ["The query identifies the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "It selects the 'clubname' from the 'Club' table.", "The JOIN operations link the 'Member_of_club' table to the 'Club' and 'Student' tables based on their respective IDs.", "A condition is added to filter the results based on the gender of the students using a placeholder for string values.", "The results are grouped by 'clubname' to aggregate the counts of members per club.", "The results are ordered by the count of members in descending order to show the most popular clubs first.", "A LIMIT clause is included to restrict the number of clubs returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "description": "This virtual table lists the names of clubs that have the highest number of members of a specific gender. The placeholders in the WHERE clause represent the gender of the students, and the LIMIT clause allows for specifying the maximum number of clubs to return.", "virtual_table": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4312", "db_id": "club_1", "question": "List the clubs that have at least a member with advisor \"1121\".", "rationale": ["The query identifies the relevant tables: 'Club', 'Member_of_club', and 'Student'.", "It selects distinct club names from the 'Club' table.", "The JOIN operations link the 'Member_of_club' table to the 'Club' table and the 'Student' table to filter clubs based on the advisor's ID.", "A condition is added to filter the results based on the advisor's ID using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  1121", "source_tables": ["club", "member_of_club", "student"], "description": "This virtual table lists the distinct names of clubs from the 'Club' table that are associated with students whose academic advisor matches a specified identifier. The placeholder in the WHERE clause represents the advisor's ID.", "virtual_table": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["The query identifies the relevant tables: 'Grants', 'Organisations', and 'Organisation_Types'.", "It selects the sum of the 'grant_amount' from the 'Grants' table.", "The query joins 'Grants' with 'Organisations' on the 'organisation_id' to associate grants with their organisations.", "It further joins 'Organisations' with 'Organisation_Types' on 'organisation_type' to filter by organisation type.", "The WHERE clause uses a placeholder to specify the organisation type description for filtering the results."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "description": "This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter by the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.", "virtual_table": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects the columns 'date_from' and 'date_to' to show the involvement dates of staff members.", "The first part of the query filters projects based on the count of staff members, using a subquery to get the top N projects.", "The second part of the query filters by a specific 'role_code', allowing for a focused view of staff involvement based on their roles."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "description": "This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4328", "db_id": "tracking_grants_for_research", "question": "Find the organisation ids and details of the organisations which are involved in", "rationale": ["The query identifies the relevant tables, 'Grants' and 'Organisations'.", "It selects the columns 'organisation_id' and 'organisation_details' from the 'Organisations' table.", "A JOIN operation is performed on the 'Grants' table to link it with the 'Organisations' table based on the 'organisation_id'.", "The results are grouped by 'organisation_id' to aggregate the grant amounts for each organisation.", "The HAVING clause filters the results to include only those organisations where the total grant amount exceeds a specified numeric value, represented by a placeholder."], "gold_sql": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  6000", "source_tables": ["grants", "organisations"], "description": "This virtual table provides a list of organisation IDs and their corresponding details from the 'Organisations' table, which are associated with grants from the 'Grants' table. The results are grouped by organisation ID, and only those organisations that have a total grant amount exceeding a specified threshold are included, as indicated by the placeholder in the HAVING clause.", "virtual_table": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the columns 'organisation_type' and 'organisation_id' from the 'Organisations' table.", "A JOIN operation is performed between 'Organisations' and 'Research_Staff' on the organisation ID to filter the results based on employed research staff.", "The results are grouped by 'organisation_id' to aggregate the data accordingly.", "The results are ordered by the count of research staff in descending order to prioritize organisations with more staff.", "A LIMIT clause is added to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on the staff members employed by them. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, limiting the output to a specified number of results.", "virtual_table": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4331", "db_id": "tracking_grants_for_research", "question": "What is the type and id of the organization that has the most research staff?", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the 'organisation_type' and 'organisation_id' from the 'Organisations' table.", "A JOIN operation is performed between 'Organisations' and 'Research_Staff' on the 'organisation_id' and 'employer_organisation_id' fields to filter the organisations based on their research staff.", "The results are grouped by 'organisation_id' to aggregate the data.", "The results are ordered by the count of research staff in descending order to prioritize organisations with more staff.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on the staff members employed by them. The results are grouped by organisation ID and ordered by the count of research staff in descending order, with a limit on the number of results returned as specified by a placeholder.", "virtual_table": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4333", "db_id": "tracking_grants_for_research", "question": "What is the type of the organization with the most research staff?", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the 'organisation_type' from the 'Organisations' table.", "A JOIN operation is performed to link 'Organisations' with 'Research_Staff' based on the organisation ID.", "The results are grouped by 'organisation_type' to aggregate the data.", "The results are ordered by the count of research staff in each organisation type in descending order.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.", "virtual_table": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["The query identifies the relevant tables: 'Documents', 'Grants', 'Organisations', and 'Organisation_Types'.", "It selects the 'sent_date' from the 'Documents' table.", "Joins are established between 'Documents' and 'Grants' on 'grant_id', then between 'Grants' and 'Organisations' on 'organisation_id', and finally between 'Organisations' and 'Organisation_Types' on 'organisation_type'.", "A condition is added to filter grants based on the specified grant amount using a placeholder for numeric values.", "Another condition filters organisations based on their type description using a placeholder for string values."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "description": "This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders represent the grant amount and the organisation type description, allowing users to specify their criteria.", "virtual_table": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER] AND T4.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4335", "db_id": "tracking_grants_for_research", "question": "What are the send dates for all documents that have a grant amount of more than 5000 and are involved in research?", "rationale": ["The query identifies the relevant tables: 'Documents', 'Grants', 'Organisations', and 'Organisation_Types'.", "It selects the 'sent_date' from the 'Documents' table.", "Joins are established between 'Documents' and 'Grants' on 'grant_id', between 'Grants' and 'Organisations' on 'organisation_id', and between 'Organisations' and 'Organisation_Types' on 'organisation_type'.", "A condition is added to filter grants with an amount greater than a specified value using a placeholder for numeric values.", "Another condition filters the organisation type description using a placeholder for string values."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "description": "This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants to documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter based on the type of organisation. The placeholders represent the grant amount and the organisation type description.", "virtual_table": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER] AND T4.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4343", "db_id": "tracking_grants_for_research", "question": "When did researchers start and stop working?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "Select the columns to display, 'date_from' and 'date_to', which represent the involvement period of staff members.", "Add a condition to filter the 'role_code' column for the specified role using a placeholder for string values."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "description": "This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4349", "db_id": "tracking_grants_for_research", "question": "What are the details for the project whose research has been published?", "rationale": ["The query identifies the relevant tables: 'Projects', 'Project_Outcomes', and 'Research_Outcomes'.", "It selects the 'project_details' column from the 'Projects' table.", "The query uses JOINs to connect 'Projects' with 'Project_Outcomes' on 'project_id' and 'Project_Outcomes' with 'Research_Outcomes' on 'outcome_code'.", "A condition is added to filter the results based on the 'outcome_description' using a placeholder for string values."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE '%Published%'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "description": "This virtual table describes the details of projects from the 'Projects' table that are associated with specific research outcomes. The query joins the 'Projects' table with the 'Project_Outcomes' table and the 'Research_Outcomes' table to filter projects based on a particular outcome description. The placeholder in the WHERE clause represents the outcome description being searched for.", "virtual_table": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["The query identifies the relevant tables, 'Projects' and 'Project_Outcomes'.", "It selects the 'project_details' and 'project_id' from the 'Projects' table.", "A JOIN operation is performed between 'Projects' and 'Project_Outcomes' on the 'project_id' to link projects with their outcomes.", "The results are grouped by 'project_id' to aggregate the outcomes for each project.", "The results are ordered by the count of outcomes in descending order to prioritize projects with more outcomes.", "A LIMIT clause is added to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.", "virtual_table": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the columns 'organisation_id', 'organisation_type', and 'organisation_details' from the 'Organisations' table.", "A JOIN operation is performed between 'Organisations' and 'Research_Staff' on the condition that the organisation ID matches the employer organisation ID.", "The results are grouped by 'organisation_id' to aggregate the data for each organisation.", "The results are ordered by the count of research staff in descending order to prioritize organisations with more staff.", "A LIMIT clause is added to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.", "virtual_table": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4361", "db_id": "tracking_grants_for_research", "question": "What are the ids, types, and details of the organization with the most research staff?", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the columns 'organisation_id', 'organisation_type', and 'organisation_details' from the 'Organisations' table.", "A JOIN operation is performed between 'Organisations' and 'Research_Staff' on the condition that the organisation ID matches the employer organisation ID.", "The results are grouped by 'organisation_id' to aggregate the data for each organisation.", "The results are ordered by the count of research staff in descending order to prioritize organisations with more staff.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned as specified by the placeholder.", "virtual_table": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["The query identifies the relevant tables: 'Staff_Roles', 'Project_Staff', and 'Project_Outcomes'.", "It selects the 'role_description' from 'Staff_Roles' and 'staff_id' from 'Project_Staff'.", "The JOIN operation is performed on 'role_code' to link staff roles with project staff.", "The query also joins 'Project_Outcomes' to associate project outcomes with the staff members.", "The results are grouped by 'staff_id' to aggregate the data based on the number of project outcomes.", "Finally, the results are ordered by the count of project outcomes in descending order, and a placeholder is added to limit the number of results."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "description": "This virtual table provides a list of staff members along with their role descriptions from the 'Staff_Roles' and 'Project_Staff' tables. It joins these tables based on the role code and groups the results by staff ID to count the number of associated project outcomes. The results are ordered by the count in descending order, and a placeholder is included to limit the number of results returned.", "virtual_table": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4367", "db_id": "tracking_grants_for_research", "question": "For grants that have descriptions of Regular and Initial Applications, what are their start dates?", "rationale": ["The query identifies the relevant tables: 'Grants', 'Documents', and 'Document_Types'.", "It selects the 'grant_start_date' from the 'Grants' table.", "Joins are used to connect 'Grants' with 'Documents' and 'Document_Types' based on their foreign key relationships.", "The WHERE clause filters results based on the 'document_description' from the 'Document_Types' table using a placeholder for string values."], "gold_sql": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Regular' INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Initial Application'", "source_tables": ["grants", "document_types", "documents"], "description": "This virtual table retrieves the start dates of grants from the 'Grants' table that are associated with documents of a specific type. The query uses joins to connect the 'Grants', 'Documents', and 'Document_Types' tables based on their foreign key relationships. The placeholder in the WHERE clause represents the description of the document type, allowing users to specify which document type they are interested in.", "virtual_table": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It selects the 'grant_id' and counts the number of documents associated with each grant using the COUNT function.", "The results are grouped by 'grant_id' to aggregate the document counts for each grant.", "The results are ordered in descending order based on the count of documents to show the grants with the most documents first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "description": "This virtual table summarizes the number of documents associated with each grant from the 'Documents' table. It groups the results by 'grant_id' and orders them in descending order based on the count of documents, allowing the user to specify a limit on the number of results returned.", "virtual_table": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4372", "db_id": "tracking_grants_for_research", "question": "What are all the details of the organisations described as 'Sponsor'? Sort the result in an ascending order.", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Organisation_Types'.", "It selects the 'organisation_details' column from the 'Organisations' table.", "A JOIN operation is performed to link 'Organisations' with 'Organisation_Types' based on the organisation type.", "A condition is added to filter the results based on the 'organisation_type_description' using a placeholder for string values.", "The results are ordered by 'organisation_details' to present them in a structured manner."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "description": "This virtual table provides the details of organisations that belong to a specific type, as defined in the 'Organisation_Types' table. The placeholder in the WHERE clause represents the description of the organisation type, allowing users to filter the results accordingly.", "virtual_table": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING] ORDER BY organisation_details"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["The query identifies the relevant tables: 'Research_Outcomes', 'Project_Outcomes', and 'Projects'.", "It selects the 'outcome_description' from the 'Research_Outcomes' table.", "The JOIN operations link the 'Research_Outcomes' to 'Project_Outcomes' using the 'outcome_code', and then link 'Project_Outcomes' to 'Projects' using 'project_id'.", "A condition is added to filter the results based on the 'project_details' column from the 'Projects' table, using a placeholder for string values."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "description": "This virtual table describes the outcome descriptions of research outcomes associated with a specific project. The placeholders in the WHERE clause represent the detailed description of the project being queried.", "virtual_table": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["The query identifies the relevant tables: 'Research_Outcomes', 'Project_Outcomes', and 'Projects'.", "It selects the 'outcome_description' from the 'Research_Outcomes' table.", "The JOIN operations link the 'Research_Outcomes' to 'Project_Outcomes' using the 'outcome_code', and 'Project_Outcomes' to 'Projects' using the 'project_id'.", "A condition is added to filter the results based on the 'project_details' column from the 'Projects' table using a placeholder for string values."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "description": "This virtual table describes the outcome descriptions of research outcomes associated with specific projects. The query joins the 'Research_Outcomes' table with the 'Project_Outcomes' table and the 'Projects' table to filter the results based on the project details. The placeholder in the WHERE clause represents the specific project details being queried.", "virtual_table": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4383", "db_id": "tracking_grants_for_research", "question": "What is the id of the organization with the maximum number of outcomes and how many outcomes are there?", "rationale": ["The query identifies the relevant tables, 'Projects' and 'Project_Outcomes'.", "It selects the 'organisation_id' from the 'Projects' table and counts the number of project outcomes associated with each organisation.", "The JOIN operation links 'Projects' and 'Project_Outcomes' on the 'project_id' to ensure that only relevant outcomes are counted for each organisation.", "The results are grouped by 'organisation_id' to aggregate the counts for each organisation.", "The ORDER BY clause sorts the results in descending order based on the count of project outcomes, allowing the user to see which organisations have the most outcomes.", "The LIMIT clause uses a placeholder to allow the user to specify how many top organisations they want to retrieve."], "gold_sql": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table provides a count of projects grouped by organisation, showing how many project outcomes each organisation has. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on their project outcomes.", "virtual_table": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4384", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects launched by the organisation", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "It selects the 'project_details' column to display the details of the projects.", "The WHERE clause filters the results to include only those organisations that have the highest number of projects, using a subquery that groups by 'organisation_id' and orders by the count of projects in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many top organisations to return."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "description": "This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.", "virtual_table": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "Select the column to display, 'role_code'.", "Add conditions to filter the 'date_from' and 'date_to' columns for the specified date range using placeholders for string values."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "description": "This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.", "virtual_table": "SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4394", "db_id": "tracking_grants_for_research", "question": "What are the descriptions of all the project outcomes?", "rationale": ["The query identifies the relevant tables, which are 'Research_Outcomes' and 'Project_Outcomes'.", "It selects the 'outcome_description' from the 'Research_Outcomes' table.", "A join is performed between 'Research_Outcomes' and 'Project_Outcomes' on the 'outcome_code' to link research outcomes with project outcomes."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code", "source_tables": ["project_outcomes", "research_outcomes"], "description": "This virtual table describes the outcome descriptions of research outcomes associated with specific project outcomes. The join between the 'Research_Outcomes' and 'Project_Outcomes' tables is based on the matching outcome codes, allowing users to retrieve detailed descriptions of research outcomes linked to their respective projects.", "virtual_table": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects the 'role_code' column to display unique role codes.", "The results are grouped by 'role_code' to aggregate the data based on the role.", "The results are ordered by the count of occurrences of each role code in descending order to show the most common roles first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "description": "This virtual table provides a list of unique role codes from the 'Project_Staff' table, grouped by the role code and ordered by the number of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of role codes to retrieve.", "virtual_table": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4410", "db_id": "network_2", "question": "Who is the oldest person whose job is student?", "rationale": ["The query identifies the relevant table, which is 'Person'.", "It selects the 'name' column to display the names of individuals.", "A condition is added to filter the 'job' column for the specified job title using a placeholder for string values.", "Additionally, it includes a subquery to find the maximum age of individuals with the same job title, ensuring that only the oldest individual(s) are selected."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "description": "This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.", "virtual_table": "SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4439", "db_id": "network_2", "question": "What is the name and age of every male? Order the results by age.", "rationale": ["The query identifies the relevant table, which is 'Person'.", "Select the column to display, 'name'.", "Add a condition to filter the 'gender' column for the specified gender using a placeholder for string values.", "Order the results by the 'age' column to sort the names accordingly."], "gold_sql": "SELECT name FROM Person WHERE gender  =  'male' ORDER BY age", "source_tables": ["person"], "description": "This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.", "virtual_table": "SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age"}
{"sample_id": "train.4441", "db_id": "network_2", "question": "What are the names and ages of every person who is a friend of both Dan and Alice?", "rationale": ["The query identifies the relevant tables, which are 'Person' and 'PersonFriend'.", "It selects the columns to display, 'name' and 'age', from the 'Person' table.", "The JOIN operation is used to connect 'Person' and 'PersonFriend' based on the person's name.", "The WHERE clause filters the results to include only those persons who are friends with a specified friend, using a placeholder for the friend's name.", "The INTERSECT operation ensures that only persons who have mutual friendships with the specified friend are included in the final result."], "gold_sql": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "description": "This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.", "virtual_table": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4444", "db_id": "network_2", "question": "Find the name of the person who has friends with age above 40 and under age 30?", "rationale": ["The query starts by selecting names from the 'Person' table, aliased as T1.", "It joins the 'PersonFriend' table, aliased as T2, on the condition that the names match.", "The first part of the INTERSECT selects names of individuals whose friends are older than a specified age, using a subquery to filter based on age.", "The second part of the INTERSECT selects names of individuals whose friends are younger than a specified age, again using a subquery for filtering."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "description": "This virtual table identifies individuals from the 'Person' table who have friends that are both older and younger than a specified age. The placeholders in the query represent the age limits for filtering friends.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4445", "db_id": "network_2", "question": "What are the names of every person who has a friend over 40 and under 30?", "rationale": ["The query starts by selecting names from the 'Person' table, aliased as T1.", "It joins the 'PersonFriend' table, aliased as T2, on the condition that the names match.", "The first part of the INTERSECT selects names of individuals whose friends are older than a specified age, using a subquery to filter based on age.", "The second part of the INTERSECT selects names of individuals whose friends are younger than a specified age, again using a subquery for filtering."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "description": "This virtual table identifies individuals from the 'Person' table who have friends that are both older and younger than a specified age. The placeholders in the query represent the age limits for filtering friends.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4449", "db_id": "network_2", "question": "What are the names of the people who have no friends who are students?", "rationale": ["The query starts by selecting names from the 'Person' table.", "It uses the EXCEPT clause to exclude names of friends from the 'PersonFriend' table.", "A JOIN is performed between 'Person' and 'PersonFriend' to find friends of individuals who have a specific job.", "The WHERE clause filters the results based on the job title using a placeholder for string values."], "gold_sql": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  'student'", "source_tables": ["personfriend", "person"], "description": "This virtual table identifies the names of individuals from the 'Person' table who do not have any friends that work in a specific occupation. The placeholder in the query allows for the specification of the job title to filter out those individuals accordingly.", "virtual_table": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4454", "db_id": "network_2", "question": "Find the name of persons who are friends with Bob.", "rationale": ["The query identifies the relevant tables, which are 'Person' and 'PersonFriend'.", "It selects the 'name' column from the 'Person' table, aliased as T1.", "A JOIN operation is performed between 'Person' (T1) and 'PersonFriend' (T2) on the condition that the names match.", "A condition is added to filter the results based on the specified friend's name using a placeholder for string values."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "description": "This virtual table describes the names of persons from the 'Person' table who have a specific friend listed in the 'PersonFriend' table. The placeholder in the WHERE clause represents the friend's name.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4455", "db_id": "network_2", "question": "What are the names of all of Bob's friends?", "rationale": ["The query identifies the relevant tables, 'Person' and 'PersonFriend'.", "It selects the 'name' column from the 'Person' table, which represents the individuals.", "A JOIN operation is performed between 'Person' and 'PersonFriend' on the 'name' column to link individuals with their friends.", "A condition is added to filter the results based on the specified friend's name using a placeholder for string values."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "description": "This virtual table describes the names of individuals from the 'Person' table who have a specific friend listed in the 'PersonFriend' table. The placeholder in the WHERE clause represents the friend's name.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4456", "db_id": "network_2", "question": "Find the names of females who are friends with Zach", "rationale": ["The query identifies the relevant tables, which are 'Person' and 'PersonFriend'.", "It selects the 'name' column from the 'Person' table, aliased as T1.", "A JOIN operation is performed between 'Person' (T1) and 'PersonFriend' (T2) on the condition that their names match.", "Conditions are added to filter the results based on the specified friend's name and the person's gender using placeholders for string values."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Zach' AND T1.gender  =  'female'", "source_tables": ["personfriend", "person"], "description": "This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.", "virtual_table": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4465", "db_id": "network_2", "question": "What are the different names of friends who are younger than the average age for a friend?", "rationale": ["The query identifies the relevant tables, which are 'Person' and 'PersonFriend'.", "It selects distinct names from the 'PersonFriend' table, specifically those who are friends of persons from the 'Person' table.", "A JOIN operation is performed on the 'name' column to link friends to their respective persons.", "A condition is added to filter persons based on their age being less than the average age calculated from the 'Person' table."], "gold_sql": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "description": "This virtual table lists the distinct names of friends of persons who are younger than the average age of all persons in the 'Person' table. The placeholder in the WHERE clause represents the age condition based on the average age.", "virtual_table": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)"}
{"sample_id": "train.4466", "db_id": "network_2", "question": "Who has friends that are older than the average age? Print their friends and their ages as well", "rationale": ["The query identifies the relevant tables, 'Person' and 'PersonFriend'.", "It selects distinct names and friends from the 'PersonFriend' table and the age from the 'Person' table.", "A JOIN operation is performed on the names to link friends to their respective ages.", "A condition is added to filter friends whose age is greater than the average age calculated from the 'Person' table."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "description": "This virtual table provides a list of distinct friends and their names along with the ages of those friends who are older than the average age of all persons in the 'Person' table. The placeholders in the query allow for dynamic filtering based on the average age calculation.", "virtual_table": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)"}
{"sample_id": "train.4467", "db_id": "network_2", "question": "Whare the names, friends, and ages of all people who are older than the average age of a person?", "rationale": ["The query identifies the relevant tables, 'Person' and 'PersonFriend'.", "It selects distinct names and friends from the 'PersonFriend' table and the age from the 'Person' table.", "A JOIN operation is performed on the names to link friends to their respective ages.", "A condition is added to filter friends whose age is greater than the average age calculated from the 'Person' table."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "description": "This virtual table provides a list of distinct friends and their names along with the ages of those friends who are older than the average age of all persons in the 'Person' table. The placeholders in the query allow for dynamic filtering based on the average age calculation.", "virtual_table": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)"}
{"sample_id": "train.4473", "db_id": "network_2", "question": "What are the names of all people who are friends with Alice for the shortest amount of time?", "rationale": ["The query identifies the relevant table, which is 'PersonFriend'.", "Select the column to display, 'name', which represents the person who has the specified friend.", "Add a condition to filter the 'friend' column for the specified friend's name using a placeholder for string values.", "Include a subquery to find the minimum year of friendship for the specified friend, ensuring that the results are filtered by the earliest established friendship."], "gold_sql": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend"], "description": "This virtual table describes the names of persons who have a specific friend, filtered by the year when the friendship was established. The placeholders in the WHERE clause represent the friend's name and the year of the friendship.", "virtual_table": "SELECT name FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4475", "db_id": "network_2", "question": "What are the names, ages, and jobs of all people who are friends with Alice for the longest amount of time?", "rationale": ["The query identifies the relevant tables, 'Person' and 'PersonFriend'.", "It selects the columns 'name', 'age', and 'job' from the 'Person' table.", "A JOIN operation is performed on the 'name' column to link 'Person' and 'PersonFriend'.", "Conditions are added to filter results based on the specified friend's name and the most recent year of friendship using subquery with a placeholder for string values."], "gold_sql": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend", "person"], "description": "This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year of friendship established with that friend. The placeholders in the WHERE clause represent the friend's name.", "virtual_table": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4478", "db_id": "network_2", "question": "Which person whose friends have the oldest average age?", "rationale": ["The query identifies the relevant tables, 'Person' and 'PersonFriend'.", "It selects the friend's name from 'PersonFriend' and calculates the average age of friends from 'Person'.", "A JOIN operation is performed on the names to link friends with their ages.", "The results are grouped by the friend's name to calculate the average age for each friend.", "The results are ordered by the average age in descending order and limited by a placeholder for numeric values."], "gold_sql": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT 1", "source_tables": ["personfriend", "person"], "description": "This virtual table provides the names of friends along with the average age of their respective friends from the 'Person' table. The results are grouped by the friend's name and ordered by the average age in descending order, with a limit on the number of results specified by a placeholder.", "virtual_table": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4480", "db_id": "network_2", "question": "What is the total number of people who has no friend living in the city of Austin.", "rationale": ["The query identifies the relevant table, which is 'PersonFriend'.", "It counts the distinct names of persons who have friends.", "A subquery is used to filter out friends based on their city of residence from the 'Person' table, using a placeholder for the city name."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "description": "This virtual table counts the number of distinct persons from the 'PersonFriend' table who have friends that do not reside in a specified city. The placeholder in the WHERE clause represents the name of the city to filter out friends.", "virtual_table": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4503", "db_id": "document_management", "question": "Find the types of documents with more than 4 documents.", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It selects the 'document_type_code' to display the different types of documents.", "The query groups the results by 'document_type_code' to aggregate the data.", "A condition is added to filter the groups using the HAVING clause to include only those with an access count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "description": "This virtual table provides a summary of the different types of documents stored in the 'Documents' table. It groups the documents by their type and filters the results to show only those document types that have been accessed more than a specified number of times, represented by a placeholder for numeric values.", "virtual_table": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4504", "db_id": "document_management", "question": "What are the codes of types of documents of which there are for or more?", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It selects the 'document_type_code' to display the different types of documents.", "The query groups the results by 'document_type_code' to aggregate the data.", "A condition is added to filter the groups using the HAVING clause to show only those with an access count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "description": "This virtual table provides a summary of the different types of documents stored in the 'Documents' table. It groups the documents by their type and filters the results to show only those document types that have been accessed more than a specified number of times, represented by a placeholder for numeric values.", "virtual_table": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4505", "db_id": "document_management", "question": "Find the total access count of all documents in the most popular document type.", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It calculates the total access count for each document type using the SUM function.", "The results are grouped by 'document_type_code' to aggregate access counts for each type.", "The results are ordered by the count of documents in descending order to prioritize the most accessed types.", "A placeholder is included in the LIMIT clause to allow the user to specify how many document types they want to retrieve."], "gold_sql": "SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "description": "This virtual table summarizes the total access counts of documents grouped by their type. The placeholder in the LIMIT clause allows the user to specify the maximum number of document types to retrieve based on their access counts.", "virtual_table": "SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4525", "db_id": "document_management", "question": "Find names of the document without any images.", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It selects the 'document_name' column to display the names of the documents.", "The EXCEPT clause is used to exclude document names that are found in a join between 'Documents', 'Document_Sections', and 'Document_Sections_Images', effectively filtering out documents that have associated images."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "description": "This virtual table lists the names of documents from the 'Documents' table that do not have any associated images in their sections. The query uses an EXCEPT clause to filter out document names that are linked to sections containing images, ensuring only documents without images are returned.", "virtual_table": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id"}
{"sample_id": "train.4532", "db_id": "document_management", "question": "Count the number of users that are logged in.", "rationale": ["The query identifies the relevant table, which is 'Users'.", "It uses the COUNT function to count the total number of records that match the specified condition.", "The condition filters the records based on the 'user_login' column, using a placeholder for numeric values."], "gold_sql": "SELECT count(*) FROM users WHERE user_login  =  1", "source_tables": ["users"], "description": "This virtual table counts the number of users in the 'Users' table based on a specific login username. The placeholder in the WHERE clause represents the user's login name.", "virtual_table": "SELECT count(*) FROM users WHERE user_login  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4733", "db_id": "department_store", "question": "Return the distinct name of customers whose order status is Pending, in the order of customer id.", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Orders'.", "It selects distinct customer names from the 'Customers' table.", "A JOIN operation is performed on 'Customer_Orders' to link customers with their orders based on the customer ID.", "A condition is added to filter the results based on the specified order status code using a placeholder for string values.", "The results are ordered by the customer ID."], "gold_sql": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending' ORDER BY T2.customer_id", "source_tables": ["customer_orders", "customers"], "description": "This virtual table provides a list of distinct customer names from the 'Customers' table who have placed orders with a specific status. The placeholder in the WHERE clause represents the order status code that is being filtered.", "virtual_table": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T2.customer_id"}
{"sample_id": "train.4736", "db_id": "department_store", "question": "What are the names and addressed of customers who have both New and Pending orders?", "rationale": ["The query identifies the relevant table, which is 'Customers' and 'Customer_Orders'.", "It selects the columns to display, 'customer_name' and 'customer_address'.", "The JOIN operation links the 'Customers' table with the 'Customer_Orders' table based on the 'customer_id'.", "The WHERE clause filters the results based on the 'order_status_code', using a placeholder for string values.", "The INTERSECT operation is used to find common customers who have multiple orders with the same status."], "gold_sql": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'New' INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending'", "source_tables": ["customer_orders", "customers"], "description": "This virtual table provides the names and addresses of customers who have placed orders with a specific status. The query uses an INTERSECT operation to find customers who have multiple orders with the same status, represented by a placeholder in the WHERE clause.", "virtual_table": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4749", "db_id": "department_store", "question": "Find the id and name of the staff who has been assigned for the shortest period.", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "It selects the 'staff_id' and 'staff_name' columns from the 'Staff' table.", "A JOIN operation is performed between 'Staff' and 'Staff_Department_Assignments' on the 'staff_id' to filter staff members with department assignments.", "The results are ordered by the duration of the assignment, calculated as 'date_assigned_to' minus 'date_assigned_from'.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "description": "This virtual table provides a list of staff members along with their unique identifiers from the 'Staff' table. It joins the 'Staff' table with the 'Staff_Department_Assignments' table to include only those staff members who have been assigned to a department. The results are ordered by the duration of their assignment, calculated as the difference between the end date and the start date of their assignment. The placeholder in the LIMIT clause allows for specifying the maximum number of records to return.", "virtual_table": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "It selects the 'staff_id' and 'staff_name' columns from the 'Staff' table.", "A JOIN operation is performed to link 'Staff' with 'Staff_Department_Assignments' based on the 'staff_id'.", "The results are ordered by the duration of the assignment, calculated as 'date_assigned_to' minus 'date_assigned_from'.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "description": "This virtual table provides a list of staff members along with their unique identifiers from the 'Staff' table. It joins the 'Staff' table with the 'Staff_Department_Assignments' table to include only those staff members who have been assigned to a department. The results are ordered by the duration of their assignment, calculated as the difference between the end date and start date of their assignment. The placeholder in the LIMIT clause allows for specifying the maximum number of records to return.", "virtual_table": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4753", "db_id": "department_store", "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.", "rationale": ["The query identifies the relevant table, which is 'Customer_Orders'.", "It selects distinct customer IDs to ensure each customer is listed only once.", "A condition is added to filter orders based on the order date, specifically those placed after the earliest order date with a given status code, using a subquery and a placeholder for the order status code."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "description": "This virtual table lists unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The placeholder in the subquery represents the order status code used to filter the earliest order date.", "virtual_table": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4755", "db_id": "department_store", "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?", "rationale": ["The query identifies the relevant table, which is 'Staff_Department_Assignments'.", "It selects the 'staff_id' column to display the unique identifiers of staff members.", "A condition is added to filter the results based on the 'date_assigned_to' column, ensuring it is less than the maximum 'date_assigned_to' for a specified job title.", "The subquery retrieves the maximum assignment end date for the specified job title using a placeholder for string values."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "description": "This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.", "virtual_table": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "Select the columns to display, 'customer_name' and 'customer_id'.", "Add a condition to filter the 'customer_address' column using a LIKE clause for the specified address pattern with a placeholder for string values."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "description": "This virtual table describes the names and unique identifiers of customers from the 'Customers' table whose addresses match a specific pattern. The placeholder in the WHERE clause represents the address pattern to filter the results.", "virtual_table": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4760", "db_id": "department_store", "question": "What are the names and genders of staff who were assigned in 2016?", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "It selects the columns to display, 'staff_name' and 'staff_gender'.", "A JOIN operation is performed to link the 'Staff' table with the 'Staff_Department_Assignments' table based on the 'staff_id'.", "A condition is added to filter the results based on the 'date_assigned_from' column using a placeholder for string values."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "description": "This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.", "virtual_table": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Staff_Department_Assignments'.", "It selects the 'staff_name' from the 'Staff' table.", "A JOIN operation is performed between 'Staff' and 'Staff_Department_Assignments' on the 'staff_id' to link staff members with their department assignments.", "The results are grouped by 'staff_id' to aggregate the assignments for each staff member.", "The HAVING clause filters the results to include only those staff members who have more than a specified number of assignments, using a placeholder for the numeric value."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "description": "This virtual table describes the names of staff members from the 'Staff' table who are assigned to departments, filtered to include only those with more than a specified number of assignments. The placeholder in the HAVING clause represents the minimum count of assignments required.", "virtual_table": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "Select the columns to display, 'customer_id' and 'customer_name'.", "Add conditions to filter the 'customer_address' using a LIKE clause for a specific pattern and exclude customers with a certain 'payment_method_code' using a NOT EQUAL condition with a placeholder for string values."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "description": "This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.", "virtual_table": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4793", "db_id": "department_store", "question": "Find the average price of all product clothes.", "rationale": ["The query identifies the relevant table, which is 'Products'.", "It selects the average of the 'product_price' column to compute the average price.", "A condition is added to filter the 'product_type_code' column for the specified product type using a placeholder for string values."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "description": "This virtual table calculates the average price of products from the 'Products' table that belong to a specific product type. The placeholder in the WHERE clause represents the product type code.", "virtual_table": "SELECT avg(product_price) FROM products WHERE product_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4795", "db_id": "department_store", "question": "Find the name of the most expensive hardware product.", "rationale": ["The query identifies the relevant table, which is 'Products'.", "Select the column to display, 'product_name'.", "Add a condition to filter the 'product_type_code' column for the specified product type using a placeholder for string values.", "Order the results by 'product_price' in descending order to show the most expensive products first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1", "source_tables": ["products"], "description": "This virtual table provides a list of product names from the 'Products' table that match a specific product type code. The results are ordered by the product price in descending order, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT product_name FROM products WHERE product_type_code  =  [PLACEHOLDER-TYPE:STRING] ORDER BY product_price DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["The query identifies the relevant table, which is 'product'.", "Select the column 'max_page_size' to display the maximum page sizes of products.", "Group the results by 'max_page_size' to aggregate the data based on this attribute.", "Use the HAVING clause to filter groups that have a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "description": "This virtual table provides the maximum page sizes of products from the 'product' table, grouped by their maximum page size. The placeholder in the HAVING clause represents the minimum count of products that must share the same maximum page size to be included in the results.", "virtual_table": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4903", "db_id": "store_product", "question": "What is the maximum page size for everything that has more than 3 products listed?", "rationale": ["The query identifies the relevant table, which is 'product'.", "It selects the 'max_page_size' column to display the maximum page sizes of products.", "The results are grouped by 'max_page_size' to aggregate the data based on this attribute.", "A condition is added in the HAVING clause to filter groups that have a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "description": "This virtual table provides the maximum page sizes of products from the 'product' table, grouped by their maximum page size. The placeholder in the HAVING clause represents the minimum count of products that must share the same maximum page size to be included in the results.", "virtual_table": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4913", "db_id": "store_product", "question": "What is the total number of residents for the districts with the 3 largest areas?", "rationale": ["The query identifies the relevant table, which is 'district'.", "It selects the sum of the 'city_population' column to get the total population.", "The results are ordered by 'city_area' in descending order to prioritize larger areas.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3", "source_tables": ["district"], "description": "This virtual table calculates the total population of cities within districts from the 'district' table, ordering the results by the area of the cities in descending order. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["The query identifies the relevant tables: 'store', 'store_district', and 'district'.", "It selects the 'store_name' column from the 'store' table.", "The query uses JOIN operations to connect 'store' with 'store_district' and then 'store_district' with 'district'.", "A condition is added to filter the results based on the 'district_name' column using a placeholder for string values."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "description": "This virtual table describes the names of stores located in a specific district. The query joins the 'store', 'store_district', and 'district' tables to filter stores based on the district's name provided as a placeholder.", "virtual_table": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["The query identifies the relevant tables: 'store', 'store_district', and 'district'.", "It joins these tables to connect stores with their respective districts and the cities where those districts are headquartered.", "The selection focuses on the 'headquartered_city' from the 'district' table.", "The results are grouped by 'headquartered_city' to aggregate the data based on the number of stores in each city.", "The results are ordered by the count of stores in descending order to prioritize cities with the most stores.", "A limit is applied to restrict the number of cities returned, using a placeholder for numeric values."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "description": "This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in descending order, with a limit on the number of cities returned, specified by a placeholder for numeric values.", "virtual_table": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4930", "db_id": "store_product", "question": "Find products with max page size as \"A4\" and pages per minute color smaller than 5.", "rationale": ["The query identifies the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add conditions to filter the 'max_page_size' column for a specified maximum size using a placeholder for string values.", "Add another condition to filter the 'pages_per_minute_color' column for values less than a specified number using a placeholder for numeric values."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "description": "This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color printing.", "virtual_table": "SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4932", "db_id": "store_product", "question": "Find products with max page size as \"A4\" or pages per minute color smaller than 5.", "rationale": ["The query identifies the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add conditions to filter the 'max_page_size' for a specified value using a placeholder for string values and 'pages_per_minute_color' for a specified numeric value using a placeholder for numeric values."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "description": "This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.", "virtual_table": "SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4935", "db_id": "store_product", "question": "What are all of the products whose name includes the substring \"Scanner\"?", "rationale": ["The query identifies the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add a condition to filter the 'product' column using the LIKE operator for pattern matching with a placeholder for string values."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "description": "This virtual table describes the names or descriptions of products from the 'product' table that match a specific pattern. The placeholder in the LIKE clause represents the search term for the product name or description.", "virtual_table": "SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4937", "db_id": "store_product", "question": "What is the most common maximum page size?", "rationale": ["The query identifies the relevant table, which is 'product'.", "It selects the 'max_page_size' column to display the maximum page sizes of products.", "The results are grouped by 'max_page_size' to aggregate similar sizes together.", "The results are ordered by the count of occurrences of each maximum page size in descending order to show the most common sizes first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1", "source_tables": ["product"], "description": "This virtual table provides a list of maximum page sizes from the 'product' table, grouped by the maximum page size and ordered by the frequency of each size in descending order. The placeholder in the LIMIT clause represents the number of results to return.", "virtual_table": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4938", "db_id": "store_product", "question": "Find the name of the products that are not using the most frequently-used max page size.", "rationale": ["The query identifies the relevant table, which is 'product'.", "Select the column to display, 'product'.", "Add a condition to filter out products that have the maximum page size, using a subquery to find the most common maximum page size.", "The subquery groups the products by 'max_page_size' and orders them by their count, limiting the result to the top entry, which is represented by a placeholder for numeric values."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "description": "This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value to limit the results based on the count of maximum page sizes.", "virtual_table": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["The query identifies the relevant table, which is 'College'.", "It selects the average of the 'enr' column to compute the average enrollment number.", "The use of the aggregate function 'avg' allows for the calculation of the average across all entries in the 'enr' column."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "description": "This virtual table calculates the average enrollment number of students across all colleges listed in the 'College' table. The result provides insight into the overall student population in these institutions.", "virtual_table": "SELECT avg(enr) FROM College"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["The query is identifying the relevant table, which is 'Player'.", "Select the column to calculate the average, which is 'HS'.", "The use of the aggregate function 'avg' indicates that we want to compute the average of the high school values."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "description": "This virtual table calculates the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the high school data that will be averaged.", "virtual_table": "SELECT avg(HS) FROM Player"}
{"sample_id": "train.4956", "db_id": "soccer_2", "question": "Find the name and training hours of players whose hours are below 1500.", "rationale": ["The query is identifying the relevant table, which is 'Player'.", "Select the columns to display, 'pName' and 'HS'.", "Add a condition to filter the 'HS' column for high schools with an enrollment number less than the specified value using a placeholder for numeric values."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "description": "This virtual table describes the names and high schools of players from the 'Player' table who attended high schools with an enrollment number less than a specified value. The placeholder in the WHERE clause represents the enrollment number of students at the high school.", "virtual_table": "SELECT pName ,  HS FROM Player WHERE HS  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4961", "db_id": "soccer_2", "question": "What are the different types of player positions?", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "It uses the COUNT function to count the number of distinct values in the 'pPos' column, which represents the positions players are trying out for."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "description": "This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.", "virtual_table": "SELECT count(DISTINCT pPos) FROM tryout"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "It counts the total number of entries that match a specific decision.", "A condition is added to filter the results based on the 'decision' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "description": "This virtual table provides the total number of players who received a specific decision regarding their tryout from the 'Tryout' table. The placeholder in the WHERE clause represents the decision made about the players' tryouts.", "virtual_table": "SELECT count(*) FROM tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["The query identifies the relevant table, which is 'Player'.", "It selects the average, maximum, and minimum values of the 'HS' column.", "The use of aggregate functions (avg, max, min) indicates that we are interested in statistical summaries of the high school data."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "description": "This virtual table provides the average, maximum, and minimum values of the high school attended by players from the 'Player' table. The placeholders in the SELECT clause represent the calculated statistics for the high school data.", "virtual_table": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player"}
{"sample_id": "train.4967", "db_id": "soccer_2", "question": "What is the average, maximum, and minimum for the number of hours spent training?", "rationale": ["The query identifies the relevant table, which is 'Player'.", "It selects the average, maximum, and minimum values of the 'HS' column.", "The use of aggregate functions (avg, max, min) indicates that we are interested in statistical summaries of the high school data."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "description": "This virtual table provides the average, maximum, and minimum values of the high school attended by players from the 'Player' table. The placeholders in the SELECT clause represent the calculated statistics for the high school data.", "virtual_table": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player"}
{"sample_id": "train.4970", "db_id": "soccer_2", "question": "What are the names of players whose training hours is between 500 and 1500?", "rationale": ["The query is identifying the relevant table, which is 'Player'.", "Select the column to display, 'pName'.", "Add a condition to filter the 'HS' column for high school enrollment numbers within a specified range using placeholders for numeric values."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "description": "This virtual table describes the names of players from the 'Player' table who attended high schools within a specific range of enrollment numbers. The placeholders in the WHERE clause represent the lower and upper bounds of the enrollment numbers.", "virtual_table": "SELECT pName FROM Player WHERE HS BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4971", "db_id": "soccer_2", "question": "What are the names of players who train between 500 and 1500 hours?", "rationale": ["The query is identifying the relevant table, which is 'Player'.", "Select the column to display, 'pName'.", "Add a condition to filter the 'HS' column for high school enrollment numbers within a specified range using placeholders for numeric values."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "description": "This virtual table describes the names of players from the 'Player' table who attended high schools within a specific range of enrollment numbers. The placeholders in the WHERE clause represent the lower and upper bounds of the enrollment numbers.", "virtual_table": "SELECT pName FROM Player WHERE HS BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4975", "db_id": "soccer_2", "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?", "rationale": ["The query identifies the relevant table, which is 'College'.", "Select the columns to display, 'cName' and 'enr'.", "Add conditions to filter the 'enr' column for values greater than a specified number and the 'state' column for a specific state using placeholders for numeric and string values."], "gold_sql": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = 'LA'", "source_tables": ["college"], "description": "This virtual table provides the names and enrollment numbers of colleges from the 'College' table that have an enrollment greater than a specified number and are located in a specific state. The placeholders in the WHERE clause represent the minimum enrollment number and the state name.", "virtual_table": "SELECT cName ,  enr FROM College WHERE enr  >  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4981", "db_id": "soccer_2", "question": "What are the name of the players who received a card in descending order of the hours of training?", "rationale": ["The query identifies the relevant table, which is 'Player'.", "Select the column to display, 'pName'.", "Add a condition to filter the 'yCard' column for the specified year of eligibility using a placeholder for string values.", "Order the results by the 'HS' column in descending order."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "description": "This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended, in descending order. The placeholder in the WHERE clause represents the year of the player's card.", "virtual_table": "SELECT pName FROM Player WHERE yCard  =  [PLACEHOLDER-TYPE:STRING] ORDER BY HS DESC"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "It selects the 'pPos' column to display the positions players are trying out for.", "The results are grouped by 'pPos' to aggregate the data based on player positions.", "The results are ordered by the count of players in each position in descending order to show the most popular positions first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "description": "This virtual table provides a list of player positions from the 'Tryout' table, grouped by position and ordered by the number of players trying out for each position. The placeholder in the LIMIT clause represents the maximum number of positions to return.", "virtual_table": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "It selects the 'pPos' column to display the positions players are trying out for.", "The results are grouped by 'pPos' to aggregate the data based on player positions.", "The results are ordered by the count of players in each position in descending order to show the most popular positions first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "description": "This virtual table provides a list of player positions from the 'Tryout' table, grouped by position and ordered by the number of players trying out for each position. The placeholder in the LIMIT clause represents the maximum number of positions to return.", "virtual_table": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["The query identifies the relevant tables, which are 'Tryout' and 'Player'.", "It selects the minimum high school attended by players using the 'min' function on the 'HS' column from the 'Player' table.", "The 'pPos' column from the 'Tryout' table is included to show the position for which the players are trying out.", "A JOIN operation is performed on the 'pID' column to link the two tables, allowing access to both player and tryout information.", "The results are grouped by the 'pPos' column to aggregate the minimum high school for each position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "description": "This virtual table summarizes the minimum high school attended by players for each position they are trying out for, based on the data from the 'Tryout' and 'Player' tables. The placeholder in the SELECT clause represents the high school name, while the position is grouped accordingly.", "virtual_table": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["The query identifies the relevant tables, which are 'Tryout' and 'Player'.", "It selects the minimum high school name from the 'Player' table and the position from the 'Tryout' table.", "A JOIN operation is performed on the player ID to link the two tables based on the player's participation in the tryout.", "The results are grouped by the position the player is trying out for, allowing for aggregation of high school names per position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "description": "This virtual table provides the minimum high school name associated with each position that players are trying out for, by joining the 'Tryout' and 'Player' tables. The placeholder in the SELECT clause represents the high school name, while the grouping is done by the position the player is trying out for.", "virtual_table": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the columns to display, 'pName' and 'HS' from the 'Player' table.", "A JOIN operation is performed between 'Player' and 'Tryout' on the player ID to link the two tables.", "A condition is added to filter the results based on the 'decision' column in the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "description": "This virtual table provides the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.", "virtual_table": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the 'pName' column from the 'Player' table.", "A JOIN operation is performed between 'Player' and 'Tryout' on the 'pID' column to link players with their tryout information.", "Conditions are added to filter the results based on the 'decision' and 'pPos' columns in the 'Tryout' table using placeholders for string values."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "description": "This virtual table describes the names of players from the 'Player' table who have participated in tryouts and received a specific decision for a particular position. The placeholders in the WHERE clause represent the decision made regarding the player's tryout and the position they are trying out for.", "virtual_table": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING] AND T2.pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["The query identifies the relevant tables, which are 'Player' and 'Tryout'.", "It selects the average of the 'HS' column from the 'Player' table, which represents the high school attended by the players.", "A JOIN operation is performed between 'Player' and 'Tryout' on the 'pID' column to link players with their tryout information.", "A condition is added to filter the results based on the 'decision' column in the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "description": "This virtual table calculates the average high school attended by players who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.", "virtual_table": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5018", "db_id": "soccer_2", "question": "Which college has any student who is a goalie and succeeded in the tryout.", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "Select the column to display, 'cName', which represents the college name.", "Add conditions to filter the 'decision' and 'pPos' columns for the specified values using placeholders for string values."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "description": "This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.", "virtual_table": "SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["The query identifies the relevant tables, which are 'College' and 'Tryout'.", "It selects distinct values for 'state' and 'enr' from the 'College' table.", "A JOIN operation is performed between 'College' and 'Tryout' on the college name to link the two tables.", "A condition is added to filter the results based on the 'decision' column in the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "description": "This virtual table provides a distinct list of states and enrollment numbers from the 'College' table for colleges where players have participated in tryouts. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.", "virtual_table": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["The query identifies the relevant tables, 'College' and 'Tryout'.", "It selects distinct values for 'state' and 'enr' from the 'College' table.", "A JOIN operation is performed between 'College' and 'Tryout' on the college name to link the two tables.", "A condition is added to filter the results based on the 'decision' column in the 'Tryout' table using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "description": "This virtual table provides a distinct list of states and enrollment numbers from the 'College' table for colleges where players have participated in tryouts. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.", "virtual_table": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5026", "db_id": "soccer_2", "question": "Find the names of schools that have some students playing in goalie and mid positions.", "rationale": ["The query is identifying the relevant table, which is 'Tryout'.", "It selects the 'cName' column to display the names of colleges.", "The INTERSECT operator is used to find colleges where players are trying out for two different positions, specified by placeholders for string values."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "description": "This virtual table identifies the colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.", "virtual_table": "SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5028", "db_id": "soccer_2", "question": "Find the names of states that have some college students playing in goalie and mid positions.", "rationale": ["The query identifies the relevant tables, which are 'College' and 'Tryout'.", "It selects the 'state' column from the 'College' table.", "The JOIN operation links the 'College' and 'Tryout' tables based on the college name.", "The WHERE clause filters the results based on the player's position using a placeholder for string values.", "The INTERSECT operation ensures that only states with tryouts for the specified position are included in the final result."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "description": "This virtual table identifies the states where colleges are located that are hosting tryouts for a specific position. The query uses an intersection to find states that have tryouts for the same position, ensuring that only relevant states are returned. The placeholders in the WHERE clause represent the position for which players are trying out.", "virtual_table": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5029", "db_id": "soccer_2", "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?", "rationale": ["The query identifies the relevant tables, which are 'College' and 'Tryout'.", "It selects the 'state' column from the 'College' table.", "The JOIN operation links the 'College' and 'Tryout' tables based on the college name.", "The WHERE clause filters the results based on the player's position using a placeholder for string values.", "The INTERSECT operation ensures that only states with tryouts for the specified position are included in the final result."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "description": "This virtual table identifies the states of colleges that are hosting tryouts for a specific position. The query uses an intersection to find states where the tryout position matches the specified placeholder value, ensuring that only relevant states are returned.", "virtual_table": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["The query identifies the relevant table, which is 'Tryout'.", "It uses a subquery to find colleges where players are trying out for the first specified position.", "It uses another subquery to find colleges where players are trying out for the second specified position.", "The INTERSECT operator is used to find colleges that appear in both subqueries, meaning they have players trying out for both positions.", "Finally, the COUNT function is used to count the number of colleges that meet this criteria."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "description": "This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify any two positions they are interested in.", "virtual_table": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5037", "db_id": "soccer_2", "question": "What is the count of states with college students playing in the mid position but not as goalies?", "rationale": ["The query identifies the relevant tables, which are 'College' and 'Tryout'.", "It uses a JOIN operation to combine data from both tables based on the college name.", "The first SELECT statement retrieves states where tryouts for a specific position occurred.", "The EXCEPT clause is used to exclude states where tryouts for the same position also occurred, ensuring only unique states are counted."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')", "source_tables": ["tryout", "college"], "description": "This virtual table counts the number of unique states where colleges are located that have hosted tryouts for a specific position, excluding those states that have hosted tryouts for the same position. The placeholders in the query represent the position for which the tryouts are being considered.", "virtual_table": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["The query identifies the relevant table, which is 'College'.", "It selects distinct values from the 'state' column to avoid duplicates.", "A subquery is used to find the maximum enrollment number from the 'College' table.", "The main query filters the states based on the condition that the enrollment number is less than the maximum found in the subquery."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "description": "This virtual table provides a list of distinct states where colleges are located, specifically filtering for those colleges that have an enrollment number less than the maximum enrollment number found in the 'College' table. The placeholder in the WHERE clause represents the enrollment number for comparison.", "virtual_table": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)"}
{"sample_id": "train.5102", "db_id": "cre_Drama_Workshop_Groups", "question": "Show the minimum, average, maximum order quantity of all invoices.", "rationale": ["The query identifies the relevant table, which is 'INVOICES'.", "It selects the minimum, average, and maximum values of the 'Order_Quantity' column to provide insights into the order quantities.", "The use of aggregate functions (min, avg, max) allows for a summary of the order quantities across all invoices."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "description": "This virtual table provides the minimum, average, and maximum quantities of products ordered as recorded in the 'INVOICES' table. The placeholders in the SELECT statement represent the aggregated values of the 'Order_Quantity' column.", "virtual_table": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES"}
{"sample_id": "train.5118", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the payment method code used by the most orders?", "rationale": ["The query identifies the relevant table, which is 'INVOICES'.", "It selects the 'payment_method_code' to display unique payment methods.", "The GROUP BY clause is used to group the results by 'payment_method_code'.", "The ORDER BY clause sorts the results based on the count of occurrences of each payment method in descending order.", "The LIMIT clause allows the user to specify how many of the most frequently used payment methods to return."], "gold_sql": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices"], "description": "This virtual table provides a list of unique payment method codes used in the invoices, grouped by the payment method code and ordered by the frequency of their usage. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.", "virtual_table": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5127", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the descriptions of the service types that cost more than 100.", "rationale": ["The query identifies the relevant tables, which are 'Ref_Service_Types' and 'Services'.", "It selects the 'Service_Type_Description' from 'Ref_Service_Types'.", "A JOIN is performed between 'Ref_Service_Types' and 'Services' on the 'Service_Type_Code' to link the service types with their descriptions.", "A condition is added to filter the results based on the 'Product_Price' from the 'Services' table using a placeholder for numeric values."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "description": "This virtual table describes the service type descriptions from the 'Ref_Service_Types' table that are associated with services in the 'Services' table, filtered by a specific product price. The placeholder in the WHERE clause represents the minimum product price to filter the results.", "virtual_table": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["The query identifies the relevant tables, 'Drama_Workshop_Groups' and 'Services'.", "It selects the columns 'Store_Phone' and 'Store_Email_Address' from the 'Drama_Workshop_Groups' table.", "A JOIN operation is performed between 'Drama_Workshop_Groups' and 'Services' on the 'Workshop_Group_ID' to link the two tables.", "A condition is added to filter the results based on the 'Product_Name' from the 'Services' table using a placeholder for string values."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "description": "This virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular product. The placeholder in the WHERE clause represents the name of the product being queried.", "virtual_table": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5142", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the order details of the products with price higher than 2000?", "rationale": ["The query identifies the relevant tables, 'Order_Items' and 'Products'.", "It selects the 'Other_Item_Details' column from the 'Order_Items' table.", "A JOIN operation is performed between 'Order_Items' and 'Products' on the 'Product_ID' to link order items with their corresponding products.", "A condition is added to filter products based on their price, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "description": "This virtual table retrieves additional details about order items from the 'Order_Items' table, specifically for those products whose price exceeds a specified amount. The placeholder in the WHERE clause represents the price threshold for filtering the products.", "virtual_table": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["The query identifies the relevant tables, 'Order_Items' and 'Products'.", "It selects the 'Other_Item_Details' column from the 'Order_Items' table.", "A JOIN operation is performed between 'Order_Items' and 'Products' on the 'Product_ID' to link order items with their corresponding product details.", "A condition is added to filter products based on their price, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "description": "This virtual table retrieves additional details about order items from the 'Order_Items' table, specifically for those products whose price exceeds a specified amount. The placeholder in the WHERE clause represents the price threshold for filtering the products.", "virtual_table": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5160", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the most frequent status of bookings?", "rationale": ["The query identifies the relevant table, which is 'Bookings'.", "It selects the 'Status_Code' column to display unique booking statuses.", "The results are grouped by 'Status_Code' to aggregate the counts of each status.", "The results are ordered by the count of bookings for each status in descending order to show the most common statuses first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "description": "This virtual table summarizes the unique status codes of bookings from the 'Bookings' table, grouped by their status and ordered by the count of bookings for each status in descending order. The placeholder in the LIMIT clause represents the maximum number of status codes to return.", "virtual_table": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["The query identifies the relevant table, which is 'Bookings'.", "It selects the 'Status_Code' column to display the unique status codes of bookings.", "The GROUP BY clause is used to group the results by 'Status_Code'.", "The ORDER BY clause sorts the results based on the count of bookings for each status in descending order.", "The LIMIT clause restricts the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "description": "This virtual table summarizes the unique status codes of bookings from the 'Bookings' table, grouped by their status and ordered by the count of bookings for each status in descending order. The placeholder in the LIMIT clause represents the maximum number of status codes to return.", "virtual_table": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["The query identifies the relevant tables, 'Bookings' and 'Drama_Workshop_Groups'.", "It selects the 'Store_Name' from the 'Drama_Workshop_Groups' table.", "A JOIN operation is performed on 'Workshop_Group_ID' to link bookings to their respective workshop groups.", "A condition is added to filter the bookings based on a specific 'Status_Code' using a placeholder for string values."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "description": "This virtual table provides the names of stores associated with bookings that have a specific status. The placeholder in the WHERE clause represents the status code of the booking.", "virtual_table": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5171", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the description of the service type that offers not only the photo product but also the film product.", "rationale": ["The query identifies the relevant tables, which are 'Ref_Service_Types' and 'Services'.", "It selects the 'Service_Type_Description' from 'Ref_Service_Types' by joining it with 'Services' on 'Service_Type_Code'.", "The WHERE clause filters the results based on the 'Product_Name' from the 'Services' table using a placeholder for string values.", "The INTERSECT operator is used to ensure that only service types associated with the same product name are returned in both parts of the query."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "description": "This virtual table describes the service type descriptions associated with a specific product from the 'Services' table, ensuring that the same product name is used in both parts of the query. The placeholders in the WHERE clause represent the product's name.", "virtual_table": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5459", "db_id": "voter_2", "question": "Find the average age of female students.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the average of the 'Age' column to compute the average age of students.", "A condition is added to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  'F'", "source_tables": ["student"], "description": "This virtual table calculates the average age of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5466", "db_id": "voter_2", "question": "What are the distinct president votes on 08/30/2015?", "rationale": ["The query identifies the relevant table, which is 'Voting_record'.", "Select the distinct values of the 'PRESIDENT_Vote' column to avoid duplicates.", "Add a condition to filter the records based on the 'Registration_Date' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "description": "This virtual table provides a distinct list of presidential votes cast by students from the 'Voting_record' table, filtered by the registration date. The placeholder in the WHERE clause represents the specific registration date being queried.", "virtual_table": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["The query identifies the relevant table, which is 'Voting_record'.", "Select the distinct values of the 'PRESIDENT_Vote' column to avoid duplicates.", "Add a condition to filter the records based on the 'Registration_Date' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "description": "This virtual table provides a distinct list of presidential votes cast by students from the 'Voting_record' table, filtered by the date of registration. The placeholder in the WHERE clause represents the specific registration date being queried.", "virtual_table": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5476", "db_id": "voter_2", "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the distinct ages from the 'Student' table.", "A join is performed between 'Student' and 'Voting_record' on the condition that the student's ID matches the vote cast for the secretary candidate.", "A condition is added to filter the results based on the specified election cycle using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "description": "This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the distinct 'Advisor' from the 'Student' table.", "A join is performed between 'Student' and 'Voting_record' on the condition that 'StuID' matches 'Treasurer_Vote'.", "A condition is added to filter the results based on the specified 'Election_Cycle' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.", "virtual_table": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5486", "db_id": "voter_2", "question": "How many male (sex is M) students have class senator votes in the fall election cycle?", "rationale": ["The query identifies the relevant tables, which are 'Student' and 'Voting_record'.", "It performs a JOIN operation on the 'StuID' to link students with their voting records.", "The SELECT statement counts the total number of students that meet the specified criteria.", "Conditions are added to filter the results based on the student's gender and the election cycle using placeholders for string values."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "description": "This virtual table counts the number of students from the 'Student' table who are female or male and have participated in the voting process during a specific election cycle. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.", "virtual_table": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the average age from the 'Student' table.", "A JOIN operation is performed on the 'StuID' to link students with their voting records, specifically filtering for those who voted for the secretary candidate.", "Conditions are added to filter students based on their city code and the election cycle using placeholders for string values."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle during which the votes were cast.", "virtual_table": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5492", "db_id": "voter_2", "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects the average age from the 'Student' table.", "A JOIN is performed on the 'StuID' to link students with their voting records, specifically filtering for those who voted for the secretary candidate.", "Conditions are added to filter by the student's gender and the election cycle using placeholders for string values."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "description": "This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.", "virtual_table": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects distinct first names from the 'Student' table (aliased as T1) that are associated with the vice presidential votes in the 'Voting_record' table (aliased as T2).", "The JOIN condition links the 'StuID' from 'Student' with the 'Vice_President_Vote' in 'Voting_record'.", "The EXCEPT clause is used to exclude students from the results who reside in a specified city, indicated by a placeholder for the city code."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "description": "This virtual table describes the first names of students who voted for a specific vice presidential candidate, excluding those who reside in a particular city. The placeholder in the EXCEPT clause represents the city code.", "virtual_table": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5495", "db_id": "voter_2", "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects distinct first names from the 'Student' table (aliased as T1) that are associated with the vice president votes in the 'Voting_record' table (aliased as T2).", "The JOIN condition links the 'StuID' from 'Student' with the 'Vice_President_Vote' from 'Voting_record'.", "The EXCEPT clause is used to exclude students who reside in a specific city, represented by a placeholder for the city code."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "description": "This virtual table describes the first names of students who voted for the vice president but are not residents of a specific city. The placeholder in the EXCEPT clause represents the city code that is used to filter out students from that city.", "virtual_table": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5496", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is not 2192.", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects distinct last names from the 'Student' table (aliased as T1) that are associated with the presidential votes in the 'Voting_record' table (aliased as T2).", "The JOIN condition links the 'StuID' from the 'Student' table to the 'President_Vote' in the 'Voting_record' table.", "The EXCEPT clause is used to exclude students who have a specific advisor, represented by a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "description": "This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.", "virtual_table": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5499", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes and have 8741 as the advisor?", "rationale": ["The query identifies the relevant tables, 'Student' and 'Voting_record'.", "It selects distinct last names from the 'Student' table where the student ID matches the presidential vote in the 'Voting_record' table.", "The INTERSECT operation is used to find students who also have a specific advisor, filtering by the 'Advisor' column with a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "description": "This virtual table describes the last names of students who have voted for a presidential candidate and are assigned to a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.", "virtual_table": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the column to display, 'Major'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values.", "Group the results by 'Major' to aggregate the data.", "Order the results by the count of students in each major in descending order.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of majors from the 'Student' table, filtered by the gender of the students. The results are grouped by major and ordered by the number of students in each major in descending order, with a limit on the number of results returned. The placeholders represent the gender of the students and the maximum number of majors to display.", "virtual_table": "SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the column to display, 'Major'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values.", "Group the results by 'Major' to aggregate the data.", "Order the results by the count of students in each major in descending order.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of majors from the 'Student' table, filtered by the gender of the students. The results are grouped by major and ordered by the number of students in each major in descending order, with a limit on the number of results returned. The placeholders represent the gender of the students and the maximum number of majors to display.", "virtual_table": "SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["The query identifies the relevant table, which is 'Products'.", "It uses the COUNT function to count the number of products that meet specific criteria.", "The WHERE clause filters products based on the 'product_category_code' and 'typical_buying_price', using placeholders for the string and numeric values."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "description": "This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.", "virtual_table": "SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["The query identifies the relevant tables, which are 'Ref_Product_Categories' and 'Products'.", "It selects the 'product_category_description' from 'Ref_Product_Categories'.", "A JOIN is performed on the 'product_category_code' to link 'Ref_Product_Categories' with 'Products'.", "A condition is added to filter products based on their description using a placeholder for string values."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "description": "This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.", "virtual_table": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', and 'Characteristics'.", "It uses JOIN operations to link these tables based on their foreign key relationships.", "The SELECT statement counts the distinct characteristic names from the 'Characteristics' table.", "A condition is added to filter the results based on the specified product name using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "description": "This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product for which the distinct characteristics are being counted.", "virtual_table": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors'.", "It uses JOIN operations to link these tables based on their foreign key relationships.", "The SELECT statement counts the total number of products that meet the specified conditions.", "The WHERE clause filters the results based on either the color description or the characteristic name, using placeholders for user-defined values."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "description": "This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using joins based on their relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.", "virtual_table": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["The query is identifying the relevant table, which is 'Ref_Product_Categories'.", "Select the column to display, 'unit_of_measure'.", "Add a condition to filter the 'product_category_code' column for the specified product category using a placeholder for string values."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "description": "This virtual table describes the unit of measure for a specific product category from the 'Ref_Product_Categories' table. The placeholder in the WHERE clause represents the unique code for the product category.", "virtual_table": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["The query identifies the relevant tables, which are 'Products' and 'Ref_Product_Categories'.", "It selects the columns 'unit_of_measure' and 'product_category_code' from the 'Ref_Product_Categories' table.", "A JOIN operation is performed on the 'product_category_code' to link the 'Products' table with the 'Ref_Product_Categories' table.", "A condition is added to filter the results based on the specified product name using a placeholder for string values."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "description": "This virtual table provides the unit of measure and product category code for a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.", "virtual_table": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["The query identifies the relevant tables, 'Products' and 'Ref_Colors'.", "It selects the 'color_description' from the 'Ref_Colors' table.", "A JOIN operation is performed on the 'color_code' to link products with their respective colors.", "The results are grouped by 'color_description' to aggregate the data based on color.", "The ORDER BY clause sorts the colors by their count in descending order, allowing the most common colors to appear first.", "The LIMIT clause uses a placeholder to specify the maximum number of results to return."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "description": "The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the frequency of each color's occurrence. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.", "virtual_table": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["The query identifies the relevant tables, which are 'Products' and 'Ref_Colors'.", "It selects the 'color_description' from the 'Ref_Colors' table.", "A JOIN operation is performed on the 'color_code' to link products with their respective colors.", "The results are grouped by 'color_description' to aggregate the data based on color.", "The results are ordered by the count of products associated with each color in ascending order.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "description": "This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the count of products associated with each color in ascending order. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.", "virtual_table": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', and 'Characteristics'.", "It selects the 'characteristic_name' from the 'Characteristics' table.", "The tables are joined based on their relationships: 'Products' to 'Product_Characteristics' via 'product_id', and 'Product_Characteristics' to 'Characteristics' via 'characteristic_id'.", "The results are grouped by 'characteristic_name' to aggregate the data.", "A HAVING clause is added to filter the results based on the count of products associated with each characteristic name, using a placeholder for numeric values."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "description": "This virtual table describes the names of characteristics associated with products from the 'Products' table. It retrieves characteristic names by joining the 'Products', 'Product_Characteristics', and 'Characteristics' tables. The results are grouped by characteristic name, and only those with a count of associated products greater than or equal to a specified number are included. The placeholder in the HAVING clause represents the minimum count of products for the characteristic names to be displayed.", "virtual_table": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["The query identifies the relevant table, which is 'railway'.", "Select the column to display, 'Builder'.", "Add an ORDER BY clause to sort the results in ascending order based on the 'Builder' column."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "description": "This virtual table provides a list of builders from the 'railway' table, sorted in ascending order by the builder's name. The query retrieves the 'Builder' column, which indicates the name of the company or individual responsible for constructing the railway.", "virtual_table": "SELECT Builder FROM railway ORDER BY Builder ASC"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["The query identifies the relevant tables, 'railway' and 'train', and uses a JOIN to combine them based on the common 'Railway_ID'.", "It selects the 'Railway_ID' from the 'train' table and the 'Builder' from the 'railway' table.", "The results are grouped by 'Railway_ID' to aggregate the data, allowing for counting the number of trains associated with each railway.", "The ORDER BY clause sorts the results in descending order based on the count of trains, ensuring that the railways with the most trains appear first.", "The LIMIT clause uses a placeholder to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "description": "This virtual table provides a list of railway IDs along with the names of the builders for each railway. The data is aggregated by railway ID, showing the most frequently associated railways based on the number of trains linked to them. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["The query identifies the relevant table, which is 'railway'.", "Select the 'Builder' column to display the names of builders.", "Group the results by 'Builder' to aggregate the data based on builder names.", "Order the results by the count of railways each builder has constructed in descending order to show the most prolific builders first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "description": "This virtual table provides a list of builders from the 'railway' table, grouped by their names. It orders the results by the number of railways each builder has constructed, showing the top results based on a specified limit. The placeholder in the LIMIT clause represents the maximum number of builders to display.", "virtual_table": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the 'LName' column to display the last names of students.", "The first part of the query filters students by 'sex' and 'city_code' using placeholders for string values.", "The second part of the query filters students by 'sex' and 'age' using a placeholder for numeric values, and combines the results using UNION."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "description": "This virtual table provides a list of last names of students from the 'Student' table based on specific criteria. It includes students of a certain gender residing in a specific city, as well as students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age criteria.", "virtual_table": "SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND city_code  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["The query identifies the relevant tables, which are 'dorm' and 'has_amenity'.", "It selects the count of amenities and the dormitory ID from the 'dorm' table.", "A JOIN operation is performed between 'dorm' and 'has_amenity' on the dormitory ID to link dormitories with their amenities.", "A condition is added to filter dormitories based on their student capacity using a placeholder for numeric values.", "The results are grouped by the dormitory ID to provide a count of amenities for each qualifying dormitory."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "description": "This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.", "virtual_table": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["The query identifies the relevant tables: 'student', 'lives_in', and 'dorm'.", "It joins the 'student' table with the 'lives_in' table on the student ID to associate students with their dormitory.", "Then, it joins the 'lives_in' table with the 'dorm' table on the dormitory ID to access dormitory details.", "Finally, it adds a condition to filter the results based on the gender designation of the dormitory using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "description": "This virtual table provides the count of students residing in dormitories based on gender designation. The placeholders in the WHERE clause represent the gender of the dormitory.", "virtual_table": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["The query identifies the relevant tables, which are 'Student', 'Lives_in', 'Dorm', 'Has_amenity', and 'Dorm_amenity'.", "It selects the 'fname' column from the 'Student' table.", "The query joins 'Student' with 'Lives_in' to find which students live in which dorms.", "A subquery is used to find dormitories with the most amenities by joining 'Dorm', 'Has_amenity', and 'Dorm_amenity', counting the amenities, and ordering them.", "The LIMIT clause uses a placeholder for the maximum number of dormitories to include in the results."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "description": "The virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It then filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them in descending order and limiting the results to a specified number of dorms. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.", "virtual_table": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["The query identifies the relevant tables, 'student' and 'lives_in', to retrieve student information.", "It selects the columns 'fname' and 'age' from the 'student' table.", "A JOIN operation is performed between 'student' and 'lives_in' to link students with their respective dormitories.", "A subquery is used to filter out dormitories that have a specific amenity by checking against the 'has_amenity' and 'dorm_amenity' tables.", "The placeholder in the subquery represents the amenity's name that is being excluded from the results."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "description": "This virtual table describes the first names and ages of students who live in dormitories that do not have a specific amenity. The placeholders in the WHERE clause represent the amenity's name that is being filtered out.", "virtual_table": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["The query identifies the relevant tables, 'Customers' and 'Complaints'.", "It selects the 'email_address' from the 'Customers' table, aliased as 't1'.", "A JOIN operation is performed between 'Customers' and 'Complaints' on the 'customer_id' to link customers with their complaints.", "The results are grouped by 'customer_id' to ensure that each customer appears only once in the results.", "The results are ordered by the count of complaints for each customer, allowing us to see which customers have the most complaints.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "description": "This virtual table provides the email addresses of customers from the 'Customers' table who have made complaints, grouped by customer to ensure unique entries. The results are ordered by the number of complaints each customer has made, and the limit on the number of results returned can be specified using a placeholder for numeric values.", "virtual_table": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["The query identifies the relevant tables: 'Products', 'Complaints', and 'Customers'.", "It selects distinct product names from the 'Products' table.", "The query joins the 'Products' table with the 'Complaints' table on the product identifier to link complaints to products.", "It further joins with the 'Customers' table to group the results by customer identifiers.", "The results are ordered by the count of complaints associated with each customer, and a limit is applied to control the number of results returned."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "description": "This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and then groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints per customer, and a limit is applied to restrict the number of product names returned based on a specified number.", "virtual_table": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["The query identifies the relevant tables: 'staff', 'complaints', and 'products'.", "It selects the 'last_name' column from the 'staff' table.", "The query uses JOIN operations to connect the 'staff' table with the 'complaints' table based on the 'staff_id', and then connects the 'complaints' table with the 'products' table based on the 'product_id'.", "The results are ordered by the 'product_price' from the 'products' table.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "description": "This virtual table provides a list of last names of staff members who are associated with complaints related to products. The results are ordered by the price of the products, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["The query identifies the relevant table, which is 'Complaints'.", "It selects the 'complaint_status_code' to display.", "The GROUP BY clause is used to group the results by 'complaint_status_code'.", "The HAVING clause filters the groups to include only those with a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "description": "The virtual table summarizes the different complaint status codes from the 'Complaints' table, specifically focusing on those status codes that have a count exceeding a specified number. The placeholder in the HAVING clause represents the minimum count of complaints required for a status code to be included in the results.", "virtual_table": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It uses the COUNT function to count the number of customers for each type, grouping the results by 'customer_type_code'.", "The results are ordered in descending order based on the count of customers, allowing the most common customer types to appear first.", "A LIMIT clause is included to restrict the number of results returned, with a placeholder for the user to specify the desired number."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.", "virtual_table": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Complaints'.", "It selects the 'first_name' column from the 'Staff' table.", "A JOIN operation is performed between 'Staff' and 'Complaints' on the 'staff_id' column to link staff members to the complaints they handle.", "The results are grouped by 'staff_id' to aggregate the data for each staff member.", "The results are ordered by the count of complaints handled by each staff member.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "description": "This virtual table provides the first names of staff members from the 'Staff' table who are associated with complaints in the 'Complaints' table. The results are grouped by staff member and ordered by the number of complaints they have handled, with a limit specified by a placeholder for numeric values.", "virtual_table": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["The query identifies the relevant tables, which are 'Staff' and 'Complaints'.", "It selects the 'first_name' column from the 'Staff' table, aliased as 't1'.", "A JOIN operation is performed between 'Staff' and 'Complaints' on the 'staff_id' column to link staff members to the complaints they handle.", "The results are grouped by 'staff_id' from the 'Complaints' table to aggregate the data per staff member.", "The results are ordered by the count of complaints handled by each staff member, allowing us to see who has the most complaints.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "description": "This virtual table provides the first names of staff members from the 'Staff' table who are associated with complaints in the 'Complaints' table. The results are grouped by staff member and ordered by the number of complaints they have handled, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The query identifies the relevant table, which is 'Investors'.", "Select the column to display, 'Investor_details'."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "description": "This virtual table provides detailed information about investors from the 'Investors' table. The query selects the 'Investor_details' column, which contains specific information regarding each investor.", "virtual_table": "SELECT Investor_details FROM INVESTORS"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["The query identifies the relevant tables, which are 'Investors' and 'Transactions'.", "It selects the 'Investor_details' column from the 'Investors' table.", "A JOIN operation is performed between 'Investors' and 'Transactions' on the 'investor_id' to link investors with their transactions.", "A condition is added to filter the results based on the 'share_count' column from the 'Transactions' table, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "description": "This virtual table provides detailed information about investors from the 'Investors' table who have made transactions involving a number of shares greater than a specified amount. The placeholder in the WHERE clause represents the minimum share count for filtering the transactions.", "virtual_table": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["The query identifies the relevant tables: 'Lots', 'Transactions_Lots', and 'Transactions'.", "It selects the 'lot_details' column from the 'Lots' table.", "The query uses JOINs to connect 'Lots' with 'Transactions_Lots' and 'Transactions' based on their respective identifiers.", "A condition is added to filter the results where the 'share_count' in the 'Transactions' table is less than a specified numeric value using a placeholder."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "description": "This virtual table describes the details of lots associated with transactions where the number of shares involved in the transaction is less than a specified amount. The placeholders in the WHERE clause represent the numeric value for the share count.", "virtual_table": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "It selects the 'transaction_type_code' to categorize the transactions.", "The query calculates the average of 'amount_of_transaction' for each transaction type.", "The GROUP BY clause is used to group the results by 'transaction_type_code' to get the average amount for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "description": "This virtual table summarizes the average amount of transactions grouped by their respective transaction types from the 'Transactions' table. The placeholder in the SELECT clause represents the transaction type code, while the average amount is calculated for each type.", "virtual_table": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "It selects the 'transaction_type_code' to categorize the results by transaction type.", "The query uses aggregate functions 'max' and 'min' to calculate the maximum and minimum share counts for each transaction type.", "The 'GROUP BY' clause is used to group the results by 'transaction_type_code' to ensure the aggregation is performed for each type of transaction."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "description": "This virtual table summarizes the maximum and minimum share counts for each type of transaction recorded in the 'Transactions' table. The placeholder in the SELECT clause represents the transaction type code, while the aggregation functions calculate the maximum and minimum share counts for each group of transaction types.", "virtual_table": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["The query is identifying the relevant tables, which are 'Sales' and 'Purchases'.", "It selects the 'sales_details' from the 'Sales' table and 'purchase_details' from the 'Purchases' table.", "The UNION operator is used to combine the results from both tables into a single result set, allowing for a unified view of transaction details."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "description": "This virtual table combines the details of sales and purchase transactions from the 'Sales' and 'Purchases' tables. The placeholder in the SELECT statements allows for the retrieval of specific details related to sales and purchases.", "virtual_table": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases"}
{"sample_id": "train.5898", "db_id": "cre_Theme_park", "question": "What is the average price range of five star hotels that allow pets?", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "It selects the average of the 'price_range' column to determine the average price of hotels.", "Conditions are added to filter the results based on the specified 'star_rating_code' and whether pets are allowed, using placeholders for string and numeric values."], "gold_sql": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  '5' AND pets_allowed_yn  =  1", "source_tables": ["hotels"], "description": "This virtual table calculates the average price range of hotels from the 'Hotels' table that have a specific star rating and indicate whether pets are allowed. The placeholders in the WHERE clause represent the star rating code and the pets allowed status.", "virtual_table": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5904", "db_id": "cre_Theme_park", "question": "Find all the locations whose names contain the word \"film\".", "rationale": ["The query identifies the relevant table, which is 'Locations'.", "Select the column to display, 'Location_Name'.", "Add a condition to filter the 'Location_Name' column using a LIKE operator with a placeholder for string values."], "gold_sql": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE '%film%'", "source_tables": ["locations"], "description": "This virtual table provides a list of location names from the 'Locations' table that match a specific pattern. The placeholder in the WHERE clause allows for flexible searching of location names based on user input.", "virtual_table": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["The query identifies the relevant tables, which are 'Museums' and 'Tourist_Attractions'.", "It selects the 'Museum_Details' from the 'Museums' table and 'Opening_Hours' from the 'Tourist_Attractions' table.", "A JOIN operation is performed on the 'Museum_ID' from the 'Museums' table and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table to link the two tables based on their relationship."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "description": "This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.", "virtual_table": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.5916", "db_id": "cre_Theme_park", "question": "Give me the detail and opening hour for each museum.", "rationale": ["The query identifies the relevant tables, which are 'Museums' and 'Tourist_Attractions'.", "It selects the 'Museum_Details' from the 'Museums' table and 'Opening_Hours' from the 'Tourist_Attractions' table.", "A JOIN operation is performed on the 'Museum_ID' from the 'Museums' table and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table to link the two tables based on their relationship."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "description": "This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.", "virtual_table": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["The query identifies the relevant tables, which are 'Royal_Family' and 'Tourist_Attractions'.", "It selects the 'Royal_Family_Details' from the 'Royal_Family' table and 'How_to_Get_There' from the 'Tourist_Attractions' table.", "A join operation is performed on the 'Royal_Family_ID' from the 'Royal_Family' table and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table to link the two tables based on their relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "description": "This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The join operation links the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for royal family entries and the tourist attraction ID.", "virtual_table": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.5923", "db_id": "cre_Theme_park", "question": "What are the details of the shops that can be accessed by walk?", "rationale": ["The query identifies the relevant tables, which are 'SHOPS' and 'TOURIST_ATTRACTIONS'.", "It selects the 'Shop_Details' column from the 'SHOPS' table.", "A JOIN operation is performed to link 'SHOPS' with 'TOURIST_ATTRACTIONS' based on the matching 'Shop_ID' and 'Tourist_Attraction_ID'.", "A condition is added to filter the results based on the 'How_to_Get_There' column from the 'TOURIST_ATTRACTIONS' table, using a placeholder for string values."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "description": "This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.", "virtual_table": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5931", "db_id": "cre_Theme_park", "question": "Which tourist attractions does the visitor with detail 'Vincent' visit?", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Visits', and 'Visitors'.", "It selects the 'Name' column from the 'Tourist_Attractions' table.", "The query joins 'Tourist_Attractions' with 'Visits' on the 'Tourist_Attraction_ID' to connect attractions with their visits.", "It further joins 'Visits' with 'Visitors' on 'Tourist_ID' to link visits to specific tourists.", "A condition is added to filter the results based on the 'Tourist_Details' of the specified tourist using a placeholder for string values."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the details of a specific tourist. The placeholder in the WHERE clause represents the details of the tourist being queried.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5932", "db_id": "cre_Theme_park", "question": "Show the tourist attractions visited by the tourist whose detail is 'Vincent'.", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Visits', and 'Visitors'.", "It selects the 'Name' column from the 'Tourist_Attractions' table.", "It joins 'Tourist_Attractions' with 'Visits' on the 'Tourist_Attraction_ID' to link attractions to visits.", "It further joins 'Visits' with 'Visitors' on 'Tourist_ID' to associate visits with specific tourists.", "A condition is added to filter the results based on the specified tourist's details using a placeholder for string values."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5941", "db_id": "cre_Theme_park", "question": "Show the details of the top 3 most expensive hotels.", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Select the column to display, 'other_hotel_details'.", "Order the results by 'price_range' in descending order to show the most expensive hotels first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "description": "This virtual table provides a list of additional details about hotels from the 'Hotels' table, ordered by their price range in descending order. The placeholder in the LIMIT clause represents the maximum number of hotel details to retrieve.", "virtual_table": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Select the column to display, 'other_hotel_details'.", "Order the results by 'price_range' in descending order to show the most expensive hotels first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "description": "This virtual table provides a list of additional details about hotels from the 'Hotels' table, ordered by their price range in descending order. The placeholder in the LIMIT clause represents the maximum number of hotel details to retrieve.", "virtual_table": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5944", "db_id": "cre_Theme_park", "question": "What are the details and star ratings of the three hotels with the lowest price ranges?", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Selects the columns to display, 'other_hotel_details' and 'star_rating_code'.", "Orders the results by 'price_range' in ascending order to show the cheapest hotels first.", "Limits the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "description": "This virtual table provides a list of additional details about hotels along with their star rating codes, sorted by the price range in ascending order. The placeholder in the LIMIT clause represents the maximum number of hotel records to return.", "virtual_table": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["The query identifies the relevant table, which is 'Tourist_Attractions'.", "It selects the 'How_to_Get_There' column to display the instructions for reaching attractions.", "The results are grouped by 'How_to_Get_There' to consolidate similar instructions.", "The results are ordered by the count of occurrences of each instruction in descending order to highlight the most common ones.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "description": "This virtual table provides a list of instructions on how to reach various tourist attractions, grouped by the unique directions provided. The results are ordered by the frequency of each instruction, allowing users to see the most common ways to get to attractions. The placeholder in the LIMIT clause represents the maximum number of instructions to retrieve.", "virtual_table": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["The query identifies the relevant table, which is 'Tourist_Attractions'.", "Select the column 'How_to_Get_There' to display the instructions for reaching attractions.", "Group the results by 'How_to_Get_There' to consolidate similar instructions.", "Order the results by the count of occurrences of each instruction in descending order to prioritize the most common ones.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "description": "This virtual table provides a list of instructions on how to reach various tourist attractions, grouped by the unique directions provided. The results are ordered by the frequency of each instruction, allowing users to see the most common ways to get to attractions. The placeholder in the LIMIT clause represents the maximum number of instructions to retrieve.", "virtual_table": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5955", "db_id": "cre_Theme_park", "question": "Show the names and ids of tourist attractions that are visited at most once.", "rationale": ["The query identifies the relevant tables, 'Tourist_Attractions' and 'Visits'.", "It selects the 'Name' and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table.", "A JOIN operation is performed between 'Tourist_Attractions' and 'Visits' on the 'Tourist_Attraction_ID' to link attractions with their visit records.", "The results are grouped by 'Tourist_Attraction_ID' to aggregate visit counts.", "The HAVING clause filters the results to include only those attractions with visit counts less than or equal to the specified numeric placeholder."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "description": "This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table, ensuring that only attractions with visit counts below or equal to the specified threshold are included.", "virtual_table": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5956", "db_id": "cre_Theme_park", "question": "What are the names and ids of the tourist attractions that are visited at most once?", "rationale": ["The query identifies the relevant tables, 'Tourist_Attractions' and 'Visits'.", "It selects the 'Name' and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table.", "A JOIN operation is performed between 'Tourist_Attractions' and 'Visits' on the 'Tourist_Attraction_ID' to link attractions with their visit records.", "The results are grouped by 'Tourist_Attraction_ID' to aggregate visit counts.", "A HAVING clause is used to filter the results based on the count of visits, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "description": "This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the count of visits recorded in the 'Visits' table, ensuring that only attractions with visit counts less than or equal to the specified number are included.", "virtual_table": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Tourist_Attraction_Features', and 'Features'.", "It selects the 'Name' column from the 'Tourist_Attractions' table.", "The JOIN operations link the tables based on their foreign key relationships, ensuring that only attractions with the specified features are included.", "The WHERE clause filters the results based on the feature details, using placeholders for the specific feature descriptions. The UNION operator allows for combining results from two similar queries, each filtering by a different feature detail."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "description": "This virtual table lists the names of tourist attractions that feature specific characteristics. The query combines results from the 'Tourist_Attractions', 'Tourist_Attraction_Features', and 'Features' tables, filtering based on the details of the features. The placeholders in the WHERE clause represent the specific feature details being queried.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Tourist_Attraction_Features', and 'Features'.", "It selects the 'Name' column from the 'Tourist_Attractions' table.", "The query uses JOIN operations to connect the tables based on their foreign key relationships.", "It applies a condition to filter attractions based on specific feature details using placeholders for string values.", "The UNION operator is used to combine results from two similar queries, allowing for multiple feature criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "description": "This virtual table lists the names of tourist attractions that feature specific characteristics. The query retrieves attraction names from the 'Tourist_Attractions' table by joining it with the 'Tourist_Attraction_Features' and 'Features' tables. The placeholders in the WHERE clause represent the details of the features that the attractions must have, allowing users to specify different feature criteria.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5963", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions Vincent and Marcelle visit?", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Visitors', and 'Visits'.", "It selects the 'Name' of the tourist attractions from the 'Tourist_Attractions' table.", "The JOIN operations link the 'Tourist_Attraction_ID' and 'Tourist_ID' across the 'Tourist_Attractions', 'Visitors', and 'Visits' tables to find the attractions visited by the tourists.", "The WHERE clause filters the results based on the details of the tourists using placeholders for string values.", "The INTERSECT operator is used to find common attractions visited by both tourists based on their details."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5985", "db_id": "game_1", "question": "Which game type has most number of games?", "rationale": ["The query identifies the relevant table, which is 'Video_Games'.", "It selects the 'GType' column to display the types of video games.", "The results are grouped by 'GType' to aggregate the data based on the genre.", "The results are ordered by the count of games in each genre in descending order.", "A limit is applied to restrict the number of genres displayed, using a placeholder for numeric values."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["video_games"], "description": "This virtual table summarizes the types of video games from the 'Video_Games' table, grouping them by genre and ordering the results by the number of games in each genre. The placeholder in the LIMIT clause represents the maximum number of genres to display.", "virtual_table": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5988", "db_id": "game_1", "question": "What is the type with the fewest games?", "rationale": ["The query identifies the relevant table, which is 'Video_Games'.", "It selects the 'GType' column to display the genre of the video games.", "The query groups the results by 'GType' to aggregate the data based on the genre.", "It orders the results by the count of each genre to prioritize the most common ones.", "The LIMIT clause uses a placeholder to specify the maximum number of genres to return."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) LIMIT 1", "source_tables": ["video_games"], "description": "This virtual table summarizes the types of video games from the 'Video_Games' table, grouping them by their genre. The placeholder in the LIMIT clause represents the maximum number of genres to be displayed.", "virtual_table": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6001", "db_id": "game_1", "question": "How many students play sports?", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "It uses the COUNT function to count the number of distinct 'StuID' entries.", "The DISTINCT keyword ensures that only unique student identifiers are counted, providing the total number of unique students involved in sports."], "gold_sql": "SELECT count(DISTINCT StuID) FROM Sportsinfo", "source_tables": ["sportsinfo"], "description": "This virtual table provides the count of distinct students from the 'SportsInfo' table, indicating how many unique students are participating in sports activities. The query uses the COUNT function to aggregate the unique student identifiers.", "virtual_table": "SELECT count(DISTINCT StuID) FROM Sportsinfo"}
{"sample_id": "train.6003", "db_id": "game_1", "question": "List ids for all student who are on scholarship.", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "Select the column to display, 'StuID', which is the unique identifier for each student.", "Add a condition to filter the 'OnScholarship' column for the specified scholarship status using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "description": "This virtual table lists the unique identifiers of students from the 'SportsInfo' table who are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status, which can be either 'Yes' or 'No'.", "virtual_table": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6004", "db_id": "game_1", "question": "What are the ids for all sporty students who are on scholarship?", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "Select the column to display, 'StuID', which is the unique identifier for each student.", "Add a condition to filter the 'OnScholarship' column for the specified scholarship status using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "description": "This virtual table lists the unique identifiers of students from the 'SportsInfo' table who are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status, which can be either 'Yes' or 'No'.", "virtual_table": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6006", "db_id": "game_1", "question": "What are the last names for all scholarship students?", "rationale": ["The query identifies the relevant tables, which are 'SportsInfo' and 'Student'.", "It uses a JOIN operation to combine records from both tables based on the common 'StuID' field.", "The SELECT statement specifies that only the 'LName' column from the 'Student' table should be displayed.", "A condition is added to filter the results based on the 'OnScholarship' column from the 'SportsInfo' table using a placeholder for string values."], "gold_sql": "SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.", "virtual_table": "SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6010", "db_id": "game_1", "question": "What is the total number of all football games played by scholarship students?", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "It selects the sum of the 'GamesPlayed' column to get the total number of games played.", "Conditions are added to filter the results based on the specified 'SportName' and whether the student is 'OnScholarship', using placeholders for string values."], "gold_sql": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  'Football' AND onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "description": "This virtual table summarizes the total number of games played by students involved in a specific sport who are also on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.", "virtual_table": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6014", "db_id": "game_1", "question": "What are the ids of all students along with how many sports and games did they play?", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "It selects the 'StuID' to group the results by each student.", "The count function is used to count the number of entries for each student, and the sum function calculates the total number of games played by each student.", "The GROUP BY clause is applied to aggregate the results based on 'StuID' to ensure each student's data is summarized correctly."], "gold_sql": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID", "source_tables": ["sportsinfo"], "description": "This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. The placeholder in the SELECT clause represents the unique student identifier, while the count and sum functions aggregate the data accordingly.", "virtual_table": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID"}
{"sample_id": "train.6019", "db_id": "game_1", "question": "Which sport has most number of students on scholarship?", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "Select the column to display, 'SportName'.", "Add a condition to filter the 'OnScholarship' column for the specified scholarship status using a placeholder for string values.", "Group the results by 'SportName' to aggregate the data.", "Order the results by the count of students participating in each sport in descending order.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "description": "This virtual table describes the names of sports in which students are involved, filtered by their scholarship status. The results are grouped by sport name and ordered by the number of students participating in each sport, with a limit on the number of results returned. The placeholders represent the scholarship status and the maximum number of results to display.", "virtual_table": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sportname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6020", "db_id": "game_1", "question": "What is the sport with the most scholarship students?", "rationale": ["The query identifies the relevant table, which is 'SportsInfo'.", "Select the column to display, 'SportName'.", "Add a condition to filter the 'OnScholarship' column for the specified scholarship status using a placeholder for string values.", "Group the results by 'SportName' to aggregate the data.", "Order the results by the count of students in each sport in descending order.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "description": "This virtual table provides a list of sports names from the 'SportsInfo' table for students who are either on or not on a sports scholarship, depending on the specified condition. The results are grouped by sport name and ordered by the number of students participating in each sport, with a limit on the number of results returned.", "virtual_table": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sportname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6024", "db_id": "game_1", "question": "What are the student ids for those on scholarship in major number 600?", "rationale": ["The query is identifying the relevant table, which is 'Student' and 'SportsInfo'.", "Select the column 'StuID' to display the unique identifier for students.", "Add a condition to filter the 'major' column for the specified major using a placeholder for numeric values.", "Use the INTERSECT operator to find students who are also in the 'SportsInfo' table with a condition on the 'OnScholarship' column using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Student WHERE major  =  600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.", "virtual_table": "SELECT StuID FROM Student WHERE major  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6025", "db_id": "game_1", "question": "Show student ids who are female and play football.", "rationale": ["The query is identifying the relevant table, which is 'Student' and 'SportsInfo'.", "Select the column 'StuID' to display the unique identifier of the students.", "Add a condition to filter the 'sex' column for the specified gender using a placeholder for string values.", "Use the INTERSECT operator to find students who are both of the specified gender and participate in the specified sport, filtering the 'SportName' column in the 'SportsInfo' table with another placeholder for string values."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table identifies students who are of a specific gender and also participate in a particular sport. The placeholders in the WHERE clauses represent the gender and the sport's name.", "virtual_table": "SELECT StuID FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6026", "db_id": "game_1", "question": "What are the ids of all female students who play football?", "rationale": ["The query is identifying the relevant table, which is 'Student' and 'SportsInfo'.", "Select the column 'StuID' to display the unique identifier of the students.", "Add a condition to filter the 'sex' column for the specified gender using a placeholder for string values.", "Use the INTERSECT operator to find students who are also listed in the 'SportsInfo' table for a specific sport, using a placeholder for the sport's name."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table identifies students who are of a specific gender and also participate in a particular sport. The placeholders in the WHERE clauses represent the gender and the sport's name.", "virtual_table": "SELECT StuID FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6028", "db_id": "game_1", "question": "What are the ids of all male students who do not play football?", "rationale": ["The query starts by selecting the 'StuID' from the 'Student' table.", "It applies a filter to include only those students whose 'Sex' matches the specified placeholder for gender.", "The EXCEPT clause is used to exclude students who are involved in a specific sport, identified by the 'SportName' placeholder from the 'SportsInfo' table."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "description": "This virtual table identifies students from the 'Student' table who are of a specific gender and are not participating in a specified sport. The placeholders in the WHERE clause represent the gender and the sport's name.", "virtual_table": "SELECT StuID FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6060", "db_id": "customers_and_addresses", "question": "Find the average order quantity per order.", "rationale": ["The query identifies the relevant table, which is 'Order_Items'.", "It selects the average of the 'order_quantity' column to determine the typical quantity of products ordered."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "description": "This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.", "virtual_table": "SELECT avg(order_quantity) FROM order_items"}
{"sample_id": "train.6071", "db_id": "customers_and_addresses", "question": "What are the details of all products?", "rationale": ["The query is identifying the relevant table, which is 'Products'.", "Select the column to display, 'product_details'.", "Use DISTINCT to ensure that only unique product specifications are returned."], "gold_sql": "SELECT DISTINCT product_details FROM products", "source_tables": ["products"], "description": "The virtual table provides a unique list of product specifications from the 'Products' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be added later.", "virtual_table": "SELECT DISTINCT product_details FROM products"}
{"sample_id": "train.6075", "db_id": "customers_and_addresses", "question": "Find the detail of products whose detail contains the word \"Latte\" or the word \"Americano\"", "rationale": ["The query identifies the relevant table, which is 'Products'.", "Select the column to display, 'product_details'.", "Add a condition to filter the 'product_details' column for specified patterns using placeholders for string values."], "gold_sql": "SELECT product_details FROM products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'", "source_tables": ["products"], "description": "This virtual table retrieves the product details from the 'Products' table that match specific criteria. The placeholders in the WHERE clause represent the patterns to search for in the product details.", "virtual_table": "SELECT product_details FROM products WHERE product_details LIKE [PLACEHOLDER-TYPE:STRING] OR product_details LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["The query identifies the relevant tables: 'Customers', 'Customer_Addresses', and 'Addresses'.", "It selects the 'city' column from the 'Addresses' table.", "The query joins the 'Customers' table with 'Customer_Addresses' on 'customer_id' and then joins 'Customer_Addresses' with 'Addresses' on 'address_id'.", "The results are grouped by 'city' to aggregate the number of customers in each city.", "The results are ordered by the count of customers in descending order, and a limit is applied to restrict the number of cities returned using a placeholder for numeric values."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "description": "This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified numeric value.", "virtual_table": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6086", "db_id": "customers_and_addresses", "question": "Find the city where the most customers live.", "rationale": ["The query identifies the relevant tables: 'Customers', 'Customer_Addresses', and 'Addresses'.", "It selects the 'city' column from the 'Addresses' table.", "The JOIN operations link customers to their addresses through the 'Customer_Addresses' table.", "The results are grouped by 'city' to aggregate customer counts.", "The results are ordered by the count of customers in each city in descending order.", "A limit is applied to restrict the number of cities returned based on a placeholder for numeric values."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "description": "This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified numeric value.", "virtual_table": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6097", "db_id": "customers_and_addresses", "question": "Which contact channel has been used by the customer with name \"Tillman Ernser\"?", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It selects distinct values from the 'channel_code' column to avoid duplicates.", "The JOIN operation links the two tables using the 'customer_id' to ensure that the contact channels correspond to the correct customer.", "A condition is added to filter the results based on the specified customer's name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.", "virtual_table": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It selects the maximum value of 'active_to_date' from 'Customer_Contact_Channels' to find the most recent deactivation date.", "A JOIN operation is performed on 'customer_id' to link the two tables based on the customer.", "A condition is added to filter the results based on the specified customer's name using a placeholder for string values."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table retrieves the most recent deactivation date of a contact channel for a specific customer from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the customer's name.", "virtual_table": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["The query identifies the relevant table, which is 'Customer_Contact_Channels'.", "It calculates the average duration by subtracting 'active_from_date' from 'active_to_date'.", "The result is aggregated using the AVG function to provide the average duration of active contact channels."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "description": "This virtual table calculates the average duration that contact channels remain active for customers in the 'Customer_Contact_Channels' table. The placeholder in the SELECT clause represents the calculation of the difference between the active dates.", "virtual_table": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels"}
{"sample_id": "train.6103", "db_id": "customers_and_addresses", "question": "What is the channel code and contact number of the customer contact channel that was active for the longest time?", "rationale": ["The query identifies the relevant table, which is 'Customer_Contact_Channels'.", "It selects the columns 'channel_code' and 'contact_number' to display.", "The condition filters the records based on the difference between 'active_to_date' and 'active_from_date', ensuring we only get the most recently active contact channel.", "The subquery retrieves the maximum duration of activity, and the placeholder allows the user to specify how many records to limit the results to."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "description": "This virtual table provides the channel codes and associated contact numbers from the 'Customer_Contact_Channels' table for the most recently active contact channel based on the duration of activity. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.", "virtual_table": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.6108", "db_id": "customers_and_addresses", "question": "Find the name of the customer who made the order of the largest amount of goods.", "rationale": ["The query identifies the relevant tables: 'Customers', 'Customer_Orders', and 'Order_Items'.", "It selects the 'customer_name' from the 'Customers' table.", "The JOIN operations link customers to their orders and the items in those orders.", "The WHERE clause filters the results to only include customers whose order quantity matches the maximum order quantity found in the 'Order_Items' table."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)", "source_tables": ["customer_orders", "customers", "order_items"], "description": "This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.", "virtual_table": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)"}
{"sample_id": "train.6123", "db_id": "customers_and_addresses", "question": "What is the total number of products that are in orders with status \"Cancelled\"?", "rationale": ["The query identifies the relevant tables, which are 'Customer_Orders' and 'Order_Items'.", "It uses a JOIN operation to link 'Customer_Orders' with 'Order_Items' based on the 'order_id'.", "The SUM function is applied to the 'order_quantity' column from 'Order_Items' to calculate the total quantity ordered.", "A condition is added to filter the results based on the 'order_status' column from 'Customer_Orders', using a placeholder for string values."], "gold_sql": "SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_status  =  'Cancelled'", "source_tables": ["customer_orders", "order_items"], "description": "This virtual table calculates the total quantity of products ordered from the 'Customer_Orders' table, filtered by a specific order status. The placeholder in the WHERE clause represents the order status to be specified by the user.", "virtual_table": "SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_status  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6130", "db_id": "customers_and_addresses", "question": "What is the most frequently ordered product? Tell me the detail of the product", "rationale": ["The query identifies the relevant tables, 'Order_Items' and 'Products'.", "It selects the 'product_details' from the 'Products' table.", "The JOIN operation links 'Order_Items' to 'Products' using the 'product_id'.", "The results are grouped by 'product_id' to aggregate the data.", "The ORDER BY clause sorts the results based on the count of orders in descending order.", "The LIMIT clause uses a placeholder to specify how many product details to return."], "gold_sql": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "order_items"], "description": "This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to aggregate the product details, grouping by product ID and ordering the results by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.", "virtual_table": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["The query identifies the relevant tables, 'Order_Items' and 'Products'.", "It selects the 'product_details' and 'product_id' from the 'Products' table.", "A JOIN operation is performed between 'Order_Items' and 'Products' on the 'product_id' to link the ordered items with their details.", "The results are grouped by 'product_id' to aggregate the order quantities for each product.", "The results are ordered by the sum of 'order_quantity' to show the most ordered products first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "description": "This virtual table provides a summary of product details and their identifiers from the 'Products' table, based on the quantities ordered from the 'Order_Items' table. The results are grouped by product ID and ordered by the total quantity ordered, with a limit specified by a placeholder for numeric values.", "virtual_table": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6132", "db_id": "customers_and_addresses", "question": "What are the name and ID of the product bought the most.", "rationale": ["The query identifies the relevant tables, 'Order_Items' and 'Products'.", "It selects the 'product_details' and 'product_id' from the 'Products' table.", "A JOIN operation is performed between 'Order_Items' and 'Products' on the 'product_id' to link the ordered items with their details.", "The results are grouped by 'product_id' to aggregate the order quantities for each product.", "The results are ordered by the sum of 'order_quantity' to show the most ordered products first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "description": "This virtual table provides a summary of product details and their identifiers from the 'Products' table, based on the quantities ordered from the 'Order_Items' table. The results are grouped by product ID and ordered by the total quantity ordered, with a limit specified by a placeholder for numeric values.", "virtual_table": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects the 'address_content' column to display the detailed description of the addresses.", "The query includes two conditions to filter the results based on the specified city and state, using placeholders for string values.", "The UNION operator is used to combine results from two identical queries, allowing for flexibility in retrieving addresses from different entries that match the criteria."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "description": "This virtual table retrieves the detailed address content from the 'Addresses' table for specific cities and states, allowing for the combination of results from two different queries based on the same criteria. The placeholders in the WHERE clauses represent the city and state names.", "virtual_table": "SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6155", "db_id": "music_4", "question": "What are the category of music festivals with result \"Awarded\"?", "rationale": ["The query identifies the relevant table, which is 'music_festival'.", "Select the column to display, 'Category'.", "Add a condition to filter the 'RESULT' column for the specified result using a placeholder for string values."], "gold_sql": "SELECT Category FROM music_festival WHERE RESULT  =  'Awarded'", "source_tables": ["music_festival"], "description": "This virtual table provides the categories of awards or recognitions from the 'music_festival' table based on a specific result. The placeholder in the WHERE clause represents the outcome of the festival participation.", "virtual_table": "SELECT Category FROM music_festival WHERE RESULT  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6167", "db_id": "music_4", "question": "Please show the songs that have result \"nominated\" at music festivals.", "rationale": ["The query identifies the relevant tables, which are 'music_festival' and 'volume'.", "It selects the 'Song' column from the 'volume' table, which is linked to the music festival results.", "A JOIN operation is performed between 'music_festival' and 'volume' on the 'Volume' and 'Volume_ID' columns to connect the data.", "A condition is added to filter the results based on the 'Result' column from the 'music_festival' table using a placeholder for string values."], "gold_sql": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  'Nominated'", "source_tables": ["music_festival", "volume"], "description": "This virtual table describes the songs associated with music festivals where the outcome was a specific result. The query joins the 'music_festival' and 'volume' tables based on the volume identifier, and filters the results based on the specified outcome using a placeholder for string values.", "virtual_table": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6180", "db_id": "music_4", "question": "Return the famous release date for the oldest artist.", "rationale": ["The query identifies the relevant table, which is 'artist'.", "Select the column to display, 'Famous_Release_date'.", "Order the results by the 'Age' column in descending order to show the oldest artists first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1", "source_tables": ["artist"], "description": "This virtual table provides the release dates of the most recognized songs by artists from the 'artist' table, ordered by the age of the artists in descending order. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6185", "db_id": "music_4", "question": "Please show the categories of the music festivals with count more than 1.", "rationale": ["The query identifies the relevant table, which is 'music_festival'.", "It selects the 'Category' column to display the different categories of awards.", "The GROUP BY clause is used to group the results by 'Category'.", "The HAVING clause filters the grouped results to include only those categories that have a count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*)  >  1", "source_tables": ["music_festival"], "description": "This virtual table summarizes the categories of awards or recognitions from the 'music_festival' table that have received more than a specified number of entries. The placeholder in the HAVING clause represents the minimum count of entries required to filter the categories.", "virtual_table": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6187", "db_id": "music_4", "question": "What is the song in the volume with the maximum weeks on top?", "rationale": ["The query identifies the relevant table, which is 'volume'.", "Select the 'Song' column to display the song identifiers.", "Order the results by 'Weeks_on_Top' in descending order to show the most successful songs first.", "Add a limit to the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "source_tables": ["volume"], "description": "This virtual table lists the songs from the 'volume' table, ordered by the number of weeks they stayed at the top, allowing users to specify a limit on the number of results returned. The placeholder in the LIMIT clause represents the maximum number of songs to display.", "virtual_table": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6195", "db_id": "music_4", "question": "What is the issue date of the volume with the minimum weeks on top?", "rationale": ["The query identifies the relevant table, which is 'volume'.", "Select the column to display, 'Issue_Date'.", "Order the results by 'Weeks_on_Top' in ascending order to show the earliest weeks at the top.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1", "source_tables": ["volume"], "description": "This virtual table provides a list of issue release dates from the 'volume' table, ordered by the number of weeks the associated song stayed at the top, allowing users to retrieve a specified number of results. The placeholder in the LIMIT clause represents the maximum number of issue dates to return.", "virtual_table": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["The query is identifying the relevant table, which is 'match'.", "Select the column to display, 'match_id'.", "Add a condition to filter the 'competition' column for the specified competition using a placeholder for string values."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "description": "This virtual table describes the unique identifiers of matches from the 'match' table that are part of a specific competition. The placeholder in the WHERE clause represents the competition's identifier.", "virtual_table": "SELECT match_id FROM MATCH WHERE competition = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6274", "db_id": "city_record", "question": "Which city has hosted the most events?", "rationale": ["The query identifies the relevant tables, 'city' and 'hosting_city'.", "It selects the 'city' from the 'city' table, using an alias for clarity.", "A JOIN operation is performed between 'city' and 'hosting_city' on the matching city identifiers to link hosted matches with their respective cities.", "The results are grouped by the host city to count the number of matches hosted in each city.", "The results are ordered in descending order based on the count of matches, allowing the most frequently hosting cities to appear first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for the user to specify the desired number."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "description": "This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["The query identifies the relevant tables, which are 'city' and 'temperature'.", "It selects the 'city' column from the 'city' table, aliased as T1.", "A JOIN operation is performed between 'city' and 'temperature' on the 'city_id' to combine data from both tables.", "The results are ordered by the average temperature in February from the 'temperature' table in descending order.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "description": "This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6287", "db_id": "city_record", "question": "In February, which city marks the highest temperature?", "rationale": ["The query identifies the relevant tables, which are 'city' and 'temperature'.", "It selects the 'city' column from the 'city' table, aliased as T1.", "A JOIN operation is performed between 'city' and 'temperature' on the 'city_id' to combine data from both tables.", "The results are ordered by the average temperature in February from the 'temperature' table in descending order.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "description": "This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["The query identifies the relevant tables, which are 'city' and 'temperature'.", "It selects the 'city' column from the 'city' table, aliased as T1.", "A JOIN operation is performed between 'city' (T1) and 'temperature' (T2) on the 'city_id' to combine data from both tables.", "The WHERE clause applies conditions to filter cities based on their average temperatures in March, July, and October using placeholders for the temperature values."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "description": "This virtual table lists the names of cities from the 'city' table that have an average temperature in March that is either lower than the average temperature in July or higher than the average temperature in October. The placeholders in the WHERE clause represent the temperature values for the respective months.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct"}
{"sample_id": "train.6289", "db_id": "city_record", "question": "Which cities' temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["The query identifies the relevant tables, which are 'city' and 'temperature'.", "It selects the 'city' column from the 'city' table, aliased as T1.", "A JOIN operation is performed between 'city' (T1) and 'temperature' (T2) on the 'city_id' to combine data from both tables.", "A WHERE clause is added to filter cities based on the temperature conditions for March, July, and October using placeholders for the temperature values."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "description": "This virtual table identifies cities from the 'city' table that have a specific temperature condition. It selects cities where the average temperature in March is either less than the average temperature in July or greater than the average temperature in October. The placeholders in the query represent the temperature values for the respective months.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct"}
{"sample_id": "train.6292", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in Dec and which have never been host cities.", "rationale": ["The query starts by selecting the 'city' from the 'city' table, aliased as T1.", "It joins the 'temperature' table, aliased as T2, on the 'city_id' to access temperature data.", "A condition is applied to filter cities where the average temperature in March is less than that in December.", "The EXCEPT clause is used to exclude cities that are found in the 'hosting_city' table, which indicates they have hosted a match. This is done by joining the 'city' table again, aliased as T3, with the 'hosting_city' table, aliased as T4, on the 'city_id' and 'host_city'."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table identifies cities that have a lower average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["The query starts by selecting the 'city' from the 'city' table, aliased as T1.", "It joins the 'temperature' table, aliased as T2, on the 'city_id' to access temperature data.", "A condition is applied to filter cities where the average temperature in March is less than that in December.", "The EXCEPT clause is used to exclude cities that are found in the 'hosting_city' table, which indicates they have hosted a match. This is done by joining the 'city' table again, aliased as T3, with the 'hosting_city' table, aliased as T4, on the 'city_id' and 'host_city'."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table identifies cities that have a lower average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6298", "db_id": "city_record", "question": "Please give me a list of cities whose regional population is over 8000000 or under 5000000.", "rationale": ["The query identifies the relevant table, which is 'city'.", "It selects the 'city' column to display the names of the cities.", "The first part of the query filters cities with a regional population greater than a specified number using a placeholder for numeric values.", "The second part of the query filters cities with a regional population less than another specified number using another placeholder for numeric values.", "The UNION operator combines the results of both queries to provide a comprehensive list of cities that meet either condition."], "gold_sql": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000", "source_tables": ["city"], "description": "This virtual table provides a list of cities from the 'city' table based on their regional population. It retrieves cities with a population greater than a specified number and also those with a population less than another specified number. The placeholders in the WHERE clauses represent the population thresholds for filtering the cities.", "virtual_table": "SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6313", "db_id": "e_government", "question": "What is the name of the party form that is most common?", "rationale": ["The query identifies the relevant tables, 'Forms' and 'Party_Forms'.", "It selects the 'form_name' from the 'Forms' table.", "A JOIN operation is performed between 'Forms' and 'Party_Forms' on the 'form_id' to link forms to parties.", "The results are grouped by 'form_id' to aggregate the counts of each form's usage.", "The results are ordered by the count of associations in descending order to prioritize the most frequently used forms.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["forms", "party_forms"], "description": "This virtual table provides a list of form names from the 'Forms' table that are associated with parties through the 'Party_Forms' table. The results are grouped by form ID and ordered by the count of associations in descending order, allowing users to see the most frequently used forms. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6329", "db_id": "e_government", "question": "What are the names of the services that have never been used?", "rationale": ["The query identifies the relevant table, which is 'Services'.", "It selects the 'service_name' column to display the names of the services.", "The EXCEPT clause is used to filter out service names that are linked to any bookings in the 'Party_Services' table by joining on 'service_id' to ensure only unbooked services are listed."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "description": "This virtual table lists the names of services from the 'Services' table that have not been booked by any party. The query uses an EXCEPT clause to exclude service names that are present in the 'Party_Services' table, indicating that those services have been booked.", "virtual_table": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects the 'town_city' column to retrieve the names of towns or cities.", "It also selects the 'state_province_county' column to retrieve the names of states, provinces, or counties.", "The UNION operator is used to combine the results from both columns, ensuring that the final output contains unique values."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "description": "This virtual table provides a combined list of town/city names and state/province/county names from the 'Addresses' table. The use of UNION allows for the retrieval of unique entries from both columns, ensuring that any duplicates are removed.", "virtual_table": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses"}
{"sample_id": "train.6342", "db_id": "e_government", "question": "Which state can address \"6862 Kaitlyn Knolls\" possibly be in?", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "Select the column to display, 'state_province_county'.", "Add a condition to filter the 'line_1_number_building' column using the LIKE operator with a placeholder for string values."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "description": "This virtual table retrieves the state, province, or county information from the 'Addresses' table based on a specific address line that matches a given pattern. The placeholder in the LIKE clause allows for flexible searching of address lines.", "virtual_table": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["The query identifies the relevant tables, which are 'Individuals' and 'Organization_Contact_Individuals'.", "It selects the 'individual_last_name' column from the 'Individuals' table.", "A JOIN operation is performed on the 'individual_id' to link individuals with their corresponding organization contacts.", "The DISTINCT keyword is used to ensure that only unique last names are included in the result."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "description": "This virtual table provides a list of unique last names of individuals who have contacted organizations. It combines data from the 'Individuals' table and the 'Organization_Contact_Individuals' table, ensuring that only distinct last names are returned.", "virtual_table": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id"}
{"sample_id": "train.6371", "db_id": "flight_company", "question": "What are the names and types of the companies that have ever operated a flight?", "rationale": ["The query identifies the relevant tables, which are 'operate_company' and 'flight'.", "It selects the columns 'name' and 'Type' from the 'operate_company' table, which represent the company's name and type.", "A JOIN operation is performed between 'operate_company' and 'flight' on the condition that the 'id' from 'operate_company' matches the 'company_id' in 'flight', linking the operating companies to their respective flights."], "gold_sql": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id", "source_tables": ["flight", "operate_company"], "description": "This virtual table provides the names and types of operating companies that are associated with flights. The data is retrieved by joining the 'operate_company' table with the 'flight' table based on the company identifier, allowing users to see which companies operate specific flights.", "virtual_table": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id"}
{"sample_id": "train.6375", "db_id": "flight_company", "question": "What is the id, name and IATA code of the airport that had most number of flights?", "rationale": ["The query identifies the relevant tables, 'airport' and 'flight', and establishes a join between them based on the airport identifier.", "It selects the columns 'id', 'name', and 'IATA' from the 'airport' table, which are relevant for identifying airports.", "The results are grouped by the flight identifier to aggregate the data based on the number of flights associated with each airport.", "The results are ordered in descending order based on the count of flights, allowing the most active airports to be listed first.", "A limit is applied to restrict the number of results returned, using a placeholder for the user to specify the desired number."], "gold_sql": "SELECT T1.id ,  T1.name ,  T1.IATA FROM airport AS T1 JOIN flight AS T2 ON T1.id  =  T2.airport_id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airport", "flight"], "description": "This virtual table provides a list of airport identifiers, names, and IATA codes from the 'airport' table, specifically for those airports that have been associated with flights. The results are grouped by flight identifiers to aggregate the data, ordered by the number of flights in descending order, and limited to a specified number of entries. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT T1.id ,  T1.name ,  T1.IATA FROM airport AS T1 JOIN flight AS T2 ON T1.id  =  T2.airport_id GROUP BY T2.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6381", "db_id": "flight_company", "question": "How many companies operates airlines in each airport?", "rationale": ["The query identifies the relevant tables: 'operate_company', 'flight', and 'airport'.", "It performs a JOIN operation to link the 'operate_company' table with the 'flight' table using the 'company_id'.", "Then, it joins the 'flight' table with the 'airport' table using the 'airport_id'.", "The SELECT statement retrieves the airport ID and counts the number of flights for each airport.", "Finally, it groups the results by the airport ID to provide a count of flights per airport."], "gold_sql": "SELECT T3.id ,  count(*) FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id JOIN airport AS T3 ON T2.airport_id  =  T3.id GROUP BY T3.id", "source_tables": ["airport", "flight", "operate_company"], "description": "This virtual table summarizes the number of flights operated by each company at different airports. It joins the 'operate_company', 'flight', and 'airport' tables to count the flights associated with each airport, identified by their unique IDs.", "virtual_table": "SELECT T3.id ,  count(*) FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id JOIN airport AS T3 ON T2.airport_id  =  T3.id GROUP BY T3.id"}
{"sample_id": "train.6517", "db_id": "wine_1", "question": "What is the name of the highest rated wine?", "rationale": ["The query identifies the relevant table, which is 'wine'.", "Select the column to display, 'Name', which represents the names of the wines.", "Order the results by the 'Score' column to prioritize higher-rated wines.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "description": "This virtual table lists the names of wines from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause indicates the maximum number of wine names to be returned.", "virtual_table": "SELECT Name FROM WINE ORDER BY Score LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6518", "db_id": "wine_1", "question": "Give the name of the wine with the highest score.", "rationale": ["The query identifies the relevant table, which is 'wine'.", "Select the column to display, 'Name'.", "Order the results by the 'Score' column to prioritize higher-rated wines.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "description": "This virtual table lists the names of wines from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause represents the maximum number of wine names to be displayed.", "virtual_table": "SELECT Name FROM WINE ORDER BY Score LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6520", "db_id": "wine_1", "question": "What is the winery at which the wine with the highest score was made?", "rationale": ["The query identifies the relevant table, which is 'wine'.", "Select the column to display, 'Winery'.", "Order the results by the 'Score' column to prioritize higher-rated wineries.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1", "source_tables": ["wine"], "description": "This virtual table lists the names of wineries from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause represents the maximum number of wineries to be displayed.", "virtual_table": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6533", "db_id": "wine_1", "question": "List the names of all distinct wines that are made of red color grape.", "rationale": ["The query identifies the relevant tables, which are 'grapes' and 'wine'.", "It uses a JOIN operation to connect the two tables based on the grape variety.", "The SELECT DISTINCT clause is used to ensure that only unique wine names are returned.", "A condition is added to filter the grape color using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red'", "source_tables": ["wine", "grapes"], "description": "This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.", "virtual_table": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6544", "db_id": "wine_1", "question": "Give the names and scores of wines made from white grapes.", "rationale": ["The query identifies the relevant tables, which are 'grapes' and 'wine'.", "It selects the columns to display, 'Name' and 'Score' from the 'wine' table.", "A join is performed between the 'grapes' and 'wine' tables on the 'Grape' column to link the grape varieties to their respective wines.", "A condition is added to filter the 'Color' column in the 'grapes' table for the specified color using a placeholder for string values."], "gold_sql": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White'", "source_tables": ["wine", "grapes"], "description": "This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.", "virtual_table": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6547", "db_id": "wine_1", "question": "Find the the grape whose white color grapes are used to produce wines with scores higher than 90.", "rationale": ["The query identifies the relevant tables, which are 'grapes' and 'wine'.", "It selects distinct grape varieties from the 'grapes' table.", "A JOIN operation is performed between 'grapes' and 'wine' on the grape variety to filter the results based on the specified conditions.", "The WHERE clause includes conditions to filter by grape color and wine score, using placeholders for the specific values."], "gold_sql": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White' AND T2.score  >  90", "source_tables": ["wine", "grapes"], "description": "This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.", "virtual_table": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.score  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6550", "db_id": "wine_1", "question": "What are the names of wines made from red grapes and with prices above 50?", "rationale": ["The query identifies the relevant tables, which are 'Grapes' and 'Wine'.", "It selects the 'Name' column from the 'Wine' table.", "A JOIN operation is performed between 'Grapes' and 'Wine' on the 'Grape' column to link the two tables.", "Conditions are added to filter the results based on the specified grape color and price using placeholders for string and numeric values."], "gold_sql": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red' AND T2.price  >  50", "source_tables": ["wine", "grapes"], "description": "This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.", "virtual_table": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6558", "db_id": "wine_1", "question": "What are the distinct names of wines with prices higher than any wine from John Anthony winery.", "rationale": ["The query identifies the relevant table, which is 'wine'.", "It selects distinct wine names from the 'wine' table.", "A subquery is used to find the minimum price of wines produced by a specified winery, using a placeholder for the winery's name."], "gold_sql": "SELECT DISTINCT Name FROM WINE WHERE Price  >  (SELECT min(Price) FROM wine WHERE Winery  =  'John Anthony')", "source_tables": ["wine"], "description": "This virtual table lists the distinct names of wines from the 'wine' table that are priced higher than the minimum price of wines produced by a specific winery. The placeholder in the subquery represents the name of the winery.", "virtual_table": "SELECT DISTINCT Name FROM WINE WHERE Price  >  (SELECT min(Price) FROM wine WHERE Winery  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.6566", "db_id": "wine_1", "question": "Give the color of the grape whose wine products have the highest average price?", "rationale": ["The query identifies the relevant tables, 'grapes' and 'wine'.", "It selects the 'Color' column from the 'grapes' table, aliased as T1.", "A JOIN operation is performed between 'grapes' and 'wine' on the 'Grape' column to link grape varieties with their corresponding wines.", "The results are grouped by the 'Grape' column from the 'wine' table to aggregate the data.", "The average price of the wines is calculated and used to order the results in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT 1", "source_tables": ["wine", "grapes"], "description": "This virtual table provides the colors of grape varieties from the 'grapes' table, which are associated with wines in the 'wine' table. The results are grouped by grape variety and ordered by the average price of the wines produced from each grape, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6588", "db_id": "wine_1", "question": "Which 3 wineries produce the most wines made from white grapes?", "rationale": ["The query identifies the relevant tables, which are 'grapes' and 'wine'.", "It selects the 'Winery' column from the 'wine' table.", "The join condition is established between 'grapes' and 'wine' on the grape variety.", "A filter is applied to the 'Color' column in the 'grapes' table using a placeholder for string values.", "The results are grouped by the 'Winery' to aggregate the data.", "The results are ordered by the count of wines produced, in descending order.", "A limit is applied to restrict the number of wineries returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  'White' GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3", "source_tables": ["wine", "grapes"], "description": "This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.", "virtual_table": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6597", "db_id": "wine_1", "question": "Find the county where produces the most number of wines with score higher than 90.", "rationale": ["The query identifies the relevant tables, 'appellations' and 'wine', and establishes a join condition based on the 'Appelation' column.", "It selects the 'County' from the 'appellations' table.", "A condition is added to filter wines based on their 'Score', using a placeholder for numeric values.", "The results are grouped by 'County' to aggregate the data, and ordered by the count of wines in descending order.", "Finally, a limit is applied to restrict the number of counties returned, using another placeholder for numeric values."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1", "source_tables": ["wine", "appellations"], "description": "This virtual table provides a list of counties where wines with a score above a specified threshold are produced. The placeholder in the WHERE clause represents the minimum score for filtering the wines, and the second placeholder limits the number of counties returned based on the count of wines produced in each county.", "virtual_table": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.County ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6626", "db_id": "driving_school", "question": "Show the detail of vehicle with id 1.", "rationale": ["The query identifies the relevant table, which is 'Vehicles'.", "Select the column to display, 'vehicle_details'.", "Add a condition to filter the 'vehicle_id' column for the specified vehicle using a placeholder for numeric values."], "gold_sql": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;", "source_tables": ["vehicles"], "description": "This virtual table provides details about vehicles from the 'Vehicles' table based on a specific vehicle identifier. The placeholder in the WHERE clause represents the unique identifier for the vehicle.", "virtual_table": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6650", "db_id": "driving_school", "question": "How many staff live in state Georgia?", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects a count of all entries in the table to determine how many addresses exist in the specified location.", "A condition is added to filter the results based on the 'state_province_county' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Addresses WHERE state_province_county = 'Georgia';", "source_tables": ["addresses"], "description": "This virtual table provides the count of addresses from the 'Addresses' table that are located in a specific state, province, or county. The placeholder in the WHERE clause represents the name of the state, province, or county being queried.", "virtual_table": "SELECT count(*) FROM Addresses WHERE state_province_county = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.6665", "db_id": "driving_school", "question": "What is the status code, phone number, and email address of the customer whose last name is Kohler or whose first name is Marina?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "Select the columns to display: 'customer_status_code', 'cell_mobile_phone_number', and 'email_address'.", "Add a condition to filter the 'first_name' and 'last_name' columns for the specified names using placeholders for string values."], "gold_sql": "SELECT customer_status_code ,  cell_mobile_phone_number ,  email_address FROM Customers WHERE first_name = 'Marina' OR last_name  =  'Kohler'", "source_tables": ["customers"], "description": "This virtual table provides the status code, mobile phone number, and email address of customers from the 'Customers' table who have a specific first name or last name. The placeholders in the WHERE clause represent the customer's first and last names.", "virtual_table": "SELECT customer_status_code ,  cell_mobile_phone_number ,  email_address FROM Customers WHERE first_name = [PLACEHOLDER-TYPE:STRING] OR last_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6676", "db_id": "driving_school", "question": "How many lessons taken by customer with first name as Rylan and last name as Goodwin were completed?", "rationale": ["The query identifies the relevant tables, 'Lessons' and 'Customers', that are needed to retrieve the count of lessons.", "It uses a JOIN operation to link the 'Lessons' table with the 'Customers' table based on the customer ID.", "The SELECT statement counts the total number of lessons for the specified customer.", "The WHERE clause filters the results based on the customer's first name, last name, and the lesson status code using placeholders for string values."], "gold_sql": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = 'Rylan' AND T2.last_name = 'Goodwin' AND T1.lesson_status_code = 'Completed';", "source_tables": ["lessons", "customers"], "description": "This virtual table provides the count of lessons associated with a specific customer identified by their first and last name. It filters the lessons based on the customer's name and the status of the lesson. The placeholders in the WHERE clause represent the customer's first name, last name, and the lesson status code.", "virtual_table": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = [PLACEHOLDER-TYPE:STRING] AND T2.last_name = [PLACEHOLDER-TYPE:STRING] AND T1.lesson_status_code = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.6688", "db_id": "driving_school", "question": "Which city does has most number of customers?", "rationale": ["The query identifies the relevant tables, 'Customers' and 'Addresses', and establishes a join between them using the customer_address_id and address_id.", "It selects the 'city' column from the 'Addresses' table.", "The results are grouped by 'city' to aggregate the customer counts per city.", "The results are ordered in descending order based on the count of customers in each city.", "A limit is applied to restrict the number of cities returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "customers"], "description": "This virtual table provides a list of cities where customers are located, derived from the 'Customers' and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.", "virtual_table": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.6711", "db_id": "driving_school", "question": "What are the last names that are used by customers and staff?", "rationale": ["The query is identifying the relevant tables, which are 'Customers' and 'Staff'.", "Select the column to display, 'last_name', from both tables.", "Use the INTERSECT operator to find common last names between the two tables."], "gold_sql": "SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff", "source_tables": ["staff", "customers"], "description": "This virtual table identifies the last names that are common between customers and staff members. The query uses the INTERSECT operator to find last names that appear in both the 'Customers' and 'Staff' tables.", "virtual_table": "SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff"}
{"sample_id": "train.6714", "db_id": "driving_school", "question": "What is the id and detail of the vehicle used in lessons for most of the times?", "rationale": ["The query identifies the relevant tables, which are 'Vehicles' and 'Lessons'.", "It selects the columns 'vehicle_id' and 'vehicle_details' from the 'Vehicles' table.", "A JOIN operation is performed between 'Vehicles' and 'Lessons' on the vehicle ID to link vehicles to the lessons they are used in.", "The results are grouped by 'vehicle_id' to aggregate the data based on each vehicle.", "The results are ordered by the count of lessons associated with each vehicle in descending order to show the most frequently used vehicles first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["lessons", "vehicles"], "description": "This virtual table provides a list of vehicle IDs and their corresponding details from the 'Vehicles' table, specifically for vehicles that have been used in lessons. The results are grouped by vehicle ID and ordered by the number of lessons associated with each vehicle in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the column to display, 'FacID'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "description": "This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.", "virtual_table": "SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6734", "db_id": "activity_1", "question": "What are the first name and last name of all the instructors?", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the columns to display, 'fname' and 'lname'.", "Add a condition to filter the 'Rank' column for the specified rank using a placeholder for string values."], "gold_sql": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  'Instructor'", "source_tables": ["faculty"], "description": "This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.", "virtual_table": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6737", "db_id": "activity_1", "question": "Which building has most faculty members?", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'building' column to display the names of the buildings.", "The results are grouped by 'building' to aggregate the data based on the building names.", "The query orders the results by the count of faculty members in each building in descending order to show the most populated buildings first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "description": "This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The results are ordered by the number of faculty members in each building in descending order, and the placeholder allows the user to specify the maximum number of buildings to return.", "virtual_table": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'sex' column and counts the number of occurrences for each gender.", "A condition is added to filter the results based on the specified 'rank' using a placeholder for string values.", "The results are grouped by 'sex' to provide a count for each gender category."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "description": "This virtual table summarizes the gender distribution of faculty members based on their academic rank. The placeholder in the WHERE clause represents the specific rank of faculty members being queried.", "virtual_table": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sex"}
{"sample_id": "train.6748", "db_id": "activity_1", "question": "How many male and female assistant professors do we have?", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'sex' column and counts the number of occurrences for each gender.", "A condition is added to filter the results based on the specified 'rank' using a placeholder for string values.", "The results are grouped by 'sex' to provide a count of faculty members for each gender within the specified rank."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "description": "This virtual table summarizes the gender distribution of faculty members based on their academic rank. The placeholder in the WHERE clause represents the specific rank of faculty members being queried.", "virtual_table": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sex"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the columns to display, 'fname' and 'lname' from the 'Faculty' table.", "A JOIN operation is performed between 'Faculty' and 'Student' on the advisor relationship.", "Conditions are added to filter the 'Student' table for the specified student's first and last names using placeholders for string values."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "description": "This virtual table describes the first names and last names of faculty members who are academic advisors to a specific student. The placeholders in the WHERE clause represent the first and last names of the student.", "virtual_table": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  [PLACEHOLDER-TYPE:STRING] AND T2.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["The query is identifying the relevant tables, which are 'Faculty' and 'Student'.", "A JOIN operation is performed to connect the 'Faculty' table with the 'Student' table based on the advisor relationship.", "The SELECT statement specifies that we want to retrieve the 'StuID' from the 'Student' table.", "A condition is added to filter faculty members based on their rank using a placeholder for string values."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "description": "This virtual table identifies the unique identifiers of students who are advised by faculty members of a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.", "virtual_table": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6752", "db_id": "activity_1", "question": "Which students have professors as their advisors? Find their student ids.", "rationale": ["The query is identifying the relevant tables, which are 'Faculty' and 'Student'.", "A JOIN operation is performed to connect the 'Faculty' table with the 'Student' table based on the advisor relationship.", "The SELECT statement specifies that we want to retrieve the 'StuID' from the 'Student' table.", "A condition is added to filter faculty members based on their rank using a placeholder for string values."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "description": "This virtual table identifies the unique identifiers of students who are advised by faculty members of a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.", "virtual_table": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the columns to display, 'fname' and 'lname' from the 'Student' table.", "A JOIN operation is performed between 'Faculty' and 'Student' on the advisor relationship.", "Conditions are added to filter the faculty member by their first and last names using placeholders for string values."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "description": "This virtual table describes the first and last names of students who are advised by a specific faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member.", "virtual_table": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6756", "db_id": "activity_1", "question": "What are the faculty id and the number of students each faculty has?", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the 'FacID' from the 'Faculty' table and counts the number of students associated with each faculty member.", "The JOIN operation links the 'Faculty' table with the 'Student' table based on the advisor relationship, where 'FacID' matches the 'advisor' field in the 'Student' table.", "The GROUP BY clause groups the results by 'FacID' to aggregate the count of students for each faculty member."], "gold_sql": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID", "source_tables": ["faculty", "student"], "description": "This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.", "virtual_table": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID"}
{"sample_id": "train.6758", "db_id": "activity_1", "question": "How many students are advised by each rank of faculty? List the rank and the number of students.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the 'rank' column from the 'Faculty' table and counts the number of students associated with each faculty member.", "The join condition links faculty members to their students through the advisor relationship.", "The results are grouped by the faculty rank to provide a count of students for each rank."], "gold_sql": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank", "source_tables": ["faculty", "student"], "description": "This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.", "virtual_table": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank"}
{"sample_id": "train.6761", "db_id": "activity_1", "question": "Show the ids for all the faculty members who have at least 2 students.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the 'FacID' from the 'Faculty' table, using an alias for clarity.", "A JOIN operation is performed between 'Faculty' and 'Student' on the advisor relationship, where 'FacID' matches the 'advisor' field in the 'Student' table.", "The results are grouped by 'FacID' to aggregate the number of students each faculty member advises.", "The HAVING clause filters the results to include only those faculty members who have advised a specified minimum number of students, using a placeholder for numeric values."], "gold_sql": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  2", "source_tables": ["faculty", "student"], "description": "This virtual table identifies faculty members who serve as advisors to students. It retrieves the unique identifiers of faculty members from the 'Faculty' table, joining it with the 'Student' table based on the advisor relationship. The results are grouped by faculty ID, and only those faculty members who have advised a specified minimum number of students are included, as indicated by the placeholder in the HAVING clause.", "virtual_table": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6777", "db_id": "activity_1", "question": "Show the names of all the activities Mark Giuliano participates in.", "rationale": ["The query identifies the relevant tables: 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "It selects the 'activity_name' from the 'Activity' table.", "The query joins the 'Faculty' table with 'Faculty_Participates_in' on the faculty ID, and then joins 'Faculty_Participates_in' with 'Activity' on the activity ID.", "Conditions are added to filter the results based on the specified first and last names of the faculty member using placeholders for string values."], "gold_sql": "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  'Mark' AND T1.lname  =  'Giuliano'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.", "virtual_table": "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6779", "db_id": "activity_1", "question": "Show the first and last name of all the faculty members who participated in some activity, together with the number of activities they participated in.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Faculty_Participates_in'.", "It selects the first name and last name of faculty members from the 'Faculty' table.", "It counts the number of activities each faculty member participates in by using the COUNT function.", "The JOIN operation links the 'Faculty' table with the 'Faculty_Participates_in' table based on the faculty identifier.", "The results are grouped by the unique identifier of each faculty member to aggregate their activity participation."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "description": "This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.", "virtual_table": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["The query is identifying the relevant tables, which are 'Participates_in' and 'Student'.", "The INTERSECT operator is used to find common student IDs from both tables.", "The first SELECT statement retrieves student IDs from the 'Participates_in' table.", "The second SELECT statement retrieves student IDs from the 'Student' table, applying a condition to filter students based on their age using a placeholder for numeric values."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "description": "This virtual table identifies students who participate in activities and are younger than a specified age. The placeholder in the WHERE clause represents the age limit for filtering the students.", "virtual_table": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6797", "db_id": "activity_1", "question": "Find the first names of professors who are not playing Canoeing or Kayaking.", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'lname' column to display the last names of faculty members.", "A condition is added to filter faculty by their 'rank' using a placeholder for string values.", "The EXCEPT clause is used to exclude faculty members who participate in activities, which involves joining the 'Faculty', 'Faculty_Participates_in', and 'Activity' tables.", "The join condition links faculty members to their activities, and the WHERE clause filters based on the activity names using placeholders for string values."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they are not involved in.", "virtual_table": "SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'lname' column to display the last names of faculty members.", "A condition is added to filter faculty by their 'rank' using a placeholder for string values.", "The EXCEPT clause is used to exclude faculty members who participate in activities, which is determined by joining the 'Faculty' table with 'Faculty_Participates_in' and 'Activity' tables.", "The activities to be excluded are specified using placeholders for their names."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they may or may not be involved in.", "virtual_table": "SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6799", "db_id": "activity_1", "question": "Find the first names of the faculty members who participate in Canoeing and Kayaking.", "rationale": ["The query identifies the relevant tables, which are 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "It selects the 'lname' column from the 'Faculty' table.", "The JOIN operations link faculty members to the activities they participate in through the 'Faculty_Participates_in' table.", "The WHERE clause filters the results based on the specified activity name using a placeholder for string values.", "The INTERSECT operation ensures that only faculty members participating in the same activity are included in the final result."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to ensure that only faculty members who are involved in the same activity are selected. The placeholders in the WHERE clause represent the name of the activity.", "virtual_table": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["The query is identifying the relevant tables, which are 'Participates_in' and 'Activity'.", "It selects the 'stuid' column from the 'Participates_in' table.", "The query uses a JOIN to connect 'Participates_in' with 'Activity' based on the 'actid'.", "It filters the results based on the 'activity_name' for the first activity using a placeholder.", "The INTERSECT operator is used to find students who participate in both activities, requiring a second selection with a similar structure and another placeholder for the second activity's name."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "description": "This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities being compared.", "virtual_table": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6825", "db_id": "flight_4", "question": "Find the number of routes operated by American Airlines.", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'routes'.", "It uses a JOIN operation to connect the two tables based on the airline ID ('alid').", "The SELECT statement counts the number of routes associated with the specified airline name, using a placeholder for the airline's name in the WHERE clause."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "description": "This virtual table provides the count of routes operated by a specific airline from the 'airlines' and 'routes' tables. The placeholder in the WHERE clause represents the name of the airline for which the route count is being queried.", "virtual_table": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6826", "db_id": "flight_4", "question": "How many routes does American Airlines operate?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'routes'.", "It uses a JOIN operation to connect the two tables based on the airline ID ('alid').", "The SELECT statement counts the number of routes associated with the specified airline name, using a placeholder for the airline's name in the WHERE clause."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "description": "This virtual table provides the count of routes operated by a specific airline from the 'airlines' and 'routes' tables. The placeholder in the WHERE clause represents the name of the airline for which the route count is being queried.", "virtual_table": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6831", "db_id": "flight_4", "question": "Find the name, city, and country of the airport that has the highest latitude.", "rationale": ["The query identifies the relevant table, which is 'airports'.", "Select the columns to display: 'name', 'city', and 'country'.", "Add an ORDER BY clause to sort the results by the 'elevation' column in descending order.", "Include a LIMIT clause with a placeholder to specify the maximum number of records to return."], "gold_sql": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT 1", "source_tables": ["airports"], "description": "This virtual table provides a list of airport names, their respective cities, and countries from the 'airports' table, sorted by elevation in descending order. The placeholder in the LIMIT clause represents the maximum number of records to return.", "virtual_table": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6834", "db_id": "flight_4", "question": "What is the name and city of the airport that the most routes end at?", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the 'name' and 'city' columns from the 'airports' table (aliased as T1) and the 'dst_apid' from the 'routes' table (aliased as T2).", "A JOIN operation is performed on the 'apid' of the 'airports' table and the 'dst_apid' of the 'routes' table to link the destination airports with their routes.", "The results are grouped by 'dst_apid' to aggregate the data based on destination airport IDs.", "The results are ordered by the count of routes to each destination in descending order, and a limit is applied to restrict the number of results based on a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.", "virtual_table": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6838", "db_id": "flight_4", "question": "What is the name and city of the airport from most of the routes start?", "rationale": ["The query identifies the relevant tables, 'airports' and 'routes'.", "It selects the 'name' and 'city' columns from the 'airports' table and the 'src_apid' from the 'routes' table.", "A JOIN operation is performed on the 'apid' of 'airports' and 'src_apid' of 'routes' to combine relevant data.", "The results are grouped by 'src_apid' to aggregate the data based on source airports.", "The results are ordered by the count of routes in descending order to show the most active source airports first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "This virtual table provides a list of airport names and their corresponding cities from the 'airports' table, along with the source airport IDs from the 'routes' table. The results are grouped by source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.", "virtual_table": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6841", "db_id": "flight_4", "question": "Which countries has the most number of airlines?", "rationale": ["The query identifies the relevant table, which is 'airlines'.", "It selects the 'country' column to display the countries where airlines are based.", "The results are grouped by 'country' to aggregate the data.", "The query orders the results by the count of airlines in each country in descending order.", "A limit is applied to restrict the number of countries returned, using a placeholder for numeric values."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "description": "This virtual table provides a list of countries where airlines are based, grouped by country and ordered by the number of airlines in each country. The placeholder in the LIMIT clause allows the user to specify the maximum number of countries to return.", "virtual_table": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6842", "db_id": "flight_4", "question": "What is the name of the country with the most number of home airlines?", "rationale": ["The query identifies the relevant table, which is 'airlines'.", "It selects the 'country' column to display the countries where airlines are based.", "The GROUP BY clause is used to group the results by 'country'.", "The ORDER BY clause sorts the countries based on the count of airlines in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many countries to return."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "description": "This virtual table provides a list of countries where airlines are based, grouped by country and ordered by the number of airlines in each country. The placeholder in the LIMIT clause allows the user to specify the maximum number of countries to return.", "virtual_table": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6858", "db_id": "flight_4", "question": "What are the cities that have more than 2 airports sorted by number of airports?", "rationale": ["The query identifies the relevant table, which is 'airports'.", "It selects the 'city' column to display the names of cities.", "The GROUP BY clause is used to group the results by city.", "The HAVING clause filters the groups to include only those cities that have a count of airports greater than a specified number, using a placeholder for numeric values.", "Finally, the results are ordered by the count of airports in ascending order."], "gold_sql": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)", "source_tables": ["airports"], "description": "This virtual table provides a list of cities that have more than a specified number of airports. The placeholder in the HAVING clause represents the minimum count of airports required for a city to be included in the results.", "virtual_table": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER] ORDER BY count(*)"}
{"sample_id": "train.6862", "db_id": "flight_4", "question": "For each  airport name, how many routes start at that airport, ordered from most to least?", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the count of routes and the name of the airport from the 'airports' table, using an alias for clarity.", "A JOIN operation is performed between 'airports' and 'routes' on the source airport ID to link the two tables.", "The results are grouped by the airport name to aggregate the count of routes for each airport.", "Finally, the results are ordered in descending order based on the count of routes to show the most active airports first."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC", "source_tables": ["airports", "routes"], "description": "This virtual table provides a count of routes originating from each airport, along with the airport names. The data is aggregated by airport name and sorted in descending order based on the number of routes.", "virtual_table": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC"}
{"sample_id": "train.6867", "db_id": "flight_4", "question": "For each country and airline name, how many routes are there?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'routes'.", "It selects the 'country' and 'name' columns from the 'airlines' table and counts the number of routes associated with each airline.", "The JOIN operation links the 'airlines' table with the 'routes' table based on the airline ID, ensuring that only routes operated by the airlines are counted.", "The GROUP BY clause is used to aggregate the results by 'country' and 'name', providing a count of routes for each airline in each country."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "description": "This virtual table summarizes the number of routes operated by each airline, grouped by the country and name of the airline. The placeholders in the query allow for dynamic filtering based on the airline's country and name.", "virtual_table": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name"}
{"sample_id": "train.6868", "db_id": "flight_4", "question": "What is the total number of routes for each country and airline in that country?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'routes'.", "It selects the 'country' and 'name' columns from the 'airlines' table and counts the number of routes associated with each airline.", "The JOIN operation links the 'airlines' table with the 'routes' table based on the airline ID, ensuring that only routes operated by the airlines are counted.", "The GROUP BY clause is used to aggregate the results by 'country' and 'name', providing a count of routes for each airline in each country."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "description": "This virtual table summarizes the number of routes operated by each airline, grouped by the country and name of the airline. The placeholders in the query allow for dynamic filtering based on the airline's country and name.", "virtual_table": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name"}
{"sample_id": "train.6873", "db_id": "flight_4", "question": "Find the number of routes that have destination John F Kennedy International Airport.", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It uses a JOIN operation to connect the two tables based on the destination airport ID.", "The SELECT statement counts the number of routes that match the specified destination airport name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'", "source_tables": ["airports", "routes"], "description": "This virtual table provides the count of routes that lead to a specific destination airport from the 'airports' and 'routes' tables. The placeholder in the WHERE clause represents the name of the destination airport.", "virtual_table": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6880", "db_id": "flight_4", "question": "What is the name of the airline with the most routes?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'routes'.", "It selects the 'name' column from the 'airlines' table, aliased as T1.", "A JOIN operation is performed between 'airlines' and 'routes' on the airline ID (alid) to associate airlines with their routes.", "The results are grouped by the airline name to aggregate the count of routes for each airline.", "The results are ordered in descending order based on the count of routes, allowing us to see which airlines operate the most routes.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["routes", "airlines"], "description": "This virtual table provides a list of airline names from the 'airlines' table that are associated with routes in the 'routes' table. The results are grouped by airline name and ordered by the number of routes each airline operates, with a limit on the number of results returned as specified by the placeholder.", "virtual_table": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6883", "db_id": "flight_4", "question": "Find the busiest destination airport that runs most number of routes in China.", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the 'name' column from the 'airports' table, aliased as T1.", "The query joins the 'airports' table with the 'routes' table on the destination airport ID.", "A condition is added to filter the results based on the specified country using a placeholder for string values.", "The results are grouped by airport name to aggregate the data.", "The results are ordered by the count of routes in descending order to show the most popular destinations first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "The virtual table describes the names of airports located in a specific country that serve as destinations for routes. The query joins the 'airports' table with the 'routes' table to filter the airports based on the specified country. The results are grouped by airport name and ordered by the number of routes to each airport in descending order, with a limit on the number of results returned.", "virtual_table": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6884", "db_id": "flight_4", "question": "What is the name of the airport that is the destination of the most number of routes that start in China?", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'routes'.", "It selects the 'name' column from the 'airports' table, aliased as T1.", "The query joins the 'airports' table with the 'routes' table on the destination airport ID to filter the results.", "A condition is added to filter the airports based on the specified country using a placeholder for string values.", "The results are grouped by airport name to aggregate the data.", "The results are ordered by the count of routes in descending order to show the most popular destinations first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "description": "The virtual table describes the names of airports located in a specific country that serve as destinations for routes. The query joins the 'airports' table with the 'routes' table to filter and group the results based on the country of the airports. The placeholders in the WHERE clause represent the country name, and the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6980", "db_id": "culture_company", "question": "Show all publishers which do not have a book in 1989.", "rationale": ["The query identifies the relevant table, which is 'book_club'.", "It selects the 'publisher' column to display.", "The EXCEPT clause is used to exclude publishers from the results based on a specific year, using a placeholder for numeric values."], "gold_sql": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  1989", "source_tables": ["book_club"], "description": "This virtual table lists the publishers of books discussed in the 'book_club' table, excluding those publishers whose books were discussed in a specific year. The placeholder in the WHERE clause represents the year to filter out the publishers.", "virtual_table": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6990", "db_id": "culture_company", "question": "Show all director names who have a movie in the year 1999 or 2000.", "rationale": ["The query identifies the relevant table, which is 'movie'.", "Select the column to display, 'director'.", "Add a condition to filter the 'Year' column for the specified years using placeholders for numeric values."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "description": "The virtual table describes the directors of movies released in specific years from the 'movie' table. The placeholders in the WHERE clause represent the years of interest.", "virtual_table": "SELECT director FROM movie WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] OR YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6991", "db_id": "culture_company", "question": "Which directors had a movie in either 1999 or 2000?", "rationale": ["The query identifies the relevant table, which is 'movie'.", "Select the column to display, 'director'.", "Add a condition to filter the 'Year' column for the specified years using placeholders for numeric values."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "description": "This virtual table provides the names of directors from the 'movie' table for movies released in specific years. The placeholders in the WHERE clause represent the years of interest.", "virtual_table": "SELECT director FROM movie WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] OR YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6996", "db_id": "culture_company", "question": "Show the movie titles and book titles for all companies in China.", "rationale": ["The query identifies the relevant tables: 'movie', 'culture_company', and 'book_club'.", "It selects the 'title' from the 'movie' table and 'book_title' from the 'book_club' table.", "The JOIN operations link the 'movie' table to the 'culture_company' table using 'movie_id', and the 'culture_company' table to the 'book_club' table using 'book_club_id'.", "A condition is added to filter results based on the 'incorporated_in' year from the 'culture_company' table using a placeholder for string values."], "gold_sql": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  'China'", "source_tables": ["culture_company", "movie", "book_club"], "description": "This virtual table describes the titles of movies and the corresponding book titles discussed in book clubs, filtered by the year a cultural company was incorporated. The placeholders in the WHERE clause represent the year of incorporation.", "virtual_table": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'Model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the condition that 'MakeId' from 'car_names' matches 'Id' from 'cars_data'.", "The results are ordered by the 'horsepower' column from 'cars_data' in ascending order.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.103", "db_id": "car_1", "question": "Which distinct car models are the produced after 1980?", "rationale": ["The query identifies the relevant tables: 'model_list', 'car_names', and 'cars_data'.", "It selects distinct car models from the 'model_list' table.", "The JOIN operations link the 'model_list' to 'car_names' based on the model name, and then to 'cars_data' using the MakeId.", "A condition is added to filter the results to include only those models manufactured after a specified year, using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "description": "This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.", "virtual_table": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.106", "db_id": "car_1", "question": "What is the name of each continent and how many car makers are there in each one?", "rationale": ["The query identifies the relevant tables: 'continents', 'countries', and 'car_makers'.", "It selects the 'Continent' from the 'continents' table and counts the number of entries.", "The JOIN operations link the 'countries' table to the 'continents' table using the continent identifier, and the 'car_makers' table to the 'countries' table using the country identifier.", "The GROUP BY clause is used to aggregate the count of car makers for each continent."], "gold_sql": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;", "source_tables": ["countries", "car_makers", "continents"], "description": "This virtual table provides a count of car makers grouped by continent. It joins the 'continents' table with the 'countries' table to associate each country with its continent, and then further joins with the 'car_makers' table to count the number of car makers from each continent. The placeholder in the SELECT statement represents the continent's name.", "virtual_table": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["The query identifies the relevant tables, which are 'cars_data' and 'car_names'.", "It selects the 'Accelerate' column from the 'cars_data' table.", "A JOIN operation is performed to link 'cars_data' with 'car_names' based on the matching 'Id' and 'MakeId'.", "A condition is added to filter the results based on the specified car make using a placeholder for string values."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "description": "The virtual table describes the acceleration times of cars from the 'cars_data' table, filtered by a specific car make from the 'car_names' table. The placeholder in the WHERE clause represents the name of the car make.", "virtual_table": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["The query identifies the relevant tables, which are 'car_makers' and 'countries'.", "It uses a JOIN operation to connect these tables based on the country identifier.", "The SELECT statement counts the number of car makers that match the specified country name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "description": "This virtual table provides the count of car makers based in a specific country. It joins the 'car_makers' table with the 'countries' table using the country identifier, and filters the results based on the specified country name.", "virtual_table": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.114", "db_id": "car_1", "question": "What is the number of makers of care in France?", "rationale": ["The query identifies the relevant tables, which are 'car_makers' and 'countries'.", "It uses a JOIN operation to combine these tables based on the country identifier.", "The SELECT statement counts the number of car makers that match the specified country name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "description": "This virtual table provides the count of car makers based in a specific country. It joins the 'car_makers' table with the 'countries' table using the country identifier, and filters the results based on the specified country name.", "virtual_table": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.115", "db_id": "car_1", "question": "How many car models are produced in the usa?", "rationale": ["The query identifies the relevant tables: 'model_list', 'car_makers', and 'countries'.", "It uses JOIN operations to connect these tables based on their foreign key relationships: 'Maker' in 'model_list' with 'Id' in 'car_makers', and 'Country' in 'car_makers' with 'CountryId' in 'countries'.", "The SELECT statement counts the number of car models that meet the specified condition.", "A condition is added to filter the results based on the 'CountryName' column in the 'countries' table using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "description": "This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.", "virtual_table": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["The query identifies the relevant tables: 'countries', 'continents', and 'car_makers'.", "It selects the 'CountryName' from the 'countries' table.", "The JOIN operation connects 'countries' with 'continents' based on the continent identifier, allowing filtering by continent.", "Another JOIN connects 'countries' with 'car_makers' to ensure that only countries with car makers are included.", "The GROUP BY clause groups the results by 'CountryName' to aggregate the data.", "The HAVING clause filters the grouped results to include only those countries that have a count of car makers greater than or equal to a specified number."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "description": "This virtual table lists the names of countries from the 'countries' table that belong to a specific continent. It joins the 'continents' table to filter countries by continent and the 'car_makers' table to ensure that the countries have associated car makers. The placeholders in the WHERE clause represent the continent's name and the minimum count of car makers per country.", "virtual_table": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.CountryName HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data', and uses a JOIN to combine them based on the relationship between 'MakeId' and 'Id'.", "It selects the 'Make' from 'car_names' and 'horsepower' from 'cars_data'.", "A condition is added to filter the results based on the number of cylinders using a placeholder for numeric values.", "The results are ordered by 'horsepower' in descending order to show the most powerful cars first.", "A limit is applied to restrict the number of results returned, using another placeholder for numeric values."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table provides a list of car makes along with their corresponding horsepower from the 'car_names' and 'cars_data' tables. The results are filtered to include only those cars with a specific number of cylinders, represented by a placeholder for numeric values. Additionally, the results are ordered by horsepower in descending order, and the number of results returned is limited by another numeric placeholder.", "virtual_table": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.133", "db_id": "car_1", "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'Model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the 'MakeId' and 'Id' columns to combine data from both tables.", "The results are ordered by the 'MPG' column from the 'cars_data' table in descending order to show the most fuel-efficient models first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "The virtual table describes the car models from the 'car_names' table, ordered by their fuel efficiency (MPG) in descending order. The placeholder in the LIMIT clause represents the maximum number of car models to return.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["The query identifies the relevant tables, which are 'car_makers' and 'model_list'.", "It selects the 'FullName' and 'Id' columns from the 'car_makers' table.", "A JOIN operation is performed between 'car_makers' and 'model_list' on the 'Id' and 'Maker' columns respectively to associate car makers with their models.", "The results are grouped by the 'Id' of the car makers to aggregate the number of models they have produced.", "The HAVING clause is used to filter the grouped results to include only those car makers that have produced more than a specified number of models, using a placeholder for numeric values."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "description": "This virtual table provides a list of car makers along with their unique identifiers from the 'car_makers' table. It filters the results to include only those car makers that have produced more than a specified number of car models, as indicated by the placeholder in the HAVING clause.", "virtual_table": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.158", "db_id": "car_1", "question": "For a volvo model, how many cylinders does the version with least accelerate have?", "rationale": ["The query identifies the relevant tables, 'cars_data' and 'car_names'.", "It selects the 'cylinders' column from the 'cars_data' table.", "A JOIN operation is performed to connect 'cars_data' with 'car_names' based on the matching 'Id' and 'MakeId'.", "A condition is added to filter results based on a specific car model using a placeholder for string values.", "The results are ordered by the 'accelerate' column in ascending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "description": "This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the query limits the output to a specified number of entries. The placeholders represent the car model name and the limit on the number of results.", "virtual_table": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.160", "db_id": "car_1", "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?", "rationale": ["The query identifies the relevant table, which is 'cars_data'.", "It counts the number of entries in 'cars_data' where the 'Accelerate' value is greater than a certain threshold.", "The threshold is determined by a subquery that selects the 'Accelerate' value from the top specified number of cars ordered by 'Horsepower' in descending order, using a placeholder for the number of top cars."], "gold_sql": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "source_tables": ["cars_data"], "description": "This virtual table provides a count of cars from the 'cars_data' table that have an acceleration time greater than the acceleration time of the top specified number of cars with the highest horsepower. The placeholder in the subquery represents the number of top cars to consider based on horsepower.", "virtual_table": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] );"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'Model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the 'MakeId' and 'Id' columns to combine relevant data.", "A condition is added to filter the results based on the number of cylinders using a placeholder for numeric values.", "The results are ordered by the 'horsepower' column in descending order to show the most powerful cars first.", "A LIMIT clause is included to restrict the number of results returned, using another placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table lists the car models from the 'car_names' table that have a specific number of cylinders. The results are ordered by the horsepower of the cars in descending order, and the number of results returned is limited by a placeholder value.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.166", "db_id": "car_1", "question": "For all of the 4 cylinder cars, which model has the most horsepower?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'Model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the 'MakeId' and 'Id' columns respectively to combine relevant data.", "A condition is added to filter the results based on the number of cylinders using a placeholder for numeric values.", "The results are ordered by the 'horsepower' column in descending order to show the most powerful cars first.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table lists the car models from the 'car_names' table that have a specific number of cylinders. The results are ordered by the horsepower of the cars in descending order, and the number of results returned is limited by a placeholder value.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.168", "db_id": "car_1", "question": "Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?", "rationale": ["The query identifies the relevant tables, 'cars_data' and 'car_names'.", "It selects the 'makeid' and 'make' columns from the 'car_names' table.", "A JOIN operation is performed on 'cars_data' and 'car_names' using the 'id' and 'makeid' columns to link the data.", "A condition is added to filter cars with horsepower greater than the minimum horsepower from 'cars_data'.", "Another condition is included to filter cars with a cylinder count less than a specified number using a placeholder for numeric values."], "gold_sql": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  4;", "source_tables": ["cars_data", "car_names"], "description": "This virtual table provides a list of car makes and their identifiers from the 'car_names' table, specifically for cars that have a horsepower greater than the minimum horsepower recorded in the 'cars_data' table and have a cylinder count less than a specified number. The placeholder in the WHERE clause represents the maximum number of cylinders allowed.", "virtual_table": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["The query identifies the relevant tables, which are 'CAR_MAKERS', 'MODEL_LIST', and 'CAR_NAMES'.", "It selects the 'Id' and 'Maker' columns from 'CAR_MAKERS' and joins it with 'MODEL_LIST' to count the number of models for each maker.", "The first part of the query groups by 'Id' and filters those with a count of models greater than or equal to a specified number using a placeholder.", "The second part of the query performs a similar operation but includes an additional join with 'CAR_NAMES' to count the number of names associated with each model.", "The use of INTERSECT ensures that only car makers who meet both criteria are included in the final result."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "description": "This virtual table identifies car makers who have produced a significant number of car models, as well as those who have a specific number of car names associated with their models. The placeholders in the HAVING clauses represent the minimum counts of models and names, respectively.", "virtual_table": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.180", "db_id": "flight_2", "question": "What country is Jetblue Airways affiliated with?", "rationale": ["The query identifies the relevant table, which is 'airlines'.", "Select the column to display, 'Country'.", "Add a condition to filter the 'Airline' column for the specified airline using a placeholder for string values."], "gold_sql": "SELECT Country FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "description": "This virtual table provides the country of an airline based on its name. The placeholder in the WHERE clause represents the specific airline's name for which the country is being queried.", "virtual_table": "SELECT Country FROM AIRLINES WHERE Airline  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.194", "db_id": "flight_2", "question": "Give the airline with abbreviation 'UAL'.", "rationale": ["The query is identifying the relevant table, which is 'airlines'.", "Select the column to display, 'Airline'.", "Add a condition to filter the 'Abbreviation' column for the specified abbreviation using a placeholder for string values."], "gold_sql": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  'UAL'", "source_tables": ["airlines"], "description": "This virtual table describes the names of airlines from the 'airlines' table that match a specific abbreviation. The placeholder in the WHERE clause represents the abbreviation of the airline.", "virtual_table": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.214", "db_id": "flight_2", "question": "Give the number of Jetblue Airways flights.", "rationale": ["The query identifies the relevant tables, which are 'flights' and 'airlines'.", "It uses a JOIN operation to connect the 'flights' table with the 'airlines' table based on the airline's unique identifier.", "The SELECT statement counts the total number of flights for the specified airline.", "A condition is added to filter the results by the airline's name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = 'JetBlue Airways'", "source_tables": ["flights", "airlines"], "description": "This virtual table provides the count of flights operated by a specific airline from the 'flights' table. It joins the 'flights' table with the 'airlines' table to filter the results based on the airline's name. The placeholder in the WHERE clause represents the name of the airline for which the flight count is being queried.", "virtual_table": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.225", "db_id": "flight_2", "question": "What is the code of airport that has the highest number of flights?", "rationale": ["The query identifies the relevant tables, 'airports' and 'flights'.", "It selects the 'AirportCode' from the 'airports' table.", "A JOIN operation is performed between 'airports' and 'flights' on the condition that the airport code matches either the source or destination airport code.", "The results are grouped by 'AirportCode' to aggregate the data.", "The results are ordered by the count of flights associated with each airport in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "description": "This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.227", "db_id": "flight_2", "question": "What is the code of airport that has fewest number of flights?", "rationale": ["The query identifies the relevant tables, which are 'airports' and 'flights'.", "It selects the 'AirportCode' from the 'airports' table.", "A JOIN operation is performed between 'airports' and 'flights' on the condition that the airport code matches either the source or destination airport code.", "The results are grouped by 'AirportCode' to ensure uniqueness.", "The results are ordered by the count of flights associated with each airport code, and a limit is applied to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1", "source_tables": ["airports", "flights"], "description": "This virtual table lists unique airport codes from the 'airports' table that are either source or destination for flights in the 'flights' table. The placeholder in the LIMIT clause represents the maximum number of airport codes to return.", "virtual_table": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.229", "db_id": "flight_2", "question": "Which airline has most number of flights?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'flights'.", "It selects the 'Airline' column from the 'airlines' table, using an alias for clarity.", "A JOIN operation is performed between the 'airlines' and 'flights' tables based on the unique identifier of the airline.", "The results are grouped by the airline name to aggregate the flight counts.", "The results are ordered by the count of flights in descending order to show the most active airlines first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flights", "airlines"], "description": "This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of results specified by a placeholder for numeric values.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.232", "db_id": "flight_2", "question": "What is the abbreviation of the airilne has the fewest flights and what country is it in?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'flights'.", "It selects the 'Abbreviation' and 'Country' columns from the 'airlines' table, aliased as T1.", "A JOIN operation is performed between 'airlines' and 'flights' on the airline identifier to link the two tables.", "The results are grouped by the 'Airline' to aggregate the data based on the number of flights operated.", "The ORDER BY clause is used to sort the results by the count of flights in descending order.", "The LIMIT clause is included to allow the user to specify the maximum number of results to return."], "gold_sql": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1", "source_tables": ["flights", "airlines"], "description": "This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify how many results they want to retrieve.", "virtual_table": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.244", "db_id": "flight_2", "question": "Which airlines have less than 200 flights?", "rationale": ["The query identifies the relevant tables, which are 'airlines' and 'flights'.", "It selects the 'Airline' column from the 'airlines' table.", "A JOIN operation is performed between 'airlines' and 'flights' on the airline identifier to link the two tables.", "The results are grouped by the airline name to aggregate the flight counts.", "The HAVING clause filters the groups to include only those airlines that operate fewer flights than the specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "description": "This virtual table lists the names of airlines from the 'airlines' table that operate fewer flights than a specified number. The placeholder in the HAVING clause represents the maximum number of flights an airline can operate.", "virtual_table": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.258", "db_id": "flight_2", "question": "Which airports do not have departing or arriving flights?", "rationale": ["The query identifies the relevant table, which is 'Airports'.", "It selects the 'AirportName' column to display the names of the airports.", "The condition filters out airports that are either source or destination for any flights by using a subquery that combines both source and destination airports with a UNION operation."], "gold_sql": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)", "source_tables": ["airports", "flights"], "description": "This virtual table lists the names of airports from the 'Airports' table that do not serve as departure or arrival points for any flights. The query uses a subquery to identify airports that are involved in flights, ensuring that only airports without any flight connections are included.", "virtual_table": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)"}
{"sample_id": "dev.308", "db_id": "cre_Doc_Template_Mgt", "question": "Count the number of documents that use the PPT template type.", "rationale": ["The query identifies the relevant tables, which are 'Documents' and 'Templates'.", "It uses a JOIN operation to link the two tables based on the 'Template_ID'.", "The SELECT statement counts the number of documents that match the specified template type code, using a placeholder for string values in the WHERE clause."], "gold_sql": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'", "source_tables": ["templates", "documents"], "description": "This virtual table provides a count of documents associated with a specific type of template from the 'Documents' and 'Templates' tables. The placeholder in the WHERE clause represents the unique code for the template type.", "virtual_table": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.311", "db_id": "cre_Doc_Template_Mgt", "question": "What is the id and type code for the template used by the most documents?", "rationale": ["The query identifies the relevant tables, 'Documents' and 'Templates', and uses an alias for clarity.", "It selects the 'template_id' from the 'Documents' table and the 'Template_Type_Code' from the 'Templates' table.", "A JOIN operation is performed on the 'template_id' to link documents with their respective templates.", "The results are grouped by 'template_id' to aggregate the data accordingly.", "The results are ordered by the count of documents associated with each template in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "description": "This virtual table provides a list of template IDs along with their corresponding template type codes from the 'Documents' and 'Templates' tables. The results are grouped by template ID and ordered by the count of documents associated with each template, limited to a specified number of results.", "virtual_table": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.312", "db_id": "cre_Doc_Template_Mgt", "question": "Return the id and type code of the template that is used for the greatest number of documents.", "rationale": ["The query identifies the relevant tables, 'Documents' and 'Templates', and uses an alias for clarity.", "It selects the 'template_id' from the 'Documents' table and the 'Template_Type_Code' from the 'Templates' table.", "A JOIN operation is performed on the 'template_id' to link documents with their respective templates.", "The results are grouped by 'template_id' to aggregate the data accordingly.", "The results are ordered by the count of documents associated with each template in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "description": "This virtual table provides a list of template IDs along with their corresponding template type codes from the 'Documents' and 'Templates' tables. The results are grouped by template ID and ordered by the count of documents associated with each template, limited to a specified number of results.", "virtual_table": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.341", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template type codes and the number of documents using each type.", "rationale": ["The query identifies the relevant tables, which are 'Templates' and 'Documents'.", "It selects the 'template_type_code' from the 'Templates' table and counts the number of documents associated with each template type.", "A JOIN operation is performed between 'Templates' and 'Documents' on the 'template_id' to link templates with their corresponding documents.", "The results are grouped by 'template_type_code' to provide a count of documents for each template type."], "gold_sql": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code", "source_tables": ["templates", "documents"], "description": "This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.", "virtual_table": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code"}
{"sample_id": "dev.346", "db_id": "cre_Doc_Template_Mgt", "question": "What are the codes of template types that are not used for any document?", "rationale": ["The query starts by selecting the 'template_type_code' from the 'Templates' table.", "It uses an EXCEPT clause to find template types that do not have any associated documents.", "The second part of the query involves a JOIN between 'Templates' and 'Documents' on 'template_id' to identify which template types are linked to documents."], "gold_sql": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id", "source_tables": ["templates", "documents"], "description": "This virtual table identifies the unique template type codes from the 'Templates' table that are not associated with any documents in the 'Documents' table. The query uses an EXCEPT clause to filter out template types that have been linked to documents, ensuring that only those template types without any corresponding documents are returned.", "virtual_table": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id"}
{"sample_id": "dev.361", "db_id": "cre_Doc_Template_Mgt", "question": "Show paragraph details for paragraph with text 'Korea ' .", "rationale": ["The query identifies the relevant table, which is 'Paragraphs'.", "Select the column to display, 'Other_Details'.", "Add a condition to filter the 'Paragraph_Text' column using a LIKE clause for the specified text pattern, represented by a placeholder for string values."], "gold_sql": "select other_details from paragraphs where paragraph_text like 'korea'", "source_tables": ["paragraphs"], "description": "This virtual table retrieves additional details from the 'Paragraphs' table for paragraphs that contain specific text. The placeholder in the WHERE clause represents the text pattern to search for within the paragraph content.", "virtual_table": "select other_details from paragraphs where paragraph_text like [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.367", "db_id": "cre_Doc_Template_Mgt", "question": "Show all document ids and the number of paragraphs in each document. Order by document id.", "rationale": ["The query identifies the relevant table, which is 'Paragraphs'.", "It selects the 'document_id' and counts the number of paragraphs associated with each document using the count function.", "The results are grouped by 'document_id' to aggregate the paragraph counts for each document.", "Finally, the results are ordered by 'document_id' to present the data in a structured manner."], "gold_sql": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id", "source_tables": ["paragraphs"], "description": "This virtual table provides a count of paragraphs associated with each document from the 'Paragraphs' table. The results are grouped by the document identifier, allowing users to see how many paragraphs belong to each document, sorted by the document ID.", "virtual_table": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id"}
{"sample_id": "dev.439", "db_id": "wta_1", "question": "Find the highest rank of losers in all matches.", "rationale": ["The query identifies the relevant table, which is 'matches'.", "It selects the minimum value of the 'loser_rank' column to find the lowest rank of losing players.", "The use of the aggregate function 'min' allows for the calculation of the minimum rank across all matches."], "gold_sql": "SELECT min(loser_rank) FROM matches", "source_tables": ["matches"], "description": "This virtual table provides the minimum rank of losing players from the 'matches' table. The query aggregates the data to find the lowest rank among all losing players in the recorded matches.", "virtual_table": "SELECT min(loser_rank) FROM matches"}
{"sample_id": "dev.458", "db_id": "wta_1", "question": "What are the full names of all left handed players, in order of birth date?", "rationale": ["The query identifies the relevant table, which is 'players'.", "Select the columns to display, 'first_name' and 'last_name'.", "Add a condition to filter the 'hand' column for the specified playing hand using a placeholder for string values.", "Order the results by 'birth_date' to sort players by their date of birth."], "gold_sql": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date", "source_tables": ["players"], "description": "This virtual table describes the first and last names of players from the 'players' table who play with a specific hand. The results are ordered by the players' birth dates. The placeholder in the WHERE clause represents the playing hand of the players.", "virtual_table": "SELECT first_name ,  last_name FROM players WHERE hand  =  [PLACEHOLDER-TYPE:STRING] ORDER BY birth_date"}
{"sample_id": "dev.464", "db_id": "wta_1", "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?", "rationale": ["The query identifies the relevant table, which is 'matches'.", "Select the columns to display, 'winner_name' and 'winner_rank_points'.", "Group the results by 'winner_name' to aggregate the data based on the winners.", "Order the results by the count of matches won in descending order to highlight the most successful players.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["matches"], "description": "This virtual table provides the names and ranking points of the winning players from the 'matches' table, grouped by the winner's name. The results are ordered by the number of matches won in descending order, with a limit on the number of results returned, specified by a placeholder for numeric values.", "virtual_table": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.471", "db_id": "wta_1", "question": "Find the total ranking points for each player and their first name.", "rationale": ["The query identifies the relevant tables, which are 'players' and 'rankings'.", "It selects the sum of 'ranking_points' to calculate the total points for each player.", "The 'first_name' from the 'players' table is included to display the player's name alongside their total ranking points.", "A JOIN operation is performed on 'player_id' to link the two tables, ensuring that the ranking points correspond to the correct player.", "The results are grouped by 'first_name' to aggregate the ranking points for each player."], "gold_sql": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name", "source_tables": ["rankings", "players"], "description": "This virtual table summarizes the total ranking points for each player by their first name. It combines data from the 'players' and 'rankings' tables, grouping the results by the player's first name to provide a clear view of their accumulated ranking points.", "virtual_table": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name"}
{"sample_id": "dev.479", "db_id": "wta_1", "question": "Find the total number of tours for each ranking date.", "rationale": ["The query identifies the relevant table, which is 'rankings'.", "It selects the aggregated sum of the 'tours' column to get the total number of tours for each ranking date.", "The 'ranking_date' column is included to group the results, allowing us to see the total tours for each specific date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "description": "This virtual table summarizes the total number of tours or events considered for player rankings on each ranking date. The placeholder in the SELECT clause represents the aggregated sum of tours, while the GROUP BY clause organizes the results by the ranking date.", "virtual_table": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date"}
{"sample_id": "dev.480", "db_id": "wta_1", "question": "How many total tours were there for each ranking date?", "rationale": ["The query identifies the relevant table, which is 'rankings'.", "It selects the sum of the 'tours' column to aggregate the total number of tours for each ranking date.", "The 'ranking_date' column is included to group the results, allowing for a summary of tours per date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "description": "This virtual table summarizes the total number of tours or events considered for player rankings on each ranking date. The placeholder in the SELECT clause represents the aggregated sum of tours, while the GROUP BY clause organizes the results by the ranking date.", "virtual_table": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date"}
{"sample_id": "dev.533", "db_id": "student_transcripts_tracking", "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.", "rationale": ["The query identifies the relevant table, which is 'Students', and aliases it as T1.", "It selects the columns to display: 'first_name', 'middle_name', 'last_name', and 'student_id'.", "The query joins the 'Students' table with the 'Student_Enrolment' table (aliased as T2) to link students with their enrolment records.", "It groups the results by 'student_id' to aggregate the data for each student.", "The HAVING clause filters the results to include only those students who are enrolled in a specific number of courses, using a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "description": "This virtual table provides the first name, middle name, last name, and unique identifier of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.", "virtual_table": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.536", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?", "rationale": ["The query identifies the relevant tables: 'Students', 'Student_Enrolment', and 'Degree_Programs'.", "It selects distinct names (first, middle, last) from the 'Students' table.", "The JOIN operations link the 'Students' table to the 'Student_Enrolment' table using the student ID, and then to the 'Degree_Programs' table using the degree program ID.", "A condition is added to filter the results based on the specified degree program name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "description": "This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.537", "db_id": "student_transcripts_tracking", "question": "Find the kind of program which most number of students are enrolled in?", "rationale": ["The query identifies the relevant tables, 'Degree_Programs' and 'Student_Enrolment'.", "It selects the 'degree_summary_name' from the 'Degree_Programs' table.", "A JOIN operation is performed to link 'Degree_Programs' with 'Student_Enrolment' based on the 'degree_program_id'.", "The results are grouped by 'degree_summary_name' to aggregate enrolment counts.", "The results are ordered by the count of enrolments in descending order to highlight the most popular programs.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "description": "This virtual table provides a list of degree program names from the 'Degree_Programs' table, which are associated with student enrolments. The results are grouped by the degree program name and ordered by the number of enrolments in descending order, allowing users to see the most popular degree programs. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["The query identifies the relevant tables, 'Degree_Programs' and 'Student_Enrolment'.", "It selects the degree program ID and name from the 'Degree_Programs' table.", "A JOIN operation is performed between 'Degree_Programs' and 'Student_Enrolment' on the degree program ID to link degree programs with their enrollments.", "The results are grouped by the degree program ID to aggregate the number of students enrolled in each program.", "The results are ordered by the count of enrollments in descending order to highlight the most popular programs.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "description": "This virtual table provides a list of degree programs along with their unique identifiers from the 'Degree_Programs' table. It joins with the 'Student_Enrolment' table to count the number of students enrolled in each degree program. The results are grouped by the degree program ID and ordered by the number of enrollments in descending order, allowing users to see the most popular degree programs. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["The query identifies the relevant tables, 'Students' and 'Student_Enrolment'.", "It selects the student ID, first name, middle name, and last name from the 'Students' table.", "It counts the number of enrolments for each student by joining 'Students' with 'Student_Enrolment' on the student ID.", "The results are grouped by the student ID to aggregate the enrolment counts.", "Finally, the results are ordered by the count of enrolments in descending order, and a placeholder is used to limit the number of results returned."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "description": "This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.", "virtual_table": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Enrolment_Courses'.", "It selects the 'course_name' from the 'Courses' table.", "A JOIN operation is performed between 'Courses' and 'Student_Enrolment_Courses' on the 'course_id' to link courses with their enrolments.", "The results are grouped by 'course_name' to aggregate the data based on course popularity.", "The results are ordered by the count of enrolments in descending order to highlight the most popular courses.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "description": "This virtual table provides a list of course names from the 'Courses' table that are associated with student enrolments. The results are grouped by course name and ordered by the number of enrolments in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of course names to return.", "virtual_table": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["The query identifies the relevant tables, 'Students' and 'Addresses', to retrieve the last names of students.", "It joins the 'Students' table with the 'Addresses' table on the current address ID to access the state information.", "A condition is added to filter the results based on the specified state using a placeholder for string values.", "The EXCEPT clause is used to exclude students who are currently enrolled in any degree program by joining the 'Students' table with the 'Student_Enrolment' table."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "description": "This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The placeholders in the query represent the state name and ensure that the results are filtered accordingly.", "virtual_table": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["The query identifies the relevant table, which is 'Students'.", "Select the column to display, 'cell_mobile_number'.", "Add conditions to filter the 'first_name' and 'last_name' columns for the specified student using placeholders for string values."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "description": "This virtual table provides the mobile phone numbers of students from the 'Students' table based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.", "virtual_table": "select cell_mobile_number from students where first_name  =  [PLACEHOLDER-TYPE:STRING] and last_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["The query identifies the relevant tables, which are 'Addresses' and 'Students'.", "It selects the columns 'address_id', 'line_1', and 'line_2' from the 'Addresses' table.", "A JOIN operation is performed to link 'Addresses' with 'Students' based on the current address ID.", "The results are grouped by 'address_id' to ensure uniqueness of addresses.", "The results are ordered by the count of students associated with each address in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "description": "This virtual table provides a list of unique addresses that are currently associated with students, including the address ID and the primary and secondary address lines. The results are grouped by address ID and ordered by the number of students associated with each address, allowing for a limit on the number of results returned.", "virtual_table": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.576", "db_id": "student_transcripts_tracking", "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?", "rationale": ["The query is identifying the relevant tables, which are 'Degree_Programs' and 'Student_Enrolment'.", "It selects distinct semester IDs from the 'Student_Enrolment' table that are associated with a specific degree program.", "The query uses an INTERSECT operation to find common semesters for the same degree program, ensuring that the results reflect semesters where students are enrolled in that program."], "gold_sql": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs"], "description": "This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. The placeholders in the query represent the name of the degree program, allowing users to specify which program's semesters they are interested in.", "virtual_table": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.580", "db_id": "student_transcripts_tracking", "question": "What other details can you tell me about students in reverse alphabetical order?", "rationale": ["The query identifies the relevant table, which is 'Students'.", "Selects the column 'other_student_details' to display additional information about students.", "Orders the results in descending order based on the 'other_student_details' column."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "description": "This virtual table provides a list of additional details related to students from the 'Students' table, sorted in descending order. The placeholder in the SELECT clause represents the specific details of the students.", "virtual_table": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The query identifies the relevant table, which is 'Sections'.", "Select the column to display, 'section_description'.", "Add a condition to filter the 'section_name' column for the specified section using a placeholder for string values."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "description": "This virtual table provides the description of a specific section from the 'Sections' table based on the section's name. The placeholder in the WHERE clause represents the name of the section being queried.", "virtual_table": "SELECT section_description FROM Sections WHERE section_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects a count of all entries in the table.", "A condition is added to filter the results based on the 'GovernmentForm' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "description": "This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.", "virtual_table": "SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.730", "db_id": "world_1", "question": "What is the average GNP and total population in all nations whose government is US territory?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the average GNP and the sum of the population columns to provide aggregate data.", "A condition is added to filter the results based on the 'GovernmentForm' column using a placeholder for string values."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "description": "This virtual table calculates the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.", "virtual_table": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.734", "db_id": "world_1", "question": "How many type of governments are in Africa?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the count of distinct values in the 'GovernmentForm' column.", "A condition is added to filter the results based on the 'Continent' column using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "description": "This virtual table provides the count of distinct government forms present in countries located within a specific continent. The placeholder in the WHERE clause represents the continent's name.", "virtual_table": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the count of distinct values in the 'GovernmentForm' column.", "A condition is added to filter the results based on the 'Continent' column using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "description": "This virtual table provides the count of distinct government forms present in countries located within a specific continent. The placeholder in the WHERE clause represents the continent's name.", "virtual_table": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.742", "db_id": "world_1", "question": "Which continent has the most diverse languages?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It selects the 'Continent' column from the 'country' table (aliased as T1).", "A JOIN operation is performed between 'country' and 'countrylanguage' on the 'CountryCode' to associate languages with their respective countries.", "The results are grouped by 'Continent' to aggregate the count of countries per continent.", "The ORDER BY clause sorts the continents based on the count of countries in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many continents to return."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a list of continents along with the count of countries that speak languages from those continents. The placeholder in the LIMIT clause allows the user to specify the maximum number of continents to retrieve.", "virtual_table": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.743", "db_id": "world_1", "question": "Which continent speaks the most languages?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It selects the 'Continent' column from the 'country' table.", "A JOIN operation is performed between 'country' and 'countrylanguage' on the 'CountryCode' to associate countries with their languages.", "The results are grouped by 'Continent' to aggregate the count of countries per continent.", "The ORDER BY clause sorts the continents based on the count of countries in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many continents to return."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a list of continents along with the count of countries that speak languages from those continents. The placeholder in the LIMIT clause allows the user to specify the maximum number of continents to retrieve based on the number of countries speaking languages from each continent.", "virtual_table": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.746", "db_id": "world_1", "question": "What are the names of nations speak both English and French?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It uses a JOIN operation to connect the 'country' table with the 'countrylanguage' table based on the country code.", "The query filters the results to include only those countries where the specified languages are spoken, using placeholders for the language names.", "The INTERSECT operator is used to ensure that only countries that have both languages are included in the final result."], "gold_sql": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'French'", "source_tables": ["country", "countrylanguage"], "description": "This virtual table describes the names of countries that have two specific languages spoken within them. The placeholders in the WHERE clause represent the names of the languages being queried.", "virtual_table": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It performs a JOIN operation on these tables based on the country code to combine their data.", "The WHERE clause filters the results to include only those records where the specified language is spoken and indicates whether it is an official language, using placeholders for these values.", "The UNION operator is used to combine results from two similar queries, allowing for flexibility in the language and official status criteria."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a comprehensive view of countries and their languages by joining the 'country' and 'countrylanguage' tables. It filters the results to show only those countries where a specific language is spoken, and whether that language is official or not. The placeholders in the WHERE clause represent the language name and its official status.", "virtual_table": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] AND IsOfficial  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] AND IsOfficial  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It uses the SUM function to calculate the total population of countries.", "A subquery is included to filter out countries that have the specified language as an official language.", "The placeholder in the subquery represents the language name that is being checked against the countries."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "description": "This virtual table calculates the total population of countries that do not have a specific language as an official language. The placeholder in the subquery represents the language name that is being checked against the countries.", "virtual_table": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.767", "db_id": "world_1", "question": "How many people live in countries that do not speak English?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It uses the SUM function to calculate the total population of countries.", "A subquery is included to filter out countries that have the specified language as an official language.", "The placeholder in the subquery represents the language name that is being checked against the countries."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "description": "This virtual table calculates the total population of countries that do not have a specific language as an official language. The placeholder in the subquery represents the language name that is being checked against the countries.", "virtual_table": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.783", "db_id": "world_1", "question": "Return the codes of countries that do not speak English and do not have Republics for governments.", "rationale": ["The query is identifying the relevant table, which is 'country'.", "Select the 'Code' column from the 'country' table where the 'GovernmentForm' does not match the specified placeholder.", "Use the EXCEPT clause to exclude countries that have a specific language from the 'countrylanguage' table, using a placeholder for the language."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "description": "This virtual table identifies the unique codes of countries that do not have a specific form of government and are not associated with a particular language. The placeholders in the query represent the government form and the language of interest.", "virtual_table": "SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.784", "db_id": "world_1", "question": "Which cities are in European countries where English is not the official language?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'city'.", "It selects distinct city names from the 'city' table.", "A JOIN operation is performed between 'country' and 'city' based on the country code to filter cities by continent.", "A subquery is used to exclude cities from countries where a specified language is official, using placeholders for the language and its official status."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "description": "This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. The query also filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.", "virtual_table": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.785", "db_id": "world_1", "question": "What are the names of cities in Europe for which English is not the official language?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'city'.", "It selects distinct city names from the 'city' table.", "A join is performed between 'city' and 'country' on the CountryCode to filter cities based on the continent of the country.", "An additional condition is added to exclude cities from countries where a specified language is official, using a subquery that checks the 'countrylanguage' table for the official status of the language."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "description": "This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.", "virtual_table": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.788", "db_id": "world_1", "question": "What are the name, independence year, and surface area of the country with the smallest population?", "rationale": ["The query identifies the relevant table, which is 'country'.", "Select the columns to display: 'Name', 'SurfaceArea', and 'IndepYear'.", "Order the results by the 'Population' column to sort countries based on their population size.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "description": "This virtual table provides a list of countries, displaying their names, surface areas, and the year they gained independence. The results are ordered by the population of the countries, and the number of entries returned is limited by a specified placeholder for numeric values.", "virtual_table": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["The query identifies the relevant table, which is 'country'.", "Select the columns to display: 'Name', 'SurfaceArea', and 'IndepYear'.", "Order the results by the 'Population' column to sort countries based on their population size.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "description": "This virtual table provides a list of countries, displaying their names, surface areas, and the year they gained independence. The results are ordered by the population of the countries, and the number of entries returned is limited by a specified placeholder for numeric values.", "virtual_table": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It selects the count of languages (T2.Language) and the name of the country (T1.Name).", "A JOIN operation is performed on the country code to link the two tables.", "The results are grouped by the country's name to aggregate the language counts.", "A HAVING clause is used to filter the results to include only those countries with a language count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a count of languages spoken in each country from the 'country' table, along with the country's name. The query filters the results to only include countries where the number of languages spoken exceeds a specified threshold, represented by a placeholder for numeric values.", "virtual_table": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.796", "db_id": "world_1", "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the sum of the 'Population' column and the 'GovernmentForm' column.", "The results are grouped by 'GovernmentForm' to aggregate the population data accordingly.", "A condition is added to filter the results using the HAVING clause, which checks if the average 'LifeExpectancy' is greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "description": "This virtual table summarizes the total population of countries grouped by their government form, filtering for those government forms where the average life expectancy exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average life expectancy value.", "virtual_table": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the sum of the 'Population' column and the 'GovernmentForm' column.", "The results are grouped by 'GovernmentForm' to aggregate the population data accordingly.", "A condition is added to filter the results using the HAVING clause, which checks if the average 'LifeExpectancy' is greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "description": "This virtual table summarizes the total population of countries grouped by their government form, filtering for those government forms where the average life expectancy exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average life expectancy value.", "virtual_table": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.801", "db_id": "world_1", "question": "Return the names and surface areas of the 5 largest countries.", "rationale": ["The query identifies the relevant table, which is 'country'.", "Select the columns to display, 'Name' and 'SurfaceArea'.", "Order the results by 'SurfaceArea' in descending order to show the largest countries first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5", "source_tables": ["country"], "description": "This virtual table provides a list of country names along with their surface areas, sorted in descending order by surface area. The placeholder in the LIMIT clause allows the user to specify the maximum number of countries to retrieve.", "virtual_table": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.810", "db_id": "world_1", "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the sum of the 'population' and the average of the 'surfacearea' columns to provide aggregate data.", "A condition is added to filter the results based on the specified continent and a minimum surface area using placeholders for string and numeric values."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "description": "This virtual table provides the total population and average surface area of countries located in a specific continent that have a surface area greater than a specified value. The placeholders in the WHERE clause represent the continent's name and the minimum surface area.", "virtual_table": "select sum(population) ,  avg(surfacearea) from country where continent  =  [PLACEHOLDER-TYPE:STRING] and surfacearea  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.811", "db_id": "world_1", "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the sum of the 'population' and the average of the 'surfacearea' columns to provide aggregate data.", "A condition is added to filter the results based on the specified continent and a minimum surface area using placeholders for string and numeric values."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "description": "This virtual table provides the total population and average surface area of countries located in a specific continent that have a surface area greater than a specified value. The placeholders in the WHERE clause represent the continent's name and the minimum surface area.", "virtual_table": "select sum(population) ,  avg(surfacearea) from country where continent  =  [PLACEHOLDER-TYPE:STRING] and surfacearea  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["The query identifies the relevant table, which is 'city'.", "Select the column to display, 'name'.", "Add a condition to filter the 'Population' column for values between the specified range using placeholders for numeric values."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "description": "This virtual table describes the names of cities from the 'city' table that have a population within a specified range. The placeholders in the WHERE clause represent the lower and upper limits of the population range.", "virtual_table": "SELECT name FROM city WHERE Population BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.921", "db_id": "dog_kennels", "question": "Find the average age of the dogs who went through treatments.", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects the average age of dogs using the AVG function.", "The WHERE clause filters the dogs to include only those that have treatment records, which is determined by a subquery that selects dog_ids from the 'Treatments' table."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "description": "This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers if needed.", "virtual_table": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )"}
{"sample_id": "dev.924", "db_id": "dog_kennels", "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects the 'name' column to display the names of the dogs.", "A subquery is used to filter out dogs that have received treatments, grouping by 'dog_id' and summing the 'cost_of_treatment'.", "The condition in the HAVING clause uses a placeholder for the maximum total treatment cost to exclude dogs that exceed this amount."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "description": "This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum allowable total treatment cost for filtering the dogs.", "virtual_table": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "dev.937", "db_id": "dog_kennels", "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.", "rationale": ["The query identifies the relevant tables: 'Owners', 'Dogs', and 'Treatments'.", "It selects the 'owner_id' and 'last_name' from the 'Owners' table, using an alias for clarity.", "The JOIN operation links 'Owners' to 'Dogs' based on the owner_id, and 'Dogs' to 'Treatments' based on the dog_id, ensuring that only owners with treated dogs are included.", "The results are grouped by 'owner_id' to count the number of treatments per owner.", "Finally, the results are ordered by the count of treatments in descending order, and a placeholder is used in the LIMIT clause to specify how many owners to return."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "description": "This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.", "virtual_table": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["The query identifies the relevant tables, which are 'Professionals' and 'Treatments'.", "It selects the 'professional_id' and 'cell_number' from the 'Professionals' table.", "A JOIN operation is performed between 'Professionals' and 'Treatments' on the 'professional_id' to link treatments to the professionals who administered them.", "The results are grouped by 'professional_id' to aggregate the treatment counts for each professional.", "The HAVING clause filters the results to include only those professionals who have administered a specified minimum number of treatments, using a placeholder for numeric values."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "description": "This virtual table provides a list of professionals along with their cell numbers who have administered a minimum number of treatments. The placeholder in the HAVING clause represents the minimum count of treatments that a professional must have administered to be included in the results.", "virtual_table": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.943", "db_id": "dog_kennels", "question": "Find the id and cell phone of the professionals who operate two or more types of treatments.", "rationale": ["The query identifies the relevant tables, which are 'Professionals' and 'Treatments'.", "It selects the 'professional_id' and 'cell_number' from the 'Professionals' table.", "A JOIN operation is performed between 'Professionals' and 'Treatments' on the 'professional_id' to link treatments to the professionals who administered them.", "The results are grouped by 'professional_id' to aggregate the treatment counts for each professional.", "The HAVING clause filters the results to include only those professionals who have administered a specified minimum number of treatments, using a placeholder for numeric values."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "description": "This virtual table provides a list of professionals along with their cell numbers who have administered a minimum number of treatments. The placeholder in the HAVING clause represents the minimum count of treatments that a professional must have administered to be included in the results.", "virtual_table": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["The query identifies the relevant tables, which are 'Owners' and 'Dogs'.", "It selects the columns 'first_name' and 'last_name' from the 'Owners' table (aliased as T1) and 'size_code' from the 'Dogs' table (aliased as T2).", "A JOIN operation is performed on the 'owner_id' to link the two tables, ensuring that the data retrieved corresponds to the correct owner and their dog."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "description": "This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' and 'Dogs' tables, linking them through the owner_id. The placeholders in the SELECT statement allow for dynamic querying of owner names and their corresponding dog's size code.", "virtual_table": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id"}
{"sample_id": "dev.954", "db_id": "dog_kennels", "question": "List the names of the dogs of the rarest breed and the treatment dates of them.", "rationale": ["The query identifies the relevant tables, 'Dogs' and 'Treatments', and establishes a join between them based on the dog_id.", "It selects the 'name' of the dog from the 'Dogs' table and the 'date_of_treatment' from the 'Treatments' table.", "A subquery is used to find the breed_code of the least common breed by grouping the dogs by breed_code and ordering them by their count in ascending order, limiting the results to a specified number using a placeholder."], "gold_sql": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )", "source_tables": ["dogs", "treatments"], "description": "This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by the breed code, using a placeholder for the limit on the number of breeds to consider.", "virtual_table": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["The query identifies the relevant tables, which are 'Dogs' and 'Treatments'.", "It selects distinct values for the 'date_arrived' and 'date_departed' columns from the 'Dogs' table.", "A JOIN operation is performed on the 'dog_id' to link the 'Dogs' table with the 'Treatments' table, ensuring that only dogs with treatment records are included."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "description": "This virtual table provides a list of unique arrival and departure dates for dogs from the 'Dogs' table, along with their associated treatment records from the 'Treatments' table. The placeholders in the JOIN clause represent the relationships between the dogs and their treatments.", "virtual_table": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id"}
{"sample_id": "dev.960", "db_id": "dog_kennels", "question": "List the last name of the owner owning the youngest dog.", "rationale": ["The query identifies the relevant tables, which are 'Owners' and 'Dogs'.", "It selects the 'last_name' column from the 'Owners' table.", "A JOIN operation is performed between 'Owners' and 'Dogs' on the 'owner_id' to link owners to their dogs.", "A subquery is used to find the maximum age of dogs in the 'Dogs' table, ensuring that only the owners of the oldest dog are selected."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "description": "This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.", "virtual_table": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects distinct values for 'breed_code' and 'size_code' to ensure that each combination is unique.", "The use of DISTINCT ensures that duplicate entries are not included in the results."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "description": "This virtual table provides a unique list of breed codes and size codes from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.", "virtual_table": "SELECT DISTINCT breed_code ,  size_code FROM dogs"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["The query identifies the relevant tables: 'Professionals', 'Treatments', and 'Treatment_Types'.", "It selects the 'first_name' from the 'Professionals' table and 'treatment_type_description' from the 'Treatment_Types' table.", "The JOIN operations link the 'Treatments' table to both the 'Professionals' and 'Treatment_Types' tables based on their respective foreign keys.", "The DISTINCT keyword ensures that only unique combinations of professional first names and treatment descriptions are returned."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "description": "This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code"}
