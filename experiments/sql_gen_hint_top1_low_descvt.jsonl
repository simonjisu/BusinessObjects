{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["Identify the relevant tables: We need to look at the 'Student_Course_Registrations' table to find out how many students are registered for each course.", "Count the number of students for each course: We can use the COUNT() function to count the number of student IDs associated with each course ID.", "Group the results by course: We will use GROUP BY to aggregate the counts for each course.", "Order the results: To find the course with the most registered students, we will order the results in descending order based on the count of students.", "Limit the results to one: Since we only want the course with the most students, we will use LIMIT 1 to get the top result."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT course_id, COUNT(student_id) AS student_count\nFROM Student_Course_Registrations\nGROUP BY course_id\nORDER BY student_count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["We need to find the IDs of students who have attended courses.", "To do this, we will use the 'Students' table and the 'Student_Course_Attendance' table.", "We will perform a JOIN operation between these two tables on the 'student_id' column, which is common to both tables.", "Using DISTINCT will ensure that we only get unique student IDs, as a student may have attended multiple courses."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT S.student_id FROM Students S JOIN Student_Course_Attendance A ON S.student_id = A.student_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["We need to find the IDs of students who have attended at least one course.", "To do this, we will look at the 'Student_Course_Attendance' table, which records attendance for students.", "We will select the 'student_id' from this table.", "Using DISTINCT ensures that we only get unique student IDs, even if a student attended multiple courses."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["Identify the relevant tables: Candidates, Student_Course_Attendance, and Student_Course_Registrations.", "Join the Candidates table with Student_Course_Attendance on candidate_id and student_id to find candidates who attended courses.", "Join the result with Student_Course_Registrations to ensure we are looking at the correct course registrations.", "Order the results by date_of_attendance in descending order to get the most recent attendance first.", "Limit the results to 1 to get only the most recent candidate who accessed a course."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT DISTINCT c.candidate_id\nFROM Candidates c\nJOIN Student_Course_Attendance sca ON c.candidate_id = sca.student_id\nJOIN Student_Course_Registrations scr ON sca.student_id = scr.student_id AND sca.course_id = scr.course_id\nORDER BY sca.date_of_attendance DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.77", "db_id": "student_assessment", "question": "What is detail of the student who registered the most number of courses?", "rationale": ["We need to find the details of the student who registered for the most number of courses.", "To do this, we will join the 'Student_Course_Registrations' table with the 'Students' table using the student_id.", "We will group the results by student_id to count the number of courses each student has registered for.", "We will order the results in descending order based on the count of courses to get the student with the most registrations at the top.", "Finally, we will limit the results to 1 to get only the top student."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT T2.student_details \nFROM Student_Course_Registrations AS T1 \nJOIN Students AS T2 ON T1.student_id = T2.student_id \nGROUP BY T1.student_id \nORDER BY COUNT(T1.course_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["Identify the tables needed: We need to get course information and student registration counts, so we will use the 'Student_Course_Registrations' and 'Courses' tables.", "Join the 'Student_Course_Registrations' table with the 'Courses' table on the course_id to get the course names along with the registration counts.", "Use the COUNT() function to count the number of students registered for each course.", "Group the results by course_id and course_name to get the count for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT SC.course_id, C.course_name, COUNT(SC.student_id) AS student_count\nFROM Student_Course_Registrations AS SC\nJOIN Courses AS C ON SC.course_id = C.course_id\nGROUP BY SC.course_id, C.course_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.90", "db_id": "student_assessment", "question": "What are the ids of the students who registered for course 301 most recently?", "rationale": ["Identify the relevant tables: We need to look at the 'Student_Course_Registrations' table to find students registered for a specific course.", "Filter by course_id: We will filter the records to only include those where the course_id is '301'.", "Order by registration date: To find the most recent registration, we will order the results by the 'registration_date' in descending order.", "Limit the results: Since we only want the most recent registration, we will limit the results to 1."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["We need to find distinct cities of addresses associated with students.", "To do this, we will join the 'Addresses' table with the 'People_Addresses' table to link addresses to people.", "Next, we will join the 'People_Addresses' table with the 'Students' table to filter only those people who are students.", "Finally, we will select distinct cities from the resulting joined tables."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "pred_sql": "SELECT DISTINCT T1.city FROM Addresses AS T1 JOIN People_Addresses AS T2 ON T1.address_id = T2.address_id JOIN Students AS T3 ON T2.person_id = T3.student_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique cities from the 'Addresses' table that are associated with people through the 'People_Addresses' table. The placeholder in the JOIN clause represents the relationship between addresses and people.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id\"\n    }\n}\n"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["Identify the students who have registered for courses by looking at the 'Student_Course_Registrations' table.", "Determine which students have not attended any courses by checking the 'Student_Course_Attendance' table.", "Use a subquery to filter out students who are present in the 'Student_Course_Attendance' table from the 'Student_Course_Registrations' table.", "Finally, retrieve all details of the students from the 'Students' table whose IDs are in the filtered list of registered but not attended students."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "pred_sql": "SELECT * FROM Students WHERE student_id IN (SELECT student_id FROM Student_Course_Registrations WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Attendance))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of all course registrations for students who have not attended any courses. The query retrieves all columns from the 'student_course_registrations' table, filtering out students based on their attendance records.\",\n        \"virtual_table\": \"SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)\"\n    }\n}\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant tables: We need to look at the 'Student_Course_Registrations' table to find students who registered for courses and the 'Students' table to get student details.", "Determine the course of interest: The course we are interested in is 'Statistics'. We will need to filter the registrations based on this course.", "Join the tables: We will join 'Student_Course_Registrations' with 'Students' on the student_id to get the student details along with their registration information.", "Select the student IDs: We will select the student_id from the joined tables.", "Order by registration date: We will order the results by the registration_date to get the students in the order they registered for the course."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT T1.student_id FROM Student_Course_Registrations AS T1 JOIN Students AS T2 ON T1.student_id = T2.student_id WHERE T1.course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY T1.registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant tables: We need to look at the 'Student_Course_Registrations' table to find the registration details and the 'Students' table to get the student IDs.", "Join the 'Student_Course_Registrations' table with the 'Students' table on the student_id to get the necessary details.", "Filter the results to only include registrations for the course named 'Statistics'.", "Order the results by the registration date to get the students in the order they registered."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT T1.student_id FROM Student_Course_Registrations AS T1 JOIN Students AS T2 ON T1.student_id = T2.student_id WHERE T1.course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY T1.registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.123", "db_id": "bike_1", "question": "For each zip code, return the average mean temperature of August there.", "rationale": ["The task requires calculating the average mean temperature for each zip code specifically for the month of August.", "To filter the records for August, we can use the `strftime` function to extract the month from the `date` column in the `weather` table.", "We need to group the results by `zip_code` to get the average mean temperature for each zip code.", "The `AVG` function will be used to calculate the average of the `mean_temperature_f` for the filtered records."], "gold_sql": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE '8/%' GROUP BY zip_code", "source_tables": ["weather"], "pred_sql": "SELECT zip_code, AVG(mean_temperature_f) AS average_mean_temperature\nFROM weather\nWHERE strftime('%m', date) = '08'\nGROUP BY zip_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.135", "db_id": "bike_1", "question": "Which bike traveled the most often in zip code 94002?", "rationale": ["Identify the relevant table: The 'trip' table contains information about bike trips, including the bike ID and zip code.", "Filter trips by zip code: We need to focus on trips that started in the zip code 94002.", "Group by bike ID: To find out which bike traveled the most, we will group the results by bike_id.", "Count the number of trips for each bike: We will count the number of trips for each bike using COUNT(*) function.", "Order the results: We will order the results in descending order based on the trip count to get the most frequently used bike at the top.", "Limit the results: Finally, we will limit the results to 1 to get the bike that traveled the most often."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id, COUNT(*) as trip_count \nFROM trip \nWHERE zip_code = '94002' \nGROUP BY bike_id \nORDER BY trip_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.136", "db_id": "bike_1", "question": "What is the id of the bike that traveled the most in 94002?", "rationale": ["Identify the relevant table: The 'trip' table contains information about bike trips, including the bike ID and duration.", "Filter trips by zip code: We need to focus on trips that started in the zip code '94002'.", "Order the results: To find the bike that traveled the most, we will order the trips by their duration in descending order.", "Limit the results: We only need the top result, which is the bike that traveled the most, so we will use LIMIT 1."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id FROM trip WHERE zip_code = '94002' ORDER BY duration DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.143", "db_id": "bike_1", "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?", "rationale": ["Identify the relevant tables: 'station' for station details and 'status' for bike availability.", "We need to select the station names and ids, so we will select 's.name' and 's.id' from the 'station' table.", "To find the average number of bikes available, we will join the 'station' table with the 'status' table on the station id.", "We will group the results by station id to calculate the average number of bikes available for each station.", "We will use the HAVING clause to filter stations that have an average of more than 14 bikes available or were installed in December (checking the month of the installation date).", "The installation date is checked using the strftime function to extract the month from the 'installation_date' column."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT s.name, s.id \nFROM station s \nJOIN status st ON s.id = st.station_id \nGROUP BY s.id \nHAVING AVG(st.bikes_available) > 14 OR strftime('%m', s.installation_date) = '12';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.144", "db_id": "bike_1", "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "rationale": ["Identify the relevant tables: 'station' for station details and 'status' for bike availability.", "We need to select the names and ids of stations, so we will select 's.name' and 's.id' from the 'station' table.", "To find the average number of bikes available, we will join the 'station' table with the 'status' table on 'station.id' and 'status.station_id'.", "We will group the results by station id to calculate the average number of bikes available for each station.", "The HAVING clause will filter the results to include only those stations where the average number of bikes available is greater than 14 or where the installation date indicates that bikes were installed in December (using a LIKE clause to match the month)."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT s.name, s.id \nFROM station s \nJOIN status st ON s.id = st.station_id \nGROUP BY s.id \nHAVING AVG(st.bikes_available) > 14 \n   OR s.installation_date LIKE '%-12-%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.145", "db_id": "bike_1", "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?", "rationale": ["Identify the relevant table: The question pertains to cloud cover rates, which are found in the 'weather' table.", "Filter by zip code: We need to focus on records where the zip code is 94107.", "Group by cloud cover: To find the most common cloud cover rates, we will group the results by the 'cloud_cover' column.", "Count occurrences: We will count how many times each cloud cover rate appears using COUNT(cloud_cover).", "Order the results: To find the most common rates, we will order the results in descending order based on the count.", "Limit the results: We only need the top 3 most common cloud cover rates, so we will limit the results to 3."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "pred_sql": "SELECT cloud_cover, COUNT(cloud_cover) as count FROM weather WHERE zip_code = 94107 GROUP BY cloud_cover ORDER BY count DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.161", "db_id": "bike_1", "question": "For each trip, return its ending station's installation date.", "rationale": ["We need to retrieve the ending station's installation date for each trip.", "The relevant tables are 'trip' and 'station'.", "We will join the 'trip' table with the 'station' table on the 'end_station_id' from the 'trip' table and the 'id' from the 'station' table.", "We will select the 'end_station_id' from the 'trip' table and the 'installation_date' from the 'station' table."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T1.end_station_id, S.installation_date FROM trip AS T1 JOIN station AS S ON T1.end_station_id = S.id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.162", "db_id": "bike_1", "question": "What is the installation date for each ending station on all the trips?", "rationale": ["Identify the relevant tables: We need data from the 'trip' table for the ending stations and the 'station' table for the installation dates.", "Join the 'trip' table with the 'station' table on the condition that the 'end_station_id' from the 'trip' table matches the 'id' from the 'station' table.", "Select the 'installation_date' from the 'station' table for each ending station associated with the trips."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT S.installation_date FROM trip AS T JOIN station AS S ON T.end_station_id = S.id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.163", "db_id": "bike_1", "question": "Which trip started from the station with the largest dock count? Give me the trip id.", "rationale": ["Identify the relevant tables: 'trip' for trip details and 'station' for station details.", "Join the 'trip' table with the 'station' table on the condition that the start_station_id in 'trip' matches the id in 'station'.", "Select the trip id from the 'trip' table (aliased as T1).", "Order the results by the dock_count from the 'station' table (aliased as T2) in descending order to get the station with the largest dock count first.", "Limit the results to 1 to get only the trip that started from the station with the largest dock count."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "pred_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id = T2.id ORDER BY T2.dock_count DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.165", "db_id": "bike_1", "question": "Count the number of trips that did not end in San Francisco city.", "rationale": ["Identify the relevant tables: We need to count trips from the 'trip' table and filter based on the 'station' table for the ending station's city.", "Join the 'trip' table with the 'station' table on the end station ID to access the city information.", "Use a WHERE clause to filter out trips that ended in 'San Francisco'.", "Count the number of remaining trips that meet the criteria."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id = T2.id WHERE T2.city != 'San Francisco';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.166", "db_id": "bike_1", "question": "How many trips did not end in San Francisco?", "rationale": ["Identify the relevant table: The 'trip' table contains information about trips, including the end station name.", "Determine the condition: We need to count trips that did not end in San Francisco, which means we will filter the trips based on the 'end_station_name' column.", "Construct the SQL query: We will use the COUNT function to count the number of trips that meet the condition, using a WHERE clause to specify that the 'end_station_name' should not be 'San Francisco'."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != 'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip WHERE end_station_name != 'San Francisco';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.167", "db_id": "bike_1", "question": "In zip code 94107, on which day neither Fog nor Rain was not observed?", "rationale": ["Identify the relevant table: The question pertains to weather conditions, so we will use the 'weather' table.", "Filter by zip code: We need to focus on records where the zip code is 94107.", "Exclude specific weather events: We need to ensure that neither 'Fog' nor 'Rain' is present in the weather events for the selected dates.", "Construct the SQL query: We will select the 'date' from the 'weather' table where the zip code matches and the events do not include 'Fog' or 'Rain'."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT date FROM weather WHERE zip_code = 94107 AND events NOT LIKE '%Fog%' AND events NOT LIKE '%Rain%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.168", "db_id": "bike_1", "question": "On which day has it neither been foggy nor rained in the zip code of 94107?", "rationale": ["Identify the relevant table: The question pertains to weather conditions, so we will use the 'weather' table.", "Filter by zip code: We need to focus on the records where the zip code is 94107.", "Check for fog and rain: We need to ensure that there are no weather events (fog) and no precipitation (rain). In the 'weather' table, 'events' should be NULL and 'precipitation_inches' should be 0 to indicate no rain.", "Select the date: Finally, we want to retrieve the date(s) that meet these criteria."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT date FROM weather WHERE zip_code = 94107 AND events IS NULL AND precipitation_inches = 0;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.183", "db_id": "bike_1", "question": "List all the cities in a decreasing order of each city's stations' highest latitude.", "rationale": ["We need to list all the cities from the 'station' table.", "To find the highest latitude for each city, we will use the MAX function on the 'lat' column.", "We will group the results by 'city' to ensure we get the highest latitude for each city.", "Finally, we will order the results in decreasing order of the highest latitude using ORDER BY clause."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, MAX(lat) AS highest_latitude \nFROM station \nGROUP BY city \nORDER BY highest_latitude DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.184", "db_id": "bike_1", "question": "For each city, list their names in decreasing order by their highest station latitude.", "rationale": ["We need to list the names of stations for each city ordered by their highest latitude.", "To achieve this, we will first find the maximum latitude for each city using a subquery.", "The subquery will group the stations by city and select the maximum latitude for each group.", "Next, we will select the city and name from the station table where the latitude matches the maximum latitude found in the subquery.", "Finally, we will order the results by latitude in descending order."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, name FROM station WHERE lat = (SELECT MAX(lat) FROM station GROUP BY city) ORDER BY lat DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.189", "db_id": "bike_1", "question": "For each station, return its longitude and the average duration of trips that started from the station.", "rationale": ["We need to select the longitude of each station and the average duration of trips that started from that station.", "The 'station' table contains the longitude information, and the 'trip' table contains the duration of trips.", "To get the average duration of trips for each station, we will join the 'station' table with the 'trip' table on the station ID.", "We will use the AVG() function to calculate the average duration of trips for each station.", "Finally, we will group the results by the station ID to ensure we get the average duration for each individual station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT S.long, AVG(T.duration) AS average_duration \nFROM station AS S \nJOIN trip AS T ON S.id = T.start_station_id \nGROUP BY S.id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.190", "db_id": "bike_1", "question": "For each start station id, what is its name, longitude and average duration of trips started there?", "rationale": ["Identify the relevant tables: We need data from the 'station' table for station details and the 'trip' table for trip durations.", "Select the required columns: We need the station id, name, longitude from the 'station' table and the average duration of trips from the 'trip' table.", "Join the tables: We will join the 'station' table with the 'trip' table on the station id to correlate trips with their starting stations.", "Calculate the average duration: Use the AVG() function to calculate the average duration of trips for each station.", "Group the results: Use GROUP BY to group the results by station id, name, and longitude to get the average duration for each station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT S.id, S.name, S.long, AVG(T.duration) AS average_duration\nFROM station AS S\nJOIN trip AS T ON S.id = T.start_station_id\nGROUP BY S.id, S.name, S.long;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average latitude and longitude of bike stations from the 'station' table where trips have started. The placeholders in the query allow for further filtering or modifications based on specific criteria.\",\n        \"virtual_table\": \"SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id\"\n    }\n}\n"}
{"sample_id": "train.192", "db_id": "bike_1", "question": "For each end station id, what is its name, latitude, and minimum duration for trips ended there?", "rationale": ["We need to retrieve the end station id, name, latitude, and minimum duration for trips that ended at each station.", "To do this, we will join the 'station' table with the 'trip' table on the end station id.", "We will select the station's id, name, and latitude from the 'station' table.", "We will also calculate the minimum duration of trips from the 'trip' table using the MIN() function.", "Finally, we will group the results by the station's id, name, and latitude to ensure we get the minimum duration for each unique station."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.id, s.name, s.lat, MIN(t.duration) AS min_duration\nFROM station AS s\nJOIN trip AS t ON s.id = t.end_station_id\nGROUP BY s.id, s.name, s.lat;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of trips from the 'trip' table, specifically focusing on those that started at various bike stations. The results are ordered by the number of docks available at each station in descending order, allowing users to see which stations with the most docks are associated with the trips. The placeholder in the LIMIT clause represents the maximum number of trip IDs to return.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.196", "db_id": "bike_1", "question": "What are all the different zip codes that have a maximum dew point that was always below 70?", "rationale": ["We need to find all different zip codes where the maximum dew point was always below 70.", "To achieve this, we will select distinct zip codes from the weather table.", "We will apply a condition in the WHERE clause to filter records where max_dew_point_f is less than 70."], "gold_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f < 70", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.205", "db_id": "bike_1", "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.", "rationale": ["Identify the relevant tables: 'weather' for humidity data and 'trip' for trip counts.", "We need to find zip codes where the average mean humidity is below 70. This requires grouping by zip code and calculating the average humidity.", "We also need to ensure that at least 100 trips took place for each zip code. This requires counting the number of trips per zip code.", "Join the 'weather' and 'trip' tables on the zip code to combine the data needed for both conditions.", "Use GROUP BY to aggregate the results by zip code, and use HAVING to filter based on the average humidity and trip count."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code \nFROM weather \nJOIN trip ON weather.zip_code = trip.zip_code \nGROUP BY zip_code \nHAVING AVG(mean_humidity) < 70 AND COUNT(trip.id) >= 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.206", "db_id": "bike_1", "question": "What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?", "rationale": ["Identify the relevant tables: We need to use the 'trip' table to count the number of trips per zip code and the 'weather' table to calculate the average mean humidity per zip code.", "Determine the conditions: We need to find zip codes with an average mean humidity below 70 and at least 100 trips.", "Use a subquery: Create a subquery that selects zip codes from the 'weather' table, grouping by zip code and filtering for those with an average mean humidity below 70.", "Count trips: In the main query, count the number of trips for each zip code in the 'trip' table and filter for those with at least 100 trips.", "Combine results: Use the IN clause to filter the main query based on the results of the subquery."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code \nFROM trip \nWHERE zip_code IN (\n    SELECT zip_code \n    FROM weather \n    GROUP BY zip_code \n    HAVING AVG(mean_humidity) < 70\n) \nGROUP BY zip_code \nHAVING COUNT(id) >= 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the maximum temperature reached a specified threshold. The placeholder in the WHERE clause represents the minimum temperature value to filter the results.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE max_temperature_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.304", "db_id": "product_catalog", "question": "What are the attribute data types with more than 3 attribute definitions?", "rationale": ["Identify the table that contains the attribute data types, which is 'Attribute_Definitions'.", "We need to group the results by 'attribute_data_type' to count how many definitions exist for each type.", "Use the COUNT function to count the number of 'attribute_id' for each 'attribute_data_type'.", "Apply the HAVING clause to filter the groups where the count is greater than 3."], "gold_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  3", "source_tables": ["attribute_definitions"], "pred_sql": "SELECT attribute_data_type\nFROM Attribute_Definitions\nGROUP BY attribute_data_type\nHAVING COUNT(attribute_id) > 3;", "hint": "\n"}
{"sample_id": "train.316", "db_id": "product_catalog", "question": "Find the entry names of the catalog with the attribute that have the most entries.", "rationale": ["Identify the relevant tables: Catalog_Contents for entry names and Catalog_Contents_Additional_Attributes for attributes.", "We need to find the attribute that has the most entries, which requires counting the occurrences of each attribute_id in the Catalog_Contents_Additional_Attributes table.", "Use a subquery to select the attribute_id that has the maximum count of entries.", "Join the Catalog_Contents table with the Catalog_Contents_Additional_Attributes table on catalog_entry_id to get the entry names associated with the most frequent attribute.", "Filter the results to only include entries that have the most common attribute_id found in the subquery."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT cc.catalog_entry_name\nFROM Catalog_Contents cc\nJOIN Catalog_Contents_Additional_Attributes cca ON cc.catalog_entry_id = cca.catalog_entry_id\nWHERE cca.attribute_id IN (\n    SELECT attribute_id\n    FROM Catalog_Contents_Additional_Attributes\n    GROUP BY attribute_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.317", "db_id": "product_catalog", "question": "What is the entry name of the most expensive catalog (in USD)?", "rationale": ["Identify the relevant tables: Catalog_Contents for catalog entries and their prices, and Catalogs for catalog information.", "We need to find the entry name of the most expensive catalog, which implies sorting the entries by price in descending order.", "Join the Catalog_Contents table with the Catalogs table to access the catalog entry names and their prices.", "Use the ORDER BY clause to sort the entries by price_in_dollars in descending order to get the most expensive entry at the top.", "Limit the results to 1 to get only the most expensive catalog entry name."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1", "source_tables": ["catalog_contents"], "pred_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalogs AS t2 ON t1.catalog_level_number = t2.catalog_id ORDER BY t1.price_in_dollars DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.330", "db_id": "product_catalog", "question": "What are the names of catalog entries with level number 8?", "rationale": ["Identify the relevant tables: Catalog_Contents and Catalog_Structure.", "We need to retrieve the names of catalog entries, which are found in the Catalog_Contents table under the column catalog_entry_name.", "The level number we are interested in is 8, which is found in the Catalog_Structure table under the column catalog_level_number.", "We will join the Catalog_Contents table with the Catalog_Structure table on the catalog_level_number to filter the entries by the specified level number.", "Finally, we will select the catalog_entry_name from the Catalog_Contents where the catalog_level_number in the Catalog_Structure is 8."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  '8'", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Structure AS t2 ON t1.catalog_level_number = t2.catalog_level_number WHERE t2.catalog_level_number = '8'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.331", "db_id": "product_catalog", "question": "Find the names of the products with length smaller than 3 or height greater than 5.", "rationale": ["Identify the table that contains product information, which is the Catalog_Contents table.", "Determine the relevant columns needed for the query: catalog_entry_name for product names, length for the length condition, and height for the height condition.", "Construct the SQL SELECT statement to retrieve the catalog_entry_name from the Catalog_Contents table.", "Add the WHERE clause to filter products based on the conditions: length smaller than 3 or height greater than 5."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name \nFROM Catalog_Contents \nWHERE length < 3 OR height > 5;", "hint": "\n"}
{"sample_id": "train.332", "db_id": "product_catalog", "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.", "rationale": ["Identify the relevant table: Catalog_Contents contains the length of catalog entries and their names.", "Formulate the condition: We need to find entries where the length is below 3 or above 5.", "Select the catalog entry names: We will select the 'catalog_entry_name' from the Catalog_Contents table where the length condition is met."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT cc.catalog_entry_name FROM Catalog_Contents cc WHERE (cc.length < 3 OR cc.length > 5);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.338", "db_id": "product_catalog", "question": "On which days more than one revisions were made on catalogs.", "rationale": ["Identify the relevant table: The question pertains to revisions made on catalogs, so we will focus on the 'Catalogs' table.", "Determine the relevant columns: We need the 'date_of_latest_revision' to group by the days and count the number of revisions.", "Use COUNT function: We will count the number of catalogs that have the same 'date_of_latest_revision'.", "Group the results: We will group the results by 'date_of_latest_revision' to aggregate the counts for each day.", "Filter the results: We will use HAVING to filter out the days where the count of revisions is more than one."], "gold_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1", "source_tables": ["catalogs"], "pred_sql": "SELECT date_of_latest_revision, COUNT(*) as revision_count \nFROM Catalogs \nGROUP BY date_of_latest_revision \nHAVING COUNT(*) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of catalog levels from the 'Catalog_Structure' table that are associated with entries in the 'Catalog_Contents' table. The results are ordered by the price in dollars of the catalog entries, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t2.catalog_level_name FROM catalog_contents AS t1 JOIN catalog_structure AS t2 ON t1.catalog_level_number  =  t2.catalog_level_number ORDER BY t1.price_in_dollars LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their origins and destinations.", "Determine the required information: We need to find the origins of flights that are headed to Honolulu.", "Construct the SQL query: Use a SELECT statement to retrieve the 'origin' column from the 'flight' table where the 'destination' column matches 'Honolulu'."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight WHERE destination = 'Honolulu'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the origins of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\",\n        \"virtual_table\": \"SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the columns needed: We need 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We want flights that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query: Use a SELECT statement to retrieve the required columns from the 'flight' table with the specified conditions."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the origins of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\",\n        \"virtual_table\": \"SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the necessary information about flights, including their prices.", "Determine the columns needed: We need the 'price' column to calculate the average price of flights.", "Apply the condition for the specific route: We need to filter the flights where the origin is 'LA' and the destination is 'Honolulu'.", "Use the AVG() function to calculate the average price of the filtered flights."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT AVG(price) AS average_price FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the origins of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\",\n        \"virtual_table\": \"SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["We need to retrieve the names of the aircraft and the number of flights associated with each aircraft.", "To do this, we will select the 'name' column from the 'aircraft' table.", "We will also count the number of flight numbers ('flno') from the 'flight' table for each aircraft.", "To connect the two tables, we will use a LEFT JOIN on the 'aid' column, which is the common key between 'aircraft' and 'flight'.", "Finally, we will group the results by the aircraft ID ('aid') and name to get the count of flights for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT a.name, COUNT(f.flno) AS number_of_flights \nFROM aircraft a \nLEFT JOIN flight f ON a.aid = f.aid \nGROUP BY a.aid, a.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the flight numbers from the 'Flight' table, ordered by the distance of each flight in ascending order. The placeholder in the LIMIT clause represents the maximum number of flight numbers to be returned.\",\n        \"virtual_table\": \"SELECT flno FROM Flight ORDER BY distance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables involved: We need data from the 'aircraft' table for aircraft names and the 'flight' table for flight counts.", "Determine the relationship: The 'flight' table has a foreign key 'aid' that relates to the 'aircraft' table's 'aid'.", "Use a LEFT JOIN to include all aircraft even if they have no flights.", "Count the number of flights for each aircraft using COUNT(flight.flno).", "Group the results by aircraft name to get the count for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT aircraft.name, COUNT(flight.flno) AS flight_count \nFROM aircraft \nLEFT JOIN flight ON aircraft.aid = flight.aid \nGROUP BY aircraft.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the origins of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.\",\n        \"virtual_table\": \"SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["Identify the main table to query from, which is the 'employee' table to get employee names.", "We need to find employees who are not certified to fly a specific aircraft, in this case, the 'Boeing 737-800'.", "To find certified employees, we will use the 'certificate' table and join it with the 'aircraft' table to filter by aircraft name.", "The subquery will select employee IDs (eid) from the 'certificate' table where the associated aircraft is 'Boeing 737-800'.", "The main query will select names from the 'employee' table where the employee ID is not in the list of IDs returned by the subquery."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.name \nFROM employee e \nWHERE e.eid NOT IN (\n    SELECT c.eid \n    FROM certificate c \n    JOIN aircraft a ON c.aid = a.aid \n    WHERE a.name = 'Boeing 737-800'\n);", "hint": "\n"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["We need to find the name of the aircraft with the fewest number of certificates held by employees.", "To do this, we will join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid).", "We will group the results by the aircraft ID to count the number of certificates for each aircraft.", "Next, we will order the results by the count of certificates in ascending order to get the aircraft with the fewest certificates at the top.", "Finally, we will limit the results to just one entry to get the aircraft with the fewest certificates."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nORDER BY COUNT(c.eid) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.432", "db_id": "flight_1", "question": "What are the names of the aircraft that the least people are certified to fly?", "rationale": ["Identify the relevant tables: We need to find aircraft names and the number of employees certified to fly each aircraft, so we will use the 'aircraft' and 'certificate' tables.", "Join the tables: We will join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid) to link aircraft with their certified employees.", "Group by aircraft: We will group the results by the aircraft ID to count the number of certifications for each aircraft.", "Count certifications: Use COUNT(c.eid) to count how many employees are certified for each aircraft.", "Order by count: We will order the results in ascending order based on the count of certifications to find the aircraft with the least certifications.", "Limit the results: Finally, we will limit the results to 1 to get the aircraft with the least number of certified employees."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nORDER BY COUNT(c.eid) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["Identify the relevant tables: employee, certificate, and aircraft.", "We need to find employees who have certificates to fly aircraft with a distance greater than 5000.", "Join the employee table with the certificate table on employee ID (eid) and then join with the aircraft table on aircraft ID (aid).", "Filter the results to include only those aircraft where the distance is greater than 5000.", "Group the results by employee ID to count the number of certificates each employee has.", "Order the results by the count of certificates in descending order to find the employee with the most certificates.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.salary, e.name \nFROM employee e \nJOIN certificate c ON e.eid = c.eid \nJOIN aircraft a ON c.aid = a.aid \nWHERE a.distance > 5000 \nGROUP BY e.eid \nORDER BY COUNT(c.aid) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The user is asking for all the different food allergies, which implies we need to retrieve unique allergy types.", "We will use the 'Allergy_Type' table to get the different types of allergies.", "To ensure we get only unique allergy types, we will use the DISTINCT keyword in our SQL query."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT AllergyType FROM Allergy_Type;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the type or category of a specific allergy from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the name of the allergy being queried.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type WHERE allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.452", "db_id": "allergy_1", "question": "How many animal type allergies exist?", "rationale": ["Identify the relevant table: Allergy_Type contains the allergy types.", "Determine the requirement: We need to count distinct allergy types.", "Construct the SQL query: Use COUNT and DISTINCT to count unique AllergyType entries."], "gold_sql": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  'animal'", "source_tables": ["allergy_type"], "pred_sql": "SELECT count(DISTINCT AllergyType) FROM Allergy_Type", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    }\n}\n"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["Identify the relevant tables: Allergy_Type and Has_Allergy are needed to find the allergy types and their counts.", "Join the Allergy_Type table with the Has_Allergy table on the Allergy column to associate allergies with their types.", "Group the results by AllergyType to count the number of allergies for each type.", "Use COUNT(Allergy) to get the number of allergies for each type.", "Order the results in descending order based on the count of allergies to find the type with the most allergies.", "Limit the results to 1 to get only the top allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(Allergy) AS AllergyCount \nFROM Allergy_Type \nJOIN Has_Allergy ON Allergy_Type.Allergy = Has_Allergy.Allergy \nGROUP BY AllergyType \nORDER BY AllergyCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct allergy types from the 'Allergy_Type' table. The result will indicate how many unique categories of allergies are present in the database.\",\n        \"virtual_table\": \"SELECT count(DISTINCT allergytype) FROM Allergy_type\"\n    }\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["We need to find the least common allergy type.", "To do this, we will join the 'Has_Allergy' table with the 'Allergy_Type' table on the 'Allergy' column.", "We will group the results by 'AllergyType' to count how many students have each type of allergy.", "We will use COUNT(*) to count the number of occurrences of each allergy type.", "To find the least common allergy type, we will order the results by the count in ascending order.", "Finally, we will limit the results to 1 to get only the least common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(*) as AllergyCount \nFROM Has_Allergy \nJOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy \nGROUP BY AllergyType \nORDER BY AllergyCount ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the type or category of a specific allergy from the 'Allergy_Type' table. The placeholder in the WHERE clause represents the name of the allergy being queried.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type WHERE allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student names, which is the 'Student' table.", "To get the full names, we need to concatenate the 'Fname' and 'LName' columns.", "Use the SQL SELECT statement to retrieve the concatenated names as 'FullName'."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName FROM Student;", "hint": "\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the relevant table: The 'Student' table contains the information about students, including their gender.", "Determine the required information: We need the student IDs (StuID) for all male students.", "Use the provided hint: The hint suggests a virtual table that selects StuID from the Student table where Sex matches a specific value.", "Replace the placeholder in the hint with 'Male' to filter for male students."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the major information, which is the 'Student' table.", "To find the largest major, we need to count the number of students in each major.", "We will use the COUNT function to count the number of students for each major.", "We will group the results by the 'Major' column to get the count for each major.", "To find the largest major, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.502", "db_id": "allergy_1", "question": "Give the advisor with the most students.", "rationale": ["Identify the relevant table: The 'Student' table contains the 'Advisor' and 'StuID' columns.", "Count the number of students for each advisor: Use COUNT(StuID) to count the number of students associated with each advisor.", "Group the results by advisor: Use GROUP BY Advisor to aggregate the counts for each advisor.", "Order the results: Use ORDER BY StudentCount DESC to sort the advisors by the number of students in descending order.", "Limit the results to the top advisor: Use LIMIT 1 to get only the advisor with the most students."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(StuID) AS StudentCount\nFROM Student\nGROUP BY Advisor\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["Identify the tables involved: Has_Allergy and Allergy_Type.", "Determine the relationship between the tables: Has_Allergy links students to their allergies, and Allergy_Type categorizes those allergies.", "We need to count the number of students with a specific allergy, which is 'cat' in this case.", "Use a JOIN to combine the two tables on the Allergy column.", "Filter the results using a WHERE clause to specify the allergy type as 'cat'.", "Use the COUNT function to get the total number of students with cat allergies."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'cat'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the tables involved: Has_Allergy and Allergy_Type.", "Determine the relationship between the tables: Has_Allergy links students to their allergies, and Allergy_Type categorizes those allergies.", "We need to count the number of students affected by cat allergies, which means we need to filter the results based on the allergy type.", "Use a JOIN to combine the two tables on the Allergy column.", "Apply a WHERE clause to filter for the specific allergy type, which is 'cat'.", "Use the COUNT function to get the total number of students with cat allergies."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'cat'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the tables needed: Has_Allergy for allergies, Allergy_Type for allergy types, and Student for student details.", "Join the Has_Allergy table with the Allergy_Type table to get the allergy types associated with each student.", "Join the resulting table with the Student table to filter by gender (female).", "Use a WHERE clause to specify that we are only interested in female students who have allergies to either milk or eggs.", "Count the number of students that meet these criteria."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy JOIN Student AS S ON T1.StuID = S.StuID WHERE S.Sex = 'Female' AND T2.Allergy IN ('milk', 'eggs')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.514", "db_id": "allergy_1", "question": "Which allergy is the most common?", "rationale": ["To find the most common allergy, we need to count how many students have each allergy.", "We will join the 'Has_Allergy' table with the 'Allergy_Type' table to get the allergy names and their counts.", "We will use the COUNT function to count the number of students for each allergy.", "We will group the results by the allergy name to get the count for each allergy.", "To find the most common allergy, we will order the results by the count in descending order.", "Finally, we will limit the results to 1 to get only the most common allergy."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT T2.Allergy, COUNT(*) as StudentCount FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy GROUP BY T2.Allergy ORDER BY StudentCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["Identify the tables needed: We need to get student information (last name and age) from the Student table and allergy information from the Has_Allergy table.", "We need to find students who have allergies to both milk and cat. This requires joining the Has_Allergy table twice: once for each allergy.", "Join the Student table with the Has_Allergy table on StuID to link students with their allergies.", "Use a WHERE clause to filter for students who have both allergies: one instance for 'milk' and another for 'cat'.", "Select the last name and age of the students who meet the criteria."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.LName, S.Age \nFROM Student S \nJOIN Has_Allergy HA1 ON S.StuID = HA1.StuID \nJOIN Has_Allergy HA2 ON S.StuID = HA2.StuID \nWHERE HA1.Allergy = 'milk' AND HA2.Allergy = 'cat';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the tables needed: We need to retrieve student information (last names and ages) and their allergies, so we will use the 'Student' and 'Has_Allergy' tables.", "Determine the join condition: The 'Has_Allergy' table links to the 'Student' table via the 'StuID' column, so we will perform a JOIN on these tables using this column.", "Specify the columns to select: We need the last names (LName) and ages (Age) of the students, so we will select these columns from the 'Student' table.", "Filter the results: We need to find students who are allergic to 'milk' and 'cat', so we will use a WHERE clause to filter the allergies in the 'Has_Allergy' table.", "Group the results: Since a student can have multiple allergies, we will group the results by 'StuID' to ensure we get unique students."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Student.LName, Student.Age \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat') \nGROUP BY Student.StuID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.523", "db_id": "allergy_1", "question": "Find the first name and gender of the student who has allergy to milk but not cat.", "rationale": ["Identify the columns needed: first name (Fname) and gender (Sex) of students.", "We need to find students who have an allergy to milk. This requires a subquery to select StuID from the Has_Allergy table where Allergy is 'milk'.", "We also need to exclude students who have an allergy to cat. This requires another subquery to select StuID from the Has_Allergy table where Allergy is 'cat'.", "Combine these conditions using the IN and NOT IN clauses in the main query to filter the students accordingly."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex \nFROM Student \nWHERE StuID IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'milk'\n) \nAND StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'cat'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    }\n}\n"}
{"sample_id": "train.524", "db_id": "allergy_1", "question": "What are the first name and gender of the students who have allergy to milk but can put up with cats?", "rationale": ["Identify the tables needed: We need to retrieve student information (first name and gender) from the Student table and their allergies from the Has_Allergy table.", "We need to find students who have an allergy to milk. This requires a join between the Student table and the Has_Allergy table where the allergy is 'milk'.", "We also need to ensure that these students do not have an allergy to cats. This requires another join on the Has_Allergy table where the allergy is 'cats'.", "To achieve this, we can join the Has_Allergy table twice: once for milk and once for cats, linking both to the Student table using the StuID.", "Finally, we select the first name and gender of the students who meet these criteria."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.Fname, S.Sex \nFROM Student S \nJOIN Has_Allergy HA1 ON S.StuID = HA1.StuID \nJOIN Has_Allergy HA2 ON S.StuID = HA2.StuID \nWHERE HA1.Allergy = 'milk' AND HA2.Allergy = 'cats'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the tables needed: We need to get student ages from the Student table, and we need to filter students based on their allergies from the Has_Allergy and Allergy_Type tables.", "Join the tables: We will join the Student table with the Has_Allergy table on StuID, and then join the result with the Allergy_Type table on Allergy.", "Filter by allergy types: We need to filter the results to include only those students who have allergies categorized as 'food' or 'animal'.", "Calculate the average age: We will use the AVG function to calculate the average age of the filtered students. We need to ensure that the age is treated as an integer for accurate calculation."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT AVG(CAST(S.age AS INTEGER)) FROM Student AS S JOIN Has_Allergy AS HA ON S.StuID = HA.StuID JOIN Allergy_Type AS AT ON HA.Allergy = AT.Allergy WHERE AT.AllergyType IN ('food', 'animal')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["Identify the requirement: We need the full names of students who are not allergic to any type of food.", "Understand the schema: We have three tables - Student, Has_Allergy, and Allergy_Type. We need to focus on the Student and Has_Allergy tables.", "Use the provided hint: The hint suggests using a virtual table that identifies students without allergies by using the EXCEPT clause.", "Construct the inner query: The inner query will select StuID from the Student table and exclude those who have allergies from the Has_Allergy table.", "Construct the outer query: The outer query will select the first name (Fname) and last name (LName) of students whose StuID is in the result of the inner query."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname, LName FROM Student WHERE StuID IN (SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_Allergy)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    }\n}\n"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["Identify the relevant tables: Has_Allergy, Allergy_Type, and Student.", "We need to count the number of male students with food allergies.", "Join the Has_Allergy table with the Allergy_Type table to filter by allergy type (Food).", "Join the resulting table with the Student table to filter by sex (M).", "Use the COUNT function to get the total number of male students with food allergies."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy JOIN Student AS S ON T1.StuID = S.StuID WHERE T2.AllergyType = 'Food' AND S.Sex = 'M'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables involved: We need to get student information from the 'Student' table and allergy information from the 'Has_Allergy' table.", "Determine the relationship: The 'Has_Allergy' table links students to their allergies via the 'StuID' column.", "Select the required fields: We need the distinct first names (Fname) and city codes (city_code) of students with specific allergies.", "Filter the results: We want to find students who have allergies to either 'milk' or 'cat'.", "Construct the SQL query using JOIN to combine the 'Student' and 'Has_Allergy' tables, applying the necessary filters and selecting distinct values."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code \nFROM Student S \nJOIN Has_Allergy HA ON S.StuID = HA.StuID \nWHERE HA.Allergy IN ('milk', 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.\",\n        \"virtual_table\": \"SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy\"\n    }\n}\n"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["Identify the tables needed: We need information from the Student table for first names and city codes, and from the Has_Allergy table to filter students based on their allergies.", "Determine the relationship: The Has_Allergy table links students to their allergies through the StuID column, which is a foreign key in Has_Allergy referencing the Student table.", "Select the distinct first names and city codes: We need to ensure that the results do not contain duplicates, hence we use DISTINCT.", "Filter the allergies: We need to include only those students who have allergies to either 'milk' or 'cat'. This is done using the WHERE clause with the IN operator to specify the allergies of interest."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT Student.Fname, Student.city_code \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Has_Allergy.Allergy IN ('milk', 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the allergy type being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["Identify the relevant table: The invoices table contains the billing country and total amount for each invoice.", "Select the required columns: We need to select the billing_country and calculate the average of the total column.", "Group the results: To get the average invoice size per country, we will group the results by billing_country.", "Order the results: We want the top countries by average invoice size, so we will order the results in descending order of average_invoice_size.", "Limit the results: To get only the top countries, we will limit the results to 10."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size\nFROM invoices\nGROUP BY billing_country\nORDER BY average_invoice_size DESC\nLIMIT 10;", "hint": "\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["Identify the relevant table: The invoices table contains the billing information including the state.", "Determine the required fields: We need the billing_state and a count of invoices for each state.", "Use the COUNT() function to count the number of invoices for each state.", "Group the results by billing_state to get the count for each state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state;", "hint": "\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["Identify the relevant table: The 'invoices' table contains the 'billing_state' column and the unique identifier for each invoice.", "Count the number of invoices per state: Use the COUNT() function to count the number of invoices for each state.", "Group the results by state: Use GROUP BY to aggregate the results based on 'billing_state'.", "Order the results: Use ORDER BY to sort the results in descending order based on the count of invoices."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state\nORDER BY invoice_count DESC;", "hint": "\n"}
{"sample_id": "train.568", "db_id": "store_1", "question": "What is the number of invoices and total money billed in them from CA?", "rationale": ["Identify the relevant tables: invoices and customers.", "We need to count the number of invoices and sum the total billed amount, so we will use COUNT() and SUM() functions.", "To get the invoices related to customers from California (CA), we need to join the invoices table with the customers table on the customer_id.", "Filter the results where the state of the customer is 'CA'.", "Construct the SQL query using the SELECT statement to retrieve the count of invoices and the sum of the total billed amount."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS number_of_invoices, SUM(total) AS total_billed\nFROM invoices\nJOIN customers ON invoices.customer_id = customers.id\nWHERE customers.state = 'CA';", "hint": "\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the table that contains employee information, which is the 'employees' table.", "Determine the columns needed for the output, which are 'email' and 'phone'.", "Filter the results to find the specific employee by their first name 'Astrid' and last name 'Gruber'.", "Construct the SQL SELECT statement to retrieve the desired columns from the 'employees' table with the appropriate WHERE clause."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "\n"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["Identify the relevant table: The question asks about customers, so we will use the 'customers' table.", "Determine the required information: We need to count the number of customers from California.", "Formulate the SQL query: We will use the COUNT() function to count the number of records where the state is 'California'.", "Construct the SELECT statement: We will select the count and specify the table and condition in the WHERE clause."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) AS customer_count FROM customers WHERE state = 'California';", "hint": "\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: employees and customers.", "We need to find the employee who supported the most customers, so we will join the employees table with the customers table on the support_rep_id.", "We will group the results by employee id to count the number of customers each employee supports.", "We will order the results by the count of customers in descending order to get the employee with the most customers at the top.", "Finally, we will limit the results to 1 to get only the top employee.", "Select the full name of the employee by concatenating first_name and last_name."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["Identify the relevant tables: invoices and customers.", "We need to count the number of invoices associated with a specific customer, Luca Mancini.", "Join the invoices table with the customers table on the customer_id field.", "Filter the results to only include invoices for the customer with first name 'Luca' and last name 'Mancini'.", "Use the COUNT() function to count the number of invoices that match the criteria."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "pred_sql": "SELECT COUNT(*) AS order_count \nFROM invoices \nJOIN customers ON invoices.customer_id = customers.id \nWHERE customers.first_name = 'Luca' AND customers.last_name = 'Mancini';", "hint": "\n"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["Identify the tables involved: We need to find the album title from the 'albums' table and the track name from the 'tracks' table.", "Determine the relationship: The 'tracks' table has a foreign key 'album_id' that references the 'id' in the 'albums' table.", "Construct the JOIN clause: We will join the 'albums' table with the 'tracks' table on the condition that 'albums.id' matches 'tracks.album_id'.", "Specify the condition: We need to filter the results to find the album that contains the track named 'Balls to the Wall'.", "Select the desired output: We want to retrieve the 'title' from the 'albums' table."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.album_id WHERE T2.name = 'Balls to the Wall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.626", "db_id": "store_1", "question": "What is the name of all tracks in the album named Balls to the Wall?", "rationale": ["Identify the tables involved: We need to get track names from the 'tracks' table and filter them based on the album title from the 'albums' table.", "Determine the relationship: The 'tracks' table has a foreign key 'album_id' that references the 'id' in the 'albums' table.", "Construct the JOIN clause: We will join the 'albums' table (aliased as T1) with the 'tracks' table (aliased as T2) on the condition that T1.id = T2.album_id.", "Add the WHERE clause: We need to filter the results to only include tracks from the album titled 'Balls to the Wall'.", "Formulate the final SQL query: Combine all the components into a complete SQL statement."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.album_id WHERE T1.title = 'Balls to the Wall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.630", "db_id": "store_1", "question": "What are the names of all Rock tracks that are stored on MPEG audio files?", "rationale": ["Identify the relevant tables: tracks, media_types, and genres are needed to get track names, their media type, and genre.", "Join the tracks table with the media_types table on media_type_id to filter for MPEG audio files.", "Join the tracks table with the genres table on genre_id to filter for Rock tracks.", "Use a WHERE clause to specify that the media type must be 'MPEG audio' and the genre must be 'Rock'.", "Select the name of the tracks that meet these criteria."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT T1.name \nFROM tracks AS T1 \nJOIN media_types AS T2 ON T1.media_type_id = T2.id \nJOIN genres AS T3 ON T1.genre_id = T3.id \nWHERE T2.name = 'MPEG audio' AND T3.name = 'Rock';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the relevant tables: tracks, genres, and media_types.", "Join the tracks table with the genres table on genre_id to filter tracks by genre.", "Join the tracks table with the media_types table on media_type_id to filter tracks by media type.", "Add a WHERE clause to filter for tracks that belong to the 'Rock' genre and have the media type 'MPEG'.", "Select the name of the tracks that meet these criteria."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN genres ON tracks.genre_id = genres.id \nJOIN media_types ON tracks.media_type_id = media_types.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of different media types from the 'media_types' table. The query retrieves all media type names without any filtering conditions.\",\n        \"virtual_table\": \"SELECT name FROM media_types;\"\n    }\n}\n"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["Identify the relevant tables: We need to find tracks that a specific customer (Dean Peeters) bought, which involves the 'tracks', 'invoices', 'invoice_lines', and 'customers' tables.", "Join the tables: We will join 'invoice_lines' with 'invoices' to link the purchased tracks to the invoices, and then join 'invoices' with 'customers' to filter by the specific customer.", "Filter by customer name: We will add a WHERE clause to filter the results to only include tracks purchased by Dean Peeters by checking both the first and last name in the 'customers' table."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "pred_sql": "SELECT T3.name \nFROM invoice_lines AS T1 \nJOIN invoices AS T2 ON T1.invoice_id = T2.id \nJOIN tracks AS T3 ON T1.track_id = T3.id \nJOIN customers AS T4 ON T2.customer_id = T4.id \nWHERE T4.first_name = 'Dean' AND T4.last_name = 'Peeters';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n        \"virtual_table\": \"SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.686", "db_id": "customers_card_transactions", "question": "What are the full names of customers who do not have any accounts?", "rationale": ["Identify the information needed: full names of customers without accounts.", "To get the full names, we need to select the first and last names from the Customers table.", "We need to filter out customers who have accounts, which requires a subquery.", "The subquery selects customer_ids from the Accounts table.", "The main query selects customer_first_name and customer_last_name from the Customers table where the customer_id is not in the list of customer_ids from the Accounts table."], "gold_sql": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nWHERE customer_id NOT IN (\n    SELECT customer_id\n    FROM Accounts\n);", "hint": "\n"}
{"sample_id": "train.688", "db_id": "customers_card_transactions", "question": "What are the full names of customers who have accounts?", "rationale": ["Identify the tables involved: Customers and Accounts.", "Determine the relationship between the tables: Customers have a unique identifier (customer_id) that links to Accounts.", "Select the required fields: We need the full names of customers, which can be constructed by concatenating first and last names.", "Use a JOIN clause to combine the Customers and Accounts tables based on the customer_id.", "Construct the SQL query to select the concatenated full name from the Customers table where there is a matching account."], "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Customers.customer_first_name || ' ' || Customers.customer_last_name AS full_name\nFROM Customers\nJOIN Accounts ON Customers.customer_id = Accounts.customer_id;", "hint": "\n"}
{"sample_id": "train.704", "db_id": "customers_card_transactions", "question": "Return the full name and phone of the customer who has card number 4560596484842.", "rationale": ["Identify the required information: full name and phone number of the customer.", "The full name can be constructed by concatenating the first name and last name of the customer.", "The customer information is stored in the Customers table, while the card information is in the Customers_Cards table.", "To link the customer to their card, a JOIN operation is needed between Customers and Customers_Cards on the customer_id.", "The WHERE clause will filter the results to only include the customer with the specified card number (4560596484842)."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.card_number  =  '4560596484842'", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT Customers.customer_first_name || ' ' || Customers.customer_last_name AS full_name, Customers.customer_phone \nFROM Customers \nJOIN Customers_Cards ON Customers.customer_id = Customers_Cards.customer_id \nWHERE Customers_Cards.card_number = '4560596484842';", "hint": "\n"}
{"sample_id": "train.717", "db_id": "customers_card_transactions", "question": "What is the customer id, first and last name with least number of accounts.", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to find the customer ID, first name, and last name, so we will select these columns from the Customers table.", "To find the number of accounts per customer, we will join the Customers table with the Accounts table on the customer_id.", "We will group the results by customer_id, customer_first_name, and customer_last_name to count the number of accounts for each customer.", "We will order the results by the count of accounts in ascending order to get the customer with the least number of accounts.", "Finally, we will limit the results to 1 to get only the customer with the least number of accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name\nORDER BY COUNT(a.account_id) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.718", "db_id": "customers_card_transactions", "question": "Return the id and full name of the customer who has the fewest accounts.", "rationale": ["We need to find the customer with the fewest accounts.", "To do this, we will join the Customers table with the Accounts table on the customer_id.", "We will group the results by customer_id to count the number of accounts each customer has.", "We will order the results by the count of accounts in ascending order to get the customer with the fewest accounts at the top.", "Finally, we will limit the results to 1 to get only the customer with the fewest accounts.", "We will select the customer_id and concatenate the first and last name to get the full name."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id\nORDER BY COUNT(a.account_id) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.721", "db_id": "customers_card_transactions", "question": "What is the card type code with most number of cards?", "rationale": ["To find the card type code with the most number of cards, we need to count the occurrences of each card type code in the Customers_Cards table.", "We will use the COUNT function to count the number of card_id entries for each card_type_code.", "We will group the results by card_type_code to aggregate the counts for each type.", "To get the card type code with the highest count, we will order the results in descending order based on the count.", "Finally, we will limit the results to 1 to get only the top card type code."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "pred_sql": "SELECT card_type_code FROM Customers_Cards GROUP BY card_type_code ORDER BY COUNT(card_id) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique card type codes from the 'Customers_Cards' table. The placeholder in the SELECT statement allows for the retrieval of distinct card types without any filtering conditions.\",\n        \"virtual_table\": \"SELECT DISTINCT card_type_code FROM Customers_Cards\"\n    }\n}\n"}
{"sample_id": "train.735", "db_id": "customers_card_transactions", "question": "Show the number of transaction types.", "rationale": ["The user wants to know the number of transaction types.", "To achieve this, we need to count the occurrences of each transaction type in the Financial_Transactions table.", "We will use the COUNT() function to count the number of transactions for each type.", "We will group the results by transaction_type to get the count for each distinct type."], "gold_sql": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, COUNT(*) as transaction_count FROM Financial_Transactions GROUP BY transaction_type;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of customer cards from the 'Customers_Cards' table that match a specific card type. The placeholder in the WHERE clause represents the card type code being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Customers_cards WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.743", "db_id": "customers_card_transactions", "question": "What is the transaction type that has processed the greatest total amount in transactions?", "rationale": ["Identify the relevant table: Financial_Transactions contains the transaction details including type and amount.", "We need to group the transactions by their type to calculate the total amount for each type.", "Use the SUM function to calculate the total amount for each transaction type.", "Order the results in descending order to find the transaction type with the greatest total amount.", "Limit the results to 1 to get only the top transaction type."], "gold_sql": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, SUM(transaction_amount) AS total_amount\nFROM Financial_Transactions\nGROUP BY transaction_type\nORDER BY total_amount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.893", "db_id": "insurance_fnol", "question": "What are the customer phone numbers under the policy \"Life Insurance\"?", "rationale": ["Identify the relevant table: Available_Policies contains the customer phone numbers and policy types.", "Determine the specific policy type we are interested in: 'Life Insurance'.", "Construct the SQL query to select Customer_Phone from Available_Policies where the policy_type_code matches 'Life Insurance'."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "pred_sql": "SELECT Customer_Phone FROM Available_Policies WHERE policy_type_code = 'Life Insurance'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the contact phone numbers of customers from the 'Available_Policies' table who have a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code.\",\n        \"virtual_table\": \"SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.895", "db_id": "insurance_fnol", "question": "Which policy type has the most records in the database?", "rationale": ["Identify the relevant table: The question pertains to policy types, so we will focus on the 'Available_Policies' table.", "Count the records for each policy type: We need to group the records by 'policy_type_code' and count how many records exist for each type.", "Sort the results: To find the policy type with the most records, we will order the results in descending order based on the count.", "Limit the results: Since we only want the policy type with the most records, we will limit the output to 1."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "pred_sql": "SELECT policy_type_code, COUNT(*) as record_count \nFROM Available_Policies \nGROUP BY policy_type_code \nORDER BY record_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the contact phone numbers of customers from the 'Available_Policies' table who have a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code.\",\n        \"virtual_table\": \"SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.897", "db_id": "insurance_fnol", "question": "What are all the customer phone numbers under the most popular policy type?", "rationale": ["Identify the relevant table: We need to get customer phone numbers, which are in the Available_Policies table.", "Determine the most popular policy type: We need to find out which policy type is the most popular. This can be done by counting the number of customers associated with each policy type.", "Join the Customers_Policies table with the Available_Policies table to access the policy type codes and count the occurrences of each policy type.", "Group the results by policy type code and order them by the count in descending order to find the most popular one.", "Use a subquery to get the most popular policy type code and use it in the main query to filter the customer phone numbers."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT Customer_Phone FROM Available_Policies WHERE policy_type_code = (SELECT policy_type_code FROM Customers_Policies cp JOIN Available_Policies ap ON cp.Policy_ID = ap.Policy_ID GROUP BY ap.policy_type_code ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the contact phone numbers of customers from the 'Available_Policies' table who have a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code.\",\n        \"virtual_table\": \"SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.898", "db_id": "insurance_fnol", "question": "Find the phone numbers of customers using the most common policy type among the available policies.", "rationale": ["Identify the goal: We need to find the phone numbers of customers using the most common policy type.", "Determine the most common policy type: This can be done by grouping the policies in the Available_Policies table by policy_type_code and counting the occurrences of each type, ordering them in descending order, and limiting the result to the top one.", "Use the result of the subquery to filter the phone numbers: We will use the most common policy type obtained from the subquery in the WHERE clause of the main query to get the corresponding customer phone numbers."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT Customer_Phone FROM Available_Policies WHERE policy_type_code = (SELECT policy_type_code FROM Available_Policies GROUP BY policy_type_code ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the contact phone numbers of customers from the 'Available_Policies' table who have a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code.\",\n        \"virtual_table\": \"SELECT customer_phone FROM available_policies WHERE policy_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1060", "db_id": "match_season", "question": "Show the players from college UCLA.", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players and their colleges.", "Determine the filtering condition: We need to filter players who attended UCLA.", "Construct the SQL query: Use a SELECT statement to get the 'Player' column from the 'match_season' table where the 'College' is 'UCLA'.", "Include the ORDER BY clause to sort the results by college name, even though we are filtering for a specific college."], "gold_sql": "SELECT Player FROM match_season WHERE College  =  'UCLA'", "source_tables": ["match_season"], "pred_sql": "SELECT Player FROM match_season WHERE College = 'UCLA' ORDER BY College ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\",\n        \"virtual_table\": \"SELECT player FROM match_season ORDER BY College ASC\"\n    }\n}\n"}
{"sample_id": "train.1082", "db_id": "match_season", "question": "Show the season, the player, and the name of the team that players belong to.", "rationale": ["Identify the required columns: Season, Player, and Team.", "These columns are found in the match_season table.", "Construct the SELECT statement to retrieve these columns from the match_season table."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "pred_sql": "SELECT match_season.Season, match_season.Player, match_season.Team FROM match_season", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\",\n        \"virtual_table\": \"SELECT player FROM match_season ORDER BY College ASC\"\n    }\n}\n"}
{"sample_id": "train.1092", "db_id": "match_season", "question": "Show the country names and the corresponding number of players.", "rationale": ["Identify the tables needed: We need the 'country' table for country names and the 'match_season' table to count players.", "We need to join the 'country' table with the 'match_season' table on the country identifier, which is 'Country_id' in 'country' and 'Country' in 'match_season'.", "Use the COUNT() function to count the number of players for each country.", "Group the results by country name to get the count for each country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "pred_sql": "SELECT c.Country_name, COUNT(m.Player) AS Number_of_Players\nFROM country c\nJOIN match_season m ON c.Country_id = m.Country\nGROUP BY c.Country_name;", "hint": "\n"}
{"sample_id": "train.1098", "db_id": "match_season", "question": "Show the top 3 most common colleges of players in match seasons.", "rationale": ["We need to find the most common colleges of players in match seasons.", "To do this, we will select the 'College' column from the 'match_season' table.", "We will count the occurrences of each college using COUNT(*) and alias it as 'College_Count'.", "To get the most common colleges, we will group the results by 'College'.", "We will then order the results in descending order based on 'College_Count' to get the most common colleges at the top.", "Finally, we will limit the results to the top 3 colleges using LIMIT 3."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as College_Count FROM match_season GROUP BY College ORDER BY College_Count DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\",\n        \"virtual_table\": \"SELECT player FROM match_season ORDER BY College ASC\"\n    }\n}\n"}
{"sample_id": "train.1099", "db_id": "match_season", "question": "What are the three colleges from which the most players are from?", "rationale": ["We need to find the colleges with the most players.", "To do this, we will select the 'College' column from the 'match_season' table.", "We will count the number of players from each college using COUNT(*) and alias it as 'Player_Count'.", "We will group the results by 'College' to aggregate the player counts for each college.", "To get the colleges with the most players, we will order the results by 'Player_Count' in descending order.", "Finally, we will limit the results to the top 3 colleges."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as Player_Count \nFROM match_season \nGROUP BY College \nORDER BY Player_Count DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\",\n        \"virtual_table\": \"SELECT player FROM match_season ORDER BY College ASC\"\n    }\n}\n"}
{"sample_id": "train.1107", "db_id": "match_season", "question": "Return the names of countries that have players that play the Forward position, as well as players who play the Defender position.", "rationale": ["We need to find the names of countries that have players in specific positions (Forward and Defender).", "To do this, we will join the 'country' table with the 'match_season' table on the country identifier.", "We will select the distinct country names to avoid duplicates.", "The condition for the join will be that the player's position in the 'match_season' table must be either 'Forward' or 'Defender'."], "gold_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "pred_sql": "SELECT DISTINCT c.Country_name \nFROM country c \nJOIN match_season ms ON c.Country_id = ms.Country \nWHERE ms.Position IN ('Forward', 'Defender');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\",\n        \"virtual_table\": \"SELECT player FROM match_season ORDER BY College ASC\"\n    }\n}\n"}
{"sample_id": "train.1109", "db_id": "match_season", "question": "Return the colleges that have players who play the Midfielder position, as well as players who play the Defender position.", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players, their positions, and the colleges they attended.", "Determine the required positions: We need players who play as 'Midfielder' or 'Defender'.", "Use the WHERE clause to filter players based on their positions.", "Select the 'College' column to get the colleges of these players.", "Use DISTINCT to ensure that each college is listed only once in the result."], "gold_sql": "SELECT College FROM match_season WHERE POSITION  =  'Midfielder' INTERSECT SELECT College FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "pred_sql": "SELECT DISTINCT College FROM match_season WHERE Position IN ('Midfielder', 'Defender')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'match_season' table, ordered by their college names in ascending order. The placeholder in the ORDER BY clause represents the college names.\",\n        \"virtual_table\": \"SELECT player FROM match_season ORDER BY College ASC\"\n    }\n}\n"}
{"sample_id": "train.1222", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with type code \"Duplex\"?", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for apartment type.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to link bookings to their respective apartments.", "Filter the results to only include apartments with the type code 'Duplex'.", "Select the booking_start_date and booking_end_date from the filtered results."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  'Duplex'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT AB.booking_start_date, AB.booking_end_date \nFROM Apartment_Bookings AS AB \nJOIN Apartments AS A ON AB.apt_id = A.apt_id \nWHERE A.apt_type_code = 'Duplex'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1224", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with more than 2 bedrooms?", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "We need to select the booking start and end dates, which are in the Apartment_Bookings table.", "We need to filter apartments based on the number of bedrooms, which is in the Apartments table.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to access both booking dates and bedroom count.", "Apply the condition to filter apartments with more than 2 bedrooms."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT AB.booking_start_date, AB.booking_end_date \nFROM Apartment_Bookings AS AB \nJOIN Apartments AS A ON AB.apt_id = A.apt_id \nWHERE A.bedroom_count > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1225", "db_id": "apartment_rentals", "question": "Find the booking start date and end date for the apartments that have more than two bedrooms.", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to access both booking dates and bedroom count.", "Filter the results to include only those apartments that have more than two bedrooms by using a WHERE clause with the condition 'A.bedroom_count > 2'.", "Select the booking start date and end date from the joined tables."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT AB.booking_start_date, AB.booking_end_date \nFROM Apartment_Bookings AS AB \nJOIN Apartments AS A ON AB.apt_id = A.apt_id \nWHERE A.bedroom_count > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1229", "db_id": "apartment_rentals", "question": "Which apartments have bookings with status code \"Confirmed\"? Return their apartment numbers.", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking status and Apartments for apartment details.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to link bookings to their respective apartments.", "Filter the results to include only those bookings with a status code of 'Confirmed'.", "Select the apartment number from the Apartments table as the desired output."], "gold_sql": "SELECT DISTINCT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  'Confirmed'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT T2.apt_number \nFROM Apartment_Bookings AS T1 \nJOIN Apartments AS T2 ON T1.apt_id = T2.apt_id \nWHERE T1.booking_status_code = 'Confirmed';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides information about apartment bookings, specifically the apartment number and the start date of the booking. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n        \"virtual_table\": \"SELECT T2.apt_number ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id\"\n    }\n}\n"}
{"sample_id": "train.1232", "db_id": "apartment_rentals", "question": "Show the guest first names, start dates, and end dates of all the apartment bookings.", "rationale": ["Identify the required fields: guest first names, booking start dates, and booking end dates.", "Determine the relevant tables: Apartment_Bookings for booking details and Guests for guest information.", "Establish the relationship between the tables using the guest_id foreign key.", "Construct the SQL query using a JOIN to combine data from both tables based on the guest_id.", "Select the specified fields from the joined tables."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT T2.guest_first_name, T1.booking_start_date, T1.booking_end_date \nFROM Apartment_Bookings AS T1 \nJOIN Guests AS T2 ON T1.guest_id = T2.guest_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of guests along with the start dates of their apartment bookings. The placeholders in the query allow for filtering or additional conditions to be applied as needed.\",\n        \"virtual_table\": \"SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id\"\n    }\n}\n"}
{"sample_id": "train.1234", "db_id": "apartment_rentals", "question": "Show the start dates and end dates of all the apartment bookings made by guests with gender code \"Female\".", "rationale": ["Identify the tables involved: Apartment_Bookings for booking details and Guests for guest information.", "Determine the columns needed: booking_start_date and booking_end_date from Apartment_Bookings.", "Establish the relationship between the tables: Join Apartment_Bookings and Guests on guest_id.", "Filter the results based on the gender code: Only include guests with gender code 'Female'.", "Construct the SQL query using the identified tables, columns, and conditions."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  'Female'", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT T1.booking_start_date, T1.booking_end_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id = T2.guest_id WHERE T2.gender_code = 'Female'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start dates of apartment bookings along with the corresponding booking end dates for guests filtered by a specific gender. The placeholders in the WHERE clause represent the gender code of the guests.\",\n        \"virtual_table\": \"SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1238", "db_id": "apartment_rentals", "question": "Show the facility codes of apartments with more than 4 bedrooms.", "rationale": ["Identify the relevant tables: Apartment_Facilities and Apartments.", "Determine the relationship between the tables: Apartment_Facilities is linked to Apartments via the apt_id.", "Specify the condition: We need apartments with more than 4 bedrooms, which is indicated by the bedroom_count column in the Apartments table.", "Construct the SQL query using a JOIN to combine the two tables and apply the condition in the WHERE clause."], "gold_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "source_tables": ["apartments", "apartment_facilities"], "pred_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n        \"virtual_table\": \"SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1256", "db_id": "apartment_rentals", "question": "Show the top 3 apartment type codes sorted by the average number of rooms in descending order.", "rationale": ["We need to select the apartment type codes from the Apartments table.", "To find the average number of rooms for each apartment type code, we will use the AVG function on the room_count column.", "We will group the results by apt_type_code to calculate the average number of rooms for each type.", "To sort the results in descending order based on the average number of rooms, we will use the ORDER BY clause with AVG(room_count) DESC.", "Finally, we will limit the results to the top 3 apartment type codes using the LIMIT clause."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY AVG(room_count) DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n        \"virtual_table\": \"SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1258", "db_id": "apartment_rentals", "question": "Show the apartment type code that has the largest number of total rooms, together with the number of bathrooms and number of bedrooms.", "rationale": ["Identify the relevant table: The Apartments table contains the columns we need: apt_type_code, bathroom_count, bedroom_count, and room_count.", "Determine the requirement: We need to find the apartment type code with the largest number of total rooms.", "Use ORDER BY clause: We will order the results by room_count in descending order to get the apartment with the most rooms at the top.", "Limit the results: We will use LIMIT 1 to only get the top result after ordering.", "Select the necessary columns: We will select apt_type_code, bathroom_count, and bedroom_count from the Apartments table."], "gold_sql": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, bathroom_count, bedroom_count FROM Apartments ORDER BY room_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n        \"virtual_table\": \"SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1261", "db_id": "apartment_rentals", "question": "Which apartment type code appears the most often?", "rationale": ["Identify the relevant table: The Apartments table contains the apt_type_code which we need to analyze.", "Count the occurrences of each apartment type code: We will use COUNT(*) to count how many times each apt_type_code appears.", "Group the results by apt_type_code: This is done using GROUP BY to aggregate the counts for each type code.", "Order the results to find the most frequent type: We will order the results in descending order based on the count of each type code.", "Limit the results to the top one: We will use LIMIT 1 to get only the most frequently occurring apartment type code."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, COUNT(*) as type_count FROM Apartments GROUP BY apt_type_code ORDER BY type_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n        \"virtual_table\": \"SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1262", "db_id": "apartment_rentals", "question": "Show the most common apartment type code among apartments with more than 1 bathroom.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of bathrooms.", "Filter apartments: We need to filter apartments that have more than 1 bathroom, which is done using the WHERE clause.", "Group by apartment type: To find the most common apartment type, we will group the results by the apartment type code.", "Count occurrences: We will count the number of occurrences of each apartment type code using COUNT(*) and alias it as 'count'.", "Order results: To find the most common type, we will order the results in descending order based on the count.", "Limit results: Finally, we will limit the results to 1 to get the most common apartment type code."], "gold_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, COUNT(*) as count\nFROM Apartments\nWHERE bathroom_count > 1\nGROUP BY apt_type_code\nORDER BY count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n        \"virtual_table\": \"SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1272", "db_id": "apartment_rentals", "question": "Show the apartment numbers of apartments with unit status availability of both 0 and 1.", "rationale": ["Identify the relevant tables: Apartments and View_Unit_Status.", "We need to select the apartment numbers, so we will focus on the 'apt_number' column from the Apartments table.", "To check the availability status, we will join the Apartments table with the View_Unit_Status table on the 'apt_id' column.", "The condition for availability is specified as both 0 and 1, which means we will use the IN clause to filter the 'available_yn' column in the View_Unit_Status table."], "gold_sql": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1", "source_tables": ["view_unit_status", "apartments"], "pred_sql": "SELECT apt_number FROM Apartments AS A JOIN View_Unit_Status AS V ON A.apt_id = V.apt_id WHERE V.available_yn IN ('0', '1')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the facility codes of apartments that have a specified number of bedrooms. The placeholder in the WHERE clause represents the minimum number of bedrooms required for the apartments.\",\n        \"virtual_table\": \"SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1294", "db_id": "soccer_1", "question": "How many leagues are there in England?", "rationale": ["Identify the relevant table: The question pertains to leagues, so we will use the 'League' table.", "Determine the condition: We need to count the leagues specifically in England.", "Construct the SQL query: Use the COUNT function to count the number of records in the 'League' table where the name is 'England'."], "gold_sql": "SELECT count(*) FROM Country AS T1 JOIN League AS T2 ON T1.id  =  T2.country_id WHERE T1.name  =  'England'", "source_tables": ["country", "league"], "pred_sql": "SELECT COUNT(*) AS league_count FROM League WHERE name = 'England';", "hint": "\n"}
{"sample_id": "train.1303", "db_id": "soccer_1", "question": "List all of the player ids with a height of at least 180cm and an overall rating higher than 85.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to select player ids, so we will select the 'id' column from the Player table.", "We need to filter players based on height (at least 180cm) and overall rating (higher than 85).", "Join the Player table with Player_Attributes on the player_api_id to access both height and overall rating.", "Use the WHERE clause to apply the height and overall rating conditions.", "Select distinct player ids to avoid duplicates."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE overall_rating  >  85", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT DISTINCT Player.id FROM Player JOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id WHERE Player.height >= 180 AND Player_Attributes.overall_rating > 85;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique player names from the 'Player' table, joined with their corresponding attributes from the 'Player_Attributes' table. The results are ordered by the players' overall skill ratings in descending order, and the number of results returned is limited by a specified placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY overall_rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1304", "db_id": "soccer_1", "question": "List all of the ids for left-footed players with a height between 180cm and 190cm.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to select the 'id' from the Player table.", "We need to join Player with Player_Attributes on the player_api_id to access player attributes.", "Filter for players with a height between 180cm and 190cm using the height column from the Player table.", "Filter for left-footed players using the preferred_foot column from the Player_Attributes table."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 AND height  <=  190 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE preferred_foot  =  'left'", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT Player.id FROM Player JOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id WHERE Player.height BETWEEN 180 AND 190 AND Player_Attributes.preferred_foot = 'left';", "hint": "\n"}
{"sample_id": "train.1306", "db_id": "soccer_1", "question": "List the names and birthdays of the top five players in terms of potential.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to retrieve player names and birthdays, which are in the Player table.", "The potential attribute is in the Player_Attributes table.", "Join the Player table with the Player_Attributes table on player_api_id to access both player names and potential ratings.", "Order the results by potential in descending order to get the top players.", "Limit the results to the top five players."], "gold_sql": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT 5", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT player_name, birthday \nFROM Player \nJOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id \nORDER BY potential DESC \nLIMIT 5;", "hint": "\n"}
{"sample_id": "train.1511", "db_id": "insurance_and_eClaims", "question": "Which type of policy is most frequently used? Give me the policy type code.", "rationale": ["Identify the relevant table: The question asks about policy types, so we will focus on the Policies table.", "Determine the required columns: We need the Policy_Type_Code and a count of how many times each type is used.", "Use the COUNT function: To find the frequency of each policy type, we will use COUNT(*) to count the occurrences of each Policy_Type_Code.", "Group the results: We will group the results by Policy_Type_Code to aggregate the counts for each type.", "Order the results: To find the most frequently used policy type, we will order the results in descending order based on the frequency count.", "Limit the results: Since we only want the most frequently used policy type, we will limit the results to 1."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(*) as Frequency\nFROM Policies\nGROUP BY Policy_Type_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1513", "db_id": "insurance_and_eClaims", "question": "Find all the policy types that are used by more than 2 customers.", "rationale": ["Identify the relevant table: The Policies table contains the Policy_Type_Code and Customer_ID, which are needed to answer the question.", "Determine the condition: We need to find policy types that are used by more than 2 customers. This means we need to count the number of distinct customers for each policy type.", "Use a subquery: Create a subquery that selects Customer_ID from the Policies table, groups by Customer_ID, and uses HAVING to filter for those with a count greater than 2.", "Group by Policy_Type_Code: In the main query, we will group by Policy_Type_Code to get the distinct policy types that meet the criteria from the subquery."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code\nFROM Policies\nWHERE Customer_ID IN (\n    SELECT Customer_ID\n    FROM Policies\n    GROUP BY Customer_ID\n    HAVING COUNT(DISTINCT Customer_ID) > 2\n)\nGROUP BY Policy_Type_Code;", "hint": "\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["Identify the relevant table: Claim_Headers contains the amount paid for claims.", "Determine the required calculations: We need to calculate the total and average of the 'Amount_Paid' column.", "Construct the SQL query using aggregate functions: Use SUM() for total and AVG() for average on the 'Amount_Paid' column.", "Format the output to include aliases for clarity: Use AS to label the output columns as 'Total_Amount_Paid' and 'Average_Amount_Paid'."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT sum(Amount_Piad) AS Total_Amount_Paid, avg(Amount_Piad) AS Average_Amount_Paid FROM Claim_Headers", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the total and average of the 'amount_paid' column.\",\n        \"virtual_table\": \"SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers\"\n    }\n}\n"}
{"sample_id": "train.1518", "db_id": "insurance_and_eClaims", "question": "How much amount in total were claimed in the most recently created document?", "rationale": ["Identify the relevant tables: Claim_Headers for claim amounts and Claims_Documents for document creation dates.", "We need to sum the 'Amount_Claimed' from the Claim_Headers table.", "To find the most recently created document, we will use a subquery to get the maximum 'Created_Date' from the Claims_Documents table.", "Join Claim_Headers and Claims_Documents on the Claim_ID to link claims to their documents.", "Filter the results to only include claims associated with the most recently created document."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT SUM(ch.Amount_Claimed) AS Total_Claimed\nFROM Claim_Headers ch\nJOIN Claims_Documents cd ON ch.Claim_Header_ID = cd.Claim_ID\nWHERE cd.Created_Date = (SELECT MAX(Created_Date) FROM Claims_Documents);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the total and average of the 'amount_paid' column.\",\n        \"virtual_table\": \"SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers\"\n    }\n}\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers are needed to find the customer with the largest claim.", "Join the Customers table with the Policies table on Customer_ID to link customers to their policies.", "Join the resulting table with the Claim_Headers table on Policy_ID to access claim information related to each customer.", "Use a subquery to find the maximum amount claimed from the Claim_Headers table.", "Filter the results to only include the customer(s) who made a claim equal to this maximum amount."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID \nWHERE ch.Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claim_Headers)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the total and average of the 'amount_paid' column.\",\n        \"virtual_table\": \"SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers\"\n    }\n}\n"}
{"sample_id": "train.1521", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the minimum amount of payment in one claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers are needed to find the customer details and their claims.", "Join the Customers table with the Policies table on Customer_ID to link customers to their policies.", "Join the resulting table with the Claim_Headers table on Policy_ID to access claim information related to each customer.", "Use a subquery to find the minimum amount paid in claims from the Claim_Headers table.", "Filter the results to only include the customer(s) who have made a claim with the minimum amount paid."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID \nWHERE ch.Amount_Piad = (SELECT MIN(Amount_Piad) FROM Claim_Headers)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the total and average of the 'amount_paid' column.\",\n        \"virtual_table\": \"SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers\"\n    }\n}\n"}
{"sample_id": "train.1531", "db_id": "insurance_and_eClaims", "question": "Find the names of the customers who have an deputy policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Select the Customer_Details from the Customers table.", "Filter the results to include only those policies with a Policy_Type_Code of 'deputy'.", "Use DISTINCT to ensure that each customer's name appears only once in the results."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT DISTINCT Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Policy_Type_Code = 'deputy';", "hint": "\n"}
{"sample_id": "train.1533", "db_id": "insurance_and_eClaims", "question": "Find the names of customers who either have an deputy policy or uniformed policy.", "rationale": ["Identify the tables involved: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Select the relevant columns: We need Customer_Details from the Customers table.", "Filter the results based on the Policy_Type_Code: We are looking for policies that are either 'deputy' or 'uniformed'.", "Use a JOIN to combine the Customers and Policies tables based on the Customer_ID.", "Use DISTINCT to ensure that we only get unique customer names."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy' OR t1.policy_type_code  =  'Uniform'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT DISTINCT Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Policy_Type_Code IN ('deputy', 'uniformed');", "hint": "\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find the customer associated with the most recently started policy, so we will join the Customers table with the Policies table on the Customer_ID.", "We will order the results by the Start_Date of the policies in descending order to get the most recent one first.", "Finally, we will limit the results to 1 to get only the most recent customer."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nORDER BY Policies.Start_Date DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers are needed to get account details for a specific customer.", "Determine the columns to select: We need account_id, account_name, and other_account_details from the Accounts table.", "Establish the relationship between tables: Use a JOIN to connect Accounts with Customers based on customer_id.", "Apply the filter: Use a WHERE clause to filter results for customers with the first name 'Meaghan'."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Accounts.account_id, Accounts.account_name, Accounts.other_account_details \nFROM Accounts \nJOIN Customers ON Accounts.customer_id = Customers.customer_id \nWHERE Customers.customer_first_name = 'Meaghan';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n        \"virtual_table\": \"SELECT count(DISTINCT customer_id) FROM Accounts\"\n    }\n}\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Accounts and Customers are needed to get account details for a specific customer.", "Determine the relationship: The Accounts table has a foreign key (customer_id) that links to the Customers table.", "Select the required fields: We need account_id, date_account_opened, account_name, and other_account_details from the Accounts table.", "Filter the results: We need to filter the results based on the customer's first and last name, which are 'Meaghan' and 'Keeling' respectively.", "Construct the SQL query using JOIN to combine the Accounts and Customers tables based on the customer_id."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT a.account_id, a.date_account_opened, a.account_name, a.other_account_details \nFROM Accounts a \nJOIN Customers c ON a.customer_id = c.customer_id \nWHERE c.customer_first_name = 'Meaghan' AND c.customer_last_name = 'Keeling';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n        \"virtual_table\": \"SELECT count(DISTINCT customer_id) FROM Accounts\"\n    }\n}\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "Determine the columns needed: full names (first and last) from Customers and account name from Accounts.", "Join the Customers table with the Accounts table on the customer_id field to link customers with their accounts.", "Filter the results to include only those accounts with the name '900'.", "Select the concatenated first and last names as the full name."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nJOIN Accounts ON Customers.customer_id = Accounts.customer_id\nWHERE Accounts.account_name = '900';", "hint": "\n"}
{"sample_id": "train.1568", "db_id": "customers_and_invoices", "question": "Return the id and full name of the customer with the most accounts.", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to join these tables on the customer_id to get customer details along with their accounts.", "Group the results by customer_id to count the number of accounts each customer has.", "Order the results by the count of accounts in descending order to find the customer with the most accounts.", "Limit the results to 1 to get only the top customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id\nORDER BY COUNT(a.account_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.\",\n        \"virtual_table\": \"SELECT count(DISTINCT customer_id) FROM Accounts\"\n    }\n}\n"}
{"sample_id": "train.1579", "db_id": "customers_and_invoices", "question": "How many transaction does each account have? Show the number and account id.", "rationale": ["Identify the relevant table: The 'Financial_Transactions' table contains the transaction data, including the account ID.", "Determine the required output: We need to count the number of transactions for each account and display the account ID alongside the count.", "Use the COUNT() function: This function will allow us to count the number of transactions for each account.", "Group the results: To get the count per account, we will use the GROUP BY clause on the account_id column.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT count(*) AS transaction_count, account_id FROM Financial_Transactions GROUP BY account_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\",\n        \"virtual_table\": \"SELECT count(*) ,  account_id FROM Financial_transactions\"\n    }\n}\n"}
{"sample_id": "train.1589", "db_id": "customers_and_invoices", "question": "Show the account name, id and the number of transactions for each account.", "rationale": ["The query needs to retrieve the account name and account ID from the Accounts table.", "We also need to count the number of transactions associated with each account, which requires joining the Accounts table with the Financial_Transactions table.", "The hint provides a virtual table that counts transactions grouped by account ID, which we can use to count the transactions for each account.", "We will use a LEFT JOIN to ensure that accounts with no transactions are still included in the results.", "Finally, we will group the results by account ID and account name to get the correct counts for each account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "pred_sql": "SELECT a.account_name, a.account_id, COUNT(ft.transaction_id) AS transaction_count\nFROM Accounts a\nLEFT JOIN Financial_Transactions ft ON a.account_id = ft.account_id\nGROUP BY a.account_id, a.account_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\",\n        \"virtual_table\": \"SELECT count(*) ,  account_id FROM Financial_transactions\"\n    }\n}\n"}
{"sample_id": "train.1599", "db_id": "customers_and_invoices", "question": "Show the invoice number and the number of transactions for each invoice.", "rationale": ["We need to show the invoice number and the number of transactions for each invoice.", "The relevant table for transactions is 'Financial_Transactions', which contains the 'invoice_number' and 'transaction_id'.", "We will join the 'Financial_Transactions' table with the 'Invoices' table on the 'invoice_number' to get the corresponding invoices.", "We will use the COUNT function to count the number of transactions for each invoice.", "Finally, we will group the results by 'invoice_number' to get the count for each invoice."], "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"], "pred_sql": "SELECT invoice_number, COUNT(transaction_id) AS number_of_transactions \nFROM Financial_Transactions \nJOIN Invoices ON Financial_Transactions.invoice_number = Invoices.invoice_number \nGROUP BY invoice_number;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\",\n        \"virtual_table\": \"SELECT count(*) ,  account_id FROM Financial_transactions\"\n    }\n}\n"}
{"sample_id": "train.1602", "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?", "rationale": ["Identify the need to find the invoice number and date for the invoice with the greatest number of transactions.", "Use the hint to create a virtual table that counts financial transactions grouped by account ID.", "Determine the maximum transaction count from the virtual table.", "Link the maximum transaction count back to the orders to find the corresponding order IDs.", "Select the invoice number and date from the Invoices table where the order ID matches the orders with the maximum transaction count."], "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"], "pred_sql": "SELECT invoice_number, invoice_date FROM Invoices WHERE order_id IN (SELECT order_id FROM Orders WHERE order_id IN (SELECT order_id FROM Order_Items GROUP BY order_id HAVING COUNT(*) = (SELECT MAX(transaction_count) FROM (SELECT COUNT(*) AS transaction_count, account_id FROM Financial_Transactions GROUP BY account_id))))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.\",\n        \"virtual_table\": \"SELECT count(*) ,  account_id FROM Financial_transactions\"\n    }\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["Identify the tables needed: We need the Orders table to get order IDs and the Order_Items table to count the number of items in each order.", "Use a LEFT JOIN to combine Orders and Order_Items on the order_id, ensuring we include all orders even if they have no items.", "Use COUNT(Order_Items.order_item_id) to count the number of items for each order.", "Group the results by Orders.order_id to get the count of items for each specific order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT Orders.order_id, COUNT(Order_Items.order_item_id) AS number_of_items\nFROM Orders\nLEFT JOIN Order_Items ON Orders.order_id = Order_Items.order_id\nGROUP BY Orders.order_id;", "hint": "\n"}
{"sample_id": "train.2049", "db_id": "party_people", "question": "Show all ministers who do not belong to Progress Party.", "rationale": ["Identify the relevant table: The 'party' table contains information about political parties and their associated ministers.", "Determine the required information: We need to select the 'Minister' column from the 'party' table.", "Apply the condition: We want to exclude ministers who belong to the 'Progress Party'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Minister' from the 'party' table where the 'Party_name' is not 'Progress Party'."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT minister FROM party WHERE Party_name != 'Progress Party'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.\",\n        \"virtual_table\": \"SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2058", "db_id": "party_people", "question": "How many members are in each party?", "rationale": ["Identify the relevant tables: We need to use the 'party' table to get party names and the 'member' table to count the members associated with each party.", "Join the 'party' table with the 'member' table on the Party_ID to associate members with their respective parties.", "Use COUNT() function to count the number of members for each party.", "Group the results by party name to get the count of members for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT party.Party_name, COUNT(member.Member_ID) AS Member_Count\nFROM party\nLEFT JOIN member ON party.Party_ID = member.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.\",\n        \"virtual_table\": \"SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2071", "db_id": "party_people", "question": "Show party names and the number of events for each party.", "rationale": ["Identify the relevant tables: We need data from the 'party' table for party names and the 'party_events' table for event counts.", "Join the 'party' table with the 'party_events' table on the Party_ID to associate each party with its events.", "Use a LEFT JOIN to ensure that parties with no events are still included in the results.", "Count the number of events for each party using COUNT(pe.Event_ID).", "Group the results by party name to get the count of events per party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT p.Party_name, COUNT(pe.Event_ID) AS Number_of_Events\nFROM party p\nLEFT JOIN party_events pe ON p.Party_ID = pe.Party_ID\nGROUP BY p.Party_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.\",\n        \"virtual_table\": \"SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the relevant tables: party_events, party, and region.", "We need to count the number of events, so we will use the COUNT() function.", "Join the party_events table with the party table on Party_ID to link events to their respective parties.", "Join the party table with the region table on Region_ID to filter events by region.", "Add a WHERE clause to filter for events named 'Annual Meeting' and for the region named 'United Kingdom'.", "Select the count of these filtered events."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT COUNT(*) AS Annual_Meeting_Count\nFROM party_events pe\nJOIN party p ON pe.Party_ID = p.Party_ID\nJOIN region r ON p.Region_ID = r.Region_ID\nWHERE pe.Event_Name = 'Annual Meeting' AND r.Region_name = 'United Kingdom';", "hint": "\n"}
{"sample_id": "train.2176", "db_id": "formula_1", "question": "What are the names and years of all races that had a driver with the last name Lewis?", "rationale": ["Identify the tables needed: races, results, and drivers.", "We need to find races that had a driver with the last name 'Lewis'.", "Join the races table with the results table on raceId to link races with their results.", "Join the results table with the drivers table on driverId to link results with the drivers.", "Filter the results to only include those where the driver's surname is 'Lewis'.", "Select the names and years of the races from the races table."], "gold_sql": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = 'Lewis'", "source_tables": ["results", "drivers", "races"], "pred_sql": "SELECT races.name, races.year FROM races JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE drivers.surname = 'Lewis';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the tables needed: drivers, results, and races.", "Join the drivers table with the results table to get the drivers who participated in races.", "Join the results table with the races table to filter for the 'Australian Grand Prix'.", "Use a subquery to find drivers who participated in the 'Chinese Grand Prix'.", "Use the NOT IN clause to exclude those drivers from the main query.", "Select the first and last names of the remaining drivers."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.forename, d.surname \nFROM drivers d \nJOIN results r1 ON d.driverId = r1.driverId \nJOIN races ra ON r1.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' \nAND d.driverId NOT IN (\n    SELECT d2.driverId \n    FROM drivers d2 \n    JOIN results r2 ON d2.driverId = r2.driverId \n    JOIN races rb ON r2.raceId = rb.raceId \n    WHERE rb.name = 'Chinese Grand Prix'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2183", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who was in position 1 as standing and won?", "rationale": ["We need to find distinct drivers who were in position 1 in the standings and also won races.", "To do this, we will join the 'drivers' table with the 'driverStandings' table on the driverId.", "We will filter the results where the position in the standings is 1 and the number of wins is greater than 0.", "Finally, we will select the distinct forenames of these drivers."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.wins > 0;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2185", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["We need to find distinct drivers who won in position 1 as per driver standings and had more than 20 points.", "To achieve this, we will select the 'forename' from the 'drivers' table.", "We will join the 'drivers' table with the 'driverStandings' table on the 'driverId' to get the standings of each driver.", "We will filter the results where the 'position' in the standings is 1 and the 'points' are greater than 20.", "Using DISTINCT ensures that we only get unique forenames of the drivers."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2186", "db_id": "formula_1", "question": "What are the first names of the different drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["We need to find the first names of drivers who won in position 1 as per driver standings and had more than 20 points.", "To do this, we will join the 'drivers' table with the 'driverStandings' table to get the standings of each driver.", "Next, we will join the 'results' table to ensure we are only considering the results of the drivers in the standings.", "We will filter the results where the position in the standings is 1 and the points are greater than 20.", "Finally, we will select the distinct first names of these drivers."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM drivers d \nJOIN driverStandings ds ON d.driverId = ds.driverId \nJOIN results r ON ds.raceId = r.raceId AND ds.driverId = r.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2189", "db_id": "formula_1", "question": "What are the numbers of races for each constructor id?", "rationale": ["The question asks for the number of races for each constructor id.", "To get this information, we need to count the number of races associated with each constructor.", "The relevant table for this information is 'constructorResults', which links constructors to races.", "We will use the COUNT() function to count the occurrences of raceId for each constructorId.", "We will group the results by constructorId to get the count for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(raceId) AS number_of_races FROM constructorResults GROUP BY constructorId", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of race names from the 'races' table, sorted in descending order. The placeholder in the ORDER BY clause indicates that the results will be organized based on the race names.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM races ORDER BY name DESC\"\n    }\n}\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the relevant table: We need to look at the 'constructors' table to find the names of constructors and their nationality.", "Filter by nationality: We want only those constructors that are Japanese, so we will add a WHERE clause to filter by 'nationality = 'Japanese'\".", "Determine points earned: We need to check the points earned by each constructor, which is found in the 'constructorResults' table.", "Group by constructorId: To find the total points for each constructor, we will group the results by 'constructorId'.", "Use HAVING clause: We will use a HAVING clause to filter those constructors that have earned more than 5 points.", "Combine results: We will use a subquery to combine the results from the 'constructors' table with the filtered results from the 'constructorResults' table."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT name FROM constructors WHERE nationality = 'Japanese' AND constructorId IN (SELECT constructorId FROM constructorResults GROUP BY constructorId HAVING SUM(points) > 5);", "hint": "\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the tables needed: 'races' for race details and 'results' for fastest lap speeds.", "Join the 'races' table with the 'results' table on the raceId to correlate race details with results.", "Filter the results for the specific year (2008) and the specific race name ('Monaco Grand Prix').", "Use the AVG function to calculate the average of the fastest lap speeds from the results table."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT avg(T2.fastestLapSpeed) FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2221", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["Identify the relevant tables: 'races' for race details and 'results' for fastest lap speeds.", "Join the 'races' table with the 'results' table on the raceId to correlate race details with results.", "Filter the results for the specific race name 'Monaco Grand Prix' and the year 2008.", "Select the maximum fastest lap speed from the results that meet the criteria."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(T2.fastestLapSpeed) FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: 'races' and 'results'.", "We need to find the maximum fastest lap speed for a specific race (Monaco Grand Prix) in a specific year (2008).", "Join the 'races' table with the 'results' table on the raceId to access the fastest lap speed.", "Filter the results to only include the race that took place in 2008 and is named 'Monaco Grand Prix'.", "Use the MAX function to get the maximum fastest lap speed from the filtered results."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT max(T2.fastestLapSpeed) FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["Identify the relevant tables: 'races' for race names and years, and 'results' for fastest lap speeds.", "Join the 'races' table with the 'results' table on the raceId to access both race names and their corresponding fastest lap speeds.", "Filter the results to include only races that occurred after the year 2004.", "Group the results by race name to calculate the maximum fastest lap speed for each race.", "Select the race name and the maximum fastest lap speed, and order the results by year."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT T1.name, MAX(T2.fastestLapSpeed) AS max_fastest_lap_speed \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nWHERE T1.year > 2004 \nGROUP BY T1.name \nORDER BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2225", "db_id": "formula_1", "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the tables needed: 'races' for race details and 'results' for fastest lap speeds.", "Join the 'races' table with the 'results' table on the raceId to correlate races with their results.", "Filter the results to include only races held after the year 2004 using the WHERE clause.", "Group the results by race name to calculate the average fastest lap speed for each race.", "Use the AVG() function to calculate the average fastest lap speed for each race.", "Order the final results by year to present them in chronological order."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT T1.name, AVG(T2.fastestLapSpeed) AS average_fastest_lap_speed \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nWHERE T1.year > 2004 \nGROUP BY T1.name \nORDER BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2226", "db_id": "formula_1", "question": "What is the average fastest lap speed for races held after 2004, for each race, ordered by year?", "rationale": ["Identify the relevant tables: 'races' and 'results' are needed to get race years and fastest lap speeds.", "We need to filter races that occurred after 2004, so we will use a WHERE clause to specify this condition on the 'year' column of the 'races' table.", "To calculate the average fastest lap speed, we will use the AVG() function on the 'fastestLapSpeed' column from the 'results' table.", "We will group the results by year to get the average for each year, using GROUP BY on the 'year' column of the 'races' table.", "Finally, we will order the results by year in ascending order using ORDER BY."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT T1.year, avg(T2.fastestLapSpeed) AS average_fastest_lap_speed \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nWHERE T1.year > 2004 \nGROUP BY T1.year \nORDER BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.\",\n        \"virtual_table\": \"SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2243", "db_id": "machine_repair", "question": "What is the starting year of the oldest technicians?", "rationale": ["Identify the relevant table: The question pertains to technicians, so we will use the 'technician' table.", "Determine the required information: We need the starting year of the oldest technician.", "To find the oldest technician, we should order the technicians by age in ascending order (oldest first).", "We will use the ORDER BY clause to sort by 'Age' and the LIMIT clause to return only the first record, which will be the oldest technician's starting year."], "gold_sql": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT Starting_Year FROM technician ORDER BY Age ASC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the starting years of technicians from the 'technician' table, ordered by their age in descending order. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2248", "db_id": "machine_repair", "question": "What are the teams with the most technicians?", "rationale": ["Identify the relevant table: The 'technician' table contains information about technicians and their teams.", "Determine the required information: We need to count the number of technicians in each team.", "Use the COUNT() function to count technicians grouped by their team.", "Group the results by the 'Team' column to aggregate the counts.", "Order the results in descending order to find the teams with the most technicians."], "gold_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT Team, COUNT(technician_id) AS technician_count \nFROM technician \nGROUP BY Team \nORDER BY technician_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the starting years of technicians from the 'technician' table, ordered by their age in descending order. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2258", "db_id": "machine_repair", "question": "What are the names of the technicians  and how many machines are they assigned to repair?", "rationale": ["Identify the relevant tables: technician and repair_assignment.", "We need the names of technicians, which are in the technician table.", "We also need to count the number of machines assigned to each technician, which can be found in the repair_assignment table.", "To get the count of machines per technician, we will use a LEFT JOIN between technician and repair_assignment on technician_id.", "We will group the results by technician's name to get the count of machines for each technician.", "Finally, we will select the technician's name and the count of machines assigned to them."], "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name", "source_tables": ["repair_assignment", "technician"], "pred_sql": "SELECT technician.Name, COUNT(repair_assignment.Machine_ID) AS machine_count\nFROM technician\nLEFT JOIN repair_assignment ON technician.technician_id = repair_assignment.technician_id\nGROUP BY technician.Name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the starting years of technicians from the 'technician' table, ordered by their age in descending order. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2328", "db_id": "csu_1", "question": "Find all the campuses opened in 1958.", "rationale": ["Identify the relevant table: The question asks about campuses, so we will use the 'Campuses' table.", "Determine the condition: We need to find campuses that were opened in the year 1958, which corresponds to the 'Year' column in the 'Campuses' table.", "Construct the SQL query: We will select all columns from the 'Campuses' table where the 'Year' is equal to '1958'."], "gold_sql": "SELECT campus FROM campuses WHERE YEAR  =  1958", "source_tables": ["campuses"], "pred_sql": "SELECT * FROM Campuses WHERE Year = '1958';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of interest.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2334", "db_id": "csu_1", "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.", "rationale": ["Identify the relevant table: The question pertains to campuses, so we will use the 'Campuses' table.", "Determine the required columns: We need the 'Campus' name from the 'Campuses' table.", "Identify the filtering criteria: The campuses must be located in either 'Northridge, Los Angeles' or 'San Francisco, San Francisco'.", "Construct the SQL query using the identified table, columns, and criteria. We will use a WHERE clause to filter the locations."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE Location = 'Northridge, Los Angeles' OR Location = 'San Francisco, San Francisco'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the campuses from the 'Campuses' table that are located in a specific geographical location. The placeholder in the WHERE clause represents the location of interest.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2350", "db_id": "csu_1", "question": "Which campus has the most faculties in year 2003?", "rationale": ["Identify the relevant table for faculty data, which is the 'faculty' table.", "We need to filter the records for the year 2003, so we will use a WHERE clause to specify Year = 2003.", "To find the campus with the most faculties, we will order the results by the Faculty column in descending order.", "Finally, we will limit the results to 1 to get the campus with the highest number of faculty members."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Campus, Faculty FROM faculty WHERE Year = 2003 ORDER BY Faculty DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2356", "db_id": "csu_1", "question": "report the total number of degrees granted between 1998 and 2002.", "rationale": ["Identify the relevant table: The 'degrees' table contains information about degrees awarded, including the year and the number of degrees.", "Determine the time frame: The question specifies degrees granted between 1998 and 2002, so we need to filter the records based on the 'Year' column.", "Calculate the total number of degrees: We will use the SUM function to aggregate the total number of degrees awarded during the specified years."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(Degrees) AS TotalDegrees\nFROM degrees\nWHERE Year BETWEEN '1998' AND '2002';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the years in which degrees were awarded, grouped by year and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.\",\n        \"virtual_table\": \"SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to count the total number of degrees granted after the year 2000, so we will use the COUNT function on the Degrees column from the degrees table.", "We need to filter the results to only include campuses located in Orange County, which is done by adding a WHERE clause for the County column in the Campuses table.", "We also need to filter the degrees awarded to only those after the year 2000, which is done by adding a condition on the Year column in the degrees table.", "Finally, we will group the results by the Campus name to get the total degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT c.Campus, COUNT(d.Degrees) AS TotalDegrees\nFROM Campuses c\nJOIN degrees d ON c.Id = d.Campus\nWHERE c.County = 'Orange' AND d.Year > '2000'\nGROUP BY c.Campus;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant tables: Campuses and enrollments.", "We need to find campuses with specific enrollment criteria for the year 1956.", "Join the Campuses table with the enrollments table on the campus identifier.", "Filter the results to only include records from the year 1956.", "Apply the conditions for total enrollment (greater than 400) and full-time equivalent enrollment (greater than 200).", "Select the campus name from the resulting dataset."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT c.Campus \nFROM Campuses c \nJOIN enrollments e ON c.Id = e.Campus \nWHERE e.Year = '1956' \nAND e.TotalEnrollment_AY > 400 \nAND e.FTE_AY > 200;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of graduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the WHERE clause represent the year of enrollment and the name of the campus.\",\n        \"virtual_table\": \"SELECT sum(t1.graduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND t2.campus  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2363", "db_id": "csu_1", "question": "What campus started in year 1956, has more than 200 full time students, and more than 400 students enrolled?", "rationale": ["Identify the relevant tables: Campuses and enrollments are needed to answer the question.", "We need to filter campuses based on the year they started, which is found in the Campuses table under the 'Year' column.", "We also need to check for the number of full-time students, which is in the enrollments table under 'FTE_AY', and it should be greater than 200.", "Additionally, we need to check for total enrollments, which is in the enrollments table under 'TotalEnrollment_AY', and it should be greater than 400.", "Construct the SQL query by joining the Campuses and enrollments tables on the campus identifier, and applying the necessary filters."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT c.Campus \nFROM Campuses c \nJOIN enrollments e ON c.Id = e.Campus \nWHERE c.Year = '1956' \nAND e.FTE_AY > '200' \nAND e.TotalEnrollment_AY > '400';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2366", "db_id": "csu_1", "question": "List the campuses in Los Angeles county.", "rationale": ["Identify the relevant table: The 'Campuses' table contains information about campuses, including their location and county.", "Determine the specific information needed: The user wants to list campuses in Los Angeles county.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' column from the 'Campuses' table where the 'County' matches 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the campuses located in a specific county from the 'Campuses' table. The placeholder in the WHERE clause represents the name of the county.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to join these tables on the campus identifier (Id in Campuses and Campus in degrees).", "Filter the results to only include records for 'San Jose State University' and the year 2000.", "Use the SUM function to calculate the total number of degrees conferred in that year."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(Degrees) FROM Campuses AS T1 JOIN degrees AS T2 ON T1.Id = T2.Campus WHERE T1.Campus = 'San Jose State University' AND T2.Year = 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2374", "db_id": "csu_1", "question": "What is the number of faculty lines in campus \"Long Beach State University\" in 2002?", "rationale": ["Identify the relevant tables: We need to get the number of faculty lines, so we will use the 'faculty' table and the 'Campuses' table to filter by campus name.", "Join the tables: We will join the 'Campuses' table with the 'faculty' table on the campus identifier (Id).", "Filter by campus name: We will filter the results to only include the campus 'Long Beach State University'.", "Filter by year: We will also filter the results to only include the year 2002.", "Select the faculty count: Finally, we will select the number of faculty members from the joined tables."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2002 AND T2.campus  =  'Long Beach State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT faculty FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus WHERE T1.Campus = 'Long Beach State University' AND T2.Year = 2002", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2376", "db_id": "csu_1", "question": "How many faculty lines are there in \"San Francisco State University\" in year 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "We need to count the number of faculty lines, which means using the COUNT() function on the faculty table.", "To filter the results for 'San Francisco State University', we will join the 'faculty' table with the 'Campuses' table on the campus identifier.", "We also need to filter the results for the year 2004.", "The final SQL query will select the count of faculty lines for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) AS FacultyCount \nFROM faculty f \nJOIN Campuses c ON f.Campus = c.Id \nWHERE c.Campus = 'San Francisco State University' AND f.Year = 2004;", "hint": "\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant table: The 'faculty' table contains the number of faculty members.", "Determine the specific campus: We need to find the Id for 'San Francisco State University' from the 'Campuses' table.", "Filter by year: We are interested in the year 2004.", "Construct the SQL query to select the Faculty count for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Faculty FROM faculty WHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Francisco State University') AND Year = 2004;", "hint": "\n"}
{"sample_id": "train.2381", "db_id": "csu_1", "question": "How many faculty members did the university that conferred the most degrees in 2002 have?", "rationale": ["Identify the year of interest, which is 2002, to find the campus that conferred the most degrees.", "Use a subquery to find the campus that awarded the most degrees in 2002 by grouping the degrees by campus and counting them, ordering by the count in descending order, and limiting the result to the top campus.", "Join the faculty table with the degrees table on the campus identifier to get the faculty count for the identified campus.", "Select the faculty count for the campus that conferred the most degrees in 2002."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty AS f \nJOIN degrees AS d ON f.Campus = d.Campus \nWHERE d.Year = '2002' \nAND d.Campus = (SELECT d2.Campus \n                FROM degrees AS d2 \n                WHERE d2.Year = '2002' \n                GROUP BY d2.Campus \n                ORDER BY COUNT(d2.Degrees) DESC \n                LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\",\n        \"virtual_table\": \"SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2382", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the least number of degrees in year 2001?", "rationale": ["Identify the year of interest, which is 2001.", "Determine which campus conferred the least number of degrees in 2001 by querying the degrees table, grouping by campus, and ordering by the count of degrees in ascending order.", "Use a subquery to find the campus with the least degrees awarded in 2001.", "Count the number of faculty lines associated with that campus from the faculty table."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(*) FROM faculty WHERE Campus = (SELECT Campus FROM degrees WHERE Year = '2001' GROUP BY Campus ORDER BY COUNT(Degrees) ASC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the years in which degrees were awarded, grouped by year and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.\",\n        \"virtual_table\": \"SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the year of interest, which is 2001, for degrees awarded.", "Determine the campus that awarded the least number of degrees in 2001 by counting the degrees for that year.", "Join the faculty table with the degrees table on the campus identifier to get the faculty count for the campus with the least degrees awarded.", "Order the results by the count of degrees in ascending order to find the campus with the least degrees awarded.", "Select the faculty count for that campus."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty f \nJOIN degrees d ON f.Campus = d.Campus \nWHERE d.Year = '2001' \nORDER BY (SELECT COUNT(*) FROM degrees WHERE Year = '2001') ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the years in which degrees were awarded, grouped by year and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.\",\n        \"virtual_table\": \"SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant tables: 'discipline_enrollments' for undergraduate enrollments and 'Campuses' for campus identification.", "Join the 'discipline_enrollments' table with the 'Campuses' table on the campus identifier.", "Filter the results to only include records for 'San Jose State'.", "Use the SUM function to calculate the total number of undergraduate enrollments for the specified campus."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN Campuses AS t2 ON t1.Campus = t2.Id WHERE t2.Campus = 'San Jose State'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of graduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the WHERE clause represent the year of enrollment and the name of the campus.\",\n        \"virtual_table\": \"SELECT sum(t1.graduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND t2.campus  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2397", "db_id": "candidate_poll", "question": "Return the poll resource associated with the most candidates.", "rationale": ["We need to find the poll resource associated with the most candidates.", "To do this, we will group the results by the 'Poll_Source' column in the 'candidate' table.", "We will count the number of candidates for each poll source using COUNT(Candidate_ID).", "Next, we will order the results in descending order based on the count of candidates to get the poll source with the most candidates at the top.", "Finally, we will limit the results to just one entry to get the poll source with the highest count."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source, COUNT(Candidate_ID) AS Candidate_Count \nFROM candidate \nGROUP BY Poll_Source \nORDER BY Candidate_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the support rates of candidates from the 'candidate' table, ordered from highest to lowest. The placeholder in the LIMIT clause indicates the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2405", "db_id": "candidate_poll", "question": "Return the poll source corresponding to the candidate who has the oppose rate.", "rationale": ["Identify the relevant table: The 'candidate' table contains the 'Poll_Source' and 'Oppose_rate' columns.", "Determine the condition: We need to find the 'Poll_Source' for candidates who have an 'Oppose_rate'.", "Formulate the SQL query: We will select 'Poll_Source' from the 'candidate' table where 'Oppose_rate' is not null."], "gold_sql": "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source FROM candidate WHERE Oppose_rate IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the support rates of candidates from the 'candidate' table, ordered from highest to lowest. The placeholder in the LIMIT clause indicates the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2417", "db_id": "candidate_poll", "question": "For each sex, what is the name and sex of the candidate with the oppose rate for their sex?", "rationale": ["We need to find the candidate with the highest oppose rate for each sex.", "To do this, we will join the 'candidate' table with the 'people' table on the 'People_ID' column.", "We will select the 'Name' and 'Sex' from the 'people' table and the 'Oppose_rate' from the 'candidate' table.", "To find the candidate with the highest oppose rate for each sex, we will use a subquery that selects the maximum oppose rate for candidates of the same sex.", "The main query will filter candidates based on the maximum oppose rate obtained from the subquery for each sex.", "Finally, we will order the results by sex to group them accordingly."], "gold_sql": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex", "source_tables": ["candidate", "people"], "pred_sql": "SELECT p.Name, p.Sex, c.Oppose_rate \nFROM candidate c \nJOIN people p ON c.People_ID = p.People_ID \nWHERE c.Oppose_rate = (SELECT MAX(Oppose_rate) \n                       FROM candidate c2 \n                       JOIN people p2 ON c2.People_ID = p2.People_ID \n                       WHERE p2.Sex = p.Sex) \nORDER BY p.Sex;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the support rates of candidates from the 'candidate' table, ordered from highest to lowest. The placeholder in the LIMIT clause indicates the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT support_rate FROM candidate ORDER BY support_rate DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2434", "db_id": "movie_1", "question": "Find the titles of all movies directed by steven spielberg.", "rationale": ["Identify the relevant table: The 'Movie' table contains the information about movies, including their titles and directors.", "Determine the required columns: We need the 'title' column from the 'Movie' table.", "Specify the condition: We want to filter the results to only include movies directed by 'steven spielberg'.", "Construct the SQL query: Using the SELECT statement to retrieve the titles where the director matches 'steven spielberg'."], "gold_sql": "SELECT title FROM Movie WHERE director = 'Steven Spielberg'", "source_tables": ["movie"], "pred_sql": "SELECT title FROM Movie WHERE director = 'steven spielberg'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2461", "db_id": "movie_1", "question": "What are the different names of all reviewers whose ratings do not have a date field?", "rationale": ["We need to find the names of reviewers whose ratings do not have a date field, which means we are looking for records in the Rating table where the ratingDate is NULL.", "To achieve this, we will join the Reviewer table with the Rating table on the rID field, which is the common identifier between the two tables.", "We will select the distinct names from the Reviewer table to ensure that we do not have duplicate names in our result.", "The final SQL query will include a WHERE clause that filters the results to only include those ratings where the ratingDate is NULL."], "gold_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  'null'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT Reviewer.name FROM Reviewer JOIN Rating ON Reviewer.rID = Rating.rID WHERE Rating.ratingDate IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2476", "db_id": "movie_1", "question": "Find the names of all reviewers who rated Gone with the Wind.", "rationale": ["Identify the tables involved: Reviewer, Rating, and Movie.", "We need to find reviewers who rated a specific movie, so we will join the Reviewer and Rating tables on the reviewer ID (rID).", "Next, we need to join the Movie table to filter by the movie title 'Gone with the Wind'.", "We will select distinct names of reviewers to avoid duplicates in the results.", "The final SQL query will include the necessary joins and the condition to filter by the movie title."], "gold_sql": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  'Gone with the Wind'", "source_tables": ["rating", "movie", "reviewer"], "pred_sql": "SELECT DISTINCT Reviewer.name FROM Reviewer JOIN Rating ON Reviewer.rID = Rating.rID JOIN Movie ON Rating.mID = Movie.mID WHERE Movie.title = 'Gone with the Wind';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2483", "db_id": "movie_1", "question": "What are the names of all the reviewers and movie names?", "rationale": ["We need to retrieve the names of all reviewers and the titles of the movies they rated.", "To do this, we will join the 'Reviewer' table with the 'Rating' table on the reviewer ID (rID).", "Next, we will join the resulting table with the 'Movie' table on the movie ID (mID) to get the movie titles.", "Finally, we will select the distinct names of reviewers and the corresponding movie titles from the joined tables."], "gold_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "source_tables": ["movie", "reviewer"], "pred_sql": "SELECT Reviewer.name, Movie.title FROM Reviewer JOIN Rating ON Reviewer.rID = Rating.rID JOIN Movie ON Rating.mID = Movie.mID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2495", "db_id": "movie_1", "question": "For each director, how many reviews have they received?", "rationale": ["We need to find out how many reviews each director has received.", "To do this, we will join the 'Movie' table with the 'Rating' table on the movie ID (mID).", "We will use a LEFT JOIN to ensure that we include directors who may not have received any reviews.", "We will count the number of ratings (Rating.rID) for each director.", "Finally, we will group the results by the director's name to get the count of reviews per director."], "gold_sql": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT Movie.director, COUNT(Rating.rID) AS review_count \nFROM Movie \nLEFT JOIN Rating ON Movie.mID = Rating.mID \nGROUP BY Movie.director;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of reviewers who submitted ratings on a specific date. The query joins the 'Reviewer' and 'Rating' tables based on the reviewer's ID, filtering the results by the date of the rating submission.\",\n        \"virtual_table\": \"SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2500", "db_id": "movie_1", "question": "What are the names and years of the movies that has the top 3 highest rating star?", "rationale": ["Identify the tables involved: Movie and Rating.", "We need to join the Movie table with the Rating table to get the movie titles and their corresponding years.", "The join condition is based on the movie ID (mID) present in both tables.", "We want to order the results by the stars in descending order to get the highest ratings first.", "Finally, we limit the results to the top 3 highest ratings."], "gold_sql": "SELECT T2.title ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID ORDER BY T1.stars DESC LIMIT 3", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.title, T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID ORDER BY T1.stars DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2502", "db_id": "movie_1", "question": "For each director, return the director's name together with the title of the movie they directed that received the highest rating among all of their movies, and the value of that rating. Ignore movies whose director is NULL.", "rationale": ["We need to find the highest-rated movie for each director.", "First, we will create a subquery that selects the movie ID (mID) and the maximum stars rating for each movie from the Rating table, grouping by mID.", "Next, we will join this subquery with the Movie table to get the title and director of each movie that corresponds to the highest rating.", "We will filter out any movies where the director is NULL to meet the requirement of the query."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT M.director, M.title, R.highest_rating\nFROM Movie AS M\nJOIN (\n    SELECT mID, MAX(stars) AS highest_rating\n    FROM Rating\n    GROUP BY mID\n) AS R ON M.mID = R.mID\nWHERE M.director IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2503", "db_id": "movie_1", "question": "For each director, what are the titles and ratings for all the movies they reviewed?", "rationale": ["We need to retrieve the titles and ratings of movies for each director.", "The relevant tables are 'Movie' and 'Rating'.", "We will join the 'Movie' table with the 'Rating' table on the movie ID (mID).", "We will select the director's name, the movie title, and the rating stars from the joined tables.", "Finally, we will order the results by director and movie title for better readability."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT M.director, M.title, R.stars \nFROM Movie AS M \nJOIN Rating AS R ON M.mID = R.mID \nORDER BY M.director, M.title;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2505", "db_id": "movie_1", "question": "For each reviewer id, what is the title and rating for the movie with the smallest rating?", "rationale": ["We need to find the title and rating for the movie with the smallest rating for each reviewer id.", "To do this, we will join the Rating table with the Movie table on the movie ID (mID).", "We will select the reviewer ID (rID), movie title (title), and the stars given in the rating (stars).", "To find the smallest rating for each reviewer, we will use a subquery that selects the minimum stars from the Rating table where the reviewer ID matches the current row's reviewer ID.", "Finally, we will order the results by reviewer ID to group the results accordingly."], "gold_sql": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID", "source_tables": ["rating", "movie"], "pred_sql": "SELECT R.rID, M.title, R.stars \nFROM Rating R \nJOIN Movie M ON R.mID = M.mID \nWHERE R.stars = (SELECT MIN(stars) FROM Rating WHERE rID = R.rID) \nORDER BY R.rID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2507", "db_id": "movie_1", "question": "For each director, what is the title and score of their most poorly rated movie?", "rationale": ["We need to find the title and score of the most poorly rated movie for each director.", "To do this, we will join the Movie table with the Rating table on the movie ID (mID).", "We will group the results by director and title to aggregate the ratings for each movie.", "We will use the MIN function to find the lowest rating for each movie.", "To ensure we get the most poorly rated movie for each director, we will use a HAVING clause that compares the minimum rating of each movie to the minimum rating of all movies directed by the same director."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT M.director, M.title, MIN(R.stars) AS lowest_rating\nFROM Movie AS M\nJOIN Rating AS R ON M.mID = R.mID\nGROUP BY M.director, M.title\nHAVING MIN(R.stars) = (SELECT MIN(R2.stars) \n                       FROM Rating AS R2 \n                       JOIN Movie AS M2 ON R2.mID = M2.mID \n                       WHERE M2.director = M.director)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2508", "db_id": "movie_1", "question": "What is the name of the movie that is rated by most of times?", "rationale": ["Identify the tables involved: We need to get the movie title from the 'Movie' table and the ratings from the 'Rating' table.", "Join the 'Movie' and 'Rating' tables on the movie ID (mID) to link ratings to their respective movies.", "Group the results by movie title to count how many times each movie has been rated.", "Order the grouped results by the count of ratings in descending order to find the movie with the most ratings.", "Limit the results to 1 to get only the top-rated movie."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID GROUP BY T2.title ORDER BY COUNT(T1.mID) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2509", "db_id": "movie_1", "question": "What is the name of the movie that has been reviewed the most?", "rationale": ["To find the movie that has been reviewed the most, we need to count the number of reviews for each movie.", "We will join the 'Rating' table with the 'Movie' table using the movie ID (mID) to get the movie titles along with their ratings.", "We will group the results by the movie title to count the number of reviews for each movie.", "We will order the results in descending order based on the count of reviews to get the movie with the highest number of reviews at the top.", "Finally, we will limit the results to just one movie to get the top-reviewed movie."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID GROUP BY T2.title ORDER BY COUNT(T1.rID) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2517", "db_id": "movie_1", "question": "What are the ids of all moviest hat have not been reviewed by Britanny Harris?", "rationale": ["Identify the movies that have not been reviewed by Britanny Harris.", "To find the movies not reviewed by a specific reviewer, we need to first find the rID of Britanny Harris from the Reviewer table.", "Next, we will find all mID from the Rating table where the rID matches Britanny Harris's rID.", "Finally, we will select all mID from the Movie table that are not in the list of mID obtained from the previous step."], "gold_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT mID FROM Movie WHERE mID NOT IN (SELECT mID FROM Rating WHERE rID IN (SELECT rID FROM Reviewer WHERE name = 'Britanny Harris'));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2518", "db_id": "movie_1", "question": "Find the average rating star for each movie that received at least 2 ratings.", "rationale": ["We need to find the average rating star for each movie that has received at least 2 ratings.", "To do this, we will join the 'Movie' table with the 'Rating' table on the movie ID (mID).", "We will select the movie title and calculate the average of the stars given in the ratings using AVG(R.stars).", "We will group the results by the movie ID to ensure we get the average rating for each movie.", "To filter the results to only include movies that have received at least 2 ratings, we will use the HAVING clause with COUNT(R.rID) >= 2."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2", "source_tables": ["rating"], "pred_sql": "SELECT M.title, AVG(R.stars) AS average_rating\nFROM Movie AS M\nJOIN Rating AS R ON M.mID = R.mID\nGROUP BY M.mID\nHAVING COUNT(R.rID) >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2528", "db_id": "movie_1", "question": "What are the names of reviewers who had rated 3 star and 4 star?", "rationale": ["We need to find the names of reviewers who rated movies with 3 stars and 4 stars.", "To do this, we will join the Reviewer table with the Rating table on the reviewer ID (rID).", "We will select the distinct names from the Reviewer table to avoid duplicates.", "In the WHERE clause, we will filter the ratings to include only those that are either 3 or 4 stars using the IN operator."], "gold_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nWHERE Rating.stars IN ('3', '4')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers of reviewers from the 'Rating' table who have given a rating that is not equal to a specified number of stars. The placeholder in the WHERE clause represents the number of stars.\",\n        \"virtual_table\": \"SELECT rID FROM Rating WHERE stars != [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2530", "db_id": "movie_1", "question": "What are the names of movies that get 3 star and 4 star?", "rationale": ["Identify the tables involved: Movie and Rating.", "We need to get the titles of movies, so we will select the 'title' column from the Movie table.", "We need to filter ratings to include only those that are 3 stars and 4 stars.", "To do this, we will join the Rating table with the Movie table on the movie ID (mID).", "We will use the IN clause to specify that we want ratings that are either 3 or 4 stars."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID WHERE T1.stars IN ('3', '4')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles of movies from the 'Movie' table that have received ratings within a specified range of stars. The placeholders in the WHERE clause represent the minimum and maximum star ratings.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2576", "db_id": "inn_1", "question": "Find the most popular room in the hotel. The most popular room is the room that had seen the largest number of reservations.", "rationale": ["We need to find the most popular room based on the number of reservations.", "To do this, we will join the 'Reservations' table with the 'Rooms' table using the room identifier.", "We will count the number of reservations for each room using COUNT(*) and group the results by the room identifier.", "To determine popularity, we will order the results by the count of reservations in descending order.", "Finally, we will limit the results to only the top entry to get the most popular room."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T2.roomName, COUNT(*) AS reservation_count \nFROM Reservations AS T1 \nJOIN Rooms AS T2 ON T1.Room = T2.RoomId \nGROUP BY T2.RoomId \nORDER BY reservation_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n        \"virtual_table\": \"SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;\"\n    }\n}\n"}
{"sample_id": "train.2577", "db_id": "inn_1", "question": "Which room has the largest number of reservations?", "rationale": ["We need to find out which room has the largest number of reservations.", "To do this, we will join the 'Reservations' table with the 'Rooms' table using the room identifier.", "We will count the number of reservations for each room by grouping the results by the room name.", "To find the room with the largest number of reservations, we will order the results in descending order based on the count of reservations.", "Finally, we will limit the results to only the top entry to get the room with the largest number of reservations."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T2.roomName, COUNT(*) AS reservation_count \nFROM Reservations AS T1 \nJOIN Rooms AS T2 ON T1.Room = T2.RoomId \nGROUP BY T2.roomName \nORDER BY reservation_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n        \"virtual_table\": \"SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;\"\n    }\n}\n"}
{"sample_id": "train.2578", "db_id": "inn_1", "question": "How many kids stay in the rooms reserved by ROY SWEAZY?", "rationale": ["Identify the relevant tables: Reservations is the main table we need to query for guest information.", "We need to filter the reservations based on the guest's name, specifically looking for 'ROY SWEAZY'.", "We want to count the total number of kids from the reservations made by this guest.", "The SQL query will sum the 'Kids' column from the Reservations table where the LastName is 'SWEAZY' and FirstName is 'ROY'."], "gold_sql": "SELECT kids FROM Reservations WHERE FirstName = 'ROY' AND LastName  =  'SWEAZY';", "source_tables": ["reservations"], "pred_sql": "SELECT SUM(Kids) AS TotalKids \nFROM Reservations \nWHERE LastName = 'SWEAZY' AND FirstName = 'ROY';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n        \"virtual_table\": \"SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;\"\n    }\n}\n"}
{"sample_id": "train.2582", "db_id": "inn_1", "question": "Which room has the highest rate? List the room's full name, rate, check in and check out date.", "rationale": ["Identify the relevant tables: Rooms and Reservations.", "Determine the columns needed: roomName from Rooms, Rate, CheckIn, and CheckOut from Reservations.", "Join the Rooms table with the Reservations table on the RoomId and Room columns respectively.", "Order the results by Rate in descending order to find the highest rate.", "Limit the results to 1 to get only the room with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT r.roomName, res.Rate, res.CheckIn, res.CheckOut \nFROM Rooms r \nJOIN Reservations res ON r.RoomId = res.Room \nORDER BY res.Rate DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2583", "db_id": "inn_1", "question": "Return the name, rate, check in and check out date for the room with the highest rate.", "rationale": ["Identify the required fields: room name, rate, check-in date, and check-out date.", "The room name is in the 'Rooms' table, while the rate, check-in, and check-out dates are in the 'Reservations' table.", "To get the room name, we need to join the 'Rooms' table with the 'Reservations' table on the RoomId.", "We need to find the reservation with the highest rate, which can be done using a subquery that selects the maximum rate from the 'Reservations' table.", "The final query selects the room name, rate, check-in, and check-out date for the reservation with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT r.roomName, res.Rate, res.CheckIn, res.CheckOut \nFROM Reservations res \nJOIN Rooms r ON res.Room = r.RoomId \nWHERE res.Rate = (SELECT MAX(Rate) FROM Reservations);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2589", "db_id": "inn_1", "question": "Find the total number of king beds available.", "rationale": ["Identify the requirement: We need to find the total number of king beds available.", "Refer to the provided hint which describes a virtual table for calculating the total number of beds of a specific type.", "The hint provides a template: 'SELECT sum(beds) FROM Rooms WHERE bedtype = [PLACEHOLDER-TYPE:STRING];'.", "Replace the placeholder with 'king' to specify the type of bed we are interested in.", "Construct the final SQL query using the modified template."], "gold_sql": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT sum(beds) FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of beds available in rooms of a specific bed type from the 'Rooms' table. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT sum(beds) FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2590", "db_id": "inn_1", "question": "List the names and decor of rooms that have a king bed. Sort the list by their price.", "rationale": ["Identify the relevant table: The 'Rooms' table contains the information about room names, decor, and bed types.", "Determine the required columns: We need to select 'roomName' and 'decor' from the 'Rooms' table.", "Apply the filter: We need to filter the rooms to only include those that have a king bed, which is specified by the condition 'bedType = 'king' '.", "Sort the results: The results should be sorted by 'basePrice' to meet the requirement of sorting by price.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName, decor FROM Rooms WHERE bedType = 'king' ORDER BY basePrice;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2594", "db_id": "inn_1", "question": "What is the decor of room Recluse and defiance?", "rationale": ["Identify the relevant table: The question pertains to the decor of specific rooms, which are listed in the 'Rooms' table.", "Determine the columns needed: We need the 'decor' column to answer the question.", "Filter the results: We need to filter the rooms by their names, specifically 'Recluse' and 'defiance'.", "Construct the SQL query: Using the SELECT statement to retrieve the 'decor' for the specified room names."], "gold_sql": "SELECT decor FROM Rooms WHERE roomName  =  'Recluse and defiance';", "source_tables": ["rooms"], "pred_sql": "SELECT decor FROM Rooms WHERE roomName IN ('Recluse', 'defiance');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2604", "db_id": "inn_1", "question": "Find the first and last names of people who payed more than the rooms' base prices.", "rationale": ["Identify the relevant tables: Reservations and Rooms.", "We need to find the first and last names of guests from the Reservations table.", "We need to compare the Rate from the Reservations table with the basePrice from the Rooms table.", "To do this, we will use a subquery to select the basePrice from the Rooms table where the RoomId matches the Room in the Reservations table.", "The final query will select FirstName and LastName from Reservations where the Rate is greater than the basePrice from the corresponding room."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT FirstName, LastName \nFROM Reservations \nWHERE Rate > (SELECT basePrice FROM Rooms WHERE Rooms.RoomId = Reservations.Room);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2609", "db_id": "inn_1", "question": "How many rooms have a king bed?", "rationale": ["Identify the table to query: Rooms table contains information about the rooms.", "Determine the condition: We need to count rooms with a specific bed type, which is 'king'.", "Use the provided virtual table structure to form the SQL query: Replace the placeholder in the virtual table with 'king'.", "Construct the final SQL query to count the number of rooms with a king bed."], "gold_sql": "SELECT count(*) FROM Rooms WHERE bedType  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT count(*) FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2612", "db_id": "inn_1", "question": "Find the name of the room with the maximum occupancy.", "rationale": ["Identify the relevant table: Rooms, which contains the room details including maxOccupancy.", "To find the room with the maximum occupancy, we need to select the roomName from the Rooms table.", "We need to determine the maximum occupancy value, which can be done using a subquery that selects the maximum value from the maxOccupancy column in the Rooms table.", "The final query selects the roomName where the maxOccupancy matches the maximum occupancy found in the subquery."], "gold_sql": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE maxOccupancy = (SELECT MAX(maxOccupancy) FROM Rooms);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n        \"virtual_table\": \"SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;\"\n    }\n}\n"}
{"sample_id": "train.2621", "db_id": "inn_1", "question": "What is the average minimum and price of the rooms for each different decor.", "rationale": ["Identify the relevant table: The Rooms table contains the necessary information about room decor and prices.", "Determine the required calculations: We need to calculate the average price of rooms, which involves using the AVG() function.", "Group the results: Since we want the average price for each different decor, we will use the GROUP BY clause on the 'decor' column.", "Select the necessary columns: We will select the 'decor' column and the calculated average price, which we will alias as 'average_price'."], "gold_sql": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;", "source_tables": ["rooms"], "pred_sql": "SELECT decor, AVG(basePrice) AS average_price FROM Rooms GROUP BY decor;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room identifiers and their names from the 'Rooms' table, sorted by the base price in descending order. The placeholder in the LIMIT clause represents the maximum number of rooms to be displayed.\",\n        \"virtual_table\": \"SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2628", "db_id": "inn_1", "question": "List the name of rooms with king or queen bed.", "rationale": ["The user wants to list the names of rooms that have either a king or queen bed.", "To achieve this, we need to select the 'roomName' column from the 'Rooms' table.", "We will filter the results using a WHERE clause to check if the 'bedType' is either 'king' or 'queen'.", "The SQL query will use the IN operator to specify multiple values for the 'bedType' condition."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE bedType IN ('king', 'queen');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of rooms from the 'Rooms' table that have a specific type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["We need to find the name of each room and the number of times reservations were made for it.", "To achieve this, we will select the 'roomName' from the 'Rooms' table.", "We will also count the number of reservations for each room, which can be done using COUNT(*) on the 'Reservations' table.", "We will join the 'Reservations' table with the 'Rooms' table on the 'Room' identifier to link reservations to their respective rooms.", "Finally, we will group the results by 'roomName' to get the count of reservations for each room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T2.roomName, COUNT(*) AS reservation_count \nFROM Reservations AS T1 \nJOIN Rooms AS T2 ON T1.Room = T2.RoomId \nGROUP BY T2.roomName;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of reservations where the total number of occupants (adults and kids) matches the maximum occupancy allowed for each room. It joins the 'Reservations' table with the 'Rooms' table based on the room identifier, ensuring that only those reservations that meet the occupancy criteria are counted.\",\n        \"virtual_table\": \"SELECT count(*) FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T2.maxOccupancy  =  T1.Adults + T1.Kids;\"\n    }\n}\n"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["Identify the table needed: The question asks for details of trucks, so we will use the 'Trucks' table.", "Select all columns: We need all details of the trucks, so we will use SELECT *.", "Order by license number: The question specifies to order the results by the truck's license number, so we will add ORDER BY truck_licence_number."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "pred_sql": "SELECT * FROM Trucks ORDER BY truck_licence_number;", "hint": "\n"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to find customer names, so we will select 'customer_name' from the Customers table.", "To filter customers based on their address, we need to join the Customers table with the Customer_Addresses table using 'customer_id'.", "Next, we join the Customer_Addresses table with the Addresses table using 'address_id' to access the state information.", "Finally, we apply a WHERE clause to filter out customers whose state is 'California'."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT customer_name \nFROM Customers c \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nJOIN Addresses a ON ca.address_id = a.address_id \nWHERE a.state_province_county != 'California';", "hint": "\n"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["Identify the relevant tables: Delivery_Routes, Delivery_Route_Locations, and Order_Deliveries are needed to find the route with the highest number of deliveries.", "Join Delivery_Routes with Delivery_Route_Locations on route_id to link routes with their locations.", "Join the result with Order_Deliveries on location_code to associate deliveries with their respective routes.", "Group the results by route_name to count the number of deliveries for each route.", "Order the results in descending order based on the count of deliveries to find the route with the highest number.", "Limit the results to 1 to get only the top route."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "pred_sql": "SELECT route_name\nFROM Delivery_Routes\nJOIN Delivery_Route_Locations ON Delivery_Routes.route_id = Delivery_Route_Locations.route_id\nJOIN Order_Deliveries ON Delivery_Route_Locations.location_code = Order_Deliveries.location_code\nGROUP BY route_name\nORDER BY COUNT(Order_Deliveries.actual_order_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3175", "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["Identify the tables involved: CLASS and EMPLOYEE.", "We need to count the number of distinct professors teaching a specific class, so we will use COUNT(DISTINCT) to avoid counting the same professor multiple times.", "Join the CLASS table with the EMPLOYEE table on the professor's identifier (PROF_NUM) to get the professor's details.", "Filter the results to only include the class with the code 'ACCT-211'.", "Select the count of distinct professors from the joined tables."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT T2.emp_fname) AS professor_count \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM \nWHERE T1.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and EMPLOYEE.", "We need to count the number of distinct professors teaching a specific class, which is identified by the CLASS_CODE 'ACCT-211'.", "Join the CLASS table with the EMPLOYEE table on the professor's identifier (PROF_NUM) to get the professor's details.", "Use the COUNT function to count the distinct professors from the joined result where the CLASS_CODE matches 'ACCT-211'.", "The final SQL query selects the count of distinct first names of professors who teach the specified class."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT T2.emp_fname) AS professor_count \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM \nWHERE T1.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["Identify the tables needed: CLASS, EMPLOYEE, and COURSE.", "We need to get the first names and date of birth of professors, so we will select EMP_FNAME and EMP_DOB from the EMPLOYEE table.", "To find which professors teach the course ACCT-211, we need to join the CLASS table with the EMPLOYEE table on the professor's identifier (PROF_NUM).", "We also need to join the CLASS table with the COURSE table to filter by the course code (CRS_CODE).", "The final SQL query will select the first names and date of birth of professors who teach the specified course."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT T2.EMP_FNAME, T2.EMP_DOB \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM \nJOIN COURSE AS T3 ON T1.CRS_CODE = T3.CRS_CODE \nWHERE T3.CRS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3188", "db_id": "college_1", "question": "Where is the history department?", "rationale": ["The user is asking for the location of the history department, which implies we need to find the department with the name 'History'.", "To find the department, we will query the DEPARTMENT table, specifically looking for the DEPT_NAME column that matches 'History'.", "The SQL query will select the DEPT_NAME from the DEPARTMENT table where the DEPT_NAME is 'History'."], "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"], "pred_sql": "SELECT dept_name FROM department WHERE dept_name = 'History'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the table that contains the school locations, which is the DEPARTMENT table.", "Determine the relevant column for the location, which is DEPT_ADDRESS.", "Filter the results based on the SCHOOL_CODE, specifically for the code 'BUS'.", "Use DISTINCT to ensure that only unique locations are returned."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "\n"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE are needed to get department names and their associated courses.", "Join the DEPARTMENT table with the COURSE table on the DEPT_CODE to link departments with their courses.", "Use the SUM function to calculate the total credit hours offered by each department based on the CRS_CREDIT from the COURSE table.", "Group the results by DEPT_NAME to get the total credit hours for each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT D.DEPT_NAME, SUM(C.CRS_CREDIT) AS TOTAL_CREDIT\nFROM DEPARTMENT D\nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE\nGROUP BY D.DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3202", "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["Identify the tables involved: DEPARTMENT and COURSE.", "Determine the relationship between the tables: DEPARTMENT has a DEPT_CODE that links to COURSE's DEPT_CODE.", "We need to count the number of courses offered by each department, so we will use the COUNT function.", "Join the DEPARTMENT and COURSE tables on DEPT_CODE to get the relevant data.", "The final query will count the number of courses for each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT count(*) FROM DEPARTMENT AS T1 JOIN COURSE AS T2 ON T1.DEPT_CODE = T2.DEPT_CODE", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors and their associated school codes.", "Count the number of professors per school: Use COUNT(PROF_NUM) to count the number of professors for each SCHOOL_CODE.", "Group the results by school: Use GROUP BY SCHOOL_CODE to aggregate the counts by school.", "Order the results to find the smallest count: Use ORDER BY professor_count ASC to sort the counts in ascending order.", "Limit the results to the top entry: Use LIMIT 1 to get only the school with the smallest number of professors."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "pred_sql": "SELECT SCHOOL_CODE, COUNT(PROF_NUM) AS professor_count\nFROM PROFESSOR\nGROUP BY SCHOOL_CODE\nORDER BY professor_count ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3215", "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["Identify the tables needed: We need the PROFESSOR table to get the professors' information and the DEPARTMENT table to get the department names.", "We need to count the number of professors with a Ph.D. degree, so we will use the COUNT() function.", "To get the department names along with the count of professors, we will join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE.", "We will filter the professors to only include those with a Ph.D. degree using a WHERE clause.", "Finally, we will group the results by department name to get the count of professors in each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(PROFESSOR.EMP_NUM) AS NumberOfProfessors\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nWHERE PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D.'\nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["We need to find the number of students for each department, which requires counting students grouped by their respective departments.", "The relevant tables for this query are DEPARTMENT and STUDENT, as we need to link students to their departments.", "We will join the DEPARTMENT table with the STUDENT table on the DEPT_CODE column, which is common to both tables.", "After joining, we will group the results by DEPT_NAME to get the count of students in each department.", "Finally, we will use the COUNT function to count the number of students (STU_NUM) for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPT_NAME, COUNT(STU_NUM) AS student_count \nFROM DEPARTMENT \nJOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE \nGROUP BY DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["Identify the tables needed: STUDENT for student hours and DEPARTMENT for department names.", "Join the STUDENT table with the DEPARTMENT table on the DEPT_CODE to associate students with their respective departments.", "Use the SUM function to calculate the total hours (STU_HRS) for each department.", "Group the results by department name (DEPT_NAME) to get the total hours per department."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT D.DEPT_NAME, SUM(S.STU_HRS) AS TOTAL_HOURS\nFROM STUDENT S\nJOIN DEPARTMENT D ON S.DEPT_CODE = D.DEPT_CODE\nGROUP BY D.DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE are needed to find the total credits offered by each department.", "Join the DEPARTMENT table with the COURSE table on the DEPT_CODE to associate courses with their respective departments.", "Use the SUM function to calculate the total credits for each department by summing the CRS_CREDIT from the COURSE table.", "Group the results by department name to aggregate the total credits for each department.", "Order the results in descending order based on the total credits to find the department with the most credits.", "Limit the results to 1 to get only the department that offers the most credits."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "pred_sql": "SELECT D.DEPT_NAME, SUM(C.CRS_CREDIT) AS TOTAL_CREDITS\nFROM DEPARTMENT D\nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE\nGROUP BY D.DEPT_NAME\nORDER BY TOTAL_CREDITS DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the tables involved: STUDENT, ENROLL, and CLASS.", "Determine the relationship between the tables: STUDENT is linked to ENROLL through STU_NUM, and ENROLL is linked to CLASS through CLASS_CODE.", "Select the first name of the students, which is in the STUDENT table (STU_FNAME).", "Filter the results to only include students enrolled in the class with CLASS_CODE 'ACCT-211'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211';", "hint": "\n"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["Identify the tables needed: STUDENT for student names, ENROLL for enrollment details, and CLASS for class information.", "Join the ENROLL table with the STUDENT table on the student number (STU_NUM) to get student details for enrolled classes.", "Join the CLASS table with the ENROLL table on the class code (CLASS_CODE) to filter for the specific class 'ACCT-211'.", "Add a WHERE clause to filter for students who received a grade of 'C'.", "Select the first name of the students (STU_FNAME) from the resulting joined tables."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT S.STU_FNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nJOIN CLASS C ON E.CLASS_CODE = C.CLASS_CODE \nWHERE C.CLASS_CODE = 'ACCT-211' AND E.ENROLL_GRADE = 'C';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["We need to find the department with the most students enrolled.", "To do this, we will join the STUDENT table with the DEPARTMENT table using the DEPT_CODE.", "We will group the results by department name to count the number of students in each department.", "We will order the results in descending order based on the count of students to get the department with the most students at the top.", "Finally, we will limit the results to 1 to get only the top department."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT T2.DEPT_NAME\nFROM STUDENT AS T1\nJOIN DEPARTMENT AS T2 ON T1.DEPT_CODE = T2.DEPT_CODE\nGROUP BY T2.DEPT_NAME\nORDER BY COUNT(T1.STU_NUM) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n        \"virtual_table\": \"SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3257", "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["Identify the relevant table: The CLASS table contains information about classes, including the room where they are held.", "Determine the required columns: We need the CRS_CODE of the courses, which is also present in the CLASS table.", "Specify the condition: We want to filter the results to only include classes that take place in room 'KLR209'.", "Construct the SQL query: Use SELECT to get the distinct CRS_CODE from the CLASS table where CLASS_ROOM is 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CRS_CODE FROM CLASS WHERE CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students enrolled in classes associated with a specific course code from the 'CLASS' and 'ENROLL' tables. The placeholder in the WHERE clause represents the course code for which the enrollment count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about classes, including the room where they are held.", "Determine the required columns: We need the CRS_CODE of the courses, which is present in the CLASS table.", "Specify the condition: We are interested in classes located in room 'KLR209'.", "Construct the SQL query: Use a SELECT statement to retrieve distinct CRS_CODE values from the CLASS table where CLASS_ROOM equals 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CRS_CODE FROM CLASS WHERE CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students enrolled in classes associated with a specific course code from the 'CLASS' and 'ENROLL' tables. The placeholder in the WHERE clause represents the course code for which the enrollment count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed since we want student names and their grades.", "We need to join the STUDENT table with the ENROLL table on the student number (STU_NUM) to access the grades associated with each student.", "We are interested in students who received a grade of 'C', so we will filter the results using a WHERE clause on the ENROLL_GRADE column.", "To avoid duplicate names, we will use DISTINCT to ensure each student's first name appears only once in the result."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["Identify the relevant tables: We need to find professors from the EMPLOYEE table who do not teach any classes listed in the CLASS table.", "Use a subquery to find professors who teach classes: The subquery selects the PROF_NUM from the CLASS table, which represents professors who are teaching classes.", "Use the NOT IN clause to filter out professors who are teaching classes: We will select professors from the EMPLOYEE table whose EMP_NUM is not in the list of PROF_NUM from the CLASS table."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME FROM EMPLOYEE WHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the relevant tables: PROFESSOR and CLASS.", "We need to find professors who are not teaching any classes, which means we need to look for professors whose EMP_NUM is not present in the CLASS table's PROF_NUM column.", "The hint provides a virtual table that shows how to join CLASS and EMPLOYEE to get the first names of professors who are teaching classes.", "To find professors not teaching any classes, we can use a subquery that selects PROF_NUM from CLASS and use it in a NOT IN clause to filter out those professors from the PROFESSOR table.", "Finally, we select the first names (emp_fname) of the remaining professors."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT emp_fname FROM PROFESSOR WHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the table that contains information about professors, which is the PROFESSOR table.", "Determine the relevant column that indicates the highest degree obtained by the professors, which is PROF_HIGH_DEGREE.", "We need to count the number of professors who have either a Ph.D. or a Masters degree.", "Use the COUNT() function to count the number of rows that meet the criteria.", "Construct the SQL query to select the count from the PROFESSOR table where the PROF_HIGH_DEGREE is either 'Ph.D.' or 'Masters'."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) AS NumberOfProfessors\nFROM PROFESSOR\nWHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "hint": "\n"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["Identify the tables needed: CLASS and EMPLOYEE.", "We need to find the first names of professors, which are in the EMPLOYEE table, and the courses they teach, which are in the CLASS table.", "Join the CLASS table with the EMPLOYEE table on the professor's identifier (PROF_NUM).", "Filter the results to include only the courses CIS-220 and QM-261 using a WHERE clause with the IN operator."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "pred_sql": "SELECT T2.EMP_FNAME FROM CLASS AS T1 JOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM WHERE T1.CRS_CODE IN ('CIS-220', 'QM-261')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the tables needed: STUDENT, ENROLL, CLASS, COURSE, and DEPARTMENT.", "Join the STUDENT table with ENROLL to get the classes each student is enrolled in.", "Join the ENROLL table with CLASS to get the class details.", "Join the CLASS table with COURSE to get the course details.", "Join the COURSE table with DEPARTMENT to filter by department names.", "Use a WHERE clause to filter for departments 'Accounting' and 'Computer Info. Systems'.", "Select the distinct first names of students who meet the criteria."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME \nFROM STUDENT AS S \nJOIN ENROLL AS E ON S.STU_NUM = E.STU_NUM \nJOIN CLASS AS C ON E.CLASS_CODE = C.CLASS_CODE \nJOIN COURSE AS CRS ON C.CRS_CODE = CRS.CRS_CODE \nJOIN DEPARTMENT AS D ON CRS.DEPT_CODE = D.DEPT_CODE \nWHERE D.DEPT_NAME IN ('Accounting', 'Computer Info. Systems')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of employees, the office locations of professors, and descriptions of courses from the respective tables. The data is retrieved by joining the 'CLASS' table with the 'EMPLOYEE', 'COURSE', and 'PROFESSOR' tables based on their relationships, specifically linking professors to their classes and courses.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3308", "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["Identify the relevant tables: PROFESSOR and DEPARTMENT.", "We need to select the first names and office locations of professors, so we will select 'emp_fname' and 'prof_office' from the PROFESSOR table.", "To filter professors by department, we will join the PROFESSOR table with the DEPARTMENT table on the 'dept_code'.", "We need to filter for professors in the 'History' department and those who have a Ph.D., so we will add a WHERE clause to check for 'dept_name' = 'History' and 'prof_high_degree' = 'Ph.D.'"], "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"], "pred_sql": "SELECT T2.emp_fname, T2.prof_office \nFROM PROFESSOR AS T2 \nJOIN DEPARTMENT AS T3 ON T2.dept_code = T3.dept_code \nWHERE T3.dept_name = 'History' AND T2.prof_high_degree = 'Ph.D.';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of professors and the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3319", "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["Identify the tables needed: STUDENT for student names and ENROLL for enrollment details including grades.", "We need to find students who received either an 'A' or 'C' grade, so we will filter the ENROLL table based on the ENROLL_GRADE column.", "To get the names of the students, we will select the first and last names from the STUDENT table.", "We will join the STUDENT table with the ENROLL table on the student number (STU_NUM) to link students with their grades.", "Finally, we will use DISTINCT to ensure that we do not have duplicate names in the result set."], "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME, S.STU_LNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nWHERE E.ENROLL_GRADE IN ('A', 'C');", "hint": "\n"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, COURSE, PROFESSOR, and DEPARTMENT.", "We need to retrieve the first names of professors and their highest degree, so we will select T2.EMP_FNAME and T4.PROF_HIGH_DEGREE.", "Join the CLASS table with the EMPLOYEE table to get the professor's first name using the PROF_NUM foreign key.", "Join the CLASS table with the COURSE table to link classes to their respective courses using the CRS_CODE foreign key.", "Join the EMPLOYEE table with the PROFESSOR table to get the highest degree of the professors using the EMP_NUM foreign key.", "Join the PROFESSOR table with the DEPARTMENT table to filter professors by the department they belong to using the DEPT_CODE foreign key.", "Add a WHERE clause to filter results to only include professors from the 'Computer Information Systems' department."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "pred_sql": "SELECT T2.EMP_FNAME, T4.PROF_HIGH_DEGREE \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM \nJOIN COURSE AS T3 ON T1.CRS_CODE = T3.CRS_CODE \nJOIN PROFESSOR AS T4 ON T2.EMP_NUM = T4.EMP_NUM \nJOIN DEPARTMENT AS T5 ON T4.DEPT_CODE = T5.DEPT_CODE \nWHERE T5.DEPT_NAME = 'Computer Information Systems'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of employees, the office locations of professors, and descriptions of courses from the respective tables. The data is retrieved by joining the 'CLASS' table with the 'EMPLOYEE', 'COURSE', and 'PROFESSOR' tables based on their relationships, specifically linking professors to their classes and courses.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num\"\n    }\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE are needed to find the department offering a specific class.", "The relationship between DEPARTMENT and COURSE is established through the DEPT_CODE foreign key.", "We need to filter the courses based on their description containing the word 'Statistics'.", "Use the LIKE operator to search for 'Statistics' in the CRS_DESCRIPTION column of the COURSE table.", "Select the DEPT_NAME from the DEPARTMENT table after joining it with the COURSE table based on DEPT_CODE."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT DEPT_NAME \nFROM DEPARTMENT \nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE \nWHERE CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["Identify the relevant table: The question asks about competition types and countries, which are found in the 'competition' table.", "Select the required columns: We need to select 'Competition_type' and 'Country' from the 'competition' table.", "Construct the SQL query: Using the identified table and selected columns, the SQL query is formed as 'SELECT Competition_type, Country FROM competition'."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "pred_sql": "SELECT Competition_type, Country FROM competition;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides information about the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.\",\n        \"virtual_table\": \"SELECT Competition_type ,  Country FROM competition\"\n    }\n}\n"}
{"sample_id": "train.3355", "db_id": "sports_competition", "question": "Please show the names and the players of clubs.", "rationale": ["Identify the tables needed: 'club' for club names and 'player' for player names.", "Determine the relationship between the tables: 'club' and 'player' are linked by 'Club_ID'.", "Use a JOIN operation to combine the data from both tables based on 'Club_ID'.", "Select the desired columns: the name of the club and the name of the player."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "pred_sql": "SELECT T1.name, T2.name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID = T2.Club_ID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of clubs along with the unique identifiers of players associated with those clubs. The join operation links the 'club' table and the 'player' table based on the common 'Club_ID' field, allowing for the retrieval of player information for each club.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID\"\n    }\n}\n"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["We need to find the positions of players whose average points scored is greater than 20.", "To do this, we will select the 'Position' column from the 'player' table.", "We will group the results by 'Position' to calculate the average points for each position.", "We will use the HAVING clause to filter the groups where the average points is greater than 20."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "pred_sql": "SELECT Position\nFROM player\nGROUP BY Position\nHAVING AVG(Points) > 20;", "hint": "\n"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant column for player positions, which is 'Position'.", "Identify the column that contains the points scored by players, which is 'Points'.", "Formulate the condition to filter players based on their points: greater than 20 or less than 10.", "Construct the SQL query to select the 'Position' from the 'player' table where the points meet the specified conditions."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player WHERE Points > 20 OR Points < 10;", "hint": "\n"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competition types and countries.", "Filter for tournament competitions: We need to focus on rows where the Competition_type is 'tournament'.", "Count the number of tournaments per country: Use COUNT(*) to count the occurrences of each country in the filtered results.", "Group the results by country: Use GROUP BY Country to aggregate the counts for each country.", "Order the results: Use ORDER BY Tournament_Count DESC to sort the countries by the number of tournaments in descending order.", "Limit the results to the top country: Use LIMIT 1 to get only the country with the most tournaments."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country, COUNT(*) AS Tournament_Count \nFROM competition \nWHERE Competition_type = 'tournament' \nGROUP BY Country \nORDER BY Tournament_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides information about the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.\",\n        \"virtual_table\": \"SELECT Competition_type ,  Country FROM competition\"\n    }\n}\n"}
{"sample_id": "train.3384", "db_id": "sports_competition", "question": "what is the name of the country that participated in the most tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competition types and countries.", "Filter for tournament competitions: We need to focus on rows where the Competition_type is 'tournament'.", "Count the number of tournaments per country: Use COUNT(*) to count the number of tournaments for each country.", "Group the results by country: Use GROUP BY Country to aggregate the counts for each country.", "Order the results: Use ORDER BY Tournament_Count DESC to sort the countries by the number of tournaments in descending order.", "Limit the results to the top country: Use LIMIT 1 to get only the country with the most tournaments."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country, COUNT(*) AS Tournament_Count \nFROM competition \nWHERE Competition_type = 'tournament' \nGROUP BY Country \nORDER BY Tournament_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides information about the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.\",\n        \"virtual_table\": \"SELECT Competition_type ,  Country FROM competition\"\n    }\n}\n"}
{"sample_id": "train.3388", "db_id": "sports_competition", "question": "What are the countries that have never participated in any friendly-type competitions?", "rationale": ["We need to find countries that have never participated in friendly-type competitions.", "First, we can create a subquery that selects distinct countries from the competition table where the competition type is 'friendly'.", "Next, we will select distinct countries from the competition table and use the NOT IN clause to exclude those countries that were found in the subquery.", "This will give us the list of countries that have not participated in any friendly-type competitions."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT Country \nFROM competition \nWHERE Country NOT IN (\n    SELECT DISTINCT Country \n    FROM competition \n    WHERE Competition_type = 'friendly'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides information about the types of competitions and the countries where they are held from the 'competition' table. The placeholders represent the specific competition type and country details.\",\n        \"virtual_table\": \"SELECT Competition_type ,  Country FROM competition\"\n    }\n}\n"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["Identify the relevant table: The 'employees' table contains the necessary information about employees, including their first name, last name, and salary.", "Determine the required fields: We need to select the 'FIRST_NAME', 'LAST_NAME', and 'SALARY' columns from the 'employees' table.", "Apply the filter condition: We need to filter the results to include only those employees whose salary is below 6000, which can be done using a WHERE clause.", "Construct the SQL query: Combine the selected fields and the filter condition into a complete SQL query."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME, LAST_NAME, SALARY FROM employees WHERE SALARY < 6000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department id.", "To create the full name, concatenate the first and last names using '||'.", "Filter employees whose first name does not contain the letter 'M' using the NOT LIKE operator.", "Select the relevant fields from the 'employees' table."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID FROM employees WHERE FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by DEPARTMENT_ID.", "Construct the SQL query using the SELECT statement with the identified fields and conditions."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs to filter out departments managed by those IDs.\",\n        \"virtual_table\": \"SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department id.", "To create the full name, concatenate the first and last names using '||'.", "Filter employees whose first name does not contain the letter 'M' using the NOT LIKE operator.", "Order the results by department id in ascending order.", "Construct the SQL query using the SELECT statement with the identified fields and conditions."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant tables: jobs and employees.", "Determine the relationship between jobs and employees: employees have a JOB_ID that links to jobs.", "Select the JOB_TITLE from the jobs table.", "Filter the results to include only those employees whose salary is greater than 9000.", "Use DISTINCT to ensure unique job titles are returned."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT DISTINCT jobs.JOB_TITLE FROM jobs JOIN employees ON jobs.JOB_ID = employees.JOB_ID WHERE employees.SALARY > 9000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The question asks for job titles and salary ranges, which are found in the 'jobs' table.", "Select the required columns: We need to select 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY' from the 'jobs' table.", "Apply the filter: The question specifies that we need jobs with a maximum salary between 12000 and 18000, so we will use a WHERE clause to filter 'MAX_SALARY' accordingly.", "Construct the SQL query: Combine the selected columns and the filter into a complete SQL query."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY \nFROM jobs \nWHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["We need to find the employee IDs and the final dates of employment at their last job.", "The relevant tables are 'employees' and 'job_history'.", "We will join the 'employees' table with the 'job_history' table on the EMPLOYEE_ID.", "To get the final date of employment, we need to find the maximum END_DATE for each employee in the job_history table.", "We can use a subquery to get the maximum END_DATE for each employee and filter the results accordingly."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT e.EMPLOYEE_ID, j.END_DATE\nFROM employees e\nJOIN job_history j ON e.EMPLOYEE_ID = j.EMPLOYEE_ID\nWHERE j.END_DATE = (SELECT MAX(END_DATE) FROM job_history WHERE EMPLOYEE_ID = e.EMPLOYEE_ID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["Identify the tables needed: We need data from the 'employees' table for salary and commission percentage, and from the 'departments' table for department names.", "Join the 'employees' table with the 'departments' table on the DEPARTMENT_ID to associate employees with their respective departments.", "Filter the results to include only those employees who have a non-null commission percentage, indicating they receive a commission.", "Use the AVG() function to calculate the average salary of employees for each department.", "Group the results by department name to get the average salary for each department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_NAME, AVG(e.SALARY) AS average_salary\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nWHERE e.COMMISSION_PCT IS NOT NULL\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["Identify the table needed: The 'employees' table contains the salary and commission percentage information.", "Determine the condition: We need to filter employees whose commission percentage is not null.", "Use the AVG() function: To calculate the average salary of the filtered employees, we will use the AVG() function on the SALARY column.", "Construct the SQL query: Combine the SELECT statement with the AVG() function and the WHERE clause to filter the results."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT AVG(SALARY) AS average_salary FROM employees WHERE COMMISSION_PCT IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["Identify the required columns: COUNTRY_ID from countries and the count of cities from locations.", "To get the number of cities for each country, we need to join the countries table with the locations table on the COUNTRY_ID.", "Use the COUNT() function to count the number of cities for each country.", "Group the results by COUNTRY_ID to ensure we get a count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT countries.COUNTRY_ID, COUNT(locations.CITY) AS number_of_cities\nFROM countries\nJOIN locations ON countries.COUNTRY_ID = locations.COUNTRY_ID\nGROUP BY countries.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["Identify the tables needed: 'countries' for country information and 'locations' for city information.", "Determine the relationship between the tables: 'locations' has a foreign key 'COUNTRY_ID' that links to 'countries'.", "Use a JOIN to combine 'countries' and 'locations' on 'COUNTRY_ID'.", "Count the number of cities (from 'locations') for each country (from 'countries').", "Group the results by 'COUNTRY_ID' to get the count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT c.COUNTRY_ID, COUNT(l.CITY) AS CITY_COUNT\nFROM countries c\nJOIN locations l ON c.COUNTRY_ID = l.COUNTRY_ID\nGROUP BY c.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["The user wants detailed information about jobs done by employees earning a salary of 12000 or more.", "We need to filter employees based on their salary, so we will use the employees table to get those who meet the salary criteria.", "We will join the job_history table to get the jobs associated with those employees.", "Finally, we will join the jobs table to get the detailed information about each job.", "The final query will select all columns from the jobs table and the filtered job history and employee data."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "pred_sql": "SELECT * FROM jobs AS J JOIN (SELECT * FROM job_history AS T1 JOIN employees AS T2 ON T1.EMPLOYEE_ID = T2.EMPLOYEE_ID WHERE T2.SALARY >= 12000) AS JobDetails ON J.JOB_ID = JobDetails.JOB_ID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the requirement: We need information about employees who are managers.", "Understand the relationship: An employee is a manager if their 'EMPLOYEE_ID' matches the 'MANAGER_ID' in the 'departments' table.", "Join the 'employees' table with the 'departments' table on 'DEPARTMENT_ID' to get the relevant information.", "Use a DISTINCT clause to ensure that we do not have duplicate records of employees who are managers."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id WHERE T1.employee_id = T2.manager_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that duplicate records are eliminated, providing a unique list of such employees.\",\n        \"virtual_table\": \"SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id\"\n    }\n}\n"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["Identify the departments where managers are managing employees.", "To find managers managing 4 or more employees, we need to group employees by their MANAGER_ID and count the number of employees for each manager.", "Use the HAVING clause to filter those managers who have 4 or more employees.", "Select the DEPARTMENT_ID from the departments table where the MANAGER_ID is in the list of managers identified in the previous step."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DEPARTMENT_ID FROM departments WHERE MANAGER_ID IN (SELECT MANAGER_ID FROM employees GROUP BY MANAGER_ID HAVING COUNT(EMPLOYEE_ID) >= 4)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that duplicate records are eliminated, providing a unique list of such employees.\",\n        \"virtual_table\": \"SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id\"\n    }\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find distinct department IDs where a manager oversees 4 or more employees.", "To do this, we first need to identify managers who have 4 or more employees reporting to them. We can achieve this by grouping the employees by their manager ID and counting the number of employees for each manager.", "Using a subquery, we can select the manager IDs that have 4 or more employees using the HAVING clause.", "Next, we join the departments table with the employees table to get the department IDs for those managers identified in the subquery.", "Finally, we select distinct department IDs from this joined result to ensure we do not have duplicates."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DISTINCT d.DEPARTMENT_ID \nFROM departments d \nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nWHERE d.MANAGER_ID IN (\n    SELECT e1.MANAGER_ID \n    FROM employees e1 \n    GROUP BY e1.MANAGER_ID \n    HAVING COUNT(e1.EMPLOYEE_ID) >= 4\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that duplicate records are eliminated, providing a unique list of such employees.\",\n        \"virtual_table\": \"SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id\"\n    }\n}\n"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["Identify the relevant tables: 'employees' for employee details and 'job_history' for job history.", "Join the 'job_history' table with the 'employees' table on the employee ID to get comprehensive information.", "Filter the results to include only those employees whose salary is greater than the minimum salary from the 'jobs' table and less than 2500.", "Use a subquery to get the minimum salary from the 'jobs' table for comparison."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "pred_sql": "SELECT * FROM job_history AS T1 JOIN employees AS T2 ON T1.EMPLOYEE_ID = T2.EMPLOYEE_ID WHERE T2.SALARY > (SELECT MIN(MIN_SALARY) FROM jobs) AND T2.SALARY < 2500", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["Identify the requirement: We need the full names and hire dates of employees who work in the same department as an employee named Clara.", "To find Clara's department, we will first query the employees table to get Clara's department ID.", "We will use a subquery to find the department ID of Clara by joining the employees table with the departments table.", "Once we have Clara's department ID, we can then select the first name, last name, and hire date of all employees in that department.", "The final query will join the employees table with the departments table to filter employees based on the department ID obtained from the subquery."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, e.HIRE_DATE \nFROM employees AS e \nJOIN departments AS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nWHERE d.DEPARTMENT_ID = (SELECT d2.DEPARTMENT_ID \n                         FROM employees AS e2 \n                         JOIN departments AS d2 ON e2.DEPARTMENT_ID = d2.DEPARTMENT_ID \n                         WHERE e2.FIRST_NAME = 'Clara')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the relevant tables: We need to retrieve employee names and hire dates, which are in the 'employees' table, and we need to filter by department, which is in the 'departments' table.", "We need to find the department of the employee named Clara. This requires a subquery that selects the department ID for Clara from the 'employees' and 'departments' tables.", "The main query will select the first name, last name, and hire date of employees from the 'employees' table who belong to the same department as Clara, excluding Clara herself.", "The final SQL query combines these elements, using a JOIN to link employees to their departments and a WHERE clause to filter based on Clara's department and exclude Clara."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, e.HIRE_DATE \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nWHERE d.DEPARTMENT_ID = (SELECT d2.DEPARTMENT_ID \n                         FROM employees e2 \n                         JOIN departments d2 ON e2.DEPARTMENT_ID = d2.DEPARTMENT_ID \n                         WHERE e2.FIRST_NAME = 'Clara') \nAND e.FIRST_NAME != 'Clara';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["We need to find employees who work in the same department as any employee whose name contains 'T'.", "First, we will create a subquery to find the department IDs of employees whose first or last name contains 'T'.", "The subquery will select distinct department IDs from the employees table where the first name or last name matches the condition using the LIKE operator.", "Next, we will use this subquery in the main query to select the employee ID, first name, and last name of employees who belong to those departments.", "We will join the employees table with the departments table to ensure we can filter by department ID.", "Finally, we will use DISTINCT to avoid duplicate entries in the result set."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "pred_sql": "SELECT DISTINCT T1.employee_id, T1.first_name, T1.last_name \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nWHERE T2.department_id IN (\n    SELECT DISTINCT T3.department_id \n    FROM employees AS T3 \n    WHERE T3.first_name LIKE '%T%' OR T3.last_name LIKE '%T%'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the main requirement: to display employee number (EMPLOYEE_ID) and job id (JOB_ID) for employees with a salary smaller than any salary of those with job title 'MK_MAN'.", "To achieve this, we need to use a subquery that finds the minimum salary of employees with the job title 'MK_MAN'.", "The subquery will join the 'employees' table with the 'jobs' table to filter by job title.", "The main query will select EMPLOYEE_ID and JOB_ID from the 'employees' table where the salary is less than the result of the subquery."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID FROM employees WHERE SALARY < (SELECT MIN(SALARY) FROM employees JOIN jobs ON employees.JOB_ID = jobs.JOB_ID WHERE JOB_TITLE = 'MK_MAN')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n        \"virtual_table\": \"SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To do this, we will join the 'employees' table with the 'departments' table using the DEPARTMENT_ID.", "We will group the results by DEPARTMENT_ID to aggregate the salaries.", "We will use the SUM function to calculate the total salaries for each department.", "To filter the departments that have more than 2 employees, we will use the HAVING clause with COUNT to count the number of employees in each department."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, SUM(e.SALARY) AS total_salaries \nFROM employees AS e \nJOIN departments AS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_ID \nHAVING COUNT(e.EMPLOYEE_ID) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To get the full name, we can concatenate the first name and last name of the employee using '||'.", "We will select the DEPARTMENT_ID, the concatenated full name, and the SALARY from the employees table.", "To find the highest salary in each department, we can use a subquery that selects the maximum salary from the employees table, grouped by DEPARTMENT_ID.", "The main query will filter employees whose salary matches the maximum salary for their respective department."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                  FROM employees \n                  WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the tables needed: employees for names, departments for linking to locations, and locations for city information.", "Use a JOIN to connect employees to departments and then to locations based on their identifiers.", "Select the full name by concatenating first and last names, and also select the city from the locations table.", "Filter the results to include only those employees whose first names contain the letter 'Z' using the LIKE operator."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name || ' ' || T1.last_name AS full_name, T3.city \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nWHERE T1.first_name LIKE '%Z%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "Join the employees table with the departments table on department_id to get department information for each employee.", "Join the departments table with the locations table on location_id to get location information for each department.", "Join the locations table with the countries table on country_id to get the country information for each location.", "Select the first name and last name from the employees table and the country name from the countries table.", "Add a WHERE clause to filter the results for a specific employee ID."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name, T1.last_name, T4.country_name \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nJOIN countries AS T4 ON T3.country_id = T4.country_id \nWHERE T1.employee_id = ?", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "To get the department name, we will select it from the 'departments' table.", "To count the number of employees in each department, we will use the COUNT function on the 'EMPLOYEE_ID' from the 'employees' table.", "We will join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' to link employees to their respective departments.", "Since some departments may not have any employees, we will use a LEFT JOIN to ensure all departments are included in the result.", "Finally, we will group the results by the department name to get the count of employees per department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES \nFROM departments AS d \nLEFT JOIN employees AS e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["We need to retrieve the department names and the count of employees in each department.", "The relevant tables for this query are 'departments' and 'employees'.", "We will perform a LEFT JOIN between 'departments' and 'employees' on the 'DEPARTMENT_ID' to ensure we get all departments even if they have no employees.", "We will select the 'DEPARTMENT_NAME' from the 'departments' table and count the 'EMPLOYEE_ID' from the 'employees' table to get the number of employees in each department.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS EMPLOYEE_COUNT \nFROM departments AS d \nLEFT JOIN employees AS e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["We need to display the full name (first and last name) and salary of employees.", "The relevant tables are 'employees', 'departments', and 'locations'.", "We will join 'employees' with 'departments' on 'department_id' to get department information.", "Next, we will join 'departments' with 'locations' on 'location_id' to filter by city.", "Finally, we will filter the results to include only those employees whose departments are located in London."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name, T1.last_name, T1.salary \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nWHERE T3.city = 'London'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "We need to retrieve the first name, last name, and salary of employees.", "Join the employees table with the departments table on department_id to get department information.", "Join the departments table with the locations table on location_id to get location information.", "Join the locations table with the countries table on country_id to get country information.", "Filter the results to only include employees working in the city of London."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name, T1.last_name, T1.salary \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nJOIN countries AS T4 ON T3.country_id = T4.country_id \nWHERE T3.city = 'London';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3532", "db_id": "music_1", "question": "Find the id of the song that lasts the longest.", "rationale": ["Identify the tables involved: 'song' and 'files'.", "We need to find the song with the longest duration, which is stored in the 'files' table.", "Join the 'song' table with the 'files' table on the 'f_id' column to access the duration of each song.", "Order the results by the duration in descending order to get the longest duration first.", "Limit the results to 1 to get only the longest song's id."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT T1.f_id FROM song AS T1 JOIN files AS T2 ON T1.f_id = T2.f_id ORDER BY T2.duration DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["Identify the relevant tables: 'song' for artist names and 'files' for song durations.", "Join the 'song' table with the 'files' table on the foreign key 'f_id' to access the duration of each song.", "Select the 'artist_name' from the joined tables.", "Order the results by the 'duration' column in ascending order to get the shortest song first.", "Limit the results to 1 to get only the artist who sang the shortest song."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "pred_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id = T2.f_id ORDER BY T2.duration LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["Identify the relevant tables: 'song' and 'files' are needed to access song details and their durations.", "Join the 'song' table with the 'files' table on the foreign key 'f_id' to link songs with their respective file details.", "Use the COUNT() function to count the number of songs that meet the specified duration criteria.", "Filter the results using a WHERE clause to specify that the duration must be '4:00'."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "pred_sql": "SELECT COUNT(*) FROM song AS T1 JOIN files AS T2 ON T1.f_id = T2.f_id WHERE T2.duration = '4:00'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3549", "db_id": "music_1", "question": "What is the average rating of songs produced by female artists?", "rationale": ["Identify the tables involved: We need to use the 'artist' table to filter by gender and the 'song' table to get the ratings of the songs.", "Determine the relationship between the tables: The 'artist' table is linked to the 'song' table through the 'artist_name' column.", "Use the average function: We need to calculate the average rating of songs, which can be done using the AVG() function in SQL.", "Construct the SQL query: Based on the hint provided, we will replace the placeholder in the virtual table with 'female' to filter for female artists."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "pred_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name WHERE T1.gender = 'female'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average rating of songs performed by artists of a specific gender. The placeholder in the WHERE clause represents the gender of the artists being queried.\",\n        \"virtual_table\": \"SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["Identify the table to query: The 'files' table contains the 'formats' column which we need to analyze.", "Group the results by the 'formats' column to count how many files exist for each format.", "Order the results in descending order based on the count of files to find the most common format.", "Limit the results to 1 to get only the top format used by the most files."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of audio file formats from the 'files' table, grouped by format type. The results are ordered by the count of files in each format, allowing users to see the most common formats used. The placeholder in the LIMIT clause represents the maximum number of formats to return.\",\n        \"virtual_table\": \"SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3556", "db_id": "music_1", "question": "What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?", "rationale": ["Identify the relevant table: The 'files' table contains the information about file formats and resolutions.", "Determine the conditions: We need to filter files that are in the 'mp4' format and have a resolution smaller than 1000.", "Construct the SQL query: Use a SELECT statement to retrieve the 'f_id' from the 'files' table where the conditions are met. Use the LIKE operator to check for 'mp4' in the 'formats' column and CAST the 'resolution' to an integer for comparison."], "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"], "pred_sql": "SELECT f_id FROM files WHERE formats LIKE '%mp4%' AND CAST(resolution AS INTEGER) < 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of file identifiers from the 'files' table, sorted by the duration of the audio files in descending order. The placeholder in the LIMIT clause indicates the maximum number of file identifiers to return.\",\n        \"virtual_table\": \"SELECT f_id FROM files ORDER BY duration DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["Identify the relevant tables: 'artist' and 'song'.", "We need to find artists who are female, so we will filter the 'artist' table by gender = 'female'.", "We also need to find songs that are in Bangla, so we will filter the 'song' table by checking if the 'languages' column contains 'Bangla'.", "Join the 'artist' table with the 'song' table on the 'artist_name' column to combine the relevant information.", "Select the 'country' column from the 'artist' table to get the country of origin of the female artists who produced songs in Bangla."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE artist.gender = 'female' AND song.languages LIKE '%Bangla%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["Identify the relevant tables: 'artist' and 'song'.", "We need to filter artists based on gender, specifically female artists, so we will use the 'gender' column from the 'artist' table.", "We also need to filter songs based on the language, specifically those sung in Bangla, so we will use the 'languages' column from the 'song' table.", "We will join the 'artist' table with the 'song' table on the 'artist_name' column to get the relevant information about the artists and their songs.", "Finally, we will select the artist's name and country from the joined tables, applying the necessary filters for gender and language."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE artist.gender = 'female' AND song.languages LIKE '%Bangla%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["Identify the relevant tables: 'artist' for artist details and 'song' for song details.", "Join the 'artist' table with the 'song' table on the artist's name to get the necessary information about the artist who performed the song.", "Order the results by the 'resolution' column in the 'song' table to find the song with the smallest resolution.", "Limit the results to 1 to get only the artist associated with the song that has the smallest resolution."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "pred_sql": "SELECT T1.gender, T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name ORDER BY T2.resolution LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3567", "db_id": "music_1", "question": "For each file format, return the number of artists who released songs in that format.", "rationale": ["We need to count the number of distinct artists who released songs in each file format.", "To do this, we will join the 'files' table with the 'song' table on the file ID (f_id) to associate songs with their respective files.", "Next, we will join the 'song' table with the 'artist' table on the artist name to get the artist information for each song.", "We will then group the results by the 'formats' column from the 'files' table to count the number of distinct artists for each format.", "Finally, we will select the format and the count of distinct artists, giving us the desired result."], "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"], "pred_sql": "SELECT f.formats, COUNT(DISTINCT a.artist_name) AS artist_count \nFROM files f \nJOIN song s ON f.f_id = s.f_id \nJOIN artist a ON s.artist_name = a.artist_name \nGROUP BY f.formats;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of audio file formats from the 'files' table, grouped by format type. The results are ordered by the count of files in each format, allowing users to see the most common formats used. The placeholder in the LIMIT clause represents the maximum number of formats to return.\",\n        \"virtual_table\": \"SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3576", "db_id": "music_1", "question": "What are the names and genders of all artists who released songs in the month of March?", "rationale": ["Identify the tables involved: 'artist' and 'song'.", "We need to retrieve the names and genders of artists, so we will select 'artist_name' and 'gender' from the 'artist' table.", "To find artists who released songs in March, we need to filter the 'song' table based on the 'releasedate' column.", "Use the strftime function to extract the month from the 'releasedate' and check if it equals '03' for March.", "Join the 'artist' table with the 'song' table on the 'artist_name' to correlate artists with their songs."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "pred_sql": "SELECT T1.artist_name, T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name WHERE strftime('%m', T2.releasedate) = '03'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["Identify the relevant table: The 'song' table contains the 'languages' column that we need to analyze.", "Group the results by 'languages': This allows us to count how many songs are available in each language.", "Order the results: We want to order the languages by the number of songs, so we use 'ORDER BY count(*) DESC' to get the most common languages first.", "Select the languages: We only need the 'languages' column in our final output."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "pred_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of languages in which songs are available, grouped by language and ordered by the number of songs in each language. The placeholder in the LIMIT clause allows the user to specify the maximum number of languages to retrieve.\",\n        \"virtual_table\": \"SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3590", "db_id": "music_1", "question": "What are the names of all male British artists?", "rationale": ["Identify the relevant table: The 'artist' table contains information about artists, including their gender and country.", "Determine the conditions: We need to filter for male artists from Britain.", "Construct the SQL query: Use a SELECT statement to retrieve the artist names from the 'artist' table where the gender is 'male' and the country is 'British'."], "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"], "pred_sql": "SELECT artist_name FROM artist WHERE gender = 'male' AND country = 'British';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the gender and name of artists from the 'artist' table who have songs listed in the 'song' table. The results are ordered by the audio resolution of the songs, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3598", "db_id": "music_1", "question": "What is the average rating and resolution of all bangla songs?", "rationale": ["Identify the tables needed: We need the 'song' table for song details and the 'artist' table for artist details.", "Determine the columns to select: We need the average rating of the songs and the resolution of the songs.", "Join the tables: We will join the 'artist' table and the 'song' table on the artist's name.", "Filter the results: We need to filter the songs to only include those that are of the 'bangla' genre.", "Calculate the average rating: We will use the AVG function to calculate the average rating of the songs that match the criteria."], "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"], "pred_sql": "SELECT avg(T2.rating) AS average_rating, T2.resolution FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name WHERE T2.genre_is = 'bangla'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average rating of songs performed by artists of a specific gender. The placeholder in the WHERE clause represents the gender of the artists being queried.\",\n        \"virtual_table\": \"SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3599", "db_id": "music_1", "question": "What are the maximum and minimum resolution of songs whose duration is 3 minutes?", "rationale": ["Identify the tables involved: 'files' and 'song'.", "Determine the relationship between the tables: 'files' is joined with 'song' on the 'f_id' column.", "Focus on the requirement: finding maximum and minimum resolutions of songs with a specific duration.", "Use the provided hint to construct the SQL query, replacing the placeholder with the actual duration '3 minutes'.", "The final SQL query selects the maximum and minimum resolutions from the joined tables based on the specified duration."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "pred_sql": "SELECT max(T2.resolution), min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id WHERE T1.duration LIKE '3 minutes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum and minimum audio resolutions of songs from the 'song' table, filtered by the duration of the associated files in the 'files' table. The placeholder in the WHERE clause represents the specific duration pattern to match.\",\n        \"virtual_table\": \"SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["Identify the columns needed: maximum duration and resolution of songs, and the languages they are available in.", "Use the MAX() function to get the maximum values for duration and resolution.", "Group the results by languages to aggregate the maximum values for each language.", "Order the results by the count of songs in each language to prioritize the most popular languages."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "pred_sql": "SELECT MAX(duration) AS max_duration, MAX(resolution) AS max_resolution, languages FROM song GROUP BY languages ORDER BY COUNT(*) DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of languages in which songs are available, grouped by language and ordered by the number of songs in each language. The placeholder in the LIMIT clause allows the user to specify the maximum number of languages to retrieve.\",\n        \"virtual_table\": \"SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["Identify the relevant columns needed for the query: genre, duration, and rating from the song table.", "Use the MIN() function to find the shortest duration and lowest rating for each genre.", "Group the results by genre using GROUP BY clause to aggregate the data accordingly.", "Order the results by genre using ORDER BY clause to sort the output."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "pred_sql": "SELECT genre_is, MIN(duration) AS shortest_duration, MIN(rating) AS lowest_rating \nFROM song \nGROUP BY genre_is \nORDER BY genre_is;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of songs from the 'song' table that belong to a specific genre or are available in a specific language. The placeholders in the WHERE clause represent the genre and language criteria.\",\n        \"virtual_table\": \"SELECT song_name FROM song WHERE genre_is  =  [PLACEHOLDER-TYPE:STRING] OR languages  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3607", "db_id": "music_1", "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "rationale": ["Identify the tables involved: 'artist' and 'song'.", "We need to select the artist's name and country, which are in the 'artist' table.", "We need to filter the results based on the resolution of the songs, which is a column in the 'song' table.", "Join the 'artist' table with the 'song' table on the artist's name to ensure we only get artists who have released songs.", "Apply the condition to filter songs with resolution greater than 900."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE song.resolution > 900;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of artist names and their corresponding countries from the 'artist' table, joined with the 'song' table to include only those artists who have songs. The results are ordered by the rating of the songs in descending order, and the number of results is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3619", "db_id": "music_1", "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their languages and the artists who performed them.", "Filter songs by language: We need to filter the songs to only include those that have 'Bangla' in their languages column.", "Group by artist: To find the top artists, we will group the results by 'artist_name' and count the number of songs for each artist.", "Order the results: We will order the grouped results by the count of songs in descending order to get the artists with the most songs in Bangla at the top.", "Limit the results: Finally, we will limit the results to the top 3 artists."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist_name, COUNT(song_name) AS song_count \nFROM song \nWHERE languages LIKE '%Bangla%' \nGROUP BY artist_name \nORDER BY song_count DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of languages in which songs are available, grouped by language and ordered by the number of songs in each language. The placeholder in the LIMIT clause allows the user to specify the maximum number of languages to retrieve.\",\n        \"virtual_table\": \"SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3623", "db_id": "music_1", "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "Determine the columns needed: duration from 'song', file_size and formats from 'files'.", "Establish the relationship between the tables using the foreign key: 'song.f_id' relates to 'files.f_id'.", "Filter the results to include only songs where the genre is 'pop'.", "Order the results by the song title (song_name).", "Construct the SQL query using the SELECT statement with the appropriate JOIN and WHERE clauses."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT T1.duration, T2.file_size, T2.formats \nFROM song AS T1 \nJOIN files AS T2 ON T1.f_id = T2.f_id \nWHERE T1.genre_is = 'pop' \nORDER BY T1.song_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "We need to select the duration, file size, and formats, which are in the 'song' and 'files' tables.", "Join the 'song' table with the 'files' table on the foreign key 'f_id' to access both song and file details.", "Filter the results to include only those songs that belong to the 'pop' genre using a WHERE clause.", "Order the results alphabetically by the song title using ORDER BY clause."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT T1.duration, T2.file_size, T2.formats \nFROM song AS T1 \nJOIN files AS T2 ON T1.f_id = T2.f_id \nWHERE T1.genre_is = 'pop' \nORDER BY T1.song_name ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table, joined with the 'files' table to access the duration of their songs. The results are ordered by the duration of the audio files, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["Identify the relevant tables: 'salary' for player salaries and 'team' for team names.", "Join the 'salary' table with the 'team' table on the team identifier to link salaries to the respective teams.", "Use the 'avg' function to calculate the average salary from the 'salary' table.", "Filter the results to include only those players from the team named 'Boston Red Stockings' using a WHERE clause."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "pred_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average salary of players from a specific team in the 'salary' table. The placeholder in the WHERE clause represents the name of the team for which the average salary is being calculated.\",\n        \"virtual_table\": \"SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their birth countries.", "Select the 'birth_country' column and count the number of players from each country using COUNT(player_id).", "Group the results by 'birth_country' to aggregate the player counts for each country.", "Order the results in ascending order based on the player count to find the countries with the least players.", "Limit the results to the top 3 countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["We need to find the highest salary for each team, which requires aggregating salary data by team.", "To do this, we will use the MAX function to get the maximum salary.", "We will join the salary table with the team table to get the team names and IDs.", "The join condition will be on the team_id column from both tables.", "Finally, we will group the results by team_id and team name to ensure we get the maximum salary for each team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T2.name, T2.team_id, MAX(T1.salary) AS max_salary \nFROM salary AS T1 \nJOIN team AS T2 ON T1.team_id = T2.team_id \nGROUP BY T2.team_id, T2.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3658", "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["We need to retrieve the team name, team id, and the maximum salary for each team.", "To do this, we will select the team name and team id from the 'team' table.", "We will also need to calculate the maximum salary from the 'salary' table.", "We will join the 'salary' table with the 'team' table on the team_id to associate salaries with the correct teams.", "We will use the MAX() function to find the maximum salary for each team.", "Finally, we will group the results by team name and team id to ensure we get one result per team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T2.name, T2.team_id, MAX(T1.salary) AS max_salary\nFROM salary AS T1\nJOIN team AS T2 ON T1.team_id = T2.team_id\nGROUP BY T2.name, T2.team_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["Identify the tables needed: 'team' for team names and IDs, and 'salary' for salary information.", "Join the 'team' table with the 'salary' table on 'team_id' to associate teams with their salaries.", "Group the results by 'team_id' to calculate the average salary for each team.", "Order the results by the average salary in ascending order to find the team with the lowest average salary.", "Limit the results to 1 to get only the team with the lowest average salary."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T2.name, T2.team_id FROM team AS T2 JOIN salary AS T1 ON T2.team_id = T1.team_id GROUP BY T2.team_id ORDER BY AVG(T1.salary) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average salary of players from a specific team in the 'salary' table. The placeholder in the WHERE clause represents the name of the team for which the average salary is being calculated.\",\n        \"virtual_table\": \"SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["Identify the tables needed: We need the 'player' table for player names and the 'player_award' table to check for awards won by players.", "Join the 'player' table with the 'player_award' table twice: one for the year 1960 and another for the year 1961. This allows us to find players who won awards in both years.", "Use the condition in the WHERE clause to filter the results for the specific years (1960 and 1961).", "Select the first and last names of the players who meet the criteria."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.name_first, p.name_last\nFROM player p\nJOIN player_award pa1 ON p.player_id = pa1.player_id\nJOIN player_award pa2 ON p.player_id = pa2.player_id\nWHERE pa1.year = 1960 AND pa2.year = 1961;", "hint": "\n"}
{"sample_id": "train.3663", "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["Identify the columns needed: 'name_given' for the first name and 'name_last' for the last name from the 'player' table.", "Determine the conditions for filtering: weight greater than 220 or height shorter than 75.", "Construct the SQL SELECT statement to retrieve the specified columns from the 'player' table with the appropriate WHERE clause for the conditions."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_given, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "\n"}
{"sample_id": "train.3664", "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["Identify the relevant table: The 'player' table contains the information about players including their first name, last name, weight, and height.", "Determine the columns needed: We need 'name_first' and 'name_last' for the player's names.", "Establish the conditions: We want players with a weight greater than 220 or a height less than 75.", "Construct the SQL query: Use a SELECT statement to retrieve the names from the 'player' table where the specified conditions are met."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) of the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include the Boston Red Stockings.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(wins) FROM postseason AS P JOIN team AS T ON P.team_id_winner = T.team_id WHERE T.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) for the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(wins) FROM postseason AS P JOIN team AS T ON P.team_id_winner = T.team_id WHERE T.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3672", "db_id": "baseball_1", "question": "For each year, return the year and the number of times the team Boston Red Stockings won in the postseasons.", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team names.", "We need to count the number of wins for the team 'Boston Red Stockings' in the postseason.", "Join the 'postseason' table with the 'team' table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Group the results by year to get the count of wins for each year."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "pred_sql": "SELECT T1.year, COUNT(*) AS wins\nFROM postseason AS T1\nJOIN team AS T2 ON T1.team_id_winner = T2.team_id_br\nWHERE T2.name = 'Boston Red Stockings'\nGROUP BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3677", "db_id": "baseball_1", "question": "What is the total salary paid by team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant tables: salary and team.", "Determine the relationship between the tables: salary table contains salary data, and team table contains team names and identifiers.", "Use a JOIN to connect the salary table with the team table based on the team_id.", "Filter the results to only include the Boston Red Stockings team and the year 2010.", "Use the SUM function to calculate the total salary for the specified team and year."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year = 2010", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant table for salary information, which is the 'salary' table.", "We need to filter the results for the year 2001, so we will use a WHERE clause to specify 'year = 2001'.", "To get the highest salaries, we will order the results by the 'salary' column in descending order using ORDER BY salary DESC.", "Finally, we limit the results to the top 3 entries using LIMIT 3."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3682", "db_id": "baseball_1", "question": "How much salary did the top 3 well-paid players get in 2001?", "rationale": ["Identify the relevant table for salary data, which is the 'salary' table.", "We need to filter the data for the year 2001, so we will use a WHERE clause to specify 'year = 2001'.", "To find the top 3 well-paid players, we will order the results by 'salary' in descending order.", "Finally, we will limit the results to the top 3 players using 'LIMIT 3'."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3683", "db_id": "baseball_1", "question": "What were all the salary values of players in 2010 and 2001?", "rationale": ["Identify the relevant table: The salary table contains the salary information for players.", "Determine the years of interest: The user wants salary values for the years 2010 and 2001.", "Construct the SQL query: Use a SELECT statement to retrieve the salary column from the salary table where the year is either 2010 or 2001."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT salary FROM salary WHERE year IN (2010, 2001);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "To do this, we will count the number of inductions for each year using the 'hall_of_fame' table.", "We will group the results by the 'yearid' column to get the count of inductions per year.", "Next, we will order the results in ascending order based on the count of inductions to find the year with the least.", "Finally, we will limit the results to just one entry to get the year with the least inductions."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) AS num_inductions FROM hall_of_fame GROUP BY yearid ORDER BY num_inductions ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["To find the year with the least number of people entering the Hall of Fame, we need to count the number of inductions for each year.", "The 'hall_of_fame' table contains the 'yearid' column which indicates the year of induction and we can use it to group our results.", "We will use the COUNT function to count the number of inductions for each year.", "We will group the results by 'yearid' to get the count for each year.", "Finally, we will order the results in ascending order based on the count of inductions and limit the results to 1 to get the year with the least inductions."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) AS num_inductions FROM hall_of_fame GROUP BY yearid ORDER BY num_inductions ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: home_game and park.", "We need to find the total number of games played in a specific park (Columbia Park) in a specific year (1907).", "First, we will find the park_id for 'Columbia Park' from the park table.", "Then, we will sum the games from the home_game table where the park_id matches and the year is 1907."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) FROM home_game WHERE park_id = (SELECT park_id FROM park WHERE park_name = 'Columbia Park') AND year = 1907;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: home_game (for home games) and park (for park details).", "Join the home_game table with the park table on the park_id to link games to their respective parks.", "Filter the results to only include games that took place in 'Columbia Park' in the year 1907.", "Use COUNT(*) to count the total number of games that meet the criteria."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT COUNT(*) FROM home_game AS H JOIN park AS P ON H.park_id = P.park_id WHERE P.park_name = 'Columbia Park' AND H.year = 1907;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant tables: home_game and team.", "We need to find the total number of games played in Atlanta in the year 2000.", "Join the home_game table with the team table on team_id to access the city information.", "Filter the results to only include games played in Atlanta in the year 2000.", "Use the SUM function to calculate the total number of games played."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) FROM home_game AS H JOIN team AS T ON H.team_id = T.team_id WHERE T.city = 'Atlanta' AND H.year = 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: home_game (for games played) and park (for city information).", "Join the home_game table with the park table on the park_id to access city information.", "Filter the results to only include games played in Atlanta in the year 2000.", "Use the SUM function to count the total number of games played in that city and year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) FROM home_game AS H JOIN park AS P ON H.park_id = P.park_id WHERE P.city = 'Atlanta' AND H.year = 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3693", "db_id": "baseball_1", "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?", "rationale": ["Identify the relevant tables: home_game and team.", "We need to sum the attendance from the home_game table.", "Join the home_game table with the team table to filter by team name.", "Filter the results for the team 'Boston Red Stockings'.", "Add a condition to limit the years from 2000 to 2010.", "Construct the SQL query to select the total attendance."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT SUM(attendance) AS total_attendance \nFROM home_game AS hg \nJOIN team AS t ON hg.team_id = t.team_id \nWHERE t.name = 'Boston Red Stockings' \nAND hg.year BETWEEN 2000 AND 2010;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3698", "db_id": "baseball_1", "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?", "rationale": ["Identify the relevant tables: player, salary, and team.", "Join the player table with the salary table on player_id to get player names and their salaries.", "Join the salary table with the team table on team_id to filter for the Washington Nationals.", "Use a WHERE clause to filter for the years 2005 and 2007.", "Group the results by player_id to ensure we get unique players.", "Use HAVING to ensure that only players who have salaries in both years (count of distinct years = 2) are included."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT p.name_first, p.name_last \nFROM player AS p \nJOIN salary AS s ON p.player_id = s.player_id \nJOIN team AS t ON s.team_id = t.team_id \nWHERE t.name = 'Washington Nationals' \nAND s.year IN (2005, 2007) \nGROUP BY p.player_id \nHAVING COUNT(DISTINCT s.year) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games played by teams.", "Determine the year of interest: The query specifies the year 1980.", "Count the total number of home games for each team in 1980: Use the 'games' column in the 'home_game' table.", "Group the results by 'team_id' to aggregate the total home games for each team.", "Order the results by the total number of home games in ascending order to find the team with the least number.", "Limit the results to 1 to get only the team with the least number of home games."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, MIN(games) AS min_home_games\nFROM home_game\nWHERE year = 1980\nGROUP BY team_id\nORDER BY min_home_games ASC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3709", "db_id": "baseball_1", "question": "Which park had most attendances in 2008?", "rationale": ["Identify the relevant tables: home_game and park.", "We need to find the park with the highest attendance in 2008, so we will join the home_game table with the park table on the park_id.", "Filter the results to only include records from the year 2008.", "Select the park name and attendance columns.", "Order the results by attendance in descending order to get the park with the highest attendance at the top.", "Limit the results to 1 to get only the park with the most attendance."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT park_name, attendance FROM home_game JOIN park ON home_game.park_id = park.park_id WHERE home_game.year = 2008 ORDER BY attendance DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n        \"virtual_table\": \"SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3857", "db_id": "insurance_policies", "question": "Find the settlement amount of the claim with the largest claim amount. Show both the settlement amount and claim amount.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find the claim with the largest claim amount, so we will use the Claims table to get the maximum Amount_Claimed.", "We will join the Claims table with the Settlements table on Claim_ID to get the corresponding settlement amount.", "The final output should include both the settlement amount (from Settlements) and the claim amount (from Claims).", "We will use a subquery to find the maximum Amount_Claimed and filter the results accordingly."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"], "pred_sql": "SELECT s.Amount_Settled, c.Amount_Claimed\nFROM Claims c\nJOIN Settlements s ON c.Claim_ID = s.Claim_ID\nWHERE c.Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claims);", "hint": "\n"}
{"sample_id": "train.3862", "db_id": "insurance_policies", "question": "Among all the claims, which settlements have a claimed amount that is no more than the average? List the claim start date.", "rationale": ["Identify the relevant tables: Settlements and Claims.", "We need to find settlements where the claimed amount is no more than the average claimed amount.", "To calculate the average claimed amount, we can use a subquery that selects the average from the Settlements table.", "Join the Settlements table with the Claims table to access the claim start date.", "Select the Date_Claim_Made from the Claims table and the Amount_Claimed from the Settlements table where the claimed amount is less than or equal to the average."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT s.Date_Claim_Made, s.Amount_Claimed \nFROM Settlements s \nJOIN Claims c ON s.Claim_ID = c.Claim_ID \nWHERE s.Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Settlements)", "hint": "\n"}
{"sample_id": "train.3863", "db_id": "insurance_policies", "question": "Return the claim start date for the claims whose claimed amount is no more than the average", "rationale": ["Identify the relevant table: Claims, since we need information about claims.", "We need to select the 'Date_Claim_Made' from the Claims table.", "We need to filter the claims based on the condition that the 'Amount_Claimed' is no more than the average claimed amount.", "To find the average claimed amount, we will use a subquery that calculates the average of 'Amount_Claimed' from the Claims table.", "The final SQL query will select the 'Date_Claim_Made' from Claims where 'Amount_Claimed' is less than or equal to the average amount calculated."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT Claims.Date_Claim_Made \nFROM Claims \nWHERE Claims.Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Claims);", "hint": "\n"}
{"sample_id": "train.3868", "db_id": "insurance_policies", "question": "How many settlements were made on the claim with the most recent claim settlement date? List the number and the claim id.", "rationale": ["Identify the table that contains the information about settlements, which is the 'Settlements' table.", "Determine that we need to count the number of settlements, so we will use the COUNT() function on 'Settlement_ID'.", "We need to filter the settlements based on the claim with the most recent settlement date. This requires a subquery.", "The subquery will select the 'Claim_ID' from the 'Claims' table, ordering by 'Date_Claim_Settled' in descending order to get the most recent claim settlement date.", "The subquery will limit the results to 1 to ensure we only get the most recent claim.", "Finally, we will group the results by 'Claim_ID' to get the count of settlements for that specific claim."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT COUNT(Settlement_ID) AS Number_of_Settlements, Claim_ID \nFROM Settlements \nWHERE Claim_ID = (\n    SELECT Claim_ID \n    FROM Claims \n    ORDER BY Date_Claim_Settled DESC \n    LIMIT 1\n) \nGROUP BY Claim_ID;", "hint": "\n"}
{"sample_id": "train.3869", "db_id": "insurance_policies", "question": "Find the claim id and the number of settlements made for the claim with the most recent settlement date.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find the claim ID and the number of settlements for the claim with the most recent settlement date.", "Join the Claims table with the Settlements table on Claim_ID to link claims with their settlements.", "Use a subquery to find the maximum settlement date from the Settlements table.", "Filter the results to only include settlements that match this maximum date.", "Group the results by Claim_ID to count the number of settlements for each claim."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT Claims.Claim_ID, COUNT(Settlements.Settlement_ID) AS Number_of_Settlements\nFROM Claims\nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID\nWHERE Settlements.Date_Claim_Settled = (\n    SELECT MAX(Date_Claim_Settled)\n    FROM Settlements\n)\nGROUP BY Claims.Claim_ID;", "hint": "\n"}
{"sample_id": "train.3878", "db_id": "insurance_policies", "question": "What is the most popular payment method?", "rationale": ["Identify the relevant table: The Payments table contains information about payment transactions, including the payment method.", "Determine the information needed: We need to find the most popular payment method, which implies counting the occurrences of each payment method.", "Group the results: Use GROUP BY to aggregate the payment transactions by Payment_Method_Code.", "Count the occurrences: Use COUNT(*) to count how many times each payment method appears.", "Order the results: Use ORDER BY to sort the results in descending order based on the count of payments.", "Limit the results: Use LIMIT 1 to get only the most popular payment method."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Payment_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Payment_Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3879", "db_id": "insurance_policies", "question": "Which payment method is used the most often?", "rationale": ["Identify the relevant table: The question is about payment methods, so we will focus on the Payments table.", "Determine the required information: We need to find out which payment method is used the most often, which implies counting the occurrences of each payment method.", "Use the COUNT function: We will count the number of times each Payment_Method_Code appears in the Payments table.", "Group the results: To get the count for each payment method, we will use GROUP BY on Payment_Method_Code.", "Order the results: To find the most used payment method, we will order the results in descending order based on the count.", "Limit the results: Since we only need the most frequently used payment method, we will limit the results to 1."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Method_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Method_Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3880", "db_id": "insurance_policies", "question": "With which kind of payment method were the least number of payments processed?", "rationale": ["Identify the relevant table: The Payments table contains information about payment transactions, including the payment method and the number of payments.", "Group the data: We need to group the results by Payment_Method_Code to count the number of payments for each method.", "Count the payments: Use COUNT(Payment_ID) to count the number of payments for each payment method.", "Order the results: We want to find the payment method with the least number of payments, so we will order the results in ascending order of the count.", "Limit the results: Since we only want the payment method with the least number of payments, we will limit the results to 1."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(Payment_ID) AS Payment_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Payment_Count ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3886", "db_id": "insurance_policies", "question": "Which kind of policy type was chosen by the most customers?", "rationale": ["Identify the relevant table: The question pertains to the types of policies chosen by customers, so we will focus on the 'Customer_Policies' table.", "Count the number of customers for each policy type: We will use the COUNT function to count the number of unique customers associated with each policy type.", "Group the results by policy type: We will use the GROUP BY clause to aggregate the counts by 'Policy_Type_Code'.", "Order the results to find the most chosen policy type: We will use the ORDER BY clause to sort the counts in descending order.", "Limit the results to the top entry: We will use the LIMIT clause to return only the policy type with the highest count."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(Customer_ID) AS Customer_Count\nFROM Customer_Policies\nGROUP BY Policy_Type_Code\nORDER BY Customer_Count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer details from the 'Customers' table, excluding those customers who have associated insurance policies. The query uses an EXCEPT clause to filter out customers that are linked to any policies in the 'Customer_Policies' table.\",\n        \"virtual_table\": \"SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id\"\n    }\n}\n"}
{"sample_id": "train.3893", "db_id": "insurance_policies", "question": "Which customers do not have any policies? Find the details of these customers.", "rationale": ["Identify the main table to retrieve customer details, which is the 'Customers' table.", "Determine the need to exclude customers who have policies, which are listed in the 'Customer_Policies' table.", "Use a JOIN operation to link 'Customers' and 'Customer_Policies' on 'Customer_ID'.", "Utilize the EXCEPT clause to filter out customers that have associated policies from the list of all customers."], "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"], "pred_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.Customer_ID = T2.Customer_ID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer details from the 'Customers' table, excluding those customers who have associated insurance policies. The query uses an EXCEPT clause to filter out customers that are linked to any policies in the 'Customer_Policies' table.\",\n        \"virtual_table\": \"SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id\"\n    }\n}\n"}
{"sample_id": "train.3895", "db_id": "insurance_policies", "question": "Which claims had exactly one settlement? For each, tell me the the date the claim was made, the date it was settled and the amount settled.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find claims that have exactly one settlement, so we will join the Claims table with the Settlements table on the Claim_ID.", "We will select the required fields: Date_Claim_Made, Date_Claim_Settled, and Amount_Settled.", "To ensure we only get claims with exactly one settlement, we will group the results by Claim_ID and use the HAVING clause to filter groups with a count of settlements equal to 1."], "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT Claims.Date_Claim_Made, Claims.Date_Claim_Settled, Settlements.Amount_Settled\nFROM Claims\nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID\nGROUP BY Claims.Claim_ID\nHAVING COUNT(Settlements.Settlement_ID) = 1;", "hint": "\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to count the number of employees in each department, which requires joining the Department table with the Physician table.", "Use a LEFT JOIN to include all departments, even those without physicians.", "Count the number of employees (physicians) in each department using COUNT(Physician.EmployeeID).", "Group the results by department name to get the count per department.", "Order the results by the count of employees in descending order to find the department with the largest number of employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Physician.EmployeeID) AS EmployeeCount\nFROM Department\nLEFT JOIN Physician ON Department.Head = Physician.EmployeeID\nGROUP BY Department.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["To find the department with the most employees, we need to count the number of physicians affiliated with each department.", "We will join the Department table with the Affiliated_With table on the DepartmentID to get the list of physicians in each department.", "We will use the COUNT function to count the number of physicians for each department.", "We will group the results by department name to get the count for each department.", "To find the department with the most employees, we will order the results by the count of employees in descending order.", "Finally, we will limit the results to 1 to get only the department with the highest count."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Affiliated_With.Physician) AS EmployeeCount\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3901", "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["We need to find the head of the department with the least employees.", "To do this, we will join the Department table with the Affiliated_With table to count the number of physicians in each department.", "We will group the results by DepartmentID to get the count of physicians per department.", "Next, we will order the results by the count of physicians in ascending order to find the department with the least employees.", "Finally, we will limit the results to 1 to get only the head of that department."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Head\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.DepartmentID\nORDER BY COUNT(Affiliated_With.Physician) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["Identify the head of the department by joining the Physician and Department tables on the EmployeeID and Head columns.", "To find the department with the least number of employees, we need to count the number of physicians affiliated with each department using the Affiliated_With table.", "Group the results by department and order them by the count of physicians in ascending order to get the department with the least number of employees.", "Use a subquery to get the DepartmentID of the department with the least number of employees.", "Finally, select the Name and Position of the physician who is the head of that department."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Physician \nJOIN Department ON Physician.EmployeeID = Department.Head \nWHERE Department.DepartmentID = \n  (SELECT Affiliated_With.Department \n   FROM Affiliated_With \n   GROUP BY Affiliated_With.Department \n   ORDER BY COUNT(Affiliated_With.Physician) ASC \n   LIMIT 1);", "hint": "\n"}
{"sample_id": "train.3903", "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["Identify the head of the department by joining the Physician table with the Department table on the condition that the Physician's EmployeeID matches the Department's Head.", "To find the department with the least employees, we need to count the number of physicians affiliated with each department. This can be done using a subquery that groups by the department and orders the count in ascending order.", "The subquery will return the DepartmentID of the department with the least number of affiliated physicians, which we can then use in the main query to filter the results.", "Finally, we select the Name and Position of the physician who is the head of that department."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Physician \nJOIN Department ON Physician.EmployeeID = Department.Head \nWHERE Department.DepartmentID = \n    (SELECT Affiliated_With.Department \n     FROM Affiliated_With \n     GROUP BY Affiliated_With.Department \n     ORDER BY COUNT(Affiliated_With.Physician) ASC \n     LIMIT 1);", "hint": "\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["The question asks for the names of patients who made an appointment.", "To find this information, we need to look at the 'Appointment' table, which contains the 'Patient' identifier.", "We will join the 'Appointment' table with the 'Patient' table using the 'Patient' identifier from the 'Appointment' table and the 'SSN' from the 'Patient' table.", "We use DISTINCT to ensure that we only get unique patient names, as a patient may have multiple appointments."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT T3.Name FROM Appointment AS T1 JOIN Patient AS T3 ON T1.Patient = T3.SSN", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    }\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["Identify the tables needed: Physician, Affiliated_With, and Department.", "We need to retrieve the names of physicians and their affiliated departments.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns respectively.", "Join the result with the Department table on the DepartmentID and Department columns respectively.", "Filter the results to include only primary affiliations by checking the PrimaryAffiliation column."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT P.Name AS PhysicianName, D.Name AS DepartmentName \nFROM Physician P \nJOIN Affiliated_With AW ON P.EmployeeID = AW.Physician \nJOIN Department D ON AW.Department = D.DepartmentID \nWHERE AW.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    }\n}\n"}
{"sample_id": "train.3928", "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["Identify the tables needed: 'Physician' for physician names and 'Patient' for patient information.", "Join the 'Physician' table with the 'Patient' table on the primary care physician (PCP) relationship.", "Count the number of patients for each physician using COUNT() function.", "Group the results by physician name to get the count of patients per physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT P.Name, COUNT(PA.Patient) AS NumberOfPatients\nFROM Physician P\nJOIN Patient PA ON P.EmployeeID = PA.PCP\nGROUP BY P.Name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["Identify the relevant tables: Physician and Prescribes.", "We need to find physicians who are in charge of patients, which means we will join the Physician table with the Prescribes table.", "The join condition will be on the Physician's EmployeeID and the Physician field in the Prescribes table.", "We will group the results by the Physician's EmployeeID to count the number of patients each physician is in charge of.", "Using the HAVING clause, we will filter the groups to only include those with a count of patients greater than one."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT P.Name \nFROM Physician AS P \nJOIN Prescribes AS R ON P.EmployeeID = R.Physician \nGROUP BY P.EmployeeID \nHAVING COUNT(R.Patient) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3940", "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication.", "We need to find the names of physicians who have prescribed a specific medication, 'Thesisin'.", "Join the Physician table with the Prescribes table on the EmployeeID and Physician columns respectively to link physicians with their prescriptions.", "Next, join the resulting table with the Medication table on the Medication code to filter for the specific medication 'Thesisin'.", "Finally, select the Name of the physicians from the resulting joined table."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Prescribes AS T2 ON T1.EmployeeID = T2.Physician JOIN Medication AS T3 ON T2.Medication = T3.Code WHERE T3.Name = 'Thesisin'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3941", "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication.", "We need to join the Physician table with the Prescribes table to get the physicians who have prescribed medications.", "Next, we join the Medication table to filter for the specific medication 'Thesisin'.", "The final query selects the names of the physicians who meet the criteria."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT T1.Name \nFROM Physician AS T1 \nJOIN Prescribes AS T2 ON T1.EmployeeID = T2.Physician \nJOIN Medication AS T3 ON T2.Medication = T3.Code \nWHERE T3.Name = 'Thesisin';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["Identify the relevant tables: Medication and Prescribes.", "We need to count the number of medications prescribed for each brand, so we will use the COUNT() function.", "Join the Medication table with the Prescribes table on the medication code to link medications with their prescriptions.", "Group the results by the Brand column to get the count for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT Brand, COUNT(*) AS NumberOfMedications\nFROM Medication\nJOIN Prescribes ON Medication.Code = Prescribes.Medication\nGROUP BY Brand;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3948", "db_id": "hospital_1", "question": "Find the patient who has the most recent undergoing treatment?", "rationale": ["Identify the relevant tables: Patient and Undergoes.", "Join the Patient table with the Undergoes table on the Patient's SSN and the Patient identifier in the Undergoes table.", "Order the results by the DateUndergoes in descending order to get the most recent treatment.", "Limit the results to 1 to get only the patient with the most recent undergoing treatment."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT P.Name \nFROM Patient AS P \nJOIN Undergoes AS U ON P.SSN = U.Patient \nORDER BY U.DateUndergoes DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3949", "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["Identify the relevant tables: Patient and Undergoes.", "We need to find the patient who is undergoing the most recent treatment, which involves the Undergoes table that records procedures and their dates.", "Join the Patient table with the Undergoes table on the patient identifier (SSN).", "Order the results by the DateUndergoes in descending order to get the most recent treatment first.", "Limit the results to 1 to get only the most recent patient."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT P.Name\nFROM Patient AS P\nJOIN Undergoes AS U ON P.SSN = U.Patient\nORDER BY U.DateUndergoes DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: Physician and Prescribes.", "Join the Physician table with the Prescribes table on the physician identifier.", "Select the name of the physician from the Physician table.", "Order the results by the dosage in the Prescribes table in descending order to find the highest dose.", "Limit the results to 1 to get only the physician with the highest dose."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Prescribes AS T2 ON T1.EmployeeID = T2.Physician ORDER BY T2.Dose DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["Identify the relevant tables: Physician and Affiliated_With.", "We need to retrieve the EmployeeID from the Physician table and the Department from the Affiliated_With table.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician identifiers respectively.", "Filter the results to include only those records where the affiliation is marked as primary (assuming 'Yes' indicates primary affiliation)."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT P.EmployeeID, A.Department \nFROM Physician P \nJOIN Affiliated_With A ON P.EmployeeID = A.Physician \nWHERE A.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n        \"virtual_table\": \"SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID\"\n    }\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["Identify the relevant table: The Procedures table contains the information about medical procedures and their costs.", "Determine the required information: We need the names of the procedures and their costs, specifically the three most costly procedures.", "Construct the SQL query: We will select the Name from the Procedures table, order the results by Cost in descending order to get the most expensive procedures first, and limit the results to 3 to get only the top three procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name FROM Procedures ORDER BY Cost DESC LIMIT 3", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of medical procedures from the 'Procedures' table, ordered by their associated costs. The placeholder in the LIMIT clause allows the user to specify the maximum number of procedure names to retrieve.\",\n        \"virtual_table\": \"SELECT name FROM procedures ORDER BY cost LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3972", "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "Join the Physician table with the Trained_In table on the EmployeeID and Physician columns.", "Join the Trained_In table with the Procedures table on the Treatment and Code columns.", "Filter the results to include only those procedures where the cost is greater than 5000.", "Select the Name of the physicians from the resulting joined table."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician JOIN Procedures AS T3 ON T3.Code = T2.Treatment WHERE T3.Cost > 5000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the tables involved: Physician, Trained_In, and Procedures.", "We need to find physicians trained in procedures, so we will join Physician with Trained_In on EmployeeID and Trained_In with Procedures on Treatment.", "To find the most expensive procedure, we will use a subquery to get the maximum cost from the Procedures table.", "The final query will select the names of physicians who are trained in the procedure that has the maximum cost."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT T1.Name \nFROM Physician AS T1 \nJOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician \nJOIN Procedures AS T3 ON T3.Code = T2.Treatment \nWHERE T3.Cost = (SELECT MAX(Cost) FROM Procedures)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3980", "db_id": "hospital_1", "question": "Find all procedures which cost more than 1000 or which physician John Wen was trained in.", "rationale": ["Identify the procedures that cost more than 1000. This can be done by querying the Procedures table and filtering on the Cost column.", "Next, identify the procedures that John Wen is trained in. This requires joining the Trained_In table with the Physician table to find the treatments associated with John Wen.", "Combine the results of both queries using a UNION to get all unique procedures that either cost more than 1000 or that John Wen is trained in."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT T3.Name FROM Procedures AS T3 WHERE T3.Cost > 1000 UNION SELECT T3.Name FROM Procedures AS T3 JOIN Trained_In AS T2 ON T3.Code = T2.Treatment JOIN Physician AS T1 ON T2.Physician = T1.EmployeeID WHERE T1.Name = 'John Wen';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3993", "db_id": "hospital_1", "question": "How many patients are not using Procrastin-X as medication?", "rationale": ["Identify the main goal: Count the number of patients not using 'Procrastin-X' as medication.", "To achieve this, we need to count all patients whose SSN is not in the list of patients who have been prescribed 'Procrastin-X'.", "First, we need to find the Code for 'Procrastin-X' from the Medication table.", "Next, we will create a subquery to select all patients from the Prescribes table who have received 'Procrastin-X'.", "Finally, we will count all patients in the Patient table whose SSN is not in the result of the subquery."], "gold_sql": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )", "source_tables": ["patient", "prescribes", "medication"], "pred_sql": "SELECT COUNT(*) AS PatientCount \nFROM Patient \nWHERE SSN NOT IN (\n    SELECT Patient \n    FROM Prescribes \n    WHERE Medication IN (\n        SELECT Code \n        FROM Medication \n        WHERE Name = 'Procrastin-X'\n    )\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4256", "db_id": "club_1", "question": "What are the first names of all the students?", "rationale": ["Identify the table needed: The question asks for first names of students, which are stored in the 'Student' table.", "Determine the specific column: The first names are in the 'Fname' column.", "Use DISTINCT to ensure unique first names are returned: This prevents duplicate names from appearing in the results.", "Construct the SQL query: Combine the selected column and table with the DISTINCT keyword to form the complete SQL query."], "gold_sql": "SELECT DISTINCT fname FROM student", "source_tables": ["student"], "pred_sql": "SELECT DISTINCT Fname FROM Student", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first names of students from the 'Student' table. The use of DISTINCT ensures that each first name appears only once in the result set.\",\n        \"virtual_table\": \"SELECT DISTINCT fname FROM student\"\n    }\n}\n"}
{"sample_id": "train.4271", "db_id": "club_1", "question": "Give me the first name and last name for all the female members of the club \"Bootup Baltimore\".", "rationale": ["Identify the required fields: first name (Fname) and last name (LName) of female students.", "Filter the students based on their gender, specifically looking for 'Female'.", "Join the Student table with the Member_of_club table to link students with their respective clubs using StuID.", "Join the resulting table with the Club table to access club details using ClubID.", "Filter the results to include only those members who belong to the club named 'Bootup Baltimore'."], "gold_sql": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  'Bootup Baltimore' AND t3.sex  =  'F'", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Student.Fname, Student.LName \nFROM Student \nJOIN Member_of_club ON Student.StuID = Member_of_club.StuID \nJOIN Club ON Member_of_club.ClubID = Club.ClubID \nWHERE Student.Sex = 'Female' AND Club.ClubName = 'Bootup Baltimore';", "hint": "\n"}
{"sample_id": "train.4277", "db_id": "club_1", "question": "Find the club which has the largest number of members majoring in \"600\".", "rationale": ["Identify the relevant tables: Club, Member_of_club, and Student.", "We need to count the number of members in each club who are majoring in '600'.", "Join the Club table with the Member_of_club table on ClubID to link clubs with their members.", "Join the resulting table with the Student table on StuID to access the major of each student.", "Filter the results to include only those students whose Major is '600'.", "Group the results by ClubID to count the number of members per club.", "Order the results by the count of members in descending order to find the club with the most members majoring in '600'.", "Limit the results to 1 to get only the club with the largest number of members."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  '600' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Club.ClubName, COUNT(Member_of_club.StuID) AS MemberCount\nFROM Club\nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID\nJOIN Student ON Member_of_club.StuID = Student.StuID\nWHERE Student.Major = '600'\nGROUP BY Club.ClubID\nORDER BY MemberCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4278", "db_id": "club_1", "question": "Find the name of the club that has the most female students.", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "We need to find the club with the most female students, so we will join these tables on their respective IDs.", "Filter the students to only include females using a WHERE clause.", "Group the results by ClubID to count the number of female students in each club.", "Order the results by the count of female students in descending order to get the club with the most females at the top.", "Limit the results to 1 to get only the club with the highest count."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Club.ClubName\nFROM Club\nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID\nJOIN Student ON Member_of_club.StuID = Student.StuID\nWHERE Student.Sex = 'Female'\nGROUP BY Club.ClubID\nORDER BY COUNT(Student.StuID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4312", "db_id": "club_1", "question": "List the clubs that have at least a member with advisor \"1121\".", "rationale": ["We need to list clubs that have at least one member with a specific advisor.", "The relevant tables are Club, Member_of_club, and Student.", "We will join these tables: Club with Member_of_club on ClubID, and Member_of_club with Student on StuID.", "We will filter the results to include only those students whose Advisor is '1121'.", "Finally, we will select the distinct Club names from the results to avoid duplicates."], "gold_sql": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  1121", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT DISTINCT Club.ClubName \nFROM Club \nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID \nJOIN Student ON Member_of_club.StuID = Student.StuID \nWHERE Student.Advisor = '1121';", "hint": "\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: Grants, Organisations, and Organisation_Types.", "Determine the relationship between these tables: Grants are linked to Organisations via organisation_id, and Organisations are linked to Organisation_Types via organisation_type.", "We need to filter the organisations by their type description, which is 'research'.", "Use the SUM function to calculate the total grant amount from the Grants table for the filtered organisations.", "Construct the SQL query using JOINs to combine the necessary tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id = T2.organisation_id JOIN Organisation_Types AS T3 ON T2.organisation_type = T3.organisation_type WHERE T3.organisation_type_description = 'research'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter by the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.\",\n        \"virtual_table\": \"SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the role code for the 'Leader' role from the Staff_Roles table.", "Find the project_id(s) that have staff members with the 'Leader' role by filtering on the role_code.", "Group the results by project_id and count the number of staff members for each project.", "Order the projects by the count of staff members in descending order to find the project with the most staff.", "Limit the results to the top project (the one with the most staff).", "Select the date_from and date_to for the staff members working on that project."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to \nFROM Project_Staff \nWHERE project_id = (\n    SELECT project_id \n    FROM Project_Staff \n    WHERE role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Leader') \n    GROUP BY project_id \n    ORDER BY COUNT(staff_id) DESC \n    LIMIT 1\n)", "hint": "\n"}
{"sample_id": "train.4328", "db_id": "tracking_grants_for_research", "question": "Find the organisation ids and details of the organisations which are involved in", "rationale": ["The user wants to find organisation ids and details of the organisations involved in grants.", "To get the organisation ids and details, we need to select from the Organisations table.", "The relevant columns to select are 'organisation_id' and 'organisation_details'.", "Since the hint provided does not specify any filtering criteria, we will select all organisations from the Organisations table."], "gold_sql": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  6000", "source_tables": ["grants", "organisations"], "pred_sql": "SELECT organisation_id, organisation_details FROM Organisations", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter by the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.\",\n        \"virtual_table\": \"SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "We need to find the organisation type and id of the organisation with the most research staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id respectively.", "Group the results by organisation_id and organisation_type to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to get the organisation with the most staff at the top.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_type, Organisations.organisation_id\nFROM Organisations\nJOIN Research_Staff ON Organisations.organisation_id = Research_Staff.employer_organisation_id\nGROUP BY Organisations.organisation_id, Organisations.organisation_type\nORDER BY COUNT(Research_Staff.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    }\n}\n"}
{"sample_id": "train.4331", "db_id": "tracking_grants_for_research", "question": "What is the type and id of the organization that has the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "We need to find the organisation type and id with the most research staff.", "Join the Organisations table with the Research_Staff table on the organisation_id.", "Group the results by organisation_id and organisation_type to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to get the organisation with the most staff at the top.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_type, Organisations.organisation_id\nFROM Organisations\nJOIN Research_Staff ON Organisations.organisation_id = Research_Staff.employer_organisation_id\nGROUP BY Organisations.organisation_id, Organisations.organisation_type\nORDER BY COUNT(Research_Staff.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    }\n}\n"}
{"sample_id": "train.4333", "db_id": "tracking_grants_for_research", "question": "What is the type of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id to link research staff to their respective organisations.", "Group the results by organisation_id to count the number of research staff per organisation.", "Order the results in descending order based on the count of research staff to find the organisation with the most staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_type FROM Organisations JOIN Research_Staff ON Organisations.organisation_id = Research_Staff.employer_organisation_id GROUP BY Organisations.organisation_id ORDER BY COUNT(Research_Staff.staff_id) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    }\n}\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the relevant tables: Documents, Grants, Organisations, and Organisation_Types.", "Determine the relationships between these tables: Documents are linked to Grants via grant_id, Grants are linked to Organisations via organisation_id, and Organisations are linked to Organisation_Types via organisation_type.", "Select the 'sent_date' from the Documents table as the main output.", "Filter the results based on the grant amount from the Grants table, specifically looking for amounts greater than 5000.", "Additionally, filter by the organisation type description from the Organisation_Types table, using a placeholder for the specific type being queried."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT D.sent_date \nFROM Documents AS D \nJOIN Grants AS G ON D.grant_id = G.grant_id \nJOIN Organisations AS O ON G.organisation_id = O.organisation_id \nJOIN Organisation_Types AS OT ON O.organisation_type = OT.organisation_type \nWHERE G.grant_amount > 5000 \nAND OT.organisation_type_description = [PLACEHOLDER-TYPE:STRING];", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter by the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.\",\n        \"virtual_table\": \"SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4335", "db_id": "tracking_grants_for_research", "question": "What are the send dates for all documents that have a grant amount of more than 5000 and are involved in research?", "rationale": ["Identify the relevant tables: Documents and Grants.", "Determine the relationship between the tables: Documents are linked to Grants via grant_id.", "Select the 'sent_date' from the Documents table.", "Filter the results to include only those grants with a grant_amount greater than 5000."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT D.sent_date \nFROM Documents D \nJOIN Grants G ON D.grant_id = G.grant_id \nWHERE G.grant_amount > 5000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter by the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.\",\n        \"virtual_table\": \"SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4343", "db_id": "tracking_grants_for_research", "question": "When did researchers start and stop working?", "rationale": ["Identify the relevant table for researchers' work periods, which is 'Research_Staff'.", "Select the columns 'staff_id', 'date_from', and 'date_to' to get the identifiers of researchers and their work start and end dates.", "Construct the SQL query to retrieve this information from the 'Research_Staff' table."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT staff_id, date_from, date_to FROM Research_Staff;", "hint": "\n"}
{"sample_id": "train.4349", "db_id": "tracking_grants_for_research", "question": "What are the details for the project whose research has been published?", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes are needed to get project details and their research outcomes.", "Join Projects with Project_Outcomes on project_id to link projects with their outcomes.", "Join Project_Outcomes with Research_Outcomes on outcome_code to get the descriptions of the research outcomes.", "Filter the results to only include projects whose research has been published, which can be inferred from the outcome description containing the word 'published'.", "Select the necessary fields: project_id, project_details from Projects and outcome_description from Research_Outcomes."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE '%Published%'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT Projects.project_id, Projects.project_details, Research_Outcomes.outcome_description \nFROM Projects \nJOIN Project_Outcomes ON Projects.project_id = Project_Outcomes.project_id \nJOIN Research_Outcomes ON Project_Outcomes.outcome_code = Research_Outcomes.outcome_code \nWHERE Research_Outcomes.outcome_description LIKE '%published%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    }\n}\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes are needed to get project details and their outcomes.", "Join the Projects table with the Project_Outcomes table on the project_id to associate projects with their outcomes.", "Use COUNT() to count the number of outcomes for each project.", "Group the results by project_id and project_details to get the count for each project.", "Order the results by the count of outcomes in descending order to find the project with the most outcomes.", "Limit the results to 1 to get only the project with the highest count."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT p.project_id, p.project_details, COUNT(po.outcome_code) AS outcome_count\nFROM Projects p\nJOIN Project_Outcomes po ON p.project_id = po.project_id\nGROUP BY p.project_id, p.project_details\nORDER BY outcome_count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of project outcomes from the 'Project_Outcomes' table that match a specific outcome code. The placeholder in the WHERE clause represents the outcome code being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "We need to join these tables on the organisation_id and employer_organisation_id fields.", "We want to count the number of research staff for each organisation, so we will use the COUNT() function.", "Group the results by organisation_id, organisation_type, and organisation_details to get the count per organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id, o.organisation_type, o.organisation_details\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    }\n}\n"}
{"sample_id": "train.4361", "db_id": "tracking_grants_for_research", "question": "What are the ids, types, and details of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "We need to join these tables on the foreign key: Research_Staff.employer_organisation_id = Organisations.organisation_id.", "Select the required fields: organisation_id, organisation_type, and organisation_details from the Organisations table.", "Group the results by organisation_id to count the number of research staff per organisation.", "Order the results in descending order based on the count of research staff to find the organisation with the most staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_id, Organisations.organisation_type, Organisations.organisation_details\nFROM Organisations\nJOIN Research_Staff ON Organisations.organisation_id = Research_Staff.employer_organisation_id\nGROUP BY Organisations.organisation_id\nORDER BY COUNT(Research_Staff.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of details about research staff members from the 'Research_Staff' table, sorted in ascending order. The placeholder in the ORDER BY clause indicates that the user can specify how they want to sort the staff details.\",\n        \"virtual_table\": \"SELECT staff_details FROM Research_Staff ORDER BY staff_details ASC\"\n    }\n}\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff for staff involvement in projects and Staff_Roles for role descriptions.", "We need to find the role description for each staff member that is involved in the most number of projects.", "To do this, we will first determine which project(s) have the highest number of staff members associated with them.", "We can achieve this by grouping the Project_Staff table by project_id and counting the number of staff members for each project, ordering by this count in descending order, and limiting the result to the top project.", "Next, we will join the Project_Staff table with the Staff_Roles table to get the role descriptions for the staff members associated with the identified project(s).", "Finally, we will select the staff_id and the corresponding role_description for the staff members involved in the project with the most staff."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT ps.staff_id, sr.role_description\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nWHERE ps.project_id IN (\n    SELECT project_id\n    FROM Project_Staff\n    GROUP BY project_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role descriptions of staff members from the 'Staff_Roles' table based on a specific role code. The placeholder in the WHERE clause represents the role code being queried.\",\n        \"virtual_table\": \"SELECT role_description FROM Staff_Roles WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4367", "db_id": "tracking_grants_for_research", "question": "For grants that have descriptions of Regular and Initial Applications, what are their start dates?", "rationale": ["Identify the relevant tables: Grants and Document_Types.", "Determine the columns needed: grant_start_date from Grants and document_description from Document_Types.", "Establish the relationship between the tables: Grants are linked to Document_Types through the document_type_code.", "Filter the results to include only those grants that have descriptions of 'Regular Applications' and 'Initial Applications'.", "Construct the SQL query to select the grant_start_date from the Grants table where the document_description matches the specified values."], "gold_sql": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Regular' INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Initial Application'", "source_tables": ["grants", "document_types", "documents"], "pred_sql": "SELECT grant_start_date FROM Grants AS G JOIN Document_Types AS DT ON G.grant_id = G.grant_id WHERE DT.document_description IN ('Regular Applications', 'Initial Applications')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter by the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.\",\n        \"virtual_table\": \"SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["Identify the relevant tables: Grants and Documents.", "We need to count the number of documents associated with each grant, so we will use a LEFT JOIN between Grants and Documents on the grant_id.", "We will use COUNT(d.document_id) to count the number of documents for each grant.", "To find the document with the most recent date, we can use the MAX function on the sent_date or response_received_date, but since we need the document ID, we will select it directly in the query.", "We will group the results by grant_id to get the count of documents per grant.", "Finally, we will order the results by the document count in descending order and limit the results to get the grant with the most documents."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT g.grant_id, COUNT(d.document_id) AS document_count, d.document_id AS most_recent_document\nFROM Grants g\nLEFT JOIN Documents d ON g.grant_id = d.grant_id\nGROUP BY g.grant_id\nORDER BY document_count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter by the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.\",\n        \"virtual_table\": \"SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4372", "db_id": "tracking_grants_for_research", "question": "What are all the details of the organisations described as 'Sponsor'? Sort the result in an ascending order.", "rationale": ["Identify the table that contains organisation details: Organisations.", "Determine the relevant column for organisation type: organisation_type.", "Use the Organisation_Types table to find the organisation_type corresponding to the description 'Sponsor'.", "Construct a subquery to get the organisation_type for 'Sponsor'.", "Select all columns from the Organisations table where the organisation_type matches the result of the subquery.", "Sort the results in ascending order based on organisation_id."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "pred_sql": "SELECT * FROM Organisations WHERE organisation_type = (SELECT organisation_type FROM Organisation_Types WHERE organisation_type_description = 'Sponsor') ORDER BY organisation_id ASC;", "hint": "\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes.", "Determine the relationship between the tables: Projects has a one-to-many relationship with Project_Outcomes based on project_id.", "Select the outcome_details from Project_Outcomes that correspond to the project whose details match 'sint'.", "Construct the SQL query using JOIN to combine Projects and Project_Outcomes on project_id, and filter by project_details."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT po.outcome_details \nFROM Projects p \nJOIN Project_Outcomes po ON p.project_id = po.project_id \nWHERE p.project_details = 'sint';", "hint": "\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes.", "Determine the relationship between the tables: Projects has a one-to-many relationship with Project_Outcomes based on project_id.", "Formulate the SQL query to select outcome_details from Project_Outcomes where the project_id matches the project_id in Projects.", "Add a condition to filter Projects by the specific project detail 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT po.outcome_details \nFROM Projects p \nJOIN Project_Outcomes po ON p.project_id = po.project_id \nWHERE p.project_details = 'sint';", "hint": "\n"}
{"sample_id": "train.4383", "db_id": "tracking_grants_for_research", "question": "What is the id of the organization with the maximum number of outcomes and how many outcomes are there?", "rationale": ["Identify the relevant tables: Project_Outcomes, Projects, and Organisations are needed to find the organization associated with project outcomes.", "Join the Project_Outcomes table with the Projects table on project_id to link outcomes to their respective projects.", "Join the resulting table with the Organisations table on organisation_id to associate projects with their organizations.", "Group the results by organisation_id to count the number of outcomes for each organization.", "Use COUNT(outcome_code) to count the outcomes for each organization.", "Order the results by the count of outcomes in descending order to find the organization with the maximum outcomes.", "Limit the results to 1 to get only the organization with the maximum number of outcomes."], "gold_sql": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT organisation_id, COUNT(outcome_code) AS outcome_count\nFROM Project_Outcomes\nJOIN Projects ON Project_Outcomes.project_id = Projects.project_id\nJOIN Organisations ON Projects.organisation_id = Organisations.organisation_id\nGROUP BY organisation_id\nORDER BY outcome_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4384", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects launched by the organisation", "rationale": ["Identify the relevant tables: Projects and Organisations.", "Determine the relationship between the tables: Projects has a foreign key organisation_id that links to Organisations.", "Select the desired column: project_details from the Projects table.", "Construct the SQL query using a JOIN to combine Projects and Organisations based on the organisation_id."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT Projects.project_details \nFROM Projects \nJOIN Organisations ON Projects.organisation_id = Organisations.organisation_id;", "hint": "\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["The user wants to know the staff roles of the staff members.", "To find the staff roles, we need to query the 'Staff_Roles' table.", "The 'Staff_Roles' table contains the 'role_code' and 'role_description' columns, where 'role_description' provides the information about the staff roles.", "Since the hint provides a virtual table that selects 'role_description' based on 'role_code', we can directly use the 'Staff_Roles' table to get all role descriptions without needing a specific role code."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT role_description FROM Staff_Roles", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role descriptions of staff members from the 'Staff_Roles' table based on a specific role code. The placeholder in the WHERE clause represents the role code being queried.\",\n        \"virtual_table\": \"SELECT role_description FROM Staff_Roles WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4394", "db_id": "tracking_grants_for_research", "question": "What are the descriptions of all the project outcomes?", "rationale": ["The user wants to retrieve descriptions of all project outcomes.", "The relevant table for project outcomes is 'Project_Outcomes'.", "To get the descriptions, we need to select the 'outcome_code' and 'outcome_details' columns from the 'Project_Outcomes' table.", "The SQL query will be a simple SELECT statement that retrieves these columns without any filtering conditions."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code", "source_tables": ["project_outcomes", "research_outcomes"], "pred_sql": "SELECT outcome_code, outcome_details FROM Project_Outcomes;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of project outcomes from the 'Project_Outcomes' table that match a specific outcome code. The placeholder in the WHERE clause represents the outcome code being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["Identify the relevant tables: We need to look at the 'Project_Staff' table for staff roles and the 'Staff_Roles' table for role descriptions.", "Join the 'Project_Staff' table with the 'Staff_Roles' table on the 'role_code' to get the role descriptions associated with each staff member.", "Count the occurrences of each role description to determine which role is the most common.", "Group the results by 'role_description' to aggregate the counts for each role.", "Order the results in descending order based on the count of roles to find the most common one.", "Limit the results to 1 to get only the most common role."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_description, COUNT(*) as role_count \nFROM Project_Staff \nJOIN Staff_Roles ON Project_Staff.role_code = Staff_Roles.role_code \nGROUP BY role_description \nORDER BY role_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role descriptions of staff members from the 'Staff_Roles' table based on a specific role code. The placeholder in the WHERE clause represents the role code being queried.\",\n        \"virtual_table\": \"SELECT role_description FROM Staff_Roles WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4410", "db_id": "network_2", "question": "Who is the oldest person whose job is student?", "rationale": ["Identify the table to query: The relevant table is 'Person' as it contains information about individuals including their age and job.", "Filter the results: We need to filter the records to include only those where the job is 'student'.", "Sort the results: To find the oldest person, we will sort the results by age in descending order.", "Limit the results: Since we only want the oldest person, we will limit the results to 1."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "pred_sql": "SELECT name, age FROM Person WHERE job = 'student' ORDER BY age DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4439", "db_id": "network_2", "question": "What is the name and age of every male? Order the results by age.", "rationale": ["Identify the columns needed: 'name' and 'age'.", "Determine the table to query: 'Person'.", "Filter the results to include only males by using the condition 'gender = 'male''.", "Order the results by age using 'ORDER BY age'.", "Combine all parts into a complete SQL SELECT statement."], "gold_sql": "SELECT name FROM Person WHERE gender  =  'male' ORDER BY age", "source_tables": ["person"], "pred_sql": "SELECT name, age FROM Person WHERE gender = 'male' ORDER BY age;", "hint": "\n"}
{"sample_id": "train.4441", "db_id": "network_2", "question": "What are the names and ages of every person who is a friend of both Dan and Alice?", "rationale": ["Identify the main entities involved: persons and their friendships.", "We need to find persons who are friends with both Dan and Alice.", "Start by selecting the names and ages from the Person table.", "Join the Person table with the PersonFriend table to filter friends of Dan.", "Use a subquery to find names of persons who are friends with Alice.", "Combine the results to ensure we only get persons who are friends with both Dan and Alice."], "gold_sql": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, P.age FROM Person AS P JOIN PersonFriend AS PF1 ON P.name = PF1.name WHERE PF1.friend = 'Dan' AND P.name IN (SELECT PF2.name FROM PersonFriend AS PF2 WHERE PF2.friend = 'Alice');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4444", "db_id": "network_2", "question": "Find the name of the person who has friends with age above 40 and under age 30?", "rationale": ["Identify the main requirement: Find names of persons who have friends with age above 40 and under age 30.", "To achieve this, we need to join the 'Person' table with the 'PersonFriend' table to access both the person's name and their friends' names.", "We will use subqueries to filter friends based on their ages: one subquery for friends older than 40 and another for friends younger than 30.", "The final SQL query will select names from the 'Person' table where the friends' names match those returned by the subqueries."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age > 40) OR T2.friend IN (SELECT name FROM Person WHERE age < 30)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4445", "db_id": "network_2", "question": "What are the names of every person who has a friend over 40 and under 30?", "rationale": ["Identify the tables involved: We need to use the 'Person' and 'PersonFriend' tables.", "Determine the relationships: We need to join 'Person' with 'PersonFriend' to find friends of each person.", "Filter the friends based on age: We need to find friends who are either over 40 or under 30.", "Select distinct names: We want the names of persons who have at least one friend meeting the age criteria."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name JOIN Person AS T3 ON T2.friend = T3.name WHERE (T3.age > 40 OR T3.age < 30)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4449", "db_id": "network_2", "question": "What are the names of the people who have no friends who are students?", "rationale": ["We need to find names of people who have no friends that are students.", "To do this, we will use a LEFT JOIN to connect the Person table with the PersonFriend table on the person's name.", "Next, we will perform another LEFT JOIN with the Person table to check if any of the friends have the job title 'student'.", "We will filter the results to include only those where the friend's name (from the second join) is NULL, indicating that they have no friends who are students."], "gold_sql": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  'student'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name \nFROM Person P \nLEFT JOIN PersonFriend PF ON P.name = PF.name \nLEFT JOIN Person S ON PF.friend = S.name AND S.job = 'student' \nWHERE S.name IS NULL;", "hint": "\n"}
{"sample_id": "train.4454", "db_id": "network_2", "question": "Find the name of persons who are friends with Bob.", "rationale": ["Identify the tables involved: 'Person' and 'PersonFriend'.", "We need to find names of persons who are friends with 'Bob'.", "Use a JOIN to connect 'Person' and 'PersonFriend' on the name column.", "Filter the results where the friend is 'Bob'.", "Construct the SQL query using the identified conditions."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend = 'Bob'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4455", "db_id": "network_2", "question": "What are the names of all of Bob's friends?", "rationale": ["Identify the main subject of the query: 'Bob's friends'.", "Determine the relationship between Bob and his friends, which is represented in the 'PersonFriend' table.", "Use a JOIN operation to connect the 'Person' table (which contains friend names) with the 'PersonFriend' table (which contains the relationships).", "Filter the results to only include friends of Bob by specifying 'WHERE T2.name = 'Bob''.", "Select the names of the friends from the 'Person' table where the condition is met."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.friend WHERE T2.name = 'Bob'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4456", "db_id": "network_2", "question": "Find the names of females who are friends with Zach", "rationale": ["Identify the tables involved: 'Person' and 'PersonFriend'.", "Determine the required information: names of females who are friends with Zach.", "Use a JOIN to connect 'Person' and 'PersonFriend' on the name column.", "Filter the results to include only those where the friend is 'Zach'.", "Further filter the results to include only females by checking the gender column."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Zach' AND T1.gender  =  'female'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  = 'Zach' AND T1.gender  = 'female'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4465", "db_id": "network_2", "question": "What are the different names of friends who are younger than the average age for a friend?", "rationale": ["Identify the average age of friends by calculating the average age from the Person table where the names are in the list of friends from the PersonFriend table.", "Join the Person table with the PersonFriend table to access the friends' names and their corresponding ages.", "Filter the results to include only those friends whose age is less than the calculated average age.", "Use DISTINCT to ensure that the result set contains unique names of friends."], "gold_sql": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T1.age < (SELECT AVG(age) FROM Person WHERE name IN (SELECT friend FROM PersonFriend))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4466", "db_id": "network_2", "question": "Who has friends that are older than the average age? Print their friends and their ages as well", "rationale": ["Identify the main goal: Find friends of persons who are older than the average age.", "To achieve this, we need to join the PersonFriend table with the Person table to access the ages of the friends.", "We will use a subquery to calculate the average age from the Person table.", "The main query will select the friend's name and their age from the joined tables, applying a condition to filter friends who are older than the average age."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT PF.friend, P.age \nFROM PersonFriend AS PF \nJOIN Person AS P ON PF.friend = P.name \nWHERE P.age > (SELECT AVG(age) FROM Person)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4467", "db_id": "network_2", "question": "Whare the names, friends, and ages of all people who are older than the average age of a person?", "rationale": ["Identify the required fields: names, friends, and ages of people.", "The names and ages are from the Person table, while friends are from the PersonFriend table.", "To get the friends of each person, we need to join the Person table with the PersonFriend table on the name column.", "We need to filter the results to include only those people whose age is greater than the average age of all persons.", "To calculate the average age, we can use a subquery that selects the average of the age column from the Person table, converting the age from text to integer for accurate calculation."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name, pf.friend, p.age \nFROM Person p \nJOIN PersonFriend pf ON p.name = pf.name \nWHERE p.age > (SELECT AVG(CAST(age AS INTEGER)) FROM Person);", "hint": "\n"}
{"sample_id": "train.4473", "db_id": "network_2", "question": "What are the names of all people who are friends with Alice for the shortest amount of time?", "rationale": ["Identify the table that contains friendship information, which is the PersonFriend table.", "We need to find friends of Alice, so we will filter the PersonFriend table where the name is 'Alice'.", "To find the friends with the shortest friendship duration, we will order the results by the year the friendship was established in ascending order.", "Finally, we will select the friend(s) of Alice with the shortest duration by limiting the results to 1."], "gold_sql": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend"], "pred_sql": "SELECT T2.friend FROM PersonFriend AS T2 WHERE T2.name = 'Alice' ORDER BY T2.year ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4475", "db_id": "network_2", "question": "What are the names, ages, and jobs of all people who are friends with Alice for the longest amount of time?", "rationale": ["Identify the relevant tables: Person and PersonFriend.", "We need to find people who are friends with Alice, so we will join the Person table with the PersonFriend table on the name column.", "We will filter the results to only include those where the friend is 'Alice'.", "To get the names, ages, and jobs of these people, we will select the corresponding columns from the Person table.", "Since we want to find friends for the longest amount of time, we will order the results by the year column in ascending order."], "gold_sql": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, P.age, P.job FROM Person AS P JOIN PersonFriend AS PF ON P.name = PF.name WHERE PF.friend = 'Alice' ORDER BY PF.year ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of persons from the 'Person' table who have a specific friend and belong to a certain gender. The placeholders in the WHERE clause represent the friend's name and the gender of the person.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] AND T1.gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4478", "db_id": "network_2", "question": "Which person whose friends have the oldest average age?", "rationale": ["Identify the main goal: Find the person whose friends have the oldest average age.", "To achieve this, we need to calculate the average age of friends for each person.", "We will use a subquery to join the PersonFriend table with the Person table to get the ages of friends.", "In the subquery, we will group by the person's name and calculate the average age of their friends using AVG() function.", "Next, we will join this subquery result with the Person table to get the name of the person associated with the calculated average age.", "Finally, we will order the results by average age in descending order and limit the result to 1 to get the person with the oldest average age."], "gold_sql": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT 1", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name\nFROM Person p\nJOIN (\n    SELECT pf.name, AVG(CAST(p.age AS INTEGER)) AS avg_age\n    FROM PersonFriend pf\n    JOIN Person p ON pf.friend = p.name\n    GROUP BY pf.name\n) AS avg_ages ON p.name = avg_ages.name\nORDER BY avg_ages.avg_age DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4480", "db_id": "network_2", "question": "What is the total number of people who has no friend living in the city of Austin.", "rationale": ["Identify the main goal: Count the number of people with no friends living in Austin.", "Use the 'Person' table to get all people.", "Use a subquery to find friends of people who live in Austin by joining 'Person' and 'PersonFriend' tables.", "The subquery selects friends from the 'PersonFriend' table where the corresponding person lives in Austin.", "The main query counts all people whose names are not in the list of friends obtained from the subquery."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT COUNT(*) FROM Person WHERE name NOT IN (SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.friend WHERE T1.city = 'Austin')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of friends of persons who reside in a specific city. The query joins the 'Person' table with the 'PersonFriend' table to find friends based on the city of residence, with a placeholder for the city name.\",\n        \"virtual_table\": \"SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4503", "db_id": "document_management", "question": "Find the types of documents with more than 4 documents.", "rationale": ["Identify the requirement to find document types with more than 4 documents.", "The relevant table for document types is the 'Documents' table, which contains 'document_type_code' and 'document_code'.", "To find the count of documents for each type, we can use the COUNT() function and GROUP BY 'document_type_code'.", "To filter the results to only include types with more than 4 documents, we use the HAVING clause with COUNT(document_code) > 4."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code, COUNT(document_code) AS document_count \nFROM Documents \nGROUP BY document_type_code \nHAVING COUNT(document_code) > 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of documents from the 'Documents' table that do not have any associated images in their sections. The query uses an EXCEPT clause to exclude document names that are linked to sections containing images.\",\n        \"virtual_table\": \"SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id\"\n    }\n}\n"}
{"sample_id": "train.4504", "db_id": "document_management", "question": "What are the codes of types of documents of which there are for or more?", "rationale": ["Identify the table that contains the document types, which is the 'Documents' table.", "We need to select the 'document_type_code' from the 'Documents' table.", "To find the document types that have four or more documents, we will group the results by 'document_type_code'.", "We will use the HAVING clause to filter the groups to only include those with a count of 'document_code' that is 4 or more."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code\nFROM Documents\nGROUP BY document_type_code\nHAVING COUNT(document_code) >= 4;", "hint": "\n"}
{"sample_id": "train.4505", "db_id": "document_management", "question": "Find the total access count of all documents in the most popular document type.", "rationale": ["We need to find the total access count of all documents in the most popular document type.", "First, we need to identify the most popular document type. This can be done by grouping the documents by their document_type_code and summing their access counts.", "We will order the results by the summed access count in descending order to get the most popular document type at the top.", "To get only the most popular document type, we will limit the results to 1.", "Once we have the most popular document type, we can then sum the access counts of all documents that match this type.", "The final SQL query will select the sum of access counts from the Documents table where the document_type_code matches the most popular one."], "gold_sql": "SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT SUM(access_count) AS total_access_count\nFROM Documents\nWHERE document_type_code = (\n    SELECT document_type_code\n    FROM Documents\n    GROUP BY document_type_code\n    ORDER BY SUM(access_count) DESC\n    LIMIT 1\n);", "hint": "\n"}
{"sample_id": "train.4525", "db_id": "document_management", "question": "Find names of the document without any images.", "rationale": ["The task is to find names of documents that do not have any images associated with them.", "To achieve this, we can use the EXCEPT clause to exclude document names that are linked to sections containing images.", "First, we select all document names from the 'Documents' table.", "Next, we need to identify the document names that do have images. This involves joining the 'Documents' table with the 'Document_Sections' table on the document_code, and then joining with the 'Document_Sections_Images' table on the section_id.", "The final query will select document names from the 'Documents' table and exclude those found in the second part of the query that have images."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "pred_sql": "SELECT document_name FROM Documents EXCEPT SELECT t1.document_name FROM Documents AS t1 JOIN Document_Sections AS t2 ON t1.document_code = t2.document_code JOIN Document_Sections_Images AS t3 ON t2.section_id = t3.section_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of documents from the 'Documents' table that do not have any associated images in their sections. The query uses an EXCEPT clause to exclude document names that are linked to sections containing images.\",\n        \"virtual_table\": \"SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id\"\n    }\n}\n"}
{"sample_id": "train.4532", "db_id": "document_management", "question": "Count the number of users that are logged in.", "rationale": ["Identify the table that contains user information, which is the 'Users' table.", "To count the number of users, we will use the COUNT function in SQL.", "The query will select the count of all entries in the 'Users' table without any specific conditions, as the task is to count all logged-in users."], "gold_sql": "SELECT count(*) FROM users WHERE user_login  =  1", "source_tables": ["users"], "pred_sql": "SELECT count(*) FROM Users", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of users from the 'Users' table based on a specific login username. The placeholder in the WHERE clause represents the user's login name.\",\n        \"virtual_table\": \"SELECT count(*) FROM users WHERE user_login  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4733", "db_id": "department_store", "question": "Return the distinct name of customers whose order status is Pending, in the order of customer id.", "rationale": ["Identify the relevant tables: Customers and Customer_Orders.", "We need to retrieve customer names, so we will select from the Customers table.", "To filter customers based on their order status, we need to join the Customers table with the Customer_Orders table on the customer_id.", "The condition for filtering is that the order_status_code must be 'Pending'.", "We want distinct customer names, so we will use the DISTINCT keyword.", "Finally, we will order the results by customer_id to meet the requirement of ordering by customer id."], "gold_sql": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending' ORDER BY T2.customer_id", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT c.customer_name \nFROM Customers c \nJOIN Customer_Orders o ON c.customer_id = o.customer_id \nWHERE o.order_status_code = 'Pending' \nORDER BY c.customer_id;", "hint": "\n"}
{"sample_id": "train.4736", "db_id": "department_store", "question": "What are the names and addressed of customers who have both New and Pending orders?", "rationale": ["Identify the relevant tables: Customers, Customer_Orders, and Customer_Addresses.", "We need to select customer names and their addresses, so we will select 'customer_name' from Customers and 'address_id' from Customer_Addresses.", "Join Customers with Customer_Orders on 'customer_id' to filter orders by customers.", "Join Customers with Customer_Addresses on 'customer_id' to get the addresses of the customers.", "Filter the orders to include only those with status codes 'New' and 'Pending'.", "Use GROUP BY to group results by customer to ensure we can count the distinct order statuses.", "Use HAVING to ensure that we only include customers who have both order statuses (count of distinct statuses should be 2)."], "gold_sql": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'New' INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending'", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT c.customer_name, ca.address_id \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nWHERE co.order_status_code IN ('New', 'Pending') \nGROUP BY c.customer_id \nHAVING COUNT(DISTINCT co.order_status_code) = 2;", "hint": "\n"}
{"sample_id": "train.4749", "db_id": "department_store", "question": "Find the id and name of the staff who has been assigned for the shortest period.", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "Join the Staff table with Staff_Department_Assignments to access both staff details and their assignment periods.", "Calculate the duration of each staff member's assignment by subtracting date_assigned_from from date_assigned_to.", "Order the results by the calculated duration in ascending order to find the shortest assignment period.", "Limit the results to 1 to get only the staff member with the shortest assignment period."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name FROM Staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id = T2.staff_id ORDER BY (T2.date_assigned_to - T2.date_assigned_from) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "Join the Staff table with the Staff_Department_Assignments table on staff_id to get the staff details along with their assignment details.", "Order the results by the date_assigned_from in ascending order to find the staff member who has been assigned for the least amount of time.", "Limit the results to 1 to get only the staff member with the least assignment duration."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT T1.staff_id, T1.staff_name FROM Staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id = T2.staff_id ORDER BY T2.date_assigned_from ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4753", "db_id": "department_store", "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.", "rationale": ["Identify the main table to query: Customer_Orders, as we need customer ids related to orders.", "We need to find distinct customer ids, so we will use SELECT DISTINCT on customer_id.", "We need to filter customers who made orders after some orders that were cancelled.", "To do this, we will use a subquery that selects order_ids from Customer_Orders where the order_status_code is 'Cancelled'.", "In the subquery, we also need to ensure that the order_date of the cancelled orders is earlier than the order_date of the current orders being considered in the outer query.", "The final query will select distinct customer_ids from the outer query where the order_id is in the results of the subquery."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "pred_sql": "SELECT DISTINCT co.customer_id\nFROM Customer_Orders co\nWHERE co.order_id IN (\n    SELECT co2.order_id\n    FROM Customer_Orders co2\n    WHERE co2.order_status_code = 'Cancelled'\n    AND co2.order_date < co.order_date\n)", "hint": "\n"}
{"sample_id": "train.4755", "db_id": "department_store", "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "We need to find the staff members who had assignments earlier than any Clerical Staff.", "To do this, we will first find the minimum assignment date of Clerical Staff using a subquery.", "The subquery will join Staff_Department_Assignments and Staff to filter by job title code for Clerical.", "The main query will join Staff_Department_Assignments with Staff to get the staff_id and filter by the condition that their assignment date is earlier than the minimum date found in the subquery."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "pred_sql": "SELECT staff_id FROM Staff_Department_Assignments AS T1 JOIN Staff AS T2 ON T1.staff_id = T2.staff_id WHERE T1.date_assigned_from < (SELECT MIN(date_assigned_from) FROM Staff_Department_Assignments AS T3 JOIN Staff AS T4 ON T3.staff_id = T4.staff_id WHERE T4.job_title_code = 'Clerical')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to retrieve customer names and IDs, which are in the Customers table.", "To find customers with 'TN' in their address, we need to join the Customers table with the Customer_Addresses table to link customers to their addresses.", "Next, we join the Customer_Addresses table with the Addresses table to access the address details.", "We will use a WHERE clause to filter addresses that contain 'TN' in the address_details column.", "Finally, we select the customer_name and customer_id from the Customers table."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "pred_sql": "SELECT Customers.customer_name, Customers.customer_id \nFROM Customers \nJOIN Customer_Addresses ON Customers.customer_id = Customer_Addresses.customer_id \nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id \nWHERE Addresses.address_details LIKE '%TN%';", "hint": "\n"}
{"sample_id": "train.4760", "db_id": "department_store", "question": "What are the names and genders of staff who were assigned in 2016?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments are needed to get staff names and their assignment details.", "Select the columns needed: staff_name and staff_gender from the Staff table.", "Join the Staff table with the Staff_Department_Assignments table on staff_id to link staff members with their assignments.", "Filter the results to include only those assignments that started in the year 2016 using the strftime function to extract the year from the date_assigned_from column."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT S.staff_name, S.staff_gender \nFROM Staff AS S \nJOIN Staff_Department_Assignments AS A ON S.staff_id = A.staff_id \nWHERE strftime('%Y', A.date_assigned_from) = '2016';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["We need to find staff members who have been assigned multiple jobs.", "To do this, we will join the Staff table with the Staff_Department_Assignments table on the staff_id.", "We will group the results by staff_id to aggregate the assignments for each staff member.", "Using the HAVING clause, we will filter the groups to only include those with a count of job_title_code greater than 1, indicating multiple assignments.", "Finally, we will select the staff_name from the results."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name FROM Staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id = T2.staff_id GROUP BY T1.staff_id HAVING COUNT(T2.job_title_code) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of staff members along with their job titles from the 'Staff' and 'Staff_Department_Assignments' tables. The results are ordered by the end date of their assignments, allowing users to see the most recently assigned staff members first. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T2.job_title_code FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY T2.date_assigned_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["Identify the relevant table: Customers, which contains customer_id, customer_name, customer_address, and payment_method_code.", "Filter customers based on their address containing 'WY'. This can be done using the LIKE operator with wildcards.", "Exclude customers who use a credit card for payment by checking that payment_method_code is not equal to 'CREDIT_CARD'.", "Combine these conditions in the WHERE clause of the SQL query to retrieve the desired customer ids and names."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name \nFROM Customers \nWHERE customer_address LIKE '%WY%' \nAND payment_method_code != 'CREDIT_CARD';", "hint": "\n"}
{"sample_id": "train.4793", "db_id": "department_store", "question": "Find the average price of all product clothes.", "rationale": ["Identify the table needed: Products table contains product information including price and type.", "Determine the required calculation: We need to calculate the average price of products.", "Use the provided hint to form the SQL query: The hint suggests using the avg function on product_price with a WHERE clause for product_type_code.", "Replace the placeholder in the hint with the specific product type 'clothes'.", "Construct the final SQL query using the SELECT statement with the avg function and the appropriate WHERE clause."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "pred_sql": "SELECT avg(product_price) FROM Products WHERE product_type_code = 'clothes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average price of products from the 'Products' table that belong to a specific product type. The placeholder in the WHERE clause represents the product type code.\",\n        \"virtual_table\": \"SELECT avg(product_price) FROM products WHERE product_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4795", "db_id": "department_store", "question": "Find the name of the most expensive hardware product.", "rationale": ["Identify the relevant table: Products, which contains product information including name and price.", "Filter the products to only include those that are categorized as 'hardware'.", "Sort the filtered products by price in descending order to get the most expensive one at the top.", "Limit the results to only one entry to get the name of the most expensive hardware product."], "gold_sql": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1", "source_tables": ["products"], "pred_sql": "SELECT product_name FROM Products WHERE product_type_code = 'hardware' ORDER BY product_price DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["Identify the relevant table: The 'product' table contains the 'max_page_size' column that we need to retrieve.", "Determine the condition: We need to find products that have more than 3 listings, which can be determined by counting the occurrences of each product in the 'store_product' table.", "Use a subquery: Create a subquery that selects 'Product_ID' from 'store_product', groups by 'Product_ID', and filters those groups to only include those with a count greater than 3.", "Combine the results: Use the results of the subquery to filter the main query on the 'product' table to get the 'max_page_size' for those products."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size FROM product WHERE product_id IN (SELECT Product_ID FROM store_product GROUP BY Product_ID HAVING COUNT(*) > 3);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4903", "db_id": "store_product", "question": "What is the maximum page size for everything that has more than 3 products listed?", "rationale": ["We need to find the maximum page size for products listed in stores that have more than 3 products.", "To do this, we will join the 'product', 'store_product', and 'store' tables to access the necessary information.", "We will group the results by store to count the number of products in each store.", "Using the HAVING clause, we will filter the groups to only include those with more than 3 products.", "Finally, we will select the maximum page size from the 'product' table for the filtered stores."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT MAX(p.max_page_size) \nFROM product AS p \nJOIN store_product AS sp ON p.product_id = sp.Product_ID \nJOIN store AS s ON sp.Store_ID = s.Store_ID \nGROUP BY s.Store_ID \nHAVING COUNT(sp.Product_ID) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products available in a specific store. The placeholder in the WHERE clause represents the name of the store for which the products are being queried.\",\n        \"virtual_table\": \"SELECT t1.product FROM product AS t1 JOIN store_product AS t2 ON t1.product_id  =  t2.product_id JOIN store AS t3 ON t2.store_id  =  t3.store_id WHERE t3.store_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4913", "db_id": "store_product", "question": "What is the total number of residents for the districts with the 3 largest areas?", "rationale": ["Identify the relevant table: The question pertains to districts and their populations, so we will use the 'district' table.", "Determine the required data: We need the total number of residents, which corresponds to the 'City_Population' column.", "Find the districts with the largest areas: We will order the districts by 'City_Area' in descending order and limit the results to the top 3 districts.", "Calculate the total population: We will sum the 'City_Population' of the selected districts to get the total number of residents."], "gold_sql": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3", "source_tables": ["district"], "pred_sql": "SELECT SUM(City_Population) AS Total_Residents\nFROM district\nWHERE District_ID IN (\n    SELECT District_ID\n    FROM district\n    ORDER BY City_Area DESC\n    LIMIT 3\n);", "hint": "\n"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["Identify the tables involved: store, store_district, and district.", "Determine the relationship between the tables: store is linked to store_district by Store_ID, and store_district is linked to district by District_ID.", "Select the Store_Name from the store table (aliased as t1).", "Join the store table with store_district on Store_ID.", "Join the result with the district table on District_ID.", "Filter the results where the District_name is 'Khanewal'."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT t1.Store_Name FROM store AS t1 JOIN store_district AS t2 ON t1.Store_ID = t2.Store_ID JOIN district AS t3 ON t2.District_ID = t3.District_ID WHERE t3.District_name = 'Khanewal'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of stores located in a specific district. The query joins the 'store', 'store_district', and 'district' tables to filter stores based on the district's name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["To find the city with the most number of stores, we need to count the number of stores in each city.", "We will join the 'store' table with the 'store_district' table to associate each store with its district.", "Next, we will join the 'store_district' table with the 'district' table to get the city information for each district.", "We will group the results by the city (Headquartered_City) and count the number of stores in each city.", "Finally, we will order the results in descending order based on the count of stores and limit the result to 1 to get the city with the most stores."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT d.Headquartered_City, COUNT(s.Store_ID) AS Number_of_Stores\nFROM store AS s\nJOIN store_district AS sd ON s.Store_ID = sd.Store_ID\nJOIN district AS d ON sd.District_ID = d.District_ID\nGROUP BY d.Headquartered_City\nORDER BY Number_of_Stores DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of stores located in a specific district. The query joins the 'store', 'store_district', and 'district' tables to filter stores based on the district's name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4930", "db_id": "store_product", "question": "Find products with max page size as \"A4\" and pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the columns we need for the query.", "Determine the conditions: We need to filter products based on 'max_page_size' being 'A4' and 'pages_per_minute_color' being less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table where the specified conditions are met."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' AND pages_per_minute_color < '5';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4932", "db_id": "store_product", "question": "Find products with max page size as \"A4\" or pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the columns we need to filter by: 'max_page_size' and 'pages_per_minute_color'.", "Determine the conditions: We need to find products where 'max_page_size' is 'A4' or 'pages_per_minute_color' is less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table, applying the WHERE clause to filter based on the identified conditions."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < '5';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4935", "db_id": "store_product", "question": "What are all of the products whose name includes the substring \"Scanner\"?", "rationale": ["Identify the relevant table: The 'product' table contains the product names.", "Determine the search criterion: We need to find products whose names include the substring 'Scanner'.", "Use the SQL LIKE operator: The LIKE operator allows us to search for a specified pattern in a column.", "Construct the SQL query: We will use '%' wildcards to match any characters before and after 'Scanner'.", "Final SQL query: SELECT product FROM product WHERE product LIKE '%Scanner%';"], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that match a specific search criterion. The placeholder in the WHERE clause represents a pattern for the product name or description.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4937", "db_id": "store_product", "question": "What is the most common maximum page size?", "rationale": ["Identify the relevant table: The question pertains to the maximum page size of products, which is found in the 'product' table.", "Determine the required information: We need to find the most common maximum page size, which implies counting occurrences of each maximum page size.", "Construct the SQL query: Use the COUNT function to count occurrences of each 'max_page_size', group the results by 'max_page_size', and order the results in descending order of count.", "Limit the results to 1 to get the most common maximum page size."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1", "source_tables": ["product"], "pred_sql": "SELECT max_page_size, COUNT(*) as count\nFROM product\nGROUP BY max_page_size\nORDER BY count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4938", "db_id": "store_product", "question": "Find the name of the products that are not using the most frequently-used max page size.", "rationale": ["Identify the relevant table: The 'product' table contains the product names and their max page sizes.", "Determine the most frequently-used max page size: This can be done by grouping the products by 'max_page_size', counting the occurrences, and ordering them in descending order to get the top one.", "Construct the main query: Select the product names from the 'product' table where the 'max_page_size' is not equal to the most frequently-used max page size identified in the subquery."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "pred_sql": "SELECT product.product \nFROM product \nWHERE product.max_page_size != \n    (SELECT max_page_size \n     FROM product \n     GROUP BY max_page_size \n     ORDER BY COUNT(*) DESC \n     LIMIT 1);", "hint": "\n"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["We need to calculate the average enrollment number of students for each college.", "To do this, we will use the AVG() function on the 'enr' column from the College table.", "We will also need to group the results by the college name ('cName') to get the average for each college individually."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "pred_sql": "SELECT cName, avg(enr) as average_enrollment FROM College GROUP BY cName", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the name of the state.\",\n        \"virtual_table\": \"SELECT avg(enr) FROM College WHERE state  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["The question asks for the average training hours of players.", "Since there is no direct column for training hours in the provided schema, we need to assume that there is a column named 'training_hours' in the Player table or that it is a derived value from another context.", "To calculate the average, we use the AVG() function in SQL, which computes the average of a numeric column.", "The final SQL query selects the average of the 'training_hours' column from the Player table."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_training_hours FROM Player", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4956", "db_id": "soccer_2", "question": "Find the name and training hours of players whose hours are below 1500.", "rationale": ["The query needs to find players with training hours below 1500.", "We start by identifying the relevant tables: Player and Tryout.", "We need to join the Player table with the Tryout table to get the names of players participating in tryouts.", "The hint provides a virtual table that lists player names from the Player table who are participating in tryouts.", "We will use this virtual table to filter players based on their training hours.", "Finally, we will add a WHERE clause to filter players whose hours are below 1500."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "pred_sql": "SELECT T1.pName, T2.hours FROM (SELECT T1.pName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID) AS T1 JOIN Player AS T2 ON T1.pID = T2.pID WHERE T2.hours < 1500", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.4961", "db_id": "soccer_2", "question": "What are the different types of player positions?", "rationale": ["The user wants to know the different types of player positions.", "To find the different types of player positions, we need to look at the 'pPos' column in the 'Tryout' table.", "We can use the COUNT function along with DISTINCT to count the unique player positions.", "The provided hint suggests using a query that counts distinct positions from the 'Tryout' table.", "Thus, the final SQL query is constructed as 'SELECT count(DISTINCT pPos) FROM Tryout;'"], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "pred_sql": "SELECT count(DISTINCT pPos) FROM Tryout;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    }\n}\n"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["Identify the relevant table: The 'Tryout' table contains information about players and their decisions after tryouts.", "Determine the condition for acceptance: We need to count only those entries where the decision is 'accepted'.", "Construct the SQL query: Use the COUNT function to count the number of rows in the 'Tryout' table that meet the acceptance condition."], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) FROM Tryout WHERE decision = 'accepted'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["Identify the required statistics: max, average, and min training hours.", "Determine the relevant table: Player table contains player information.", "Assume there is a column 'training_hours' in the Player table (not explicitly mentioned in the schema).", "Construct the SQL query to select the maximum, average, and minimum of the 'training_hours' column from the Player table."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT MAX(training_hours) AS max_hours, AVG(training_hours) AS avg_hours, MIN(training_hours) AS min_hours FROM Player", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the high school data that will be averaged.\",\n        \"virtual_table\": \"SELECT avg(HS) FROM Player\"\n    }\n}\n"}
{"sample_id": "train.4967", "db_id": "soccer_2", "question": "What is the average, maximum, and minimum for the number of hours spent training?", "rationale": ["Identify the required metrics: average, maximum, and minimum hours spent training.", "Determine the relevant table that contains training hours data. Assuming there is a 'Training' table with a 'training_hours' column.", "Construct the SQL query to select the average, maximum, and minimum of the 'training_hours' column from the 'Training' table."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT avg(training_hours) AS average_training_hours, max(training_hours) AS max_training_hours, min(training_hours) AS min_training_hours FROM Training;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average high school attended by players from the 'Player' table. The placeholder in the SELECT clause represents the high school data that will be averaged.\",\n        \"virtual_table\": \"SELECT avg(HS) FROM Player\"\n    }\n}\n"}
{"sample_id": "train.4970", "db_id": "soccer_2", "question": "What are the names of players whose training hours is between 500 and 1500?", "rationale": ["Identify the relevant tables: Player and Tryout.", "The Player table contains player names and IDs, while the Tryout table links players to their tryout details.", "The hint provides a virtual table that selects player names from the Player table who are participating in tryouts.", "To find players with training hours between 500 and 1500, we need to filter the results based on the training_hours column.", "Assuming training_hours is a column in the Player table, we can add a WHERE clause to filter based on this range.", "Finally, we will order the results alphabetically by player name as indicated in the hint."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT T1.pName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T1.training_hours BETWEEN 500 AND 1500 ORDER BY T1.pName;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.4971", "db_id": "soccer_2", "question": "What are the names of players who train between 500 and 1500 hours?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to select player names, so we will focus on the 'pName' column from the Player table.", "To find players who train between 500 and 1500 hours, we need to filter based on a hypothetical 'hours' column in the Tryout table.", "Join the Player table with the Tryout table on the player ID (pID) to correlate players with their tryout information.", "Apply the condition to filter players based on the training hours between 500 and 1500.", "Order the results alphabetically by player name."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT T1.pName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.hours BETWEEN 500 AND 1500 ORDER BY T1.pName", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.4975", "db_id": "soccer_2", "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?", "rationale": ["Identify the columns needed: cName and enr from the College table.", "Determine the condition for enrollment: more than 10000.", "Specify the state condition: Louisiana.", "Construct the SQL query using SELECT to retrieve the specified columns from the College table, applying the conditions in the WHERE clause."], "gold_sql": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = 'LA'", "source_tables": ["college"], "pred_sql": "SELECT cName, enr FROM College WHERE enr > 10000 AND state = 'Louisiana';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the name of the state.\",\n        \"virtual_table\": \"SELECT avg(enr) FROM College WHERE state  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4981", "db_id": "soccer_2", "question": "What are the name of the players who received a card in descending order of the hours of training?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to select player names, so we will select 'pName' from the Player table.", "We need to join the Player table with the Tryout table on the player ID (pID).", "The results should be ordered by the 'decision' column in descending order, as it relates to the hours of training implied by the card received."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "pred_sql": "SELECT T1.pName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID ORDER BY T2.decision DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["We need to find out which position is the most popular among players in the tryout.", "To do this, we will count the number of players for each position in the 'Tryout' table.", "We will use the COUNT function to count the occurrences of each position (pPos).", "We will group the results by position using GROUP BY pPos.", "To find the most popular position, we will order the results in descending order based on the count of players for each position.", "Finally, we will limit the results to just one entry using LIMIT 1 to get the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count FROM Tryout GROUP BY pPos ORDER BY position_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    }\n}\n"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["To find the most popular position at tryouts, we need to count how many players are trying out for each position.", "We will use the COUNT function to count the number of occurrences of each position in the Tryout table.", "We will group the results by the position (pPos) to get the count for each position.", "To determine the most popular position, we will order the results in descending order based on the count of players for each position.", "Finally, we will limit the results to just one entry to get the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count FROM Tryout GROUP BY pPos ORDER BY position_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct positions that players are trying out for in the 'Tryout' table. The result will give an overview of the variety of positions available for players during tryouts.\",\n        \"virtual_table\": \"SELECT count(DISTINCT pPos) FROM tryout\"\n    }\n}\n"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["The question asks for the minimum hours of students playing in different positions, which implies we need to group the data by position.", "We will use the Tryout table since it contains the position (pPos) for each player.", "To find the minimum hours, we can count the number of players in each position, which will give us an idea of participation in that position.", "The SQL query will select the position (pPos) and count the number of players for each position, grouping the results by pPos."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, COUNT(*) AS min_hours FROM Tryout GROUP BY pPos", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["Identify the relevant tables: We need to find the minimum time students spent practicing for each position, which suggests we need a table that records practice times associated with player positions.", "Assume there is a 'Practice' table that records practice times for players, including columns for 'pID', 'pPos', and 'practice_time'.", "We need to group the results by 'pPos' to get the minimum practice time for each position.", "Use the MIN() function to find the minimum practice time for each position.", "Construct the SQL query to select the position and the minimum practice time, grouping by position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(practice_time) AS min_practice_time FROM Practice GROUP BY pPos;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need the names of players, which are in the Player table, and the decision from the Tryout table.", "Join the Player table with the Tryout table on the player ID (pID).", "Filter the results to include only those players who received a 'yes' decision in the tryouts.", "Select the player's name and the hours spent practicing."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT T1.pName, T2.hours_spent_practicing \nFROM Player AS T1 \nJOIN Tryout AS T2 ON T1.pID = T2.pID \nWHERE T2.decision = 'yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to get the names of players, so we will select 'pName' from the Player table.", "We need to join the Player table with the Tryout table on the player ID (pID).", "We need to filter the results to only include players who tried out for the position of 'striker'.", "Additionally, we need to filter for those who had a successful decision in their tryout.", "Finally, we will order the results alphabetically by the player's name."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT T1.pName \nFROM Player AS T1 \nJOIN Tryout AS T2 ON T1.pID = T2.pID \nWHERE T2.pPos = 'striker' AND T2.decision = 'successful' \nORDER BY T1.pName;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who are participating in tryouts. The results are ordered alphabetically by the player's name.\",\n        \"virtual_table\": \"SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID ORDER BY T1.pName\"\n    }\n}\n"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["Identify the tables involved: Player and Tryout.", "Determine the relationship between the tables: Player is linked to Tryout via pID.", "Focus on the decision criteria: we are interested in players who got rejected.", "Use the provided hint to construct the SQL query, replacing the placeholder with 'rejected'.", "Calculate the average of the HS column from the Player table for those who were rejected."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT avg(T1.HS) FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'rejected'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5018", "db_id": "soccer_2", "question": "Which college has any student who is a goalie and succeeded in the tryout.", "rationale": ["Identify the relevant tables: College, Player, and Tryout.", "We need to find colleges that have students who are goalies and succeeded in their tryouts.", "Join the College table with the Tryout table on the college name (cName).", "Join the resulting table with the Player table on the player ID (pID).", "Filter the results where the position (pPos) is 'goalie' and the decision is 'succeeded'.", "Select the college name (cName) from the filtered results."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "pred_sql": "SELECT C.cName FROM College AS C JOIN Tryout AS T ON C.cName = T.cName JOIN Player AS P ON T.pID = P.pID WHERE T.pPos = 'goalie' AND T.decision = 'succeeded';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find the state and enrollment of colleges where students got accepted in the tryout decision.", "Join the College table with the Tryout table on the college name (cName).", "Filter the results to include only those records where the decision in the Tryout table is 'accepted'.", "Select the state and enrollment number from the College table."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT C.state, C.enr FROM College AS C JOIN Tryout AS T ON C.cName = T.cName WHERE T.decision = 'accepted';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["Identify the colleges that have accepted students during tryouts by checking the 'decision' column in the 'Tryout' table.", "Use a subquery to select distinct college names ('cName') from the 'Tryout' table where the decision is 'accepted'.", "Join this result with the 'College' table to get the enrollment numbers and states of these colleges.", "Sum the enrollment numbers for the colleges grouped by their states to get the total number of students enrolled in those colleges."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT SUM(CAST(enr AS INTEGER)) AS total_enrollment, state FROM College WHERE cName IN (SELECT DISTINCT cName FROM Tryout WHERE decision = 'accepted') GROUP BY state;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5026", "db_id": "soccer_2", "question": "Find the names of schools that have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant table: The 'Tryout' table contains the information about players and their positions.", "Determine the positions of interest: The user is interested in players trying out for 'goalie' and 'mid' positions.", "Use the SQL 'IN' clause to filter for these positions in the 'Tryout' table.", "Group the results by college name ('cName') to aggregate the data for each college.", "Use the 'HAVING' clause to ensure that only colleges with players in both positions are included, which requires counting distinct positions and ensuring it equals 2."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "pred_sql": "SELECT cName FROM Tryout WHERE pPos IN ('goalie', 'mid') GROUP BY cName HAVING COUNT(DISTINCT pPos) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5028", "db_id": "soccer_2", "question": "Find the names of states that have some college students playing in goalie and mid positions.", "rationale": ["We need to find the names of states where college students are playing in specific positions (goalie and mid).", "To do this, we will join the College, Tryout, and Player tables based on their relationships.", "The College table provides the state information, the Tryout table links players to colleges and their positions, and the Player table gives us player details.", "We will use a JOIN operation to combine these tables: College with Tryout on college name, and Tryout with Player on player ID.", "We will filter the results to include only those players who are trying out for the positions 'goalie' and 'mid'.", "Finally, we will select distinct states to avoid duplicates in our results."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT T1.state FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName JOIN Player AS T3 ON T2.pID = T3.pID WHERE T2.pPos IN ('goalie', 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the states of colleges where a specific player has participated in tryouts. The placeholder in the WHERE clause represents the player's name.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5029", "db_id": "soccer_2", "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?", "rationale": ["Identify the relevant tables: College and Tryout.", "Determine the required information: states of colleges with players in specific positions.", "Use the Tryout table to find colleges where players are trying out for 'goalie' and 'mid-field'.", "Utilize the INTERSECT operator to find colleges that have players in both positions.", "Select the distinct states from the College table where the college names match those found in the previous step."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE cName IN (SELECT cName FROM Tryout WHERE pPos = 'goalie' INTERSECT SELECT cName FROM Tryout WHERE pPos = 'mid-field')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["Identify the positions of interest: goalie and mid.", "Use the INTERSECT operator to find colleges where players are trying out for both positions.", "Count the number of unique colleges that meet the criteria using COUNT(*) in the outer query."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) FROM (SELECT cName FROM Tryout WHERE pPos = 'goalie' INTERSECT SELECT cName FROM Tryout WHERE pPos = 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5037", "db_id": "soccer_2", "question": "What is the count of states with college students playing in the mid position but not as goalies?", "rationale": ["Identify the relevant positions: 'mid' and 'goalie'.", "We need to find colleges where players are trying out for the 'mid' position but not for the 'goalie' position.", "Use a subquery to find colleges where players are trying out for 'mid'.", "Use another subquery to exclude players who are trying out for 'goalie'.", "Count the distinct states from the College table where the college names match the results from the subquery."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')", "source_tables": ["tryout", "college"], "pred_sql": "SELECT COUNT(DISTINCT state) FROM College WHERE cName IN (SELECT cName FROM Tryout WHERE pPos = 'mid' AND pID NOT IN (SELECT pID FROM Tryout WHERE pPos = 'goalie'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["Identify the requirement: We need to find states with colleges that have enrollments less than some other college.", "Use a subquery to calculate the average enrollment for colleges in each state, as hinted in the provided virtual table.", "The subquery will be: SELECT avg(enr) FROM College WHERE state = College.state, which calculates the average enrollment for colleges in the same state.", "The main query will select distinct states from the College table where the enrollment number is less than the average enrollment calculated by the subquery."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE enr < (SELECT avg(enr) FROM College WHERE state = College.state)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the name of the state.\",\n        \"virtual_table\": \"SELECT avg(enr) FROM College WHERE state  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5102", "db_id": "cre_Drama_Workshop_Groups", "question": "Show the minimum, average, maximum order quantity of all invoices.", "rationale": ["The task is to calculate the minimum, average, and maximum order quantity from the invoices.", "The relevant table for this data is the 'Invoices' table, which contains the 'Order_Quantity' column.", "To get the required statistics, we can use aggregate functions: min(), avg(), and max() on the 'Order_Quantity' column.", "The SQL query will select these three aggregated values from the 'Invoices' table."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "pred_sql": "SELECT min(Order_Quantity), avg(Order_Quantity), max(Order_Quantity) FROM Invoices", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the minimum, average, and maximum quantities of products ordered as recorded in the 'Invoices' table. The placeholders in the SELECT statement represent the aggregated values of the order quantities.\",\n        \"virtual_table\": \"SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES\"\n    }\n}\n"}
{"sample_id": "train.5118", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the payment method code used by the most orders?", "rationale": ["We need to find the payment method code that is used by the most orders.", "To do this, we will query the 'Invoices' table, which contains the 'payment_method_code' and 'Order_ID'.", "We will group the results by 'payment_method_code' to count how many orders are associated with each payment method.", "Next, we will order the results in descending order based on the count of 'Order_ID' to get the payment method with the most orders at the top.", "Finally, we will limit the results to 1 to get only the top payment method code."], "gold_sql": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices"], "pred_sql": "SELECT payment_method_code\nFROM Invoices\nGROUP BY payment_method_code\nORDER BY COUNT(Order_ID) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Invoices' table for a specific payment method. The placeholder in the WHERE clause represents the payment method code used for filtering the results.\",\n        \"virtual_table\": \"SELECT avg(Order_Quantity) FROM Invoices WHERE payment_method_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5127", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the descriptions of the service types that cost more than 100.", "rationale": ["Identify the relevant tables: Ref_Service_Types for service type descriptions and Services for product prices.", "Join the Ref_Service_Types table with the Services table on the Service_Type_Code to link service descriptions with their respective prices.", "Filter the results to include only those services where the Product_Price is greater than 100.", "Construct the SQL query using the identified tables, join condition, and filter condition."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code WHERE T2.Product_Price > 100", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price greater than a specified amount. The placeholder in the WHERE clause represents the minimum product price to filter the results.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["Identify the relevant tables: 'Drama_Workshop_Groups' for workshop group names and 'Services' for product names.", "Establish the relationship between the two tables: 'Drama_Workshop_Groups' and 'Services' are linked by 'Workshop_Group_ID'.", "Filter the services to only include those with the product name 'film'.", "Select the 'Store_Name' from the 'Drama_Workshop_Groups' table where the conditions are met."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "pred_sql": "SELECT DW.Store_Name \nFROM Drama_Workshop_Groups AS DW \nJOIN Services AS S ON DW.Workshop_Group_ID = S.Workshop_Group_ID \nWHERE S.Product_Name = 'film';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID\"\n    }\n}\n"}
{"sample_id": "train.5142", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the order details of the products with price higher than 2000?", "rationale": ["Identify the relevant tables: Order_Items and Products are needed to get order details and product prices.", "Join the Order_Items table with the Products table on Product_ID to access product details for each order item.", "Filter the results to include only those products with a price greater than 2000 using a WHERE clause."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_Items.Order_ID, Order_Items.Product_ID, Order_Items.Order_Quantity, Products.Product_Price, Products.Product_Description \nFROM Order_Items \nJOIN Products ON Order_Items.Product_ID = Products.Product_ID \nWHERE Products.Product_Price > 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price greater than a specified amount. The placeholder in the WHERE clause represents the minimum product price to filter the results.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["Identify the relevant tables: Order_Items and Products are needed to get order details and product prices.", "Join the Order_Items table with the Products table on Product_ID to access product details for each order item.", "Filter the results to include only those products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_Items.Order_Item_ID, Order_Items.Order_ID, Order_Items.Product_ID, Order_Items.Order_Quantity, Products.Product_Name, Products.Product_Price \nFROM Order_Items \nJOIN Products ON Order_Items.Product_ID = Products.Product_ID \nWHERE Products.Product_Price > 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price greater than a specified amount. The placeholder in the WHERE clause represents the minimum product price to filter the results.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5160", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the most frequent status of bookings?", "rationale": ["Identify the relevant table: The question pertains to the 'Bookings' table, specifically the 'Status_Code' column.", "Count the occurrences of each status: Use the COUNT() function to count how many times each 'Status_Code' appears in the 'Bookings' table.", "Group the results: Use GROUP BY to group the results by 'Status_Code' so that we can count the frequency of each status.", "Order the results: Use ORDER BY to sort the results in descending order based on the frequency count.", "Limit the results: Use LIMIT 1 to get only the most frequent status."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Frequency\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most common status code, which implies counting occurrences of each status code.", "Use the COUNT function: We will count the number of bookings for each status code.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each unique status code.", "Order the results: To find the most common status code, we will order the results in descending order based on the count.", "Limit the results: Since we only need the most common status code, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Count\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["Identify the relevant tables: 'Drama_Workshop_Groups' for workshop group names and 'Bookings' for booking status.", "Join the 'Drama_Workshop_Groups' table with the 'Bookings' table on the 'Workshop_Group_ID' to link workshop groups with their bookings.", "Filter the results to include only those bookings where the 'Status_Code' is 'stop'.", "Select the 'Store_Name' from the 'Drama_Workshop_Groups' table as the final output."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "pred_sql": "SELECT DW.Store_Name \nFROM Drama_Workshop_Groups AS DW \nJOIN Bookings AS B ON DW.Workshop_Group_ID = B.Workshop_Group_ID \nWHERE B.Status_Code = 'stop';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the phone numbers and email addresses of stores associated with specific drama workshop groups. The data is retrieved by joining the 'Drama_Workshop_Groups' table with the 'Services' table based on the workshop group identifier, allowing for the extraction of relevant contact information for each store linked to the workshop groups.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID\"\n    }\n}\n"}
{"sample_id": "train.5171", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the description of the service type that offers not only the photo product but also the film product.", "rationale": ["Identify the relevant tables: Ref_Service_Types for service type descriptions and Services for product details.", "Join the Ref_Service_Types table with the Services table on the Service_Type_Code to link service types with their respective products.", "Filter the results to include only those services that offer both 'photo' and 'film' products.", "Use GROUP BY to group the results by service type description.", "Use HAVING to ensure that only service types that have both products are included in the final result."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT DISTINCT T1.Service_Type_Description \nFROM Ref_Service_Types AS T1 \nJOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code \nWHERE T2.Product_Name IN ('photo', 'film') \nGROUP BY T1.Service_Type_Description \nHAVING COUNT(DISTINCT T2.Product_Name) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of service type descriptions from the 'Ref_Service_Types' table that are associated with services having a product price greater than a specified amount. The placeholder in the WHERE clause represents the minimum product price to filter the results.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5459", "db_id": "voter_2", "question": "Find the average age of female students.", "rationale": ["Identify the table that contains the relevant data: the 'Student' table has the 'Age' and 'Sex' columns.", "To find the average age of female students, we need to filter the records where 'Sex' is 'Female'.", "Use the AVG() function to calculate the average of the 'Age' column for the filtered records.", "Construct the SQL query using the SELECT statement to retrieve the average age, applying the necessary WHERE clause for filtering."], "gold_sql": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  'F'", "source_tables": ["student"], "pred_sql": "SELECT AVG(Age) AS Average_Age FROM Student WHERE Sex = 'Female';", "hint": "\n"}
{"sample_id": "train.5466", "db_id": "voter_2", "question": "What are the distinct president votes on 08/30/2015?", "rationale": ["Identify the relevant table for the query, which is 'Voting_record' since we are interested in president votes.", "We need to select distinct values for the 'President_Vote' column.", "We need to filter the records based on the 'Registration_Date' to only include those from '08/30/2015'.", "The date format in SQL should be 'YYYY-MM-DD', so '08/30/2015' will be converted to '2015-08-30'.", "Construct the SQL query using the SELECT statement with DISTINCT and the WHERE clause for the date filter."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote FROM Voting_record WHERE Registration_Date = '2015-08-30'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["Identify the relevant table for the president votes, which is the Voting_record table.", "We need to select distinct president votes, so we will use the DISTINCT keyword.", "The condition specifies that we are interested in votes made on a specific date, which is provided as '08/30/2015'.", "The Registration_Date column in the Voting_record table will be used to filter the results based on this date."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote FROM Voting_record WHERE Registration_Date = '08/30/2015'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5476", "db_id": "voter_2", "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "We need to find distinct ages, so we will use SELECT DISTINCT on the 'Age' column from the 'Student' table.", "We need to join the 'Student' table with the 'Voting_record' table on the 'StuID' column to link students with their voting records.", "We need to filter the results to include only those records where the 'Election_Cycle' is 'fall'.", "Additionally, we need to ensure that the students have cast a vote for the secretary, which means checking that 'Secretary_Vote' is not null.", "Combine all these elements into a single SQL query."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Age FROM Student AS S JOIN Voting_record AS V ON S.StuID = V.StuID WHERE V.Election_Cycle = 'fall' AND V.Secretary_Vote IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "We need to find advisors for students who have voted for treasurer, so we will join these two tables on the 'StuID'.", "We will filter the results to include only those records where 'Treasurer_Vote' is not null, indicating that the student voted for treasurer.", "Additionally, we will filter for the specific election cycle, which is 'spring'.", "Finally, we will select distinct advisors to avoid duplicates in the results."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Advisor \nFROM Student AS S \nJOIN Voting_record AS V ON S.StuID = V.StuID \nWHERE V.Treasurer_Vote IS NOT NULL \nAND V.Election_Cycle = 'spring';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5486", "db_id": "voter_2", "question": "How many male (sex is M) students have class senator votes in the fall election cycle?", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "Determine the condition for counting male students: S.Sex = 'M'.", "Identify the voting record related to class senator votes: V.Class_Senator_Vote.", "Count only those students who have participated in the voting for class senator.", "Add a condition to filter for the fall election cycle: V.Election_Cycle = 'fall'.", "Combine these conditions in a SQL query to count the relevant records."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT COUNT(*) FROM Student AS S JOIN Voting_record AS V ON S.StuID = V.Class_Senator_Vote WHERE S.Sex = 'M' AND V.Election_Cycle = 'fall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["Identify the tables involved: We need data from the 'Student' table for student details and the 'Voting_record' table for voting details.", "Determine the conditions: We are looking for students with a city code of 'NYC' and who have cast a vote for the secretary in the spring election cycle.", "Join the tables: We will join the 'Student' table and the 'Voting_record' table on the StuID to correlate students with their voting records.", "Select the average age: We will use the AVG function to calculate the average age of the filtered students."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(Age) FROM Student AS S JOIN Voting_record AS V ON S.StuID = V.StuID WHERE S.city_code = 'NYC' AND V.Secretary_Vote IS NOT NULL AND V.Election_Cycle = 'spring';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5492", "db_id": "voter_2", "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.", "rationale": ["Identify the tables involved: We need to use the 'Student' table to get the age and sex of students, and the 'Voting_record' table to check for secretary votes.", "Determine the conditions: We are looking for female students (Sex = 'F') who have voted in the spring election cycle and have a non-null value for Secretary_Vote.", "Join the tables: We will join the 'Student' table with the 'Voting_record' table on the StuID to correlate students with their voting records.", "Calculate the average age: We will use the AVG function on the Age column, ensuring to cast it to an integer for accurate calculation."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(CAST(Age AS INTEGER)) AS Average_Age\nFROM Student AS S\nJOIN Voting_record AS V ON S.StuID = V.StuID\nWHERE S.Sex = 'F' AND V.Election_Cycle = 'spring' AND V.Secretary_Vote IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "We need to find distinct first names of students, so we will use SELECT DISTINCT on the 'Fname' column from the 'Student' table.", "We need to join the 'Student' table with the 'Voting_record' table based on the student identifier (StuID) and the vice president votes (Vice_President_Vote).", "Add a WHERE clause to filter out students whose city code is 'PIT'.", "Combine all these elements to form the final SQL query."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Fname FROM Student AS S JOIN Voting_record AS V ON S.StuID = V.Vice_President_Vote WHERE S.city_code != 'PIT'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5495", "db_id": "voter_2", "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?", "rationale": ["Identify the relevant tables: 'Student' and 'Voting_record'.", "We need to find distinct first names of students, so we will use SELECT DISTINCT on the 'Fname' column from the 'Student' table.", "We need to join the 'Student' table with the 'Voting_record' table based on the student identifier (StuID).", "The condition specifies that we are interested in students who have voted for the vice president, which corresponds to the 'Vice_President_Vote' column in the 'Voting_record' table.", "Additionally, we need to filter out students whose city code is 'PIT', so we will add a WHERE clause to exclude those records.", "Combine all these elements into a complete SQL query."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Fname FROM Student AS S JOIN Voting_record AS V ON S.StuID = V.Vice_President_Vote WHERE S.city_code != 'PIT'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5496", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is not 2192.", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "Determine the columns needed: distinct last names (LName) from the 'Student' table.", "Establish the relationship between the tables: join 'Student' and 'Voting_record' on the StuID and President_Vote columns.", "Add the condition to filter out students whose advisor is '2192'.", "Construct the SQL query using the SELECT statement to get distinct last names with the specified conditions."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student JOIN Voting_record ON Student.StuID = Voting_record.President_Vote WHERE Advisor != '2192';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5499", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes and have 8741 as the advisor?", "rationale": ["Identify the requirement to find distinct last names of students who voted for president.", "Understand that we need to join the 'Student' table with the 'Voting_record' table based on the student identifier (StuID).", "Filter the records in the 'Voting_record' table to include only those students who have cast a vote for president (i.e., President_Vote is not null).", "Additionally, filter the students based on the advisor's ID, which is '8741'.", "Use a subquery to get the StuIDs of students who voted for president and then filter the main query based on these IDs and the advisor condition."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student WHERE StuID IN (SELECT StuID FROM Voting_record WHERE President_Vote IS NOT NULL) AND Advisor = '8741';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the distinct first names of students who have voted for the class senator. The query joins the 'Student' table with the 'Voting_record' table based on the student identifier, ensuring that only those students who participated in the voting for class senator are included.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.CLASS_Senator_VOTE\"\n    }\n}\n"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and gender.", "Filter for female students: We need to filter the records to include only those where the 'Sex' column is 'F'.", "Group by major: To find the most common major, we will group the results by the 'Major' column.", "Count occurrences: We will count the number of students in each major using COUNT(*).", "Order by count: To find the most common major, we will order the results in descending order based on the count of students in each major.", "Limit the results: Since we only want the most common major, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as MajorCount \nFROM Student \nWHERE Sex = 'F' \nGROUP BY Major \nORDER BY MajorCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the field of study (Major) of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["We need to find the major studied by the most female students.", "To do this, we will select the 'Major' from the 'Student' table where the 'Sex' is 'Female'.", "We will count the number of female students for each major using COUNT(*) and alias it as 'Female_Count'.", "To get the major with the most female students, we will group the results by 'Major'.", "We will then order the results in descending order based on 'Female_Count'.", "Finally, we will limit the results to 1 to get the major with the highest count."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as Female_Count \nFROM Student \nWHERE Sex = 'Female' \nGROUP BY Major \nORDER BY Female_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the field of study (Major) of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT Major FROM STUDENT WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the relationship between the tables: Products has a foreign key product_category_code that links to Ref_Product_Categories.", "We need to filter products based on the category description 'Spices' and a selling price greater than 1000.", "Use COUNT(*) to get the total number of products that meet the criteria.", "Construct the SQL query using JOIN to combine the two tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT COUNT(*) AS product_count\nFROM Products p\nJOIN Ref_Product_Categories c ON p.product_category_code = c.product_category_code\nWHERE c.product_category_description = 'Spices' AND p.typical_selling_price > 1000;", "hint": "\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the tables involved: We need to get product category descriptions from the Ref_Product_Categories table and filter products based on their descriptions from the Products table.", "Determine the relationship: The Products table is linked to the Ref_Product_Categories table through the product_category_code.", "Formulate the SQL query: We will select the product_category_description from Ref_Product_Categories and join it with Products on product_category_code.", "Add the filtering condition: We need to filter products where the product_description contains the letter 't', which can be done using the LIKE operator with '%t%'."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT T1.product_category_description FROM Ref_Product_Categories AS T1 JOIN Products AS T2 ON T1.product_category_code = T2.product_category_code WHERE T2.product_description LIKE '%t%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\",\n        \"virtual_table\": \"SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["We need to find the distinct characteristic names for the product 'cumin'.", "First, we identify the relevant tables: Products, Product_Characteristics, and Characteristics.", "We will join these tables: Products to Product_Characteristics on product_id, and Product_Characteristics to Characteristics on characteristic_id.", "Next, we filter the results to only include the product with the name 'cumin'.", "Finally, we count the distinct characteristic names from the Characteristics table."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT c.characteristic_name) \nFROM Products p \nJOIN Product_Characteristics pc ON p.product_id = pc.product_id \nJOIN Characteristics c ON pc.characteristic_id = c.characteristic_id \nWHERE p.product_name = 'cumin';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the distinct names of characteristics from the 'Characteristics' table. This allows users to retrieve unique characteristic names without duplicates.\",\n        \"virtual_table\": \"SELECT DISTINCT characteristic_name FROM CHARACTERISTICS\"\n    }\n}\n"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["Identify the tables involved: Products, Ref_Colors, Product_Characteristics, and Characteristics.", "We need to count the number of products that either have a color described as 'white' or have a characteristic with the name 'hot'.", "Join the Products table with the Ref_Colors table to filter by color description.", "Join the Products table with the Product_Characteristics table to access the characteristics of each product.", "Join the Product_Characteristics table with the Characteristics table to filter by characteristic name.", "Use a WHERE clause to specify the conditions for color description and characteristic name.", "Use COUNT(DISTINCT p.product_id) to ensure we count each product only once, regardless of how many characteristics it has that match the criteria."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT p.product_id) \nFROM Products p \nLEFT JOIN Ref_Colors c ON p.color_code = c.color_code \nLEFT JOIN Product_Characteristics pc ON p.product_id = pc.product_id \nLEFT JOIN Characteristics ch ON pc.characteristic_id = ch.characteristic_id \nWHERE c.color_description = 'white' OR ch.characteristic_name = 'hot';", "hint": "\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the columns needed: unit_of_measure from Ref_Product_Categories.", "Establish the relationship between Products and Ref_Product_Categories using the product_category_code foreign key.", "Filter the results to include only products that have 'Herb' in their product name using a LIKE clause."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT Ref_Product_Categories.unit_of_measure \nFROM Products \nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code \nWHERE Products.product_name LIKE '%Herb%';", "hint": "\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the tables involved: We need to get the unit of measurement and product category code, which are in the 'Ref_Product_Categories' table, and we need to filter based on the product name, which is in the 'Products' table.", "Determine the relationship between the tables: The 'Ref_Product_Categories' table is linked to the 'Products' table through the 'product_category_code'.", "Use the provided hint to construct the SQL query: The hint provides a template for selecting product category descriptions based on product descriptions. We will modify it to select the unit of measure and product category code instead, filtering by product name.", "Construct the final SQL query: We will select the 'unit_of_measure' and 'product_category_code' from 'Ref_Product_Categories' and join it with 'Products' on 'product_category_code', filtering where 'product_name' is 'chervil'."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT T1.unit_of_measure, T1.product_category_code FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code = T2.product_category_code WHERE T2.product_name = 'chervil'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\",\n        \"virtual_table\": \"SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["We need to find the description of the color for most products.", "To do this, we will join the 'Ref_Colors' table with the 'Products' table on the 'color_code'.", "We will count the number of products for each color description using COUNT(P.product_id).", "We will group the results by color description to aggregate the product counts.", "To find the color with the most products, we will order the results in descending order by the product count.", "Finally, we will limit the results to 1 to get the color description for the most products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT R.color_description, COUNT(P.product_id) AS product_count \nFROM Ref_Colors AS R \nJOIN Products AS P ON R.color_code = P.color_code \nGROUP BY R.color_description \nORDER BY product_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\",\n        \"virtual_table\": \"SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["We need to find the color description used by the least number of products.", "To do this, we will join the Ref_Colors table with the Products table on the color_code.", "We will group the results by color_code to count how many products are associated with each color.", "We will order the results by the count of products in ascending order to get the color with the least products first.", "Finally, we will limit the results to 1 to get only the color description used by the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT R.color_description FROM Ref_Colors AS R JOIN Products AS P ON R.color_code = P.color_code GROUP BY R.color_code ORDER BY COUNT(P.product_id) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\",\n        \"virtual_table\": \"SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To do this, we will first identify the characteristic IDs that are linked to two or more products. This can be achieved by using a subquery that groups the 'Product_Characteristics' table by 'characteristic_id' and counts the distinct 'product_id'.", "We will use the HAVING clause to filter these groups to only include those with a count of 2 or more.", "Once we have the relevant characteristic IDs, we can then select the corresponding characteristic names from the 'Characteristics' table."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT characteristic_name FROM Characteristics WHERE characteristic_id IN (SELECT characteristic_id FROM Product_Characteristics GROUP BY characteristic_id HAVING COUNT(DISTINCT product_id) >= 2)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the distinct names of characteristics from the 'Characteristics' table. This allows users to retrieve unique characteristic names without duplicates.\",\n        \"virtual_table\": \"SELECT DISTINCT characteristic_name FROM CHARACTERISTICS\"\n    }\n}\n"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to query.", "Select the 'Builder' column: We want to list the builders, so we will select this column.", "Use DISTINCT to avoid duplicate entries: Since multiple railways can have the same builder, we will use DISTINCT to ensure each builder is listed only once.", "Order the results: We need the results in ascending alphabetical order, so we will use ORDER BY Builder ASC.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "pred_sql": "SELECT DISTINCT Builder FROM railway ORDER BY Builder ASC;", "hint": "\n"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["Identify the relevant tables: railway and train.", "We need to find the railway associated with the most trains, so we will join the railway table with the train table on the Railway_ID.", "We will group the results by Railway_ID and Builder to count the number of trains associated with each railway.", "Use COUNT(train.Train_ID) to count the number of trains for each railway.", "Order the results in descending order based on the count of trains to get the railway with the most trains at the top.", "Limit the results to 1 to get only the railway associated with the most trains."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "pred_sql": "SELECT railway.Railway_ID, railway.Builder \nFROM railway \nJOIN train ON railway.Railway_ID = train.Railway_ID \nGROUP BY railway.Railway_ID, railway.Builder \nORDER BY COUNT(train.Train_ID) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to analyze.", "Count the occurrences of each builder: We will use the COUNT() function to count how many railways each builder has constructed.", "Group the results by builder: We will use GROUP BY to aggregate the results based on the 'Builder' column.", "Order the results: To find the most common builder, we will order the results in descending order based on the count of railways.", "Limit the results to one: We will use LIMIT 1 to get only the most common builder."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "pred_sql": "SELECT Builder, COUNT(*) as Count FROM railway GROUP BY Builder ORDER BY Count DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["Identify the columns needed: We need the last names of students, so we will select 'LName' from the 'Student' table.", "Determine the conditions: We need students who are either female, live in a city with the code 'BAL', or are male and under 20 years old.", "Construct the WHERE clause: The conditions can be combined using OR operators. The first condition checks for females, the second checks for the city code, and the third checks for males under 20.", "Combine the SELECT statement with the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "pred_sql": "SELECT LName FROM Student WHERE (Sex = 'Female') OR (city_code = 'BAL') OR (Sex = 'Male' AND Age < '20');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.\",\n        \"virtual_table\": \"SELECT dorm_name FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["Identify the tables involved: We need to get information from the Dorm and Has_amenity tables.", "Determine the relationship: The Dorm table contains information about dormitories, and the Has_amenity table links dormitories to their amenities.", "Filter the dormitories: We need to filter dormitories that can accommodate more than 100 students, which is done using the WHERE clause on the student_capacity column.", "Count the amenities: We need to count the number of amenities for each dormitory, which can be done using the COUNT function on the amenid from the Has_amenity table.", "Group the results: Since we want the count of amenities for each dormitory, we will group the results by the dormid from the Dorm table."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "pred_sql": "SELECT d.dorm_name, COUNT(ha.amenid) AS number_of_amenities\nFROM Dorm d\nJOIN Has_amenity ha ON d.dormid = ha.dormid\nWHERE d.student_capacity > 100\nGROUP BY d.dormid;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.\",\n        \"virtual_table\": \"SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables involved: Lives_in and Dorm are relevant for this query since we need to count students living in male dorms.", "We need to count the number of students, which is represented by the 'stuid' in the Lives_in table.", "To filter the dorms by gender, we will join the Lives_in table with the Dorm table on the dormid column.", "The WHERE clause will specify that we are only interested in dorms where the gender is 'male'.", "Finally, we will use COUNT to get the total number of students living in male dorms."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(Lives_in.stuid) AS total_students\nFROM Lives_in\nJOIN Dorm ON Lives_in.dormid = Dorm.dormid\nWHERE Dorm.gender = 'male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.\",\n        \"virtual_table\": \"SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["Identify the dormitory with the most amenities by counting the number of amenities for each dormitory using the Has_amenity table.", "Use a subquery to select the dormid that has the maximum count of amenities, ordering the results in descending order and limiting to the top result.", "Join the Lives_in table to find students living in the identified dormitory by matching the dormid.", "Finally, select the first names of those students from the Student table using their StuID."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT Fname FROM Student WHERE StuID IN (SELECT stuid FROM Lives_in WHERE dormid = (SELECT dormid FROM Has_amenity GROUP BY dormid ORDER BY COUNT(amenid) DESC LIMIT 1))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.\",\n        \"virtual_table\": \"SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["Identify the required fields: first name and age of students.", "Determine the relationships between tables: Student, Lives_in, Dorm, Has_amenity, and Dorm_amenity.", "Join the Student table with Lives_in to get the dormitory information for each student.", "Join the Lives_in table with Dorm to access dormitory details.", "Join the Dorm table with Has_amenity to find out which amenities are available in each dormitory.", "Join the Has_amenity table with Dorm_amenity to filter for dorms that have a specific amenity, in this case, 'TV Lounge'.", "Use a WHERE clause to filter the results to only include dorms that have a 'TV Lounge'."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "pred_sql": "SELECT Student.Fname, Student.Age \nFROM Student \nJOIN Lives_in ON Student.StuID = Lives_in.stuid \nJOIN Dorm ON Lives_in.dormid = Dorm.dormid \nJOIN Has_amenity ON Dorm.dormid = Has_amenity.dormid \nJOIN Dorm_amenity ON Has_amenity.amenid = Dorm_amenity.amenid \nWHERE Dorm_amenity.amenity_name = 'TV Lounge';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.\",\n        \"virtual_table\": \"SELECT dorm_name FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the main goal: Retrieve the email addresses of customers who have filed complaints about the product with the greatest number of complaints.", "To find the product with the greatest number of complaints, we need to group the complaints by product_id and count them, ordering by the count in descending order and limiting the result to the top one.", "Next, we need to join the Customers table with the Complaints table to get the email addresses of the customers who filed complaints about that product.", "The final SQL query will select the email addresses from the Customers table where the product_id matches the one identified in the subquery."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address \nFROM Customers AS c \nJOIN Complaints AS co ON c.customer_id = co.customer_id \nWHERE co.product_id = (\n    SELECT product_id \n    FROM Complaints \n    GROUP BY product_id \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["Identify the products that have been complained about by customers.", "To find the customer who has filed the least amount of complaints, we need to group the complaints by customer_id and count them.", "We will order the results of this count in ascending order and limit the results to 1 to get the customer with the least complaints.", "Once we have the customer_id of the customer with the least complaints, we can then find the products associated with that customer by joining the Products and Complaints tables on product_id.", "Finally, we will select the product names from the Products table that match the complaints made by the identified customer."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT p.product_name \nFROM Products p \nJOIN Complaints c ON p.product_id = c.product_id \nJOIN Customers cu ON c.customer_id = cu.customer_id \nWHERE cu.customer_id = (\n    SELECT customer_id \n    FROM Complaints \n    GROUP BY customer_id \n    ORDER BY COUNT(*) ASC \n    LIMIT 1\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the tables involved: Staff, Complaints, and Products.", "We need to find the last name of the staff member handling a complaint related to the product with the lowest price.", "Join the Staff table with the Complaints table on staff_id to link staff members to their complaints.", "Join the Complaints table with the Products table on product_id to link complaints to the products.", "Order the results by product price in ascending order to get the lowest priced product at the top.", "Limit the results to 1 to get only the last name of the staff member handling the complaint for the lowest priced product."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT t1.last_name FROM Staff AS t1 JOIN Complaints AS t2 ON t1.staff_id = t2.staff_id JOIN Products AS t3 ON t2.product_id = t3.product_id ORDER BY t3.product_price LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["Identify the relevant table: The question pertains to the 'Complaints' table, specifically the 'complaint_status_code' column.", "Count the number of records for each complaint status: Use the COUNT() function to count the number of records for each unique 'complaint_status_code'.", "Group the results by complaint status: Use the GROUP BY clause to group the results based on 'complaint_status_code'.", "Filter the results: Use the HAVING clause to filter the groups to only include those with a count greater than 3."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "pred_sql": "SELECT complaint_status_code, COUNT(*) as record_count \nFROM Complaints \nGROUP BY complaint_status_code \nHAVING COUNT(*) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["Identify the table that contains customer information, which is the 'Customers' table.", "To find the most common customer type, we need to group the customers by 'customer_type_code' and count how many customers belong to each type.", "We will order the results by the count in descending order to get the most common type at the top.", "We will limit the results to 1 to get only the most common customer type code.", "Finally, we will count the number of customers that have this most common customer type code."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) AS customer_count\nFROM Customers\nWHERE customer_type_code = (\n    SELECT customer_type_code\n    FROM Customers\n    GROUP BY customer_type_code\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n);", "hint": "\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to count the number of complaints handled by each staff member, so we will use the Complaints table and group by staff_id.", "Use COUNT(complaint_id) to get the number of complaints for each staff member.", "Order the results by the count of complaints in descending order to get the top staff members.", "Limit the results to the top 5 staff members with the greatest number of complaints.", "Join the result with the Staff table to get the first names of these staff members."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT t1.first_name FROM Staff AS t1 JOIN (SELECT staff_id, COUNT(complaint_id) AS complaint_count FROM Complaints GROUP BY staff_id ORDER BY complaint_count DESC LIMIT 5) AS t2 ON t1.staff_id = t2.staff_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["We need to find the first names of the staff members who have handled the most complaints.", "To do this, we will first count the number of complaints handled by each staff member. This can be done by grouping the Complaints table by staff_id and counting the complaint_id.", "Next, we will order the results by the count of complaints in descending order to get the staff members with the most complaints at the top.", "We will limit the results to the top 5 staff members with the most complaints.", "Finally, we will join this result with the Staff table to get the first names of these staff members."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT t1.first_name FROM Staff AS t1 JOIN (SELECT staff_id, COUNT(complaint_id) AS complaint_count FROM Complaints GROUP BY staff_id ORDER BY complaint_count DESC LIMIT 5) AS t2 ON t1.staff_id = t2.staff_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id ORDER BY t2.date_complaint_raised LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The user wants to see all investor details, which means we need to select all columns from the Investors table.", "The SQL command to retrieve data is SELECT, and to get all columns, we use the asterisk (*) symbol.", "The table we are querying is Investors, so we specify that after the FROM keyword."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "pred_sql": "SELECT * FROM Investors;", "hint": "\n"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["Identify the tables involved: Investors and Transactions.", "We need to show details of all investors, so we will select columns from the Investors table.", "We need to filter investors based on their transactions, specifically those with a share count greater than 100.", "To link the Investors table with the Transactions table, we will use a JOIN on the investor_id column.", "The WHERE clause will be used to filter transactions where share_count is greater than 100."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "pred_sql": "SELECT Investors.investor_id, Investors.Investor_details \nFROM Investors \nJOIN Transactions ON Investors.investor_id = Transactions.investor_id \nWHERE Transactions.share_count > 100;", "hint": "\n"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["We need to retrieve lot details from the Lots table.", "We will join the Lots table with the Transactions_Lots table to link lots with their corresponding transactions.", "Next, we will join the Transactions_Lots table with the Transactions table to access the share count of each transaction.", "Finally, we will filter the results to include only those transactions where the share count is smaller than 50."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT L.lot_details \nFROM Lots AS L \nJOIN Transactions_Lots AS TL ON L.lot_id = TL.lot_id \nJOIN Transactions AS T ON TL.transaction_id = T.transaction_id \nWHERE T.share_count < 50;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of lots from the 'Lots' table that are not associated with any transactions. The query uses an EXCEPT clause to filter out lot details that are linked to transactions through the 'Transactions_Lots' table.\",\n        \"virtual_table\": \"SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id\"\n    }\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["Identify the tables needed: We need the Transactions table for transaction amounts and the Ref_Transaction_Types table for transaction descriptions.", "Join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to get the descriptions of each transaction type.", "Use the AVG() function to calculate the average transaction amount for each transaction type.", "Group the results by transaction type description to get the average for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["Identify the relevant tables: We need to gather data from the Transactions table for share counts and the Ref_Transaction_Types table for transaction type descriptions.", "Join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to associate each transaction with its type.", "Use aggregate functions MAX() and MIN() to find the maximum and minimum share counts for each transaction type.", "Group the results by transaction type description to get the desired output for each type."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, MAX(t.share_count) AS max_share_count, MIN(t.share_count) AS min_share_count\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates of transactions from the 'Transactions' table that correspond to a specific type of transaction. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT date_of_transaction FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["Identify the tables needed to get sales and purchases details: Sales and Purchases.", "Determine the relationship between Sales and Purchases: They are linked through the transaction_id in the Transactions table.", "Use a FULL OUTER JOIN to combine the details from both Sales and Purchases, ensuring that all records from both tables are included, even if there is no match."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "pred_sql": "SELECT Sales.sales_details, Purchases.purchase_details \nFROM Sales \nFULL OUTER JOIN Purchases ON Sales.sales_transaction_id = Purchases.purchase_transaction_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of lots from the 'Lots' table that are not associated with any transactions. The query uses an EXCEPT clause to filter out lot details that are linked to transactions through the 'Transactions_Lots' table.\",\n        \"virtual_table\": \"SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id\"\n    }\n}\n"}
{"sample_id": "train.5898", "db_id": "cre_Theme_park", "question": "What is the average price range of five star hotels that allow pets?", "rationale": ["Identify the relevant table: Hotels, which contains information about hotel star ratings, price ranges, and pet policies.", "Filter for five-star hotels by using the condition 'star_rating_code = '5'',' which corresponds to five-star hotels.", "Include the condition 'pets_allowed_yn = 'Yes'' to ensure that only hotels that allow pets are considered.", "Use the AVG() function to calculate the average price range of the filtered hotels."], "gold_sql": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  '5' AND pets_allowed_yn  =  1", "source_tables": ["hotels"], "pred_sql": "SELECT AVG(price_range) AS average_price_range FROM Hotels WHERE star_rating_code = '5' AND pets_allowed_yn = 'Yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of star ratings for hotels that fall within a specified price range. The placeholder in the WHERE clause represents the price range threshold for filtering the hotels.\",\n        \"virtual_table\": \"SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5904", "db_id": "cre_Theme_park", "question": "Find all the locations whose names contain the word \"film\".", "rationale": ["Identify the table that contains location names, which is the 'Locations' table.", "Determine the column that holds the names of the locations, which is 'Location_Name'.", "Use the SQL LIKE operator to filter for names that contain the word 'film'.", "Construct the SQL query to select the relevant columns from the 'Locations' table where 'Location_Name' matches the criteria."], "gold_sql": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE '%film%'", "source_tables": ["locations"], "pred_sql": "SELECT Location_Name, Address, Other_Details FROM Locations WHERE Location_Name LIKE '%film%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["Identify the relevant tables: Museums and Tourist_Attractions.", "Determine the columns needed: Museum_ID and Museum_Details from Museums, and Opening_Hours from Tourist_Attractions.", "Establish the relationship between the tables: Museums are linked to Tourist_Attractions through the Tourist_Attraction_ID.", "Construct the SQL query to select the required details from the joined tables."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT M.Museum_ID, M.Museum_Details, T.Opening_Hours \nFROM Museums AS M \nJOIN Tourist_Attractions AS T ON M.Museum_ID = T.Tourist_Attraction_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5916", "db_id": "cre_Theme_park", "question": "Give me the detail and opening hour for each museum.", "rationale": ["Identify the relevant tables: Museums and Tourist_Attractions.", "Determine the required fields: Museum_Details from Museums and Opening_Hours from Tourist_Attractions.", "Establish the relationship between the tables: Museums are linked to Tourist_Attractions through the Museum_ID and Tourist_Attraction_ID.", "Construct the SQL query to select the desired fields from the joined tables."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT M.Museum_Details, T.Opening_Hours \nFROM Museums AS M \nJOIN Tourist_Attractions AS T ON M.Museum_ID = T.Tourist_Attraction_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables: Royal_Family and Tourist_Attractions.", "Determine the columns needed: Royal_Family_Details from Royal_Family and How_to_Get_There from Tourist_Attractions, along with other details of the attractions like Name, Description, Opening_Hours, and Other_Details.", "Establish the relationship between the tables using the foreign key: Royal_Family_ID in Royal_Family corresponds to Tourist_Attraction_ID in Tourist_Attractions.", "Construct the SQL query using a JOIN to combine the data from both tables based on the identified relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "pred_sql": "SELECT T1.Royal_Family_Details, T2.How_to_Get_There, T2.Name, T2.Description, T2.Opening_Hours, T2.Other_Details \nFROM Royal_Family AS T1 \nJOIN Tourist_Attractions AS T2 ON T1.Royal_Family_ID = T2.Tourist_Attraction_ID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The data is retrieved by joining the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for the royal family that corresponds to the tourist attraction.\",\n        \"virtual_table\": \"SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5923", "db_id": "cre_Theme_park", "question": "What are the details of the shops that can be accessed by walk?", "rationale": ["Identify the relevant tables: Shops and Tourist_Attractions.", "Determine the relationship between the tables: Shops are linked to Tourist_Attractions through the Shop_ID and Tourist_Attraction_ID.", "Use a JOIN clause to combine the Shops and Tourist_Attractions tables based on the matching IDs.", "Filter the results based on the condition that the How_to_Get_There field in the Tourist_Attractions table is equal to 'walk'.", "Construct the SQL query to select the Shop_Details from the Shops table where the condition is met."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "pred_sql": "SELECT T1.Shop_Details FROM Shops AS T1 JOIN Tourist_Attractions AS T2 ON T1.Shop_ID = T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There = 'walk'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5931", "db_id": "cre_Theme_park", "question": "Which tourist attractions does the visitor with detail 'Vincent' visit?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Visits, and Visitors.", "We need to find the attractions visited by a specific visitor, so we will join the Visits table with the Tourist_Attractions table to get the names and descriptions of the attractions.", "Next, we will join the Visitors table to filter the results based on the visitor's details, specifically looking for 'Vincent'.", "The final SQL query will select the Name and Description of the tourist attractions that match the visitor's details."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT TA.Name, TA.Description \nFROM Tourist_Attractions AS TA \nJOIN Visits AS V ON TA.Tourist_Attraction_ID = V.Tourist_Attraction_ID \nJOIN Visitors AS T ON V.Tourist_ID = T.Tourist_ID \nWHERE T.Tourist_Details = 'Vincent';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5932", "db_id": "cre_Theme_park", "question": "Show the tourist attractions visited by the tourist whose detail is 'Vincent'.", "rationale": ["Identify the tables involved: Tourist_Attractions, Visits, and Visitors.", "We need to join these tables to get the tourist attractions visited by a specific tourist.", "The Visitors table contains the tourist details, so we will filter based on the Tourist_Details column where it equals 'Vincent'.", "We will select the Name, Description, and Opening_Hours of the tourist attractions from the Tourist_Attractions table.", "The SQL query will use JOINs to connect the tables based on their foreign key relationships."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT ta.Name, ta.Description, ta.Opening_Hours \nFROM Tourist_Attractions ta \nJOIN Visits v ON ta.Tourist_Attraction_ID = v.Tourist_Attraction_ID \nJOIN Visitors vi ON v.Tourist_ID = vi.Tourist_ID \nWHERE vi.Tourist_Details = 'Vincent';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.\",\n        \"virtual_table\": \"SELECT Tourist_Details FROM VISITORS\"\n    }\n}\n"}
{"sample_id": "train.5941", "db_id": "cre_Theme_park", "question": "Show the details of the top 3 most expensive hotels.", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "To find the most expensive hotels, we need to order the hotels by their price range in descending order.", "We will limit the results to the top 3 hotels to get the most expensive ones."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of star ratings for hotels that fall within a specified price range. The placeholder in the WHERE clause represents the price range threshold for filtering the hotels.\",\n        \"virtual_table\": \"SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "To find the most expensive hotels, we need to order the hotels by their price range in descending order.", "We will limit the results to the top three entries to get the three most expensive hotels."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of star ratings for hotels that fall within a specified price range. The placeholder in the WHERE clause represents the price range threshold for filtering the hotels.\",\n        \"virtual_table\": \"SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5944", "db_id": "cre_Theme_park", "question": "What are the details and star ratings of the three hotels with the lowest price ranges?", "rationale": ["Identify the tables needed: Hotels and Ref_Hotel_Star_Ratings.", "We need to retrieve hotel details and their star ratings, so we will select columns from both tables.", "Join the Hotels table with the Ref_Hotel_Star_Ratings table on the star_rating_code to get the star rating descriptions.", "Order the results by price_range in ascending order to get the hotels with the lowest price ranges first.", "Limit the results to 3 to get only the three hotels with the lowest price ranges."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT H.hotel_id, H.other_hotel_details, R.star_rating_description \nFROM Hotels AS H \nJOIN Ref_Hotel_Star_Ratings AS R ON H.star_rating_code = R.star_rating_code \nORDER BY H.price_range ASC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the descriptions of star ratings for hotels that fall within a specified price range. The placeholder in the WHERE clause represents the price range threshold for filtering the hotels.\",\n        \"virtual_table\": \"SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["The question asks for the most popular transportation method to tourist attractions.", "To find this, we need to count the number of visits to each tourist attraction and group them by the transportation method used to get there.", "The 'How_to_Get_There' column in the 'Tourist_Attractions' table contains the transportation methods.", "We will join the 'Visits' table with the 'Tourist_Attractions' table on the 'Tourist_Attraction_ID' to link visits to their respective attractions.", "We will count the number of visits for each transportation method and order the results in descending order to find the most popular one.", "Finally, we will limit the results to just one entry to get the top transportation method."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT T2.How_to_Get_There, COUNT(*) AS Number_of_Visits\nFROM Visits AS V\nJOIN Tourist_Attractions AS T2 ON V.Tourist_Attraction_ID = T2.Tourist_Attraction_ID\nGROUP BY T2.How_to_Get_There\nORDER BY Number_of_Visits DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant table: The question pertains to transportation methods used to reach tourist attractions, which is indicated by the 'How_to_Get_There' column in the 'Tourist_Attractions' table.", "Count the occurrences: We need to count how many times each transportation method appears, which can be done using the COUNT() function.", "Group the results: To get the count for each transportation method, we will use the GROUP BY clause on the 'How_to_Get_There' column.", "Order the results: To find the most frequently used transportation method, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most used transportation method, we will limit the results to 1."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as usage_count \nFROM Tourist_Attractions \nGROUP BY How_to_Get_There \nORDER BY usage_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5955", "db_id": "cre_Theme_park", "question": "Show the names and ids of tourist attractions that are visited at most once.", "rationale": ["Identify the relevant table: Tourist_Attractions contains the names and IDs of tourist attractions.", "Determine the condition: We need to find attractions that are visited at most once, which means we need to count the visits for each attraction.", "Use the Visits table to count the number of visits per Tourist_Attraction_ID.", "Filter the attractions where the count of visits is less than or equal to 1.", "Construct the SQL query to select the Tourist_Attraction_ID and Name from Tourist_Attractions, ensuring to exclude those with more than one visit."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attraction_ID, Name FROM Tourist_Attractions WHERE Tourist_Attraction_ID NOT IN (SELECT Tourist_Attraction_ID FROM Visits GROUP BY Tourist_Attraction_ID HAVING COUNT(Tourist_ID) > 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5956", "db_id": "cre_Theme_park", "question": "What are the names and ids of the tourist attractions that are visited at most once?", "rationale": ["Identify the relevant table: Tourist_Attractions contains the names and IDs of tourist attractions.", "Determine the criteria: We need to find attractions that are visited at most once, which means we need to count the visits for each attraction.", "Use the Visits table to count the number of visits per Tourist_Attraction_ID.", "Filter the attractions based on the count of visits: We will select those attractions whose count of visits is less than or equal to 1.", "Construct the SQL query using a subquery to filter out attractions that have more than one visit."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attraction_ID, Name FROM Tourist_Attractions WHERE Tourist_Attraction_ID NOT IN (SELECT Tourist_Attraction_ID FROM Visits GROUP BY Tourist_Attraction_ID HAVING COUNT(Tourist_ID) > 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["Identify the main table to query from, which is Tourist_Attractions, as we need the names of tourist attractions.", "We need to filter the attractions based on their features, so we will join the Tourist_Attraction_Features table to link attractions with their features.", "Next, we will join the Features table to access the details of the features associated with each attraction.", "We will filter the results to include only those attractions that have features with details 'parking' or 'shopping'.", "Finally, we will select the Name of the tourist attractions that meet the criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT T3.Name FROM Tourist_Attractions AS T3 \nJOIN Tourist_Attraction_Features AS T4 ON T3.Tourist_Attraction_ID = T4.Tourist_Attraction_ID \nJOIN Features AS T5 ON T4.Feature_ID = T5.Feature_ID \nWHERE T5.Feature_Details IN ('parking', 'shopping')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find the names of tourist attractions that have specific features (parking or shopping).", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions with their features.", "Then, join the Features table to get the details of those features.", "Use a WHERE clause to filter the features to only include 'parking' or 'shopping'.", "Select the Name of the tourist attractions that meet the criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT Tourist_Attractions.Name \nFROM Tourist_Attractions \nJOIN Tourist_Attraction_Features ON Tourist_Attractions.Tourist_Attraction_ID = Tourist_Attraction_Features.Tourist_Attraction_ID \nJOIN Features ON Tourist_Attraction_Features.Feature_ID = Features.Feature_ID \nWHERE Features.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5963", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions Vincent and Marcelle visit?", "rationale": ["Identify the tables needed: Visitors, Visits, and Tourist_Attractions.", "We need to find the names of tourist attractions visited by specific tourists (Vincent and Marcelle).", "Join the Visitors table with the Visits table on Tourist_ID to link tourists with their visits.", "Join the resulting table with the Tourist_Attractions table to get the names of the attractions.", "Filter the results where the Tourist_Details in the Visitors table match 'Vincent' or 'Marcelle'.", "Use DISTINCT to ensure that we only get unique names of attractions."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT DISTINCT TA.Name \nFROM Visitors AS V \nJOIN Visits AS VI ON V.Tourist_ID = VI.Tourist_ID \nJOIN Tourist_Attractions AS TA ON VI.Tourist_Attraction_ID = TA.Tourist_Attraction_ID \nWHERE V.Tourist_Details IN ('Vincent', 'Marcelle');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of shops associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n        \"virtual_table\": \"SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5985", "db_id": "game_1", "question": "Which game type has most number of games?", "rationale": ["Identify the table that contains the game types, which is the 'Video_Games' table.", "We need to count the number of games for each game type, so we will use the COUNT() function.", "We will group the results by the game type (GType) to get the count for each type.", "To find the type with the most games, we will order the results in descending order based on the count.", "Finally, we will limit the results to 1 to get the game type with the highest count."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType, COUNT(*) AS NumberOfGames \nFROM Video_Games \nGROUP BY GType \nORDER BY NumberOfGames DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of video games from the 'Video_Games' table that belong to a specific genre. The placeholder in the WHERE clause represents the type of the video game.\",\n        \"virtual_table\": \"SELECT count(*) FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5988", "db_id": "game_1", "question": "What is the type with the fewest games?", "rationale": ["We need to find the type of video game that has the fewest games associated with it.", "To do this, we will group the video games by their type (GType) using the GROUP BY clause.", "Next, we will count the number of games in each type using COUNT(*) function.", "To find the type with the fewest games, we will order the results in ascending order using ORDER BY COUNT(*) ASC.", "Finally, we will limit the results to just one entry using LIMIT 1 to get the type with the fewest games."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType FROM Video_Games GROUP BY GType ORDER BY COUNT(*) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of video games from the 'Video_Games' table that belong to a specific genre. The placeholder in the WHERE clause represents the type of the video game.\",\n        \"virtual_table\": \"SELECT count(*) FROM Video_games WHERE gtype  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6001", "db_id": "game_1", "question": "How many students play sports?", "rationale": ["The question asks for the number of students who play sports.", "To find this, we need to count the entries in the SportsInfo table, as it contains records of students participating in sports.", "We can use the COUNT() function to get the total number of records in the SportsInfo table, which corresponds to the number of students playing sports."], "gold_sql": "SELECT count(DISTINCT StuID) FROM Sportsinfo", "source_tables": ["sportsinfo"], "pred_sql": "SELECT COUNT(*) FROM SportsInfo;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6003", "db_id": "game_1", "question": "List ids for all student who are on scholarship.", "rationale": ["Identify the relevant tables: We need to look at the 'SportsInfo' table to find students on scholarship and the 'Student' table to get their IDs.", "Join the 'SportsInfo' table with the 'Student' table on the StuID column to link students with their scholarship status.", "Filter the results to include only those students who are on a sports scholarship by checking the 'OnScholarship' column for a value of 'Yes'.", "Select the StuID from the joined tables to get the list of student IDs who are on scholarship."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT T2.StuID FROM SportsInfo AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.OnScholarship = 'Yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6004", "db_id": "game_1", "question": "What are the ids for all sporty students who are on scholarship?", "rationale": ["Identify the relevant tables: SportsInfo for sports participation and Student for student details.", "We need to find students who are on a sports scholarship, so we will filter the SportsInfo table for 'OnScholarship' status.", "We will join the SportsInfo table with the Student table on the StuID to get the student IDs.", "Select the StuID from the joined tables where the OnScholarship column indicates the student is on a scholarship."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT T1.StuID FROM SportsInfo AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.OnScholarship = 'Yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6006", "db_id": "game_1", "question": "What are the last names for all scholarship students?", "rationale": ["Identify the relevant tables: We need to find last names of students who are on a sports scholarship, which involves the 'Student' and 'SportsInfo' tables.", "Determine the join condition: The 'StuID' in 'SportsInfo' corresponds to 'StuID' in 'Student', so we will join these tables on this column.", "Specify the condition for scholarship: We need to filter the results to include only those students who are on a scholarship, indicated by 'OnScholarship' being 'Yes'.", "Select the required column: We only need the last names, which is in the 'Student' table under the column 'LName'.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT T2.LName FROM SportsInfo AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.OnScholarship = 'Yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6010", "db_id": "game_1", "question": "What is the total number of all football games played by scholarship students?", "rationale": ["Identify the relevant tables: SportsInfo for sports participation and scholarship status.", "We need to count the total number of football games played by students on a sports scholarship.", "Filter the SportsInfo table for entries where SportName is 'Football' and OnScholarship is 'Yes'.", "Use the COUNT() function to get the total number of games played by these students."], "gold_sql": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  'Football' AND onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT COUNT(*) AS TotalGamesPlayed \nFROM SportsInfo AS S \nWHERE S.SportName = 'Football' AND S.OnScholarship = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6014", "db_id": "game_1", "question": "What are the ids of all students along with how many sports and games did they play?", "rationale": ["We need to retrieve the IDs of all students along with the count of sports and games they play.", "To get the student IDs, we will select from the 'Student' table.", "We will use LEFT JOIN to connect the 'Student' table with the 'SportsInfo' table to count the number of sports each student is involved in.", "We will also use LEFT JOIN to connect the 'Student' table with the 'Plays_Games' table to count the number of games each student plays.", "We will use COUNT(DISTINCT ...) to ensure we count unique sports and games for each student.", "Finally, we will group the results by the student ID to get the counts for each student."], "gold_sql": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID", "source_tables": ["sportsinfo"], "pred_sql": "SELECT S.StuID, COUNT(DISTINCT SG.SportName) AS SportsCount, COUNT(DISTINCT PG.GameID) AS GamesCount\nFROM Student S\nLEFT JOIN SportsInfo SG ON S.StuID = SG.StuID\nLEFT JOIN Plays_Games PG ON S.StuID = PG.StuID\nGROUP BY S.StuID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6019", "db_id": "game_1", "question": "Which sport has most number of students on scholarship?", "rationale": ["We need to find out which sport has the most number of students on scholarship.", "To do this, we will count the number of students for each sport who are on a scholarship.", "We will use the SportsInfo table to filter students who are on a scholarship by checking the 'OnScholarship' column.", "We will group the results by 'SportName' to get the count of students for each sport.", "Finally, we will order the results in descending order based on the count of students and limit the result to 1 to get the sport with the most students on scholarship."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName, COUNT(*) AS StudentCount \nFROM SportsInfo \nWHERE OnScholarship = 'Yes' \nGROUP BY SportName \nORDER BY StudentCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6020", "db_id": "game_1", "question": "What is the sport with the most scholarship students?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Filter the records to include only those students who are on a sports scholarship by using the condition 'OnScholarship = 'Yes'.", "Group the results by 'SportName' to count how many scholarship students are in each sport.", "Use COUNT(*) to count the number of scholarship students for each sport.", "Order the results in descending order based on the count of scholarship students to find the sport with the most scholarship students.", "Limit the results to 1 to get only the sport with the highest count."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName, COUNT(*) AS ScholarshipCount \nFROM SportsInfo \nWHERE OnScholarship = 'Yes' \nGROUP BY SportName \nORDER BY ScholarshipCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6024", "db_id": "game_1", "question": "What are the student ids for those on scholarship in major number 600?", "rationale": ["Identify the relevant tables: SportsInfo for scholarship status and Student for major.", "We need to find students who are on a sports scholarship, so we will filter the SportsInfo table for 'OnScholarship' status.", "We also need to filter students based on their major, which is found in the Student table.", "Join the SportsInfo table with the Student table on the StuID to combine the relevant information.", "Select the StuID from the joined tables where the conditions for scholarship and major are met."], "gold_sql": "SELECT StuID FROM Student WHERE major  =  600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT T1.StuID FROM SportsInfo AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.OnScholarship = 'Yes' AND T2.Major = '600'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6025", "db_id": "game_1", "question": "Show student ids who are female and play football.", "rationale": ["Identify the relevant tables: We need to use the 'Student' table to filter by gender and the 'SportsInfo' table to filter by sport.", "Join the 'Student' table with the 'SportsInfo' table on the StuID to get the necessary information about students who play sports.", "Filter the results to include only female students by adding a condition for the 'Sex' column in the 'Student' table.", "Add another condition to filter for students who play 'Football' by checking the 'SportName' column in the 'SportsInfo' table."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT S.StuID \nFROM Student AS S \nJOIN SportsInfo AS SI ON S.StuID = SI.StuID \nWHERE S.Sex = 'Female' AND SI.SportName = 'Football';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6026", "db_id": "game_1", "question": "What are the ids of all female students who play football?", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for student details and the 'SportsInfo' table for sports participation.", "We are interested in female students, so we will filter the 'Student' table by the 'Sex' column where it equals 'Female'.", "We also need to find students who play football, which means we will filter the 'SportsInfo' table by the 'SportName' column where it equals 'Football'.", "To get the ids of the students who meet both criteria, we will perform a JOIN between the 'Student' and 'SportsInfo' tables on the 'StuID' column, which is the unique identifier for students in both tables.", "Finally, we will select the 'StuID' from the resulting joined table."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT Student.StuID FROM Student JOIN SportsInfo ON Student.StuID = SportsInfo.StuID WHERE Student.Sex = 'Female' AND SportsInfo.SportName = 'Football';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6028", "db_id": "game_1", "question": "What are the ids of all male students who do not play football?", "rationale": ["Identify the requirement to find male students.", "Filter the 'Student' table for male students by checking the 'Sex' column.", "To find students who do not play football, we need to check the 'SportsInfo' table for students involved in football.", "Use a subquery to select 'StuID' from 'SportsInfo' where 'SportName' is 'Football'.", "Use the NOT IN clause to exclude these 'StuID's from the main query.", "Combine these conditions to form the final SQL query."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male' AND StuID NOT IN (SELECT StuID FROM SportsInfo WHERE SportName = 'Football')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students from the 'Student' table who are participating in sports and are on a sports scholarship. The placeholder in the WHERE clause represents the scholarship status.\",\n        \"virtual_table\": \"SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6060", "db_id": "customers_and_addresses", "question": "Find the average order quantity per order.", "rationale": ["Identify the relevant table: The 'Order_Items' table contains the 'order_quantity' column which is needed to calculate the average order quantity.", "Use the AVG() function: To find the average, we will use the AVG() function on the 'order_quantity' column.", "Construct the SQL query: Combine the SELECT statement with the AVG() function to create the full SQL query."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "pred_sql": "SELECT avg(order_quantity) AS average_order_quantity FROM Order_Items;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    }\n}\n"}
{"sample_id": "train.6071", "db_id": "customers_and_addresses", "question": "What are the details of all products?", "rationale": ["The user wants to retrieve details of all products.", "To get all details, we need to select all columns from the Products table.", "The SQL query to achieve this is 'SELECT * FROM Products;'"], "gold_sql": "SELECT DISTINCT product_details FROM products", "source_tables": ["products"], "pred_sql": "SELECT * FROM Products;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of product specifications from the 'Products' table. The placeholder in the SELECT clause represents the product details that can be filtered or modified as needed.\",\n        \"virtual_table\": \"SELECT DISTINCT product_details FROM products\"\n    }\n}\n"}
{"sample_id": "train.6075", "db_id": "customers_and_addresses", "question": "Find the detail of products whose detail contains the word \"Latte\" or the word \"Americano\"", "rationale": ["The user wants to find product details that contain either 'Latte' or 'Americano'.", "We will select the 'product_details' column from the 'Products' table.", "To filter the results, we will use the WHERE clause with the LIKE operator to check for the presence of 'Latte' or 'Americano' in the 'product_details'.", "The '%' wildcard is used to match any sequence of characters before or after the specified words."], "gold_sql": "SELECT product_details FROM products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'", "source_tables": ["products"], "pred_sql": "SELECT DISTINCT product_details FROM Products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of product specifications from the 'Products' table. The placeholder in the SELECT clause represents the product details that can be filtered or modified as needed.\",\n        \"virtual_table\": \"SELECT DISTINCT product_details FROM products\"\n    }\n}\n"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: We need to find the city with the most customers, so we will use the Customer_Addresses and Addresses tables.", "Join the tables: We will join Customer_Addresses with Addresses on the address_id to get the city associated with each customer.", "Count distinct customers: We will count the distinct customer_id for each city to avoid counting the same customer multiple times.", "Group by city: We will group the results by city to aggregate the customer counts for each city.", "Order the results: We will order the results in descending order based on the customer count to find the city with the most customers.", "Limit the results: We will limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(DISTINCT customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6086", "db_id": "customers_and_addresses", "question": "Find the city where the most customers live.", "rationale": ["To find the city where the most customers live, we need to count the number of customers associated with each city.", "The relevant tables are Customer_Addresses (which links customers to addresses) and Addresses (which contains city information).", "We will join the Customer_Addresses table with the Addresses table on the address_id to get the city for each customer.", "Next, we will group the results by city and count the number of customer_ids for each city to get the total number of customers per city.", "Finally, we will order the results in descending order based on the customer count and limit the results to 1 to get the city with the most customers."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6097", "db_id": "customers_and_addresses", "question": "Which contact channel has been used by the customer with name \"Tillman Ernser\"?", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "Join the Customers table with the Customer_Contact_Channels table on customer_id to link customers with their contact channels.", "Filter the results to find the customer with the name 'Tillman Ernser'.", "To find the most recent contact channel used, we need to check the active_to_date field.", "Use a subquery to get the maximum active_to_date for the specified customer, ensuring we only retrieve the contact channel that was active until that date."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT t2.channel_code FROM Customers AS t1 JOIN Customer_Contact_Channels AS t2 ON t1.customer_id = t2.customer_id WHERE t1.customer_name = 'Tillman Ernser' AND t2.active_to_date = (SELECT max(t2.active_to_date) FROM Customers AS t1 JOIN Customer_Contact_Channels AS t2 ON t1.customer_id = t2.customer_id WHERE t1.customer_name = 'Tillman Ernser')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the most recent deactivation date of a contact channel for a specific customer from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the customer's name.\",\n        \"virtual_table\": \"SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the tables involved: Customers and Customer_Contact_Channels.", "Determine the relationship between the tables: Customers is linked to Customer_Contact_Channels via customer_id.", "We need to find the latest 'active_to_date' for the contact channels associated with the customer named 'Tillman Ernser'.", "Use the max() function to get the most recent 'active_to_date'.", "Construct the SQL query using a JOIN to connect the two tables and filter by the customer's name."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT max(t2.active_to_date) FROM Customers AS t1 JOIN Customer_Contact_Channels AS t2 ON t1.customer_id = t2.customer_id WHERE t1.customer_name = 'Tillman Ernser'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the most recent deactivation date of a contact channel for a specific customer from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the customer's name.\",\n        \"virtual_table\": \"SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the contact channel information.", "Determine the columns needed: active_from_date and active_to_date are necessary to calculate the duration.", "Calculate the duration: Use the julianday function to convert the dates to Julian day numbers and find the difference.", "Use the avg function to compute the average of these durations.", "Construct the SQL query using the SELECT statement to retrieve the average duration."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT avg(julianday(active_to_date) - julianday(active_from_date)) AS average_duration FROM Customer_Contact_Channels", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average duration that contact channels remain active for customers in the 'Customer_Contact_Channels' table. The placeholder in the SELECT clause represents the calculation of the difference between the active dates.\",\n        \"virtual_table\": \"SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels\"\n    }\n}\n"}
{"sample_id": "train.6103", "db_id": "customers_and_addresses", "question": "What is the channel code and contact number of the customer contact channel that was active for the longest time?", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the channel code and contact number.", "Determine the criteria for the longest active time: This can be calculated by finding the minimum active_from_date, as the channel that has been active the longest will have the earliest start date.", "Construct a subquery to find the minimum active_from_date in the Customer_Contact_Channels table.", "Select the channel_code and contact_number from Customer_Contact_Channels where the active_from_date matches the result of the subquery."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT channel_code, contact_number FROM Customer_Contact_Channels WHERE active_from_date = (SELECT MIN(active_from_date) FROM Customer_Contact_Channels)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average duration that contact channels remain active for customers in the 'Customer_Contact_Channels' table. The placeholder in the SELECT clause represents the calculation of the difference between the active dates.\",\n        \"virtual_table\": \"SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels\"\n    }\n}\n"}
{"sample_id": "train.6108", "db_id": "customers_and_addresses", "question": "Find the name of the customer who made the order of the largest amount of goods.", "rationale": ["Identify the relevant tables: Customers, Customer_Orders, and Order_Items are needed to find the customer who made the largest order.", "Join the Customers table with Customer_Orders to link customers to their orders.", "Join the resulting table with Order_Items to access the quantities of products ordered.", "Group the results by customer to aggregate the total quantity of items ordered by each customer.", "Order the results by the total quantity in descending order to find the customer with the largest order.", "Limit the results to 1 to get only the top customer."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)", "source_tables": ["customer_orders", "customers", "order_items"], "pred_sql": "SELECT c.customer_name \nFROM Customers AS c \nJOIN Customer_Orders AS o ON c.customer_id = o.customer_id \nJOIN Order_Items AS oi ON o.order_id = oi.order_id \nGROUP BY c.customer_id \nORDER BY SUM(oi.order_quantity) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer names from the 'Customers' table who have placed orders, sorted by the most recent order date. The placeholder in the LIMIT clause allows for specifying the maximum number of customer names to retrieve.\",\n        \"virtual_table\": \"SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6123", "db_id": "customers_and_addresses", "question": "What is the total number of products that are in orders with status \"Cancelled\"?", "rationale": ["Identify the relevant tables: We need to look at the 'Order_Items' table for product quantities and the 'Customer_Orders' table for order statuses.", "Join the 'Order_Items' table with the 'Customer_Orders' table on the 'order_id' to link products with their respective orders.", "Filter the results to include only those orders that have a status of 'Cancelled'.", "Use the SUM function to calculate the total quantity of products from the filtered results."], "gold_sql": "SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_status  =  'Cancelled'", "source_tables": ["customer_orders", "order_items"], "pred_sql": "SELECT SUM(order_items.order_quantity) \nFROM Order_Items \nJOIN Customer_Orders ON Order_Items.order_id = Customer_Orders.order_id \nWHERE Customer_Orders.order_status = 'Cancelled';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    }\n}\n"}
{"sample_id": "train.6130", "db_id": "customers_and_addresses", "question": "What is the most frequently ordered product? Tell me the detail of the product", "rationale": ["Identify the relevant tables: We need to look at the 'Order_Items' table to find out which products have been ordered and how many times.", "Join the 'Order_Items' table with the 'Products' table to get product details along with the order information.", "Group the results by product_id to count the number of times each product has been ordered.", "Order the results in descending order based on the count of orders to find the most frequently ordered product.", "Limit the results to 1 to get only the top product."], "gold_sql": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Products.product_id, Products.product_details, COUNT(Order_Items.product_id) AS order_count\nFROM Order_Items\nJOIN Products ON Order_Items.product_id = Products.product_id\nGROUP BY Order_Items.product_id\nORDER BY order_count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    }\n}\n"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["We need to find the product with the largest total order quantity.", "To do this, we will use the 'Order_Items' table, which contains the 'product_id' and 'order_quantity'.", "We will group the results by 'product_id' to calculate the total quantity ordered for each product.", "We will use the SUM function to get the total order quantity for each product.", "To find the product with the largest total order quantity, we will order the results in descending order based on the total quantity.", "Finally, we will limit the results to 1 to get only the product with the largest total order quantity."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT oi.product_id, SUM(oi.order_quantity) AS total_quantity\nFROM Order_Items oi\nGROUP BY oi.product_id\nORDER BY total_quantity DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    }\n}\n"}
{"sample_id": "train.6132", "db_id": "customers_and_addresses", "question": "What are the name and ID of the product bought the most.", "rationale": ["Identify the relevant tables: We need to look at the 'Order_Items' table to find out which products were ordered and how many times.", "Count the quantity of each product ordered: We will use COUNT() to tally the total quantity for each product.", "Group the results by product_id: This allows us to aggregate the order quantities for each product.", "Order the results in descending order: This will help us find the product with the highest total quantity ordered.", "Limit the results to 1: Since we only want the product that was bought the most, we will limit our results to the top entry."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT oi.product_id, COUNT(oi.order_quantity) AS total_quantity\nFROM Order_Items oi\nGROUP BY oi.product_id\nORDER BY total_quantity DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The result provides insights into the typical order size for products.\",\n        \"virtual_table\": \"SELECT avg(order_quantity) FROM order_items\"\n    }\n}\n"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The question asks for addresses, so we will use the 'Addresses' table.", "Determine the filtering criteria: We need to find addresses in two specific cities (East Julianaside and Gleasonmouth) and their corresponding states (Texas and Arizona).", "Construct the WHERE clause: We will use an OR condition to combine the two sets of criteria for the cities and states.", "Formulate the SQL query: We will select all columns from the 'Addresses' table where the conditions are met."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "\n"}
{"sample_id": "train.6155", "db_id": "music_4", "question": "What are the category of music festivals with result \"Awarded\"?", "rationale": ["Identify the relevant table: The question pertains to music festivals, so we will focus on the 'music_festival' table.", "Determine the required columns: We need the 'Category' of the music festivals that have a result of 'Awarded'.", "Construct the SQL query: We will select the 'Category' from the 'music_festival' table where the 'Result' is 'Awarded'."], "gold_sql": "SELECT Category FROM music_festival WHERE RESULT  =  'Awarded'", "source_tables": ["music_festival"], "pred_sql": "SELECT Category FROM music_festival WHERE Result = 'Awarded'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the results of music festivals, showing the outcomes grouped by their result type. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return, enabling them to control how many of the most frequent results they wish to see.\",\n        \"virtual_table\": \"SELECT RESULT FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6167", "db_id": "music_4", "question": "Please show the songs that have result \"nominated\" at music festivals.", "rationale": ["Identify the tables involved: music_festival, volume, and artist.", "Determine the relationship between the tables: music_festival is linked to volume through Volume, and volume is linked to artist through Artist_ID.", "We need to select the artist's name and the song identifier for songs that have a result of 'nominated' in the music_festival table.", "Use JOIN clauses to combine the tables based on their relationships.", "Filter the results using a WHERE clause to only include rows where the Result is 'nominated'.", "Construct the final SQL query to retrieve the desired information."], "gold_sql": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  'Nominated'", "source_tables": ["music_festival", "volume"], "pred_sql": "SELECT artist.Artist, volume.Song \nFROM music_festival \nJOIN volume ON music_festival.Volume = volume.Volume_ID \nJOIN artist ON volume.Artist_ID = artist.Artist_ID \nWHERE music_festival.Result = 'nominated';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the results of music festivals, showing the outcomes grouped by their result type. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return, enabling them to control how many of the most frequent results they wish to see.\",\n        \"virtual_table\": \"SELECT RESULT FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6180", "db_id": "music_4", "question": "Return the famous release date for the oldest artist.", "rationale": ["Identify the table that contains the information about artists, which is the 'artist' table.", "We need to find the oldest artist, so we will sort the artists by their age in ascending order.", "To get the oldest artist, we will limit the results to 1 after sorting.", "The column we are interested in is 'Famous_Release_date', so we will select that column in our query."], "gold_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1", "source_tables": ["artist"], "pred_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age ASC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.6185", "db_id": "music_4", "question": "Please show the categories of the music festivals with count more than 1.", "rationale": ["Identify the table of interest: music_festival, which contains the Category column.", "We need to group the results by the Category to count how many times each category appears.", "Use the HAVING clause to filter the grouped results to only include categories that have a count greater than 1."], "gold_sql": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*)  >  1", "source_tables": ["music_festival"], "pred_sql": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the results of music festivals, showing the outcomes grouped by their result type. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return, enabling them to control how many of the most frequent results they wish to see.\",\n        \"virtual_table\": \"SELECT RESULT FROM music_festival GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6187", "db_id": "music_4", "question": "What is the song in the volume with the maximum weeks on top?", "rationale": ["Identify the relevant table: The 'volume' table contains the information about songs and their weeks on top.", "Determine the requirement: We need to find the song that has the maximum weeks on top.", "Use the ORDER BY clause to sort the songs by 'Weeks_on_Top' in descending order, so the song with the maximum weeks on top comes first.", "Limit the results to 1 to get only the top song.", "Construct the SQL query using the identified table and conditions."], "gold_sql": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the songs from the 'volume' table, ordered by the number of weeks they stayed at the top, with a limit on the number of results returned. The placeholder in the LIMIT clause represents the maximum number of songs to display.\",\n        \"virtual_table\": \"SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6195", "db_id": "music_4", "question": "What is the issue date of the volume with the minimum weeks on top?", "rationale": ["Identify the table that contains the issue date and weeks on top, which is the 'volume' table.", "To find the issue date of the volume with the minimum weeks on top, we need to first determine the minimum value of 'Weeks_on_Top' in the 'volume' table.", "We can use a subquery to find the minimum weeks on top: (SELECT MIN(Weeks_on_Top) FROM volume).", "Once we have the minimum weeks on top, we can select the 'Issue_Date' from the 'volume' table where 'Weeks_on_Top' matches this minimum value."], "gold_sql": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT Issue_Date FROM volume WHERE Weeks_on_Top = (SELECT MIN(Weeks_on_Top) FROM volume)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the songs from the 'volume' table, ordered by the number of weeks they stayed at the top, with a limit on the number of results returned. The placeholder in the LIMIT clause represents the maximum number of songs to display.\",\n        \"virtual_table\": \"SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["Identify the table that contains the competition information, which is the 'match' table.", "Determine the column that holds the competition name, which is 'Competition'.", "Formulate a subquery to find the Competition ID for '1994 FIFA World Cup qualification'.", "Use the result of the subquery to select the Match_ID from the 'match' table."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "pred_sql": "SELECT Match_ID FROM match WHERE Competition = (SELECT Competition FROM match WHERE Competition = '1994 FIFA World Cup qualification');", "hint": "\n"}
{"sample_id": "train.6274", "db_id": "city_record", "question": "Which city has hosted the most events?", "rationale": ["Identify the relevant table for hosting events, which is the 'hosting_city' table.", "We need to count the number of events hosted by each city, so we will use the COUNT() function.", "Group the results by 'Host_City' to get the count of events for each city.", "Order the results in descending order based on the count of events to find the city with the most events.", "Limit the results to 1 to get only the city that has hosted the most events."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "pred_sql": "SELECT Host_City, COUNT(*) AS Event_Count\nFROM hosting_city\nGROUP BY Host_City\nORDER BY Event_Count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables: 'city' for city names and 'temperature' for temperature data.", "We need to find the city with the highest temperature in February, so we will focus on the 'Feb' column in the 'temperature' table.", "Join the 'city' table with the 'temperature' table on the 'City_ID' to get city names along with their February temperatures.", "Order the results by the February temperature in descending order to get the highest temperature at the top.", "Limit the results to 1 to get only the city with the highest temperature."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, t.Feb \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nORDER BY t.Feb DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6287", "db_id": "city_record", "question": "In February, which city marks the highest temperature?", "rationale": ["Identify the relevant tables: We need data from the 'city' table for city names and the 'temperature' table for February temperatures.", "Join the 'city' table with the 'temperature' table on the City_ID to get the temperature data associated with each city.", "Select the city name and the average temperature for February from the joined tables.", "Order the results by the February temperature in descending order to find the highest temperature.", "Limit the results to 1 to get only the city with the highest temperature in February."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City, t.Feb\nFROM city c\nJOIN temperature t ON c.City_ID = t.City_ID\nORDER BY t.Feb DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables.", "Determine the conditions: We want cities where the temperature in March is lower than in July or higher than in October.", "Join the tables: We will join the 'city' table with the 'temperature' table on 'City_ID' to access city names along with their temperature data.", "Construct the SQL query: Select the city names from the joined tables where the specified temperature conditions are met."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Jul OR t.Mar > t.Oct;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6289", "db_id": "city_record", "question": "Which cities' temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables.", "Determine the conditions: We want cities where the temperature in March is lower than in July or higher than in October.", "Join the tables: We will join the 'city' table with the 'temperature' table on 'City_ID' to access city names along with their temperature data.", "Construct the SQL query: We will select the city names from the 'city' table where the specified temperature conditions are met."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Jul OR t.Mar > t.Oct;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6292", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in Dec and which have never been host cities.", "rationale": ["Identify the relevant tables: 'city' for city names and 'temperature' for temperature data.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Filter the results to include only those cities where the temperature in March (Mar) is lower than in December (Dec).", "Additionally, ensure that the cities have never hosted a match by checking that their 'City_ID' is not in the list of 'Host_City' from the 'hosting_city' table.", "Select the city names that meet both conditions."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the relevant tables: 'city' for city names and 'temperature' for temperature data.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Filter the results to find cities where the average temperature in March (t.Mar) is lower than in December (t.Dec).", "Exclude cities that have hosted matches by using a subquery that selects 'Host_City' from the 'hosting_city' table.", "Select the city names that meet both conditions."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6298", "db_id": "city_record", "question": "Please give me a list of cities whose regional population is over 8000000 or under 5000000.", "rationale": ["Identify the relevant table: The 'city' table contains the information about cities and their regional populations.", "Determine the condition for filtering: We need cities with a regional population greater than 8,000,000 or less than 5,000,000.", "Construct the SQL query: Use a SELECT statement to retrieve the 'City' column from the 'city' table where the 'Regional_Population' meets the specified conditions."], "gold_sql": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000", "source_tables": ["city"], "pred_sql": "SELECT City FROM city WHERE Regional_Population > 8000000 OR Regional_Population < 5000000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n        \"virtual_table\": \"SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6313", "db_id": "e_government", "question": "What is the name of the party form that is most common?", "rationale": ["Identify the relevant tables: Party_Forms and Forms are needed to get the form names.", "Join the Party_Forms table with the Forms table on the form_id to access the form names.", "Group the results by form_name to count how many times each form appears in the Party_Forms table.", "Use COUNT(*) to count the occurrences of each form name.", "Order the results in descending order based on the count to find the most common form.", "Limit the results to 1 to get only the most common form."], "gold_sql": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["forms", "party_forms"], "pred_sql": "SELECT form_name, COUNT(*) as form_count\nFROM Party_Forms\nJOIN Forms ON Party_Forms.form_id = Forms.form_id\nGROUP BY form_name\nORDER BY form_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6329", "db_id": "e_government", "question": "What are the names of the services that have never been used?", "rationale": ["Identify the main table of interest, which is the 'Services' table, to get the names of services.", "Use the 'Party_Services' table to find out which services have been booked.", "To find services that have never been used, we can use the EXCEPT clause to exclude the services that appear in the 'Party_Services' table from the list of all services in the 'Services' table."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "pred_sql": "SELECT service_name FROM Services EXCEPT SELECT t1.service_name FROM Services AS t1 JOIN Party_Services AS t2 ON t1.service_id = t2.service_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of services from the 'Services' table that have not been booked by any party. The query uses an EXCEPT clause to exclude service names that are present in the 'Party_Services' table, indicating that those services have been booked. The placeholder in the query allows for future modifications to filter or adjust the selection criteria as needed.\",\n        \"virtual_table\": \"SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id\"\n    }\n}\n"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table: The question asks for cities and states, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' for cities and 'state_province_county' for states.", "Use DISTINCT to avoid duplicate entries: Since we want the names of all cities and states, using DISTINCT ensures that we only get unique combinations.", "Construct the SQL query: Combine the selected columns and the table name in a SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6342", "db_id": "e_government", "question": "Which state can address \"6862 Kaitlyn Knolls\" possibly be in?", "rationale": ["Identify the relevant table: The question pertains to addresses, so we will use the 'Addresses' table.", "Determine the required column: We need to find the state, province, or county, which is stored in the 'state_province_county' column.", "Formulate the query: We will use a SELECT statement to retrieve the 'state_province_county' from the 'Addresses' table.", "Use a WHERE clause to filter the results: We will check if the 'line_1_number_building' contains the specific address '6862 Kaitlyn Knolls'.", "Utilize the LIKE operator: To allow for flexible matching, we will use the LIKE operator with wildcards around the address."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "pred_sql": "SELECT state_province_county FROM Addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the state, province, or county information from the 'Addresses' table based on a specific address line that matches a given pattern. The placeholder in the LIKE clause allows for flexible searching of address lines.\",\n        \"virtual_table\": \"SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the relevant tables: We need to find individuals who are contact individuals for organizations, so we will use the Organization_Contact_Individuals and Individuals tables.", "Determine the relationship: The Organization_Contact_Individuals table has a foreign key 'individual_id' that links to the Individuals table.", "Select the required field: We need the last names of the individuals, which is in the Individuals table under 'individual_last_name'.", "Construct the SQL query: We will use a JOIN to combine the Organization_Contact_Individuals and Individuals tables on the 'individual_id' field and select the 'individual_last_name' from the Individuals table."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "pred_sql": "SELECT Individuals.individual_last_name \nFROM Organization_Contact_Individuals \nJOIN Individuals ON Organization_Contact_Individuals.individual_id = Individuals.individual_id;", "hint": "\n"}
{"sample_id": "train.6371", "db_id": "flight_company", "question": "What are the names and types of the companies that have ever operated a flight?", "rationale": ["Identify the relevant tables: We need information from the 'operate_company' table for company names and types, and the 'flight' table to find out which companies have operated flights.", "Determine the relationship: The 'flight' table has a foreign key 'company_id' that links to the 'id' in the 'operate_company' table, allowing us to join these two tables.", "Select the required columns: We need to select the 'name' and 'Type' columns from the 'operate_company' table.", "Use DISTINCT to avoid duplicate entries: Since a company may operate multiple flights, we use DISTINCT to ensure each company is listed only once."], "gold_sql": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id", "source_tables": ["flight", "operate_company"], "pred_sql": "SELECT DISTINCT operate_company.name, operate_company.Type \nFROM operate_company \nJOIN flight ON operate_company.id = flight.company_id;", "hint": "\n"}
{"sample_id": "train.6375", "db_id": "flight_company", "question": "What is the id, name and IATA code of the airport that had most number of flights?", "rationale": ["Identify the relevant tables: 'airport' and 'flight'.", "We need to find the airport with the most flights, so we will join the 'airport' table with the 'flight' table using the foreign key relationship (airport.id = flight.airport_id).", "Select the required columns: airport.id, airport.name, and airport.IATA.", "Group the results by airport.id, airport.name, and airport.IATA to aggregate the flight counts for each airport.", "Count the number of flights for each airport using COUNT(flight.id).", "Order the results in descending order based on the flight count to get the airport with the most flights at the top.", "Limit the results to 1 to get only the airport with the highest number of flights."], "gold_sql": "SELECT T1.id ,  T1.name ,  T1.IATA FROM airport AS T1 JOIN flight AS T2 ON T1.id  =  T2.airport_id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airport", "flight"], "pred_sql": "SELECT airport.id, airport.name, airport.IATA\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nGROUP BY airport.id, airport.name, airport.IATA\nORDER BY COUNT(flight.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6381", "db_id": "flight_company", "question": "How many companies operates airlines in each airport?", "rationale": ["Identify the relevant tables: airport, operate_company, and flight.", "We need to count the number of companies that operate airlines at each airport.", "Join the airport table with the flight table on airport.id and flight.airport_id.", "Join the flight table with the operate_company table on flight.company_id and operate_company.id.", "Filter the results to include only those companies that are of type 'airline'.", "Group the results by airport name to get the count of airline companies for each airport."], "gold_sql": "SELECT T3.id ,  count(*) FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id JOIN airport AS T3 ON T2.airport_id  =  T3.id GROUP BY T3.id", "source_tables": ["airport", "flight", "operate_company"], "pred_sql": "SELECT airport.name AS Airport_Name, COUNT(operate_company.id) AS Number_of_Airline_Companies\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nJOIN operate_company ON flight.company_id = operate_company.id\nWHERE operate_company.Type = 'airline'\nGROUP BY airport.name;", "hint": "\n"}
{"sample_id": "train.6517", "db_id": "wine_1", "question": "What is the name of the highest rated wine?", "rationale": ["Identify the table that contains the wine information, which is the 'wine' table.", "To find the highest rated wine, we need to look for the maximum score in the 'Score' column of the 'wine' table.", "We can use a subquery to find the maximum score: (SELECT MAX(Score) FROM wine).", "Then, we need to select the name of the wine that has this maximum score.", "The final SQL query combines these elements to return the name of the highest rated wine."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine WHERE Score = (SELECT MAX(Score) FROM wine)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of wines from the 'wine' table that have a score higher than a specified value. The placeholder in the WHERE clause represents the minimum score threshold for filtering the wines.\",\n        \"virtual_table\": \"SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6518", "db_id": "wine_1", "question": "Give the name of the wine with the highest score.", "rationale": ["Identify the table that contains the wine information, which is the 'wine' table.", "To find the wine with the highest score, we need to select the 'Name' of the wine from the 'wine' table.", "We will use a subquery to find the maximum score from the 'wine' table.", "The subquery will be: SELECT MAX(Score) FROM wine, which gives us the highest score.", "We will then filter the main query to only return the wine names that match this maximum score."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine WHERE Score = (SELECT MAX(Score) FROM wine)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of wines from the 'wine' table that have a score higher than a specified value. The placeholder in the WHERE clause represents the minimum score threshold for filtering the wines.\",\n        \"virtual_table\": \"SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6520", "db_id": "wine_1", "question": "What is the winery at which the wine with the highest score was made?", "rationale": ["Identify the table that contains the winery information, which is the 'wine' table.", "Determine that we need to find the wine with the highest score.", "Use a subquery to find the maximum score from the 'wine' table.", "Select the winery from the 'wine' table where the score matches the maximum score found in the subquery."], "gold_sql": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Winery FROM wine WHERE Score = (SELECT MAX(Score) FROM wine)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of wines from the 'wine' table that have a score higher than a specified value. The placeholder in the WHERE clause represents the minimum score threshold for filtering the wines.\",\n        \"virtual_table\": \"SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6533", "db_id": "wine_1", "question": "List the names of all distinct wines that are made of red color grape.", "rationale": ["We need to list the names of all distinct wines made from red color grapes.", "To achieve this, we will use the 'wine' table to get the wine names and the 'grapes' table to filter by grape color.", "We will perform a JOIN operation between the 'wine' and 'grapes' tables on the grape variety.", "We will use the WHERE clause to filter the results to only include grapes that are red in color.", "The DISTINCT keyword will ensure that we only get unique wine names.", "Finally, we will order the results alphabetically by the wine name."], "gold_sql": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT wine.Name \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'red' \nORDER BY wine.Name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, sorted in alphabetical order. The query uses the DISTINCT keyword to ensure that each wine name appears only once in the result set, and the ORDER BY clause organizes the names in ascending order.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY Name\"\n    }\n}\n"}
{"sample_id": "train.6544", "db_id": "wine_1", "question": "Give the names and scores of wines made from white grapes.", "rationale": ["Identify the relevant tables: 'wine' and 'grapes'.", "We need to retrieve the names and scores of wines, so we will select 'Name' and 'Score' from the 'wine' table.", "To filter the wines made from white grapes, we need to join the 'wine' table with the 'grapes' table on the 'Grape' column.", "In the WHERE clause, we specify that we only want grapes where the 'Color' is 'white'."], "gold_sql": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT wine.Name, wine.Score \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'white';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of wines from the 'wine' table that have a score higher than a specified value. The placeholder in the WHERE clause represents the minimum score threshold for filtering the wines.\",\n        \"virtual_table\": \"SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6547", "db_id": "wine_1", "question": "Find the the grape whose white color grapes are used to produce wines with scores higher than 90.", "rationale": ["Identify the requirement to find grape varieties that are white in color.", "Recognize that we need to filter the grapes based on their usage in wines that have a score higher than 90.", "Use a subquery to select grape varieties from the 'wine' table where the score is greater than 90.", "Combine the results of the subquery with the main query to filter for white grapes in the 'grapes' table."], "gold_sql": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White' AND T2.score  >  90", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT Grape FROM grapes WHERE Color = 'white' AND Grape IN (SELECT Grape FROM wine WHERE Score > 90)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of wines from the 'wine' table that have a score higher than a specified value. The placeholder in the WHERE clause represents the minimum score threshold for filtering the wines.\",\n        \"virtual_table\": \"SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6550", "db_id": "wine_1", "question": "What are the names of wines made from red grapes and with prices above 50?", "rationale": ["Identify the relevant tables: 'wine' for wine details and 'grapes' for grape color.", "We need to filter wines based on grape color, specifically red grapes, which requires a join between the 'wine' and 'grapes' tables.", "The condition for the price of the wine is specified as greater than 50, which will be included in the WHERE clause.", "We need to select distinct wine names that meet both conditions (red grapes and price > 50).", "The final SQL query combines these elements to retrieve the desired information."], "gold_sql": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red' AND T2.price  >  50", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT wine.Name \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'red' AND wine.Price > '50'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, ordered by their retail price. The placeholder in the ORDER BY clause represents the price of the wines.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY price\"\n    }\n}\n"}
{"sample_id": "train.6558", "db_id": "wine_1", "question": "What are the distinct names of wines with prices higher than any wine from John Anthony winery.", "rationale": ["Identify the requirement to find distinct names of wines.", "Determine that we need to filter wines based on their price being higher than a specific value.", "The specific value is the maximum price of wines from the 'John Anthony' winery.", "Construct a subquery to find the maximum price of wines from 'John Anthony'.", "Use the result of the subquery to filter the main query for distinct wine names with prices higher than this value."], "gold_sql": "SELECT DISTINCT Name FROM WINE WHERE Price  >  (SELECT min(Price) FROM wine WHERE Winery  =  'John Anthony')", "source_tables": ["wine"], "pred_sql": "SELECT DISTINCT Name FROM wine WHERE Price > (SELECT MAX(Price) FROM wine WHERE Winery = 'John Anthony')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, ordered by their retail price. The placeholder in the ORDER BY clause represents the price of the wines.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY price\"\n    }\n}\n"}
{"sample_id": "train.6566", "db_id": "wine_1", "question": "Give the color of the grape whose wine products have the highest average price?", "rationale": ["Identify the relevant tables: 'grapes' for grape color and 'wine' for wine prices.", "Join the 'grapes' table with the 'wine' table on the grape variety to access both grape color and wine price.", "Group the results by grape color to calculate the average price of wines for each grape color.", "Order the results by the average price in descending order to find the highest average price.", "Limit the results to 1 to get the grape color associated with the highest average price."], "gold_sql": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT 1", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT g.Color \nFROM grapes g \nJOIN wine w ON g.Grape = w.Grape \nGROUP BY g.Color \nORDER BY AVG(w.Price) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of wines from the 'wine' table, ordered by their retail price. The placeholder in the ORDER BY clause represents the price of the wines.\",\n        \"virtual_table\": \"SELECT DISTINCT Name FROM WINE ORDER BY price\"\n    }\n}\n"}
{"sample_id": "train.6588", "db_id": "wine_1", "question": "Which 3 wineries produce the most wines made from white grapes?", "rationale": ["Identify the relevant tables: 'wine' for wineries and 'grapes' for grape colors.", "We need to filter the wines to only include those made from white grapes, which requires a JOIN between the 'wine' and 'grapes' tables.", "Count the number of wines produced by each winery using COUNT(*) and group the results by Winery.", "Order the results by the count of wines in descending order to find the top producers.", "Limit the results to the top 3 wineries."], "gold_sql": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  'White' GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT Winery, COUNT(*) as WineCount \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'white' \nGROUP BY Winery \nORDER BY WineCount DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of wineries from the 'wine' table, ordered by their rating scores. The placeholder in the LIMIT clause represents the maximum number of wineries to be displayed.\",\n        \"virtual_table\": \"SELECT Winery FROM WINE ORDER BY SCORE LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6597", "db_id": "wine_1", "question": "Find the county where produces the most number of wines with score higher than 90.", "rationale": ["Identify the relevant tables: 'wine' for wine details and 'appellations' for county information.", "We need to filter wines with a score higher than 90, which can be done using a WHERE clause on the 'Score' column in the 'wine' table.", "To find the county with the most wines, we will join the 'wine' table with the 'appellations' table on the 'Appelation' column.", "We will group the results by 'County' to count the number of wines per county.", "Finally, we will order the results in descending order based on the count of wines and limit the output to the top result."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1", "source_tables": ["wine", "appellations"], "pred_sql": "SELECT a.County, COUNT(w.No) AS WineCount\nFROM wine w\nJOIN appellations a ON w.Appelation = a.Appelation\nWHERE w.Score > 90\nGROUP BY a.County\nORDER BY WineCount DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of wines from the 'wine' table that have a score higher than a specified value. The placeholder in the WHERE clause represents the minimum score threshold for filtering the wines.\",\n        \"virtual_table\": \"SELECT Name FROM WINE WHERE score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6626", "db_id": "driving_school", "question": "Show the detail of vehicle with id 1.", "rationale": ["The user wants to see the details of a specific vehicle identified by its ID, which is '1'.", "To retrieve this information, we need to select the 'vehicle_details' column from the 'Vehicles' table.", "We will use a WHERE clause to filter the results to only include the vehicle with the specified ID ('1').", "The final SQL query will be: SELECT vehicle_details FROM Vehicles WHERE vehicle_id = '1';"], "gold_sql": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;", "source_tables": ["vehicles"], "pred_sql": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = '1';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of a specific vehicle from the 'Vehicles' table based on its unique identifier. The placeholder in the WHERE clause represents the vehicle's ID.\",\n        \"virtual_table\": \"SELECT vehicle_details FROM Vehicles WHERE vehicle_id = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.6650", "db_id": "driving_school", "question": "How many staff live in state Georgia?", "rationale": ["Identify the relevant tables: Staff and Addresses.", "Determine the relationship between Staff and Addresses using the foreign key (staff_address_id).", "Count the number of staff members who live in Georgia by filtering the Addresses table on the state_province_county column.", "Construct the SQL query using COUNT(*) to get the total number of staff in Georgia."], "gold_sql": "SELECT count(*) FROM Addresses WHERE state_province_county = 'Georgia';", "source_tables": ["addresses"], "pred_sql": "SELECT COUNT(*) AS staff_count \nFROM Staff \nJOIN Addresses ON Staff.staff_address_id = Addresses.address_id \nWHERE Addresses.state_province_county = 'Georgia';", "hint": "\n"}
{"sample_id": "train.6665", "db_id": "driving_school", "question": "What is the status code, phone number, and email address of the customer whose last name is Kohler or whose first name is Marina?", "rationale": ["Identify the relevant table: The question pertains to customer information, so we will use the Customers table.", "Determine the required columns: The question asks for the status code, phone number, and email address of the customer.", "Construct the SELECT statement: We will select customer_status_code, phone_number, and email_address from the Customers table.", "Add the WHERE clause: We need to filter the results to include customers whose last name is 'Kohler' or whose first name is 'Marina'.", "Combine all parts to form the complete SQL query."], "gold_sql": "SELECT customer_status_code ,  cell_mobile_phone_number ,  email_address FROM Customers WHERE first_name = 'Marina' OR last_name  =  'Kohler'", "source_tables": ["customers"], "pred_sql": "SELECT customer_status_code, phone_number, email_address \nFROM Customers \nWHERE last_name = 'Kohler' OR first_name = 'Marina';", "hint": "\n"}
{"sample_id": "train.6676", "db_id": "driving_school", "question": "How many lessons taken by customer with first name as Rylan and last name as Goodwin were completed?", "rationale": ["Identify the relevant tables: Lessons and Customers.", "We need to count the number of lessons, so we will use the COUNT() function.", "We need to filter the lessons based on the customer's first and last name, which requires a JOIN between the Lessons and Customers tables.", "The WHERE clause will specify the conditions for the customer's first name and last name, as well as the lesson status code to ensure we only count completed lessons."], "gold_sql": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = 'Rylan' AND T2.last_name = 'Goodwin' AND T1.lesson_status_code = 'Completed';", "source_tables": ["lessons", "customers"], "pred_sql": "SELECT COUNT(*) AS completed_lessons_count\nFROM Lessons\nJOIN Customers ON Lessons.customer_id = Customers.customer_id\nWHERE Customers.first_name = 'Rylan' AND Customers.last_name = 'Goodwin' AND Lessons.lesson_status_code = 'completed';", "hint": "\n"}
{"sample_id": "train.6688", "db_id": "driving_school", "question": "Which city does has most number of customers?", "rationale": ["Identify the relevant tables: We need to find the city with the most customers, so we will use the Addresses and Customers tables.", "Join the tables: We will join the Addresses table with the Customers table on the address_id to link customers to their respective addresses.", "Group by city: We will group the results by city to count the number of customers in each city.", "Count customers: We will use COUNT(customer_id) to count the number of customers in each city.", "Order the results: We will order the results in descending order based on the customer count to find the city with the most customers.", "Limit the results: We will limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "customers"], "pred_sql": "SELECT city, COUNT(customer_id) AS customer_count\nFROM Addresses\nJOIN Customers ON Addresses.address_id = Customers.customer_address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6711", "db_id": "driving_school", "question": "What are the last names that are used by customers and staff?", "rationale": ["Identify the tables that contain last names: Customers and Staff.", "Select the last_name column from the Customers table.", "Select the last_name column from the Staff table.", "Use UNION to combine the results from both tables, ensuring distinct last names are returned."], "gold_sql": "SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff", "source_tables": ["staff", "customers"], "pred_sql": "SELECT DISTINCT last_name FROM Customers UNION SELECT DISTINCT last_name FROM Staff;", "hint": "\n"}
{"sample_id": "train.6714", "db_id": "driving_school", "question": "What is the id and detail of the vehicle used in lessons for most of the times?", "rationale": ["Identify the vehicle used in lessons the most times.", "To find this, we need to count the occurrences of each vehicle in the Lessons table.", "We will group the results by vehicle_id and count the number of lessons for each vehicle.", "We will order the results by the count in descending order to get the vehicle with the highest count first.", "Finally, we will limit the results to 1 to get only the most used vehicle.", "We will then select the vehicle_id and vehicle_details from the Vehicles table for the identified vehicle."], "gold_sql": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["lessons", "vehicles"], "pred_sql": "SELECT vehicle_id, vehicle_details FROM Vehicles WHERE vehicle_id IN (SELECT vehicle_id FROM Lessons GROUP BY vehicle_id ORDER BY COUNT(*) DESC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of a specific vehicle from the 'Vehicles' table based on its unique identifier. The placeholder in the WHERE clause represents the vehicle's ID.\",\n        \"virtual_table\": \"SELECT vehicle_details FROM Vehicles WHERE vehicle_id = [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the table needed: Faculty table contains information about faculty members.", "Determine the condition: We need to filter faculty members based on gender, specifically for male faculty.", "Use the provided hint to construct the SQL query: The hint suggests a virtual table that selects FacID from the Faculty table where Sex matches a specified value.", "Replace the placeholder in the hint with 'male' to complete the SQL query."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "pred_sql": "SELECT FacID FROM Faculty WHERE Sex = 'male'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6734", "db_id": "activity_1", "question": "What are the first name and last name of all the instructors?", "rationale": ["Identify the table that contains instructor information, which is the Faculty table.", "Determine the columns needed for the output, which are the first name (Fname) and last name (Lname) of the instructors.", "Construct the SQL SELECT statement to retrieve the specified columns from the Faculty table."], "gold_sql": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  'Instructor'", "source_tables": ["faculty"], "pred_sql": "SELECT Fname, Lname FROM Faculty;", "hint": "\n"}
{"sample_id": "train.6737", "db_id": "activity_1", "question": "Which building has most faculty members?", "rationale": ["We need to find out which building has the most faculty members.", "To do this, we will count the number of faculty members in each building.", "We will use the COUNT() function to count the number of faculty members grouped by the 'Building' column.", "We will group the results by the 'Building' column to get the count for each building.", "Finally, we will order the results in descending order based on the count and limit the results to 1 to get the building with the most faculty members."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(*) AS FacultyCount \nFROM Faculty \nGROUP BY Building \nORDER BY FacultyCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["Identify the relevant table: The 'Faculty' table contains information about faculty members, including their rank and gender.", "Determine the criteria: We need to filter for assistant professors, which is specified by the 'Rank' column.", "Group the results: To get the count of male and female assistant professors, we will group the results by the 'Sex' column.", "Count the number of faculty members: Use the COUNT function to count the number of faculty members in each gender group."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT COUNT(*) AS count, Sex FROM Faculty WHERE Rank = 'Assistant Professor' GROUP BY Sex;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6748", "db_id": "activity_1", "question": "How many male and female assistant professors do we have?", "rationale": ["Identify the relevant table: Faculty, which contains information about faculty members including their rank and gender.", "We need to filter the faculty members to only include those who are 'Assistant Professors'.", "We need to count the number of faculty members grouped by their gender (Sex).", "The SQL query will select the gender and the count of faculty members for each gender, grouping the results by gender."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) AS Count \nFROM Faculty \nWHERE Rank = 'Assistant Professor' \nGROUP BY Sex;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the tables involved: We need to find the advisor of a student named Linda Smith, which involves the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that references the 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the SQL query: We will select the first name and last name of the faculty member from the Faculty table, joining it with the Student table on the advisor relationship.", "Add the WHERE clause: We need to filter the results to only include the student with the first name 'Linda' and last name 'Smith'."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Faculty.Fname, Faculty.Lname \nFROM Faculty \nJOIN Student ON Faculty.FacID = Student.Advisor \nWHERE Student.Fname = 'Linda' AND Student.LName = 'Smith';", "hint": "\n"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["Identify the relevant tables: We need to find students and their advisors, which involves the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that references 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the SQL query: We will select the distinct student IDs from the Student table where there is a matching faculty member in the Faculty table based on the advisor relationship."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT DISTINCT Student.StuID \nFROM Student \nJOIN Faculty ON Student.Advisor = Faculty.FacID;", "hint": "\n"}
{"sample_id": "train.6752", "db_id": "activity_1", "question": "Which students have professors as their advisors? Find their student ids.", "rationale": ["Identify the tables involved: We need to find students and their advisors, so we will use the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that corresponds to 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the SQL query: We will select the student IDs from the Student table and join it with the Faculty table on the Advisor and FacID columns."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN Faculty ON Student.Advisor = Faculty.FacID;", "hint": "\n"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the relevant tables: We need to retrieve student information, so we will use the 'Student' table.", "Determine the relationship: We need to find students who are advised by a specific advisor, in this case, Michael Goodrich. This means we need to join the 'Student' table with itself to match students with their advisors.", "Construct the JOIN clause: We will join the 'Student' table (aliased as S) with another instance of the 'Student' table (aliased as A) where the advisor's ID matches the student's ID.", "Specify the WHERE clause: We will filter the results to only include those where the advisor's first name is 'Michael' and last name is 'Goodrich'.", "Select the required columns: We will select the first name and last name of the students advised by Michael Goodrich."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT S.Fname, S.LName \nFROM Student S \nJOIN Student A ON S.Advisor = A.StuID \nWHERE A.Fname = 'Michael' AND A.LName = 'Goodrich';", "hint": "\n"}
{"sample_id": "train.6756", "db_id": "activity_1", "question": "What are the faculty id and the number of students each faculty has?", "rationale": ["Identify the relevant tables: Faculty, Faculty_Participates_in, and Participates_in.", "We need to count the number of students associated with each faculty member, which requires joining the Faculty table with the Faculty_Participates_in table to get the activities they participate in.", "Next, join the result with the Participates_in table to link those activities to the students.", "Use COUNT() to count the number of students for each faculty member.", "Group the results by faculty ID to get the count for each faculty member."], "gold_sql": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID", "source_tables": ["faculty", "student"], "pred_sql": "SELECT f.FacID, COUNT(pi.stuid) AS student_count\nFROM Faculty f\nLEFT JOIN Faculty_Participates_in fpi ON f.FacID = fpi.FacID\nLEFT JOIN Participates_in pi ON fpi.actid = pi.actid\nGROUP BY f.FacID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6758", "db_id": "activity_1", "question": "How many students are advised by each rank of faculty? List the rank and the number of students.", "rationale": ["Identify the tables needed: Faculty and Student.", "We need to count the number of students advised by each faculty member, which requires joining the Faculty table with the Student table on the Advisor field.", "The join condition is that the Advisor in the Student table matches the FacID in the Faculty table.", "We need to group the results by the Rank of the faculty members to get the count of students for each rank.", "Use COUNT() to count the number of students for each rank and select the Rank and the count as NumberOfStudents."], "gold_sql": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank", "source_tables": ["faculty", "student"], "pred_sql": "SELECT F.Rank, COUNT(S.StuID) AS NumberOfStudents\nFROM Faculty AS F\nJOIN Student AS S ON S.Advisor = F.FacID\nGROUP BY F.Rank;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6761", "db_id": "activity_1", "question": "Show the ids for all the faculty members who have at least 2 students.", "rationale": ["We need to find faculty members who have at least 2 students participating in activities.", "To do this, we will use the Faculty_Participates_in table to count the number of distinct activities each faculty member is involved in.", "We will group the results by FacID and use the HAVING clause to filter for those with a count of 2 or more activities.", "Finally, we will select the FacID from the Faculty table where the FacID matches those found in the previous step."], "gold_sql": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  2", "source_tables": ["faculty", "student"], "pred_sql": "SELECT FacID FROM Faculty WHERE FacID IN (SELECT FacID FROM Faculty_Participates_in GROUP BY FacID HAVING COUNT(DISTINCT actid) >= 2)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6777", "db_id": "activity_1", "question": "Show the names of all the activities Mark Giuliano participates in.", "rationale": ["Identify the relevant tables: Activity, Faculty_Participates_in, and Faculty.", "We need to find activities associated with a specific faculty member, Mark Giuliano.", "Join the Activity table with Faculty_Participates_in on actid to get the activities.", "Join the Faculty_Participates_in table with Faculty on FacID to filter by faculty member's name.", "Use a WHERE clause to specify the first name as 'Mark' and last name as 'Giuliano'.", "Select the activity_name from the resulting joined tables."], "gold_sql": "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  'Mark' AND T1.lname  =  'Giuliano'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Activity.activity_name \nFROM Activity \nJOIN Faculty_Participates_in ON Activity.actid = Faculty_Participates_in.actid \nJOIN Faculty ON Faculty_Participates_in.FacID = Faculty.FacID \nWHERE Faculty.Fname = 'Mark' AND Faculty.Lname = 'Giuliano';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities from the 'Activity' table. The placeholder can be used to filter or join with other tables if needed.\",\n        \"virtual_table\": \"SELECT activity_name FROM Activity\"\n    }\n}\n"}
{"sample_id": "train.6779", "db_id": "activity_1", "question": "Show the first and last name of all the faculty members who participated in some activity, together with the number of activities they participated in.", "rationale": ["Identify the tables needed: Faculty and Faculty_Participates_in.", "We need to select the first name and last name of faculty members, so we will select F.Fname and F.Lname from the Faculty table.", "We also need to count the number of activities each faculty member participated in, which requires a COUNT function on the actid from the Faculty_Participates_in table.", "To link the faculty members to their activities, we will perform a JOIN between the Faculty table and the Faculty_Participates_in table on the FacID column.", "Since we want to group the results by each faculty member, we will use GROUP BY on F.FacID, F.Fname, and F.Lname."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname, F.Lname, COUNT(FPI.actid) AS ActivityCount\nFROM Faculty AS F\nJOIN Faculty_Participates_in AS FPI ON F.FacID = FPI.FacID\nGROUP BY F.FacID, F.Fname, F.Lname;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: Participates_in and Student.", "We need to find students who participate in activities, so we will use the Participates_in table to get student IDs (stuid).", "Next, we need to filter these students based on their age, which is found in the Student table.", "We will create a subquery to select student IDs from the Student table where Age is less than 20.", "Finally, we will use this subquery in the WHERE clause of the main query to get the student IDs from Participates_in that match the criteria."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT stuid FROM Participates_in WHERE stuid IN (SELECT StuID FROM Student WHERE Age < 20);", "hint": "\n"}
{"sample_id": "train.6797", "db_id": "activity_1", "question": "Find the first names of professors who are not playing Canoeing or Kayaking.", "rationale": ["We need to find the first names of professors who are not participating in the activities 'Canoeing' or 'Kayaking'.", "To do this, we will select the first names from the Faculty table.", "We will join the Faculty table with the Faculty_Participates_in table to find out which activities each faculty member participates in.", "Next, we will join the result with the Activity table to get the names of the activities.", "We will use a WHERE clause to filter out the activities 'Canoeing' and 'Kayaking'.", "To ensure we include faculty members who do not participate in any activities, we will use a LEFT JOIN and check for NULL values in the activity name."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty AS F \nLEFT JOIN Faculty_Participates_in AS FPI ON F.FacID = FPI.FacID \nLEFT JOIN Activity AS A ON FPI.actid = A.actid \nWHERE A.activity_name NOT IN ('Canoeing', 'Kayaking') OR A.activity_name IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the main entities involved: Faculty and their participation in activities.", "We need to find faculty members who do not participate in specific activities: Canoeing and Kayaking.", "To achieve this, we can use a subquery to find all faculty IDs that participate in Canoeing or Kayaking.", "The subquery will join the Faculty_Participates_in table with the Activity table to filter by activity names.", "The main query will select the first names of faculty members whose IDs are not in the result of the subquery."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty F \nWHERE F.FacID NOT IN (\n    SELECT FP.FacID \n    FROM Faculty_Participates_in FP \n    JOIN Activity A ON FP.actid = A.actid \n    WHERE A.activity_name IN ('Canoeing', 'Kayaking')\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6799", "db_id": "activity_1", "question": "Find the first names of the faculty members who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables needed: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members, so we will select from the Faculty table.", "We need to join the Faculty table with the Faculty_Participates_in table to find out which faculty members participate in activities.", "Next, we join the Activity table to filter the activities to 'Canoeing' and 'Kayaking'.", "The final selection will be the first names of the faculty members who participate in these activities."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty AS F \nJOIN Faculty_Participates_in AS FP ON F.FacID = FP.FacID \nJOIN Activity AS A ON FP.actid = A.actid \nWHERE A.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables involved: We need to find student IDs from the Participates_in table and the activity names from the Activity table.", "Determine the relationship: The Participates_in table has a foreign key actid that links to the Activity table's actid.", "Filter the activities: We are specifically looking for students who participate in 'Canoeing' and 'Kayaking'.", "Construct the SQL query: Use a SELECT statement to get the student IDs, join the Participates_in table with the Activity table on actid, and filter the results based on the activity names."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT p.stuid \nFROM Participates_in p \nJOIN Activity a ON p.actid = a.actid \nWHERE a.activity_name IN ('Canoeing', 'Kayaking');", "hint": "\n"}
{"sample_id": "train.6825", "db_id": "flight_4", "question": "Find the number of routes operated by American Airlines.", "rationale": ["Identify the tables involved: routes, airports, and airlines.", "Determine the relationship between the tables: routes has foreign keys referencing airports and airlines.", "We need to count the number of routes operated by American Airlines, so we will use the COUNT function.", "Join the routes table with the airports table on the destination airport ID and with the airlines table on the airline ID.", "Filter the results to include only those routes operated by 'American Airlines'.", "Since American Airlines is based in the United States, we can also filter by the country if needed, but the primary focus is on the airline name."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid = T2.apid JOIN airlines AS T3 ON T1.alid = T3.alid WHERE T2.country = 'United States' AND T3.name = 'American Airlines'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6826", "db_id": "flight_4", "question": "How many routes does American Airlines operate?", "rationale": ["Identify the relevant tables: routes, airports, and airlines.", "Determine the relationship between the tables: routes are linked to airports and airlines through foreign keys.", "We need to count the number of routes operated by American Airlines, which means filtering the results based on the airline's name.", "Use a JOIN to combine the routes with the airlines to filter by the airline name.", "The final SQL query counts the number of routes where the airline name matches 'American Airlines'."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid = T2.apid JOIN airlines AS T3 ON T1.alid = T3.alid WHERE T3.name = 'American Airlines'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6831", "db_id": "flight_4", "question": "Find the name, city, and country of the airport that has the highest latitude.", "rationale": ["Identify the relevant table: The question asks for information about airports, so we will focus on the 'airports' table.", "Determine the required fields: We need the 'name', 'city', and 'country' of the airport.", "Find the airport with the highest latitude: In the context of the schema, latitude can be represented by the 'y' coordinate. We will order the results by 'y' in descending order to get the highest latitude.", "Limit the results to one: Since we only want the airport with the highest latitude, we will use 'LIMIT 1' to restrict the output to a single record."], "gold_sql": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT 1", "source_tables": ["airports"], "pred_sql": "SELECT name, city, country FROM airports ORDER BY y DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6834", "db_id": "flight_4", "question": "What is the name and city of the airport that the most routes end at?", "rationale": ["We need to find the airport that has the most routes ending at it.", "To do this, we will join the 'airports' table with the 'routes' table on the destination airport ID ('dst_apid').", "We will group the results by the airport ID ('apid') to count the number of routes for each airport.", "We will order the results in descending order based on the count of routes to get the airport with the most routes at the top.", "Finally, we will limit the results to just one record to get the airport with the most routes."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, airports.city FROM airports JOIN routes ON airports.apid = routes.dst_apid GROUP BY airports.apid ORDER BY COUNT(routes.rid) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6838", "db_id": "flight_4", "question": "What is the name and city of the airport from most of the routes start?", "rationale": ["Identify the relevant tables: We need to get information about airports, specifically their names and cities, from the routes table.", "Determine the relationship: The routes table has a foreign key 'src_apid' that links to the 'apid' in the airports table, allowing us to join these tables.", "Count the number of routes starting from each airport: We will group the results by the airport ID and count the number of routes for each.", "Sort the results: We will order the grouped results by the count of routes in descending order to find the airport with the most routes starting from it.", "Limit the results: We only need the top result, so we will limit the output to 1."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, airports.city FROM routes JOIN airports ON routes.src_apid = airports.apid GROUP BY airports.apid ORDER BY COUNT(routes.rid) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6841", "db_id": "flight_4", "question": "Which countries has the most number of airlines?", "rationale": ["We need to find out which countries have the most number of airlines.", "To do this, we will count the distinct airline IDs (alid) from the airlines table.", "We will join the airlines table with the routes table to link airlines to their routes.", "Next, we will join the routes table with the airports table to ensure we are considering routes that lead to airports in specific countries.", "We will group the results by country to get the count of airlines per country.", "Finally, we will order the results in descending order to show the countries with the most airlines at the top."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT T3.country, COUNT(DISTINCT T3.alid) AS airline_count FROM airlines AS T3 JOIN routes AS T1 ON T3.alid = T1.alid JOIN airports AS T2 ON T1.dst_apid = T2.apid GROUP BY T3.country ORDER BY airline_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6842", "db_id": "flight_4", "question": "What is the name of the country with the most number of home airlines?", "rationale": ["We need to find the country with the most number of home airlines.", "To do this, we will count the number of active airlines grouped by country.", "We will use the 'airlines' table to get the country and the count of airlines.", "We will filter the airlines to only include those that are currently active (active = 1).", "Finally, we will order the results by the count of airlines in descending order and limit the result to 1 to get the country with the most airlines."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country, COUNT(*) AS airline_count \nFROM airlines \nWHERE active = 1 \nGROUP BY country \nORDER BY airline_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6858", "db_id": "flight_4", "question": "What are the cities that have more than 2 airports sorted by number of airports?", "rationale": ["Identify the relevant table: The 'airports' table contains information about cities and airports.", "Count the number of airports in each city: Use the COUNT() function and GROUP BY city to aggregate the data.", "Filter cities with more than 2 airports: Use the HAVING clause to restrict results to cities with a count greater than 2.", "Sort the results: Use ORDER BY to sort the cities by the number of airports in descending order."], "gold_sql": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)", "source_tables": ["airports"], "pred_sql": "SELECT city, COUNT(*) as airport_count \nFROM airports \nGROUP BY city \nHAVING COUNT(*) > 2 \nORDER BY airport_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6862", "db_id": "flight_4", "question": "For each  airport name, how many routes start at that airport, ordered from most to least?", "rationale": ["We need to count the number of routes starting at each airport.", "The relevant table for this information is 'routes', which contains the source airport information in the 'src_ap' column.", "We will use the COUNT() function to count the number of routes for each source airport.", "To group the results by each airport, we will use the GROUP BY clause on 'src_ap'.", "Finally, we will order the results in descending order based on the count of routes using the ORDER BY clause."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC", "source_tables": ["airports", "routes"], "pred_sql": "SELECT src_ap, COUNT(*) AS route_count FROM routes GROUP BY src_ap ORDER BY route_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6867", "db_id": "flight_4", "question": "For each country and airline name, how many routes are there?", "rationale": ["We need to count the number of routes for each country and airline name.", "To achieve this, we will join the 'routes' table with the 'airports' table to get the country information and with the 'airlines' table to get the airline names.", "The join condition will be based on the foreign keys: routes.dst_apid with airports.apid and routes.alid with airlines.alid.", "We will use the COUNT function to count the number of routes for each combination of country and airline name.", "Finally, we will group the results by country and airline name to get the desired counts."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT T2.country, T3.name, count(*) as route_count FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid = T2.apid JOIN airlines AS T3 ON T1.alid = T3.alid GROUP BY T2.country, T3.name", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6868", "db_id": "flight_4", "question": "What is the total number of routes for each country and airline in that country?", "rationale": ["We need to count the total number of routes for each country and airline.", "To do this, we will join the 'routes' table with the 'airports' table to get the country information and with the 'airlines' table to get the airline information.", "The join condition will be based on the foreign keys: 'dst_apid' from 'routes' to 'apid' in 'airports' and 'alid' from 'routes' to 'alid' in 'airlines'.", "After joining the tables, we will group the results by country and airline name to get the count of routes for each combination.", "Finally, we will select the country, airline name, and the count of routes as total_routes."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT T2.country, T3.name, COUNT(*) AS total_routes FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid = T2.apid JOIN airlines AS T3 ON T1.alid = T3.alid GROUP BY T2.country, T3.name", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6873", "db_id": "flight_4", "question": "Find the number of routes that have destination John F Kennedy International Airport.", "rationale": ["Identify the relevant tables: 'routes' for the routes and 'airports' for the airport details.", "We need to count the number of routes that have a specific destination airport, which is 'John F Kennedy International Airport'.", "Join the 'routes' table with the 'airports' table on the destination airport ID (dst_apid).", "Filter the results to only include rows where the airport name matches 'John F Kennedy International Airport'.", "Use the COUNT function to get the total number of matching routes."], "gold_sql": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'", "source_tables": ["airports", "routes"], "pred_sql": "SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid = T2.apid WHERE T2.name = 'John F Kennedy International Airport'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6880", "db_id": "flight_4", "question": "What is the name of the airline with the most routes?", "rationale": ["We need to find the airline with the most routes, which means we need to count the number of routes for each airline.", "To do this, we will join the 'routes' table with the 'airlines' table on the airline ID (alid).", "We will group the results by the airline name to get the count of routes for each airline.", "Next, we will order the results in descending order based on the count of routes to get the airline with the most routes at the top.", "Finally, we will limit the results to just one entry to get the airline with the highest count."], "gold_sql": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT T3.name, COUNT(*) as route_count FROM routes AS T1 JOIN airlines AS T3 ON T1.alid = T3.alid GROUP BY T3.name ORDER BY route_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6883", "db_id": "flight_4", "question": "Find the busiest destination airport that runs most number of routes in China.", "rationale": ["Identify the relevant tables: routes, airports, and airlines.", "We need to count the number of routes leading to airports in China, so we will join the routes table with the airports table on the destination airport ID.", "We will filter the results to only include airports in China by using a WHERE clause on the country column of the airports table.", "To find the busiest destination airport, we will group the results by the airport name and count the number of routes for each airport.", "Finally, we will order the results in descending order based on the count of routes and limit the output to the top result."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT T2.name, COUNT(*) as route_count \nFROM routes AS T1 \nJOIN airports AS T2 ON T1.dst_apid = T2.apid \nWHERE T2.country = 'China' \nGROUP BY T2.name \nORDER BY route_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6884", "db_id": "flight_4", "question": "What is the name of the airport that is the destination of the most number of routes that start in China?", "rationale": ["Identify the relevant tables: routes and airports.", "We need to find the destination airport (dst_ap) for routes that start in China.", "Join the routes table with the airports table on the destination airport ID (dst_apid).", "Filter the results to include only those routes where the source airport is in China.", "Group the results by the destination airport name to count the number of routes to each airport.", "Order the results by the count of routes in descending order to find the airport with the most routes.", "Limit the results to 1 to get the top destination airport."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT dst_ap, COUNT(*) as route_count \nFROM routes AS r \nJOIN airports AS a ON r.dst_apid = a.apid \nWHERE a.country = 'China' \nGROUP BY dst_ap \nORDER BY route_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of routes that lead to airports located in a specific country and are operated by a particular airline. The placeholders in the WHERE clause represent the country and airline name respectively.\",\n        \"virtual_table\": \"SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  [PLACEHOLDER-TYPE:STRING] AND T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6980", "db_id": "culture_company", "question": "Show all publishers which do not have a book in 1989.", "rationale": ["Identify the requirement to find publishers without a book in 1989.", "Use the book_club table to filter out entries for the year 1989.", "Select distinct publishers from the book_club table where the year is not 1989 or where the publisher does not appear in the list of publishers for the year 1989."], "gold_sql": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  1989", "source_tables": ["book_club"], "pred_sql": "SELECT DISTINCT Publisher FROM book_club WHERE Year != '1989' OR Publisher NOT IN (SELECT DISTINCT Publisher FROM book_club WHERE Year = '1989')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of cultural companies associated with book clubs that have a specific publisher. The placeholder in the WHERE clause represents the name of the publisher.\",\n        \"virtual_table\": \"SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6990", "db_id": "culture_company", "question": "Show all director names who have a movie in the year 1999 or 2000.", "rationale": ["Identify the table that contains the information about movies, which is the 'movie' table.", "Determine the relevant column that contains the director's names, which is 'Director'.", "Identify the column that contains the year of the movie release, which is 'Year'.", "Use the SQL 'SELECT' statement to retrieve distinct director names from the 'movie' table.", "Apply a 'WHERE' clause to filter the results for the years 1999 and 2000 using the 'IN' operator."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6991", "db_id": "culture_company", "question": "Which directors had a movie in either 1999 or 2000?", "rationale": ["Identify the relevant table: The question pertains to directors and movies, so we will focus on the 'movie' table.", "Determine the columns needed: We need the 'Director' column to answer the question.", "Filter the results: We need to find movies released in either 1999 or 2000, so we will use a WHERE clause with the IN operator to specify these years.", "Use DISTINCT to ensure that each director is listed only once, even if they directed multiple movies in those years."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6996", "db_id": "culture_company", "question": "Show the movie titles and book titles for all companies in China.", "rationale": ["Identify the tables needed: culture_company, movie, and book_club.", "Determine the columns to select: movie titles from the movie table and book titles from the book_club table.", "Establish the relationships between the tables using JOINs: culture_company with movie and book_club.", "Filter the results to only include companies based in China using a WHERE clause."], "gold_sql": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  'China'", "source_tables": ["culture_company", "movie", "book_club"], "pred_sql": "SELECT movie.Title, book_club.Book_Title \nFROM culture_company \nJOIN movie ON culture_company.movie_id = movie.movie_id \nJOIN book_club ON culture_company.book_club_id = book_club.book_club_id \nWHERE culture_company.Company_name = 'China';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of cultural companies associated with book clubs that have a specific publisher. The placeholder in the WHERE clause represents the name of the publisher.\",\n        \"virtual_table\": \"SELECT T1.company_name FROM culture_company AS T1 JOIN book_club AS T2 ON T1.book_club_id  =  T2.book_club_id WHERE T2.publisher  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant tables: 'car_names' for car models and 'cars_data' for horsepower.", "Join the 'car_names' table with the 'cars_data' table on the MakeId to access horsepower information.", "Order the results by horsepower in ascending order to find the minimum.", "Limit the results to 1 to get only the model with the minimum horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id ORDER BY T2.Horsepower ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be returned.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.103", "db_id": "car_1", "question": "Which distinct car models are the produced after 1980?", "rationale": ["The question asks for distinct car models produced after 1980.", "To find car models, we need to access the 'car_names' table which contains the model names.", "We also need to filter the results based on the year of production, which is found in the 'cars_data' table.", "We will join the 'car_names' table with the 'cars_data' table on the 'MakeId' and 'Id' columns respectively to get the relevant data.", "Finally, we will use the DISTINCT keyword to ensure that we only get unique car models that meet the criteria."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "pred_sql": "SELECT DISTINCT t1.Model \nFROM car_names AS t1 \nJOIN cars_data AS t2 ON t1.MakeId = t2.Id \nWHERE t2.Year > 1980;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.106", "db_id": "car_1", "question": "What is the name of each continent and how many car makers are there in each one?", "rationale": ["Identify the relevant tables: continents, countries, and car_makers.", "We need to count the number of car makers for each continent, so we will use a JOIN operation to connect these tables based on their relationships.", "The continents table will be joined with the countries table using the ContId and Continent columns.", "Next, the countries table will be joined with the car_makers table using the CountryId and Country columns.", "We will use the COUNT function to count the number of car makers for each continent.", "Finally, we will group the results by continent to get the count for each one."], "gold_sql": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;", "source_tables": ["countries", "car_makers", "continents"], "pred_sql": "SELECT c.Continent, COUNT(cm.Id) AS NumberOfCarMakers\nFROM continents c\nJOIN countries co ON c.ContId = co.Continent\nJOIN car_makers cm ON co.CountryId = cm.Country\nGROUP BY c.Continent;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: 'cars_data' for acceleration data and 'car_names' for car make names.", "Determine the relationship between the tables: 'cars_data' is linked to 'car_names' through the 'Id' and 'MakeId' columns.", "Use a JOIN operation to combine data from 'cars_data' and 'car_names'.", "Filter the results to find the specific car make 'amc hornet sportabout (sw)' using a WHERE clause."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT T1.Accelerate FROM cars_data AS T1 JOIN car_names AS T2 ON T1.Id = T2.MakeId WHERE T2.Make = 'amc hornet sportabout (sw)';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the acceleration times of cars from the 'cars_data' table, filtered by a specific car make from the 'car_names' table. The placeholder in the WHERE clause represents the name of the car make.\",\n        \"virtual_table\": \"SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the tables involved: model_list, car_makers, and countries.", "We need to count the number of car makers in France, so we will use the count function.", "Join the model_list table with the car_makers table on the Maker field.", "Join the car_makers table with the countries table on the Country field.", "Filter the results to only include those where the CountryName is 'France'.", "Construct the SQL query using the above steps."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT count(*) FROM model_list AS T1 JOIN car_makers AS T2 ON T1.Maker = T2.Id JOIN countries AS T3 ON T2.Country = T3.CountryId WHERE T3.CountryName = 'France';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.114", "db_id": "car_1", "question": "What is the number of makers of care in France?", "rationale": ["Identify the tables involved: model_list, car_makers, and countries.", "We need to count the number of car makers in France, which means we need to filter the countries table for France.", "Join the model_list table with the car_makers table on the Maker ID, and then join the car_makers table with the countries table on the Country ID.", "Use the WHERE clause to specify that we are only interested in records where the country name is 'France'.", "Finally, use the COUNT function to get the total number of unique car makers associated with France."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT count(*) FROM model_list AS T1 JOIN car_makers AS T2 ON T1.Maker = T2.Id JOIN countries AS T3 ON T2.Country = T3.CountryId WHERE T3.CountryName = 'France';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.115", "db_id": "car_1", "question": "How many car models are produced in the usa?", "rationale": ["Identify the tables involved: model_list, car_makers, and countries.", "We need to count the number of car models, so we will use the COUNT function.", "To find car models produced in the USA, we need to join the model_list with car_makers and then with countries to filter by the country name 'usa'.", "The virtual table provided gives a template for counting car models associated with a specific country, which we will adapt for 'usa'.", "Construct the SQL query using the provided virtual table structure, replacing the placeholder with 'usa'."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "pred_sql": "SELECT count(*) FROM model_list AS T1 JOIN car_makers AS T2 ON T1.Maker = T2.Id JOIN countries AS T3 ON T2.Country = T3.CountryId WHERE T3.CountryName = 'usa';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the continent of interest, which is Europe.", "Use the CONTINENTS table to get the ContId for Europe.", "Join the COUNTRIES table with the CAR_MAKERS table to link countries to their car manufacturers.", "Group the results by country name to count the number of distinct car manufacturers for each country.", "Use the HAVING clause to filter countries that have at least 3 car manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT T3.CountryName\nFROM COUNTRIES AS T3\nWHERE T3.Continent = (SELECT ContId FROM CONTINENTS WHERE Continent = 'Europe')\nGROUP BY T3.CountryName\nHAVING COUNT(DISTINCT T2.Id) >= 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the tables involved: We need data from 'car_names', 'cars_data', 'model_list', 'car_makers', and 'countries'.", "We want to find the maximum horsepower and the make of car models with 3 cylinders.", "Join the 'car_names' table with 'cars_data' to access horsepower and cylinder information.", "Join 'model_list' to link car models to their makers.", "Join 'car_makers' to get the country information, if needed, but primarily to get the make of the car.", "Use the WHERE clause to filter for cars with 3 cylinders.", "Use the MAX function to get the maximum horsepower and select the make of the car models."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(T2.Horsepower) AS MaxHorsepower, T1.Make \nFROM car_names AS T1 \nJOIN model_list AS T3 ON T1.Model = T3.Model \nJOIN car_makers AS T4 ON T3.Maker = T4.Id \nJOIN countries AS T5 ON T4.Country = T5.CountryId \nJOIN cars_data AS T2 ON T1.MakeId = T2.Id \nWHERE T2.Cylinders = 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be returned.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.133", "db_id": "car_1", "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.", "rationale": ["Identify the relevant tables: 'car_names' for car models and 'cars_data' for MPG.", "Join the 'car_names' table with the 'cars_data' table on the MakeId and Id columns respectively to access the MPG data for each model.", "Order the results by the MPG in descending order to get the models with the highest fuel efficiency at the top.", "Limit the results to 1 to get only the model that saves the most gasoline."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "select t1.Model from car_names as t1 join cars_data as t2 on t1.MakeId = t2.Id order by t2.MPG desc limit 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["Identify the relevant tables: We need to look at the 'model_list' table for car models and the 'car_makers' table for car makers.", "Join the 'model_list' table with the 'car_makers' table on the Maker ID to get the names and IDs of the makers.", "Group the results by the Maker to count the number of models associated with each maker.", "Use the HAVING clause to filter the groups to only include those with more than 3 models."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "SELECT ml.Maker, cm.Id\nFROM model_list ml\nJOIN car_makers cm ON ml.Maker = cm.Id\nGROUP BY ml.Maker\nHAVING COUNT(ml.Model) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.158", "db_id": "car_1", "question": "For a volvo model, how many cylinders does the version with least accelerate have?", "rationale": ["Identify the relevant tables: 'cars_data', 'car_names', 'model_list', and 'car_makers' are needed to find the number of cylinders for Volvo models.", "Join the 'cars_data' table with 'car_names' on 'MakeId' to get the car models.", "Join the 'car_names' table with 'model_list' on 'Model' to link car models to their makers.", "Join the 'model_list' table with 'car_makers' on 'Maker' to filter for Volvo.", "Use a WHERE clause to specify that we are only interested in models made by Volvo.", "Order the results by the 'Accelerate' column in ascending order to find the version with the least acceleration.", "Limit the results to 1 to get only the top result, which will be the model with the least acceleration."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT c.Cylinders\nFROM cars_data AS c\nJOIN car_names AS n ON c.Id = n.MakeId\nJOIN model_list AS m ON n.Model = m.Model\nJOIN car_makers AS mk ON m.Maker = mk.Id\nWHERE mk.Maker = 'Volvo'\nORDER BY c.Accelerate ASC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n        \"virtual_table\": \"select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.160", "db_id": "car_1", "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?", "rationale": ["Identify the maximum horsepower from the cars_data table.", "Find the car with the maximum horsepower and get its accelerate value.", "Count the number of cars in the cars_data table that have an accelerate value greater than the one found in the previous step."], "gold_sql": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "source_tables": ["cars_data"], "pred_sql": "SELECT COUNT(*) FROM cars_data WHERE Accelerate > (SELECT MAX(Accelerate) FROM cars_data WHERE Horsepower = (SELECT MAX(Horsepower) FROM cars_data));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be returned.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables: 'car_names' for car models and 'cars_data' for car specifications.", "Join the 'car_names' table with the 'cars_data' table on the 'MakeId' to access horsepower and cylinder information.", "Filter the results to include only cars with 4 cylinders using a WHERE clause.", "Order the results by horsepower in descending order to get the model with the largest horsepower at the top.", "Limit the results to 1 to get only the top model with the largest horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id WHERE T2.Cylinders = 4 ORDER BY T2.Horsepower DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be returned.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.166", "db_id": "car_1", "question": "For all of the 4 cylinder cars, which model has the most horsepower?", "rationale": ["Identify the relevant tables: 'car_names' for car models and 'cars_data' for car specifications.", "Join the 'car_names' table with the 'cars_data' table on the 'MakeId' and 'Id' columns to access horsepower and cylinder information.", "Filter the results to include only cars with 4 cylinders using a WHERE clause.", "Order the results by horsepower in descending order to get the model with the highest horsepower at the top.", "Limit the results to 1 to get only the top model."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT T1.Model FROM car_names AS T1 JOIN cars_data AS T2 ON T1.MakeId = T2.Id WHERE T2.Cylinders = 4 ORDER BY T2.Horsepower DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be returned.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.168", "db_id": "car_1", "question": "Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?", "rationale": ["Identify the relevant tables: car_names and cars_data are needed to get the make ids and names of the cars.", "Join the car_names table with the cars_data table on the MakeId to access the horsepower and cylinder information.", "Filter the results to include only those cars with less than 4 cylinders.", "To find cars that do not have the minimum horsepower, we need to compare each car's horsepower against the minimum horsepower from the cars_data table.", "Use a subquery to find the minimum horsepower from the cars_data table and filter out cars that have horsepower less than this value."], "gold_sql": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  4;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT cn.MakeId, cn.Model \nFROM car_names AS cn \nJOIN cars_data AS cd ON cn.MakeId = cd.Id \nWHERE cd.Cylinders < 4 \nAND cd.Horsepower > (SELECT MIN(cd2.Horsepower) \n                     FROM cars_data AS cd2);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be returned.\",\n        \"virtual_table\": \"SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["Identify the relevant tables: car_makers, model_list, car_names, and cars_data.", "We need to find car makers that produce at least 2 models, so we will join car_makers with model_list on the Maker ID.", "Next, we need to ensure that these makers have produced more than 3 cars, so we will join with car_names and cars_data.", "We will group the results by car maker ID and name to aggregate the counts of models and cars produced.", "Use the HAVING clause to filter for car makers that have at least 2 distinct models and more than 3 cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker \nFROM car_makers cm \nJOIN model_list ml ON cm.Id = ml.Maker \nJOIN car_names cn ON ml.Model = cn.Model \nJOIN cars_data cd ON cn.MakeId = cd.Id \nGROUP BY cm.Id, cm.Maker \nHAVING COUNT(DISTINCT ml.Model) >= 2 AND COUNT(cd.Id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.\",\n        \"virtual_table\": \"SELECT Maker ,  Model FROM MODEL_LIST;\"\n    }\n}\n"}
{"sample_id": "dev.180", "db_id": "flight_2", "question": "What country is Jetblue Airways affiliated with?", "rationale": ["Identify the relevant table: The question asks about the country affiliated with Jetblue Airways, which is found in the 'airlines' table.", "Determine the necessary column: We need the 'Country' column from the 'airlines' table.", "Formulate the SQL query: We will select the 'Country' from the 'airlines' table where the 'Airline' is 'Jetblue Airways'."], "gold_sql": "SELECT Country FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "pred_sql": "SELECT Country FROM airlines WHERE Airline = 'Jetblue Airways'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the abbreviation of a specific airline from the 'airlines' table based on the airline's name. The placeholder in the WHERE clause represents the name of the airline.\",\n        \"virtual_table\": \"SELECT Abbreviation FROM AIRLINES WHERE Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.194", "db_id": "flight_2", "question": "Give the airline with abbreviation 'UAL'.", "rationale": ["Identify the relevant table: The query requires information about airlines, so we will use the 'airlines' table.", "Determine the specific column needed: We need the 'Abbreviation' of the airline.", "Formulate the SQL query: Based on the hint provided, we will select the 'Abbreviation' from the 'airlines' table where the 'Airline' matches 'UAL'."], "gold_sql": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  'UAL'", "source_tables": ["airlines"], "pred_sql": "SELECT Abbreviation FROM airlines WHERE Airline = 'UAL'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the abbreviation of a specific airline from the 'airlines' table based on the airline's name. The placeholder in the WHERE clause represents the name of the airline.\",\n        \"virtual_table\": \"SELECT Abbreviation FROM AIRLINES WHERE Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.214", "db_id": "flight_2", "question": "Give the number of Jetblue Airways flights.", "rationale": ["Identify the relevant tables: 'flights' for flight information and 'airlines' for airline details.", "We need to count the number of flights for 'Jetblue Airways'.", "Use a JOIN to connect the 'flights' table with the 'airlines' table based on the airline's unique identifier (uid).", "Filter the results to only include flights where the airline name matches 'Jetblue Airways'.", "Use the COUNT() function to get the total number of flights for the specified airline."], "gold_sql": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = 'JetBlue Airways'", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT COUNT(T1.FlightNo) FROM flights AS T1 JOIN airlines AS T2 ON T2.uid = T1.Airline WHERE T2.Airline = 'Jetblue Airways'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the unique flight numbers from the 'flights' table for a specific airline. The placeholder in the WHERE clause represents the name of the airline being queried.\",\n        \"virtual_table\": \"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.225", "db_id": "flight_2", "question": "What is the code of airport that has the highest number of flights?", "rationale": ["We need to find the airport code with the highest number of flights.", "To do this, we will count the number of flights for each source airport in the 'flights' table.", "We will use the COUNT() function to count the flights grouped by the SourceAirport.", "Next, we will order the results in descending order based on the count of flights.", "Finally, we will limit the results to only the top entry to get the airport code with the highest number of flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT SourceAirport, COUNT(*) as FlightCount FROM flights GROUP BY SourceAirport ORDER BY FlightCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the unique flight numbers from the 'flights' table for a specific airline. The placeholder in the WHERE clause represents the name of the airline being queried.\",\n        \"virtual_table\": \"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.227", "db_id": "flight_2", "question": "What is the code of airport that has fewest number of flights?", "rationale": ["Identify the relevant table: The 'flights' table contains information about flights, including the source airport.", "We need to find the airport code with the fewest number of flights, so we will group the results by the 'SourceAirport' column.", "Count the number of flights for each source airport using COUNT(*).", "Order the results in ascending order based on the count of flights to find the airport with the fewest flights.", "Limit the results to 1 to get only the airport code with the fewest flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT SourceAirport AS AirportCode\nFROM flights\nGROUP BY SourceAirport\nORDER BY COUNT(*) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.229", "db_id": "flight_2", "question": "Which airline has most number of flights?", "rationale": ["Identify the tables involved: 'flights' for flight information and 'airlines' for airline details.", "We need to count the number of flights for each airline, so we will use the COUNT() function on the FlightNo column from the flights table.", "To associate each flight with its corresponding airline, we will join the flights table with the airlines table on the airline name.", "We will group the results by airline name to get the count of flights per airline.", "To find the airline with the most flights, we will order the results in descending order based on the flight count.", "Finally, we will limit the results to 1 to get only the airline with the highest number of flights."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT T2.Airline, COUNT(T1.FlightNo) AS FlightCount \nFROM flights AS T1 \nJOIN airlines AS T2 ON T2.Airline = T1.Airline \nGROUP BY T2.Airline \nORDER BY FlightCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the unique flight numbers from the 'flights' table for a specific airline. The placeholder in the WHERE clause represents the name of the airline being queried.\",\n        \"virtual_table\": \"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.232", "db_id": "flight_2", "question": "What is the abbreviation of the airilne has the fewest flights and what country is it in?", "rationale": ["Identify the airline with the fewest flights by counting the number of flights for each airline in the 'flights' table.", "Use a subquery to group the flights by airline and count them, ordering the results in ascending order to find the airline with the least number of flights.", "Limit the results of the subquery to 1 to get only the airline with the fewest flights.", "Join the result of the subquery with the 'airlines' table to get the abbreviation and country of that airline."], "gold_sql": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT a.Abbreviation, a.Country \nFROM airlines a \nJOIN (\n    SELECT Airline, COUNT(*) as FlightCount \n    FROM flights \n    GROUP BY Airline \n    ORDER BY FlightCount ASC \n    LIMIT 1\n) f ON a.Airline = f.Airline;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the abbreviation of a specific airline from the 'airlines' table based on the airline's name. The placeholder in the WHERE clause represents the name of the airline.\",\n        \"virtual_table\": \"SELECT Abbreviation FROM AIRLINES WHERE Airline  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.244", "db_id": "flight_2", "question": "Which airlines have less than 200 flights?", "rationale": ["We need to find airlines with less than 200 flights.", "First, we will count the number of flights for each airline using the COUNT function and GROUP BY clause.", "We will use HAVING to filter the results to only include airlines with a flight count of less than 200.", "Next, we will join this result with the airlines table to get the names of the airlines.", "Finally, we will select the Airline names from the joined result."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT T2.Airline FROM (SELECT Airline, COUNT(*) AS FlightCount FROM flights GROUP BY Airline HAVING COUNT(*) < 200) AS T1 JOIN airlines AS T2 ON T1.Airline = T2.uid;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of flights operated by a specific airline from the 'flights' table. It joins the 'flights' table with the 'airlines' table to filter the results based on the airline's name. The placeholder in the WHERE clause represents the name of the airline.\",\n        \"virtual_table\": \"SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.258", "db_id": "flight_2", "question": "Which airports do not have departing or arriving flights?", "rationale": ["Identify the airports from the 'airports' table.", "Use LEFT JOIN to connect the 'airports' table with the 'flights' table twice: once for departing flights (SourceAirport) and once for arriving flights (DestAirport).", "In the WHERE clause, check for NULL values in both joined tables to find airports that do not have any flights departing or arriving."], "gold_sql": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)", "source_tables": ["airports", "flights"], "pred_sql": "SELECT a.AirportCode, a.AirportName \nFROM airports a \nLEFT JOIN flights f1 ON a.AirportCode = f1.SourceAirport \nLEFT JOIN flights f2 ON a.AirportCode = f2.DestAirport \nWHERE f1.FlightNo IS NULL AND f2.FlightNo IS NULL;", "hint": "\n"}
{"sample_id": "dev.308", "db_id": "cre_Doc_Template_Mgt", "question": "Count the number of documents that use the PPT template type.", "rationale": ["Identify the relevant tables: We need to count documents, so we will use the 'Documents' table.", "We need to filter documents based on the template type, which is found in the 'Templates' table.", "Join the 'Documents' table with the 'Templates' table on the 'Template_ID' to access the template type code.", "Use a WHERE clause to filter for the specific template type code 'PPT'.", "Count the distinct Document_IDs to get the total number of documents that use the PPT template type."], "gold_sql": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'", "source_tables": ["templates", "documents"], "pred_sql": "SELECT COUNT(DISTINCT D.Document_ID) AS Document_Count\nFROM Documents D\nJOIN Templates T ON D.Template_ID = T.Template_ID\nWHERE T.Template_Type_Code = 'PPT';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique template type codes from the 'Templates' table that are not associated with any documents in the 'Documents' table. The query uses an EXCEPT clause to filter out template types that have been linked to documents, ensuring that only those template types without any corresponding documents are returned.\",\n        \"virtual_table\": \"SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id\"\n    }\n}\n"}
{"sample_id": "dev.311", "db_id": "cre_Doc_Template_Mgt", "question": "What is the id and type code for the template used by the most documents?", "rationale": ["Identify the relevant tables: Templates and Documents.", "We need to find the template that is used by the most documents, so we will join the Templates table with the Documents table on the Template_ID.", "We will group the results by Template_ID and Template_Type_Code to count how many documents are associated with each template.", "To find the template used by the most documents, we will order the results by the count of Document_ID in descending order.", "Finally, we will limit the results to 1 to get the template with the highest count."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Templates.Template_ID, Templates.Template_Type_Code \nFROM Templates \nJOIN Documents ON Templates.Template_ID = Documents.Template_ID \nGROUP BY Templates.Template_ID, Templates.Template_Type_Code \nORDER BY COUNT(Documents.Document_ID) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique template type codes from the 'Templates' table that are not associated with any documents in the 'Documents' table. The query uses an EXCEPT clause to filter out template types that have been linked to documents, ensuring that only those template types without any corresponding documents are returned.\",\n        \"virtual_table\": \"SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id\"\n    }\n}\n"}
{"sample_id": "dev.312", "db_id": "cre_Doc_Template_Mgt", "question": "Return the id and type code of the template that is used for the greatest number of documents.", "rationale": ["We need to find the template that is used for the greatest number of documents.", "To do this, we will join the 'Templates' table with the 'Documents' table on the 'Template_ID' column.", "Next, we will group the results by 'Template_ID' and 'Template_Type_Code' to count how many documents are associated with each template.", "We will use the COUNT function to count the number of documents for each template.", "Finally, we will order the results in descending order based on the count of documents and limit the result to 1 to get the template with the greatest number of documents."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Templates.Template_ID, Templates.Template_Type_Code\nFROM Templates\nJOIN Documents ON Templates.Template_ID = Documents.Template_ID\nGROUP BY Templates.Template_ID, Templates.Template_Type_Code\nORDER BY COUNT(Documents.Document_ID) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum version number of templates grouped by their type code from the 'Templates' table. The placeholder in the SELECT clause represents the version number, while the template type code is used to categorize the templates.\",\n        \"virtual_table\": \"SELECT min(Version_Number) ,  template_type_code FROM Templates\"\n    }\n}\n"}
{"sample_id": "dev.341", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template type codes and the number of documents using each type.", "rationale": ["Identify the tables involved: Templates and Documents.", "We need to count the number of documents associated with each template type code.", "Join the Templates table with the Documents table on Template_ID to link templates with their corresponding documents.", "Select the Template_Type_Code from the Templates table and count the Document_ID from the Documents table.", "Group the results by Template_Type_Code to get the count of documents for each template type."], "gold_sql": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code", "source_tables": ["templates", "documents"], "pred_sql": "SELECT T.Template_Type_Code, COUNT(D.Document_ID) AS Document_Count\nFROM Templates T\nJOIN Documents D ON T.Template_ID = D.Template_ID\nGROUP BY T.Template_Type_Code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique template type codes from the 'Templates' table that are not associated with any documents in the 'Documents' table. The query uses an EXCEPT clause to filter out template types that have been linked to documents, ensuring that only those template types without any corresponding documents are returned.\",\n        \"virtual_table\": \"SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id\"\n    }\n}\n"}
{"sample_id": "dev.346", "db_id": "cre_Doc_Template_Mgt", "question": "What are the codes of template types that are not used for any document?", "rationale": ["Identify the unique template type codes from the 'Ref_Template_Types' table.", "Use the EXCEPT clause to filter out template types that have been linked to documents.", "The inner query selects Template_IDs from the 'Documents' table to find which template types are associated with documents.", "The final query returns only those template type codes that are not associated with any documents."], "gold_sql": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Template_Type_Code FROM Ref_Template_Types EXCEPT SELECT Template_Type_Code FROM Templates WHERE Template_ID IN (SELECT Template_ID FROM Documents)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique template type codes from the 'Templates' table that are not associated with any documents in the 'Documents' table. The query uses an EXCEPT clause to filter out template types that have been linked to documents, ensuring that only those template types without any corresponding documents are returned.\",\n        \"virtual_table\": \"SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id\"\n    }\n}\n"}
{"sample_id": "dev.361", "db_id": "cre_Doc_Template_Mgt", "question": "Show paragraph details for paragraph with text 'Korea ' .", "rationale": ["Identify the table to query: The question asks for paragraph details, which are stored in the 'Paragraphs' table.", "Determine the condition: The user wants paragraphs that contain the text 'Korea'.", "Use the LIKE operator: To find paragraphs containing 'Korea', we will use the LIKE operator with wildcards to match any text that includes 'Korea'.", "Construct the SQL query: Combine the table name, selected columns (all columns in this case), and the WHERE clause to filter the results based on the specified text."], "gold_sql": "select other_details from paragraphs where paragraph_text like 'korea'", "source_tables": ["paragraphs"], "pred_sql": "SELECT * FROM Paragraphs WHERE Paragraph_Text LIKE '%Korea%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves additional details from the 'Paragraphs' table for paragraphs that contain specific text. The placeholder in the WHERE clause represents the text pattern to search for within the paragraph content.\",\n        \"virtual_table\": \"select other_details from paragraphs where paragraph_text like [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.367", "db_id": "cre_Doc_Template_Mgt", "question": "Show all document ids and the number of paragraphs in each document. Order by document id.", "rationale": ["We need to retrieve all document IDs and the count of paragraphs associated with each document.", "To achieve this, we will use a SQL SELECT statement to select the Document_ID from the Documents table.", "We will also need to count the number of Paragraphs for each Document_ID, which can be done using the COUNT() function.", "To link the Documents and Paragraphs tables, we will use a LEFT JOIN on the Document_ID field, as this will allow us to include documents that may not have any paragraphs.", "We will group the results by Document_ID to ensure that we get a count of paragraphs for each document.", "Finally, we will order the results by Document_ID to meet the requirement of ordering the output."], "gold_sql": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id", "source_tables": ["paragraphs"], "pred_sql": "SELECT Documents.Document_ID, COUNT(Paragraphs.Paragraph_ID) AS Number_of_Paragraphs\nFROM Documents\nLEFT JOIN Paragraphs ON Documents.Document_ID = Paragraphs.Document_ID\nGROUP BY Documents.Document_ID\nORDER BY Documents.Document_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves additional details from the 'Paragraphs' table for paragraphs that contain specific text. The placeholder in the WHERE clause represents the text pattern to search for within the paragraph content.\",\n        \"virtual_table\": \"select other_details from paragraphs where paragraph_text like [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.439", "db_id": "wta_1", "question": "Find the highest rank of losers in all matches.", "rationale": ["Identify the relevant table: The 'matches' table contains information about the matches, including the rank of the losing players.", "Determine the specific column needed: We need the 'loser_rank' column to find the highest rank of losers.", "Use the MAX() function: To find the highest rank, we can use the SQL aggregate function MAX() on the 'loser_rank' column.", "Construct the SQL query: The query selects the maximum value of 'loser_rank' from the 'matches' table."], "gold_sql": "SELECT min(loser_rank) FROM matches", "source_tables": ["matches"], "pred_sql": "SELECT MAX(loser_rank) AS highest_rank_of_losers\nFROM matches;", "hint": "\n"}
{"sample_id": "dev.458", "db_id": "wta_1", "question": "What are the full names of all left handed players, in order of birth date?", "rationale": ["Identify the relevant table: The 'players' table contains the information about players, including their names and handedness.", "Filter for left-handed players: Use a WHERE clause to select only those players whose 'hand' column is 'left'.", "Select full names: Concatenate 'first_name' and 'last_name' to create a 'full_name' column in the output.", "Order by birth date: Use an ORDER BY clause to sort the results by the 'birth_date' column."], "gold_sql": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date", "source_tables": ["players"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name FROM players WHERE hand = 'left' ORDER BY birth_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of players' first names along with their country codes from the 'players' table, ordered by the number of tours they have participated in as recorded in the 'rankings' table. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.464", "db_id": "wta_1", "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?", "rationale": ["Identify the relevant tables: 'matches' for match results and 'players' for player details.", "We need the winner's name and their rank points, which are in the 'players' table and 'matches' table respectively.", "Join the 'matches' table with the 'players' table on the winner's ID to get the winner's name.", "Group the results by the winner's ID to count the number of matches won by each player.", "Order the results by the count of matches won in descending order to find the player with the most wins.", "Limit the results to 1 to get only the top player."], "gold_sql": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["matches"], "pred_sql": "SELECT winner_name, winner_rank_points FROM matches JOIN players ON matches.winner_id = players.player_id GROUP BY winner_id ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of players' first names along with their country codes from the 'players' table, ordered by the number of tours they have participated in as recorded in the 'rankings' table. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.471", "db_id": "wta_1", "question": "Find the total ranking points for each player and their first name.", "rationale": ["We need to find the total ranking points for each player and their first name.", "The relevant tables are 'players' for player information and 'rankings' for ranking points.", "We will join the 'players' table with the 'rankings' table on the player_id column to combine player names with their ranking points.", "To get the total ranking points for each player, we will use the SUM function on the ranking_points column from the 'rankings' table.", "We will group the results by the first_name column from the 'players' table to ensure we get the total points for each player individually."], "gold_sql": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name", "source_tables": ["rankings", "players"], "pred_sql": "SELECT T1.first_name, SUM(T2.ranking_points) AS total_ranking_points FROM players AS T1 JOIN rankings AS T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of players' first names along with their country codes from the 'players' table, ordered by the number of tours they have participated in as recorded in the 'rankings' table. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.479", "db_id": "wta_1", "question": "Find the total number of tours for each ranking date.", "rationale": ["We need to find the total number of tours for each ranking date.", "The relevant table for this information is the 'rankings' table, which contains the 'ranking_date' and 'tours' columns.", "To get the total number of tours for each ranking date, we can use the COUNT function on the 'tours' column.", "We will group the results by 'ranking_date' to get the total tours for each date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(tours) AS total_tours FROM rankings GROUP BY ranking_date", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of players' first names along with their country codes from the 'players' table, ordered by the number of tours they have participated in as recorded in the 'rankings' table. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.480", "db_id": "wta_1", "question": "How many total tours were there for each ranking date?", "rationale": ["Identify the relevant table: The 'rankings' table contains the 'ranking_date' and 'tours' columns needed for the query.", "Use the COUNT function to calculate the total number of tours for each ranking date.", "Group the results by 'ranking_date' to get the total tours for each date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(tours) AS total_tours FROM rankings GROUP BY ranking_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of players' first names along with their country codes from the 'players' table, ordered by the number of tours they have participated in as recorded in the 'rankings' table. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.533", "db_id": "student_transcripts_tracking", "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to join the Students table with the Student_Enrolment table to get the students' details along with their enrolment information.", "To find students enrolled in 2 different degree programs in the same semester, we can join the Student_Enrolment table with itself (self-join) on the student_id and ensure that the degree_program_id is different but the semester_id is the same.", "Use GROUP BY to group the results by student_id and use HAVING to filter those groups to only include students who are enrolled in exactly 2 distinct degree programs."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Student_Enrolment se2 ON s.student_id = se2.student_id\nWHERE se.degree_program_id != se2.degree_program_id\nAND se.semester_id = se2.semester_id\nGROUP BY s.student_id\nHAVING COUNT(DISTINCT se.degree_program_id) = 2;", "hint": "\n"}
{"sample_id": "dev.536", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs.", "We need to select the first, middle, and last names of students, which are in the Students table.", "To find out which students are enrolled in a Bachelors program, we need to join the Students table with the Student_Enrolment table on student_id.", "Next, we join the Student_Enrolment table with the Degree_Programs table on degree_program_id to filter for Bachelors programs.", "The condition for the Bachelors program is specified in the WHERE clause using a LIKE statement to match any degree summary name that contains 'Bachelors'."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name \nFROM Students s \nJOIN Student_Enrolment se ON s.student_id = se.student_id \nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id \nWHERE dp.degree_summary_name LIKE '%Bachelors%';", "hint": "\n"}
{"sample_id": "dev.537", "db_id": "student_transcripts_tracking", "question": "Find the kind of program which most number of students are enrolled in?", "rationale": ["Identify the relevant tables: We need to find the degree programs and the number of students enrolled in each program, so we will use the Student_Enrolment and Degree_Programs tables.", "Join the tables: We will join the Student_Enrolment table with the Degree_Programs table on the degree_program_id to associate each enrolment with its corresponding program.", "Count the number of students: We will use the COUNT function to count the number of student enrolment records for each degree program.", "Group the results: We will group the results by the degree program name to get the count of students for each program.", "Order the results: We will order the results in descending order based on the student count to find the program with the most students enrolled.", "Limit the results: Finally, we will limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_summary_name, COUNT(se.student_enrolment_id) AS student_count\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nGROUP BY dp.degree_summary_name\nORDER BY student_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["Identify the relevant tables: Degree_Programs and Student_Enrolment.", "We need to find the degree program with the most students enrolled, so we will join these two tables on the degree_program_id.", "Group the results by degree_program_id and degree_summary_name to count the number of students enrolled in each program.", "Use COUNT(se.student_id) to count the number of students for each program.", "Order the results in descending order based on the count of students to get the program with the most enrollments at the top.", "Limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_program_id, dp.degree_summary_name\nFROM Degree_Programs dp\nJOIN Student_Enrolment se ON dp.degree_program_id = se.degree_program_id\nGROUP BY dp.degree_program_id, dp.degree_summary_name\nORDER BY COUNT(se.student_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to count the number of enrollments for each student, so we will join the Students table with the Student_Enrolment table on the student_id.", "Use COUNT() to count the number of enrollments for each student.", "Group the results by student_id to aggregate the counts for each student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Limit the results to 1 to get only the student with the highest number of enrollments."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name, COUNT(se.student_enrolment_id) AS number_of_enrollments\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id\nORDER BY number_of_enrollments DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["Identify the table that contains course information, which is the 'Courses' table.", "Identify the table that tracks student enrollments in courses, which is the 'Student_Enrolment_Courses' table.", "Join the 'Courses' table with the 'Student_Enrolment_Courses' table on the course_id to link courses with their enrollments.", "Group the results by course_id to aggregate the number of enrollments for each course.", "Count the number of enrollments for each course using COUNT(SEC.student_course_id).", "Order the results in descending order based on the count of enrollments to find the course with the most enrollments.", "Limit the results to 1 to get only the course with the highest number of enrollments."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT C.course_name\nFROM Courses C\nJOIN Student_Enrolment_Courses SEC ON C.course_id = SEC.course_id\nGROUP BY C.course_id\nORDER BY COUNT(SEC.student_course_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant table: Students, which contains the last names of students and their address information.", "Identify the Addresses table to filter students based on their state of residence (North Carolina).", "Use a subquery to find all address_ids in the Addresses table where state_province_county is 'North Carolina'.", "Use another subquery to find all student_ids in the Student_Enrolment table to identify students who have registered in any degree programs.", "Combine these conditions in the main query to select last names of students who live in North Carolina and are not in the list of registered students."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "SELECT last_name \nFROM Students \nWHERE current_address_id IN (\n    SELECT address_id \n    FROM Addresses \n    WHERE state_province_county = 'North Carolina'\n) \nAND student_id NOT IN (\n    SELECT student_id \n    FROM Student_Enrolment\n);", "hint": "\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table: The question asks for the mobile phone number of a student, which is found in the 'Students' table.", "Determine the columns needed: We need the 'cell_mobile_number' column to get the mobile phone number.", "Filter the results: We need to filter the records to find the student named 'Timmothy Ward'. This requires checking both the 'first_name' and 'last_name' columns.", "Construct the SQL query: Using the SELECT statement to retrieve the 'cell_mobile_number' from the 'Students' table where the first name is 'Timmothy' and the last name is 'Ward'."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';", "hint": "\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["We need to find the address that holds the most number of students currently.", "To do this, we will count the number of distinct students associated with each current address in the 'Students' table.", "We will group the results by 'current_address_id' and order them in descending order based on the count of students.", "We will limit the results to only the top address with the highest count of students.", "Next, we will join this result with the 'Addresses' table to get the full address details (address_id and all lines).", "Finally, we will select the address_id and all address lines from the 'Addresses' table for the address with the most students."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT a.address_id, a.line_1, a.line_2, a.line_3\nFROM Addresses a\nJOIN (SELECT current_address_id, COUNT(DISTINCT student_id) AS student_count\n      FROM Students\n      GROUP BY current_address_id\n      ORDER BY student_count DESC\n      LIMIT 1) AS address_counts\nON a.address_id = address_counts.current_address_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of distinct current addresses associated with students from the 'Students' table. The placeholder in the SELECT clause represents the unique current address identifiers.\",\n        \"virtual_table\": \"SELECT count(DISTINCT current_address_id) FROM Students\"\n    }\n}\n"}
{"sample_id": "dev.576", "db_id": "student_transcripts_tracking", "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?", "rationale": ["Identify the relevant tables: Student_Enrolment and Degree_Programs.", "We need to find semesters that had both Masters and Bachelors students enrolled.", "Join the Student_Enrolment table with the Degree_Programs table on the degree_program_id.", "Filter the results to include only those degree programs that are either 'Masters' or 'Bachelors'.", "Group the results by semester_id to aggregate the data for each semester.", "Use HAVING clause to ensure that both degree types (Masters and Bachelors) are present in the results for each semester."], "gold_sql": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT DISTINCT se.semester_id\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nWHERE dp.degree_summary_name IN ('Masters', 'Bachelors')\nGROUP BY se.semester_id\nHAVING COUNT(DISTINCT dp.degree_summary_name) = 2;", "hint": "\n"}
{"sample_id": "dev.580", "db_id": "student_transcripts_tracking", "question": "What other details can you tell me about students in reverse alphabetical order?", "rationale": ["The user is asking for additional details about students.", "The relevant table for student details is the 'Students' table.", "The specific column that contains additional details is 'other_student_details'.", "To fulfill the request, we need to select 'other_student_details' from the 'Students' table.", "The results should be sorted in reverse alphabetical order, which can be achieved using 'ORDER BY other_student_details DESC'."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "pred_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of additional details related to students from the 'Students' table, sorted in descending order. The placeholder in the SELECT clause represents the specific details of the students.\",\n        \"virtual_table\": \"SELECT other_student_details FROM Students ORDER BY other_student_details DESC\"\n    }\n}\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve information about a section, we need to select all columns from the Sections table.", "We will use a WHERE clause to filter the results to only include the section where the section_name is 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT * FROM Sections WHERE section_name = 'h';", "hint": "\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries and their government forms.", "Determine the specific information needed: We need to count the number of countries with a government form of 'Republic'.", "Use the provided hint to construct the SQL query: The hint suggests using a count function with a WHERE clause to filter by the government form.", "Replace the placeholder in the hint with 'Republic' to complete the SQL query."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT count(*) FROM country WHERE GovernmentForm = 'Republic'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.730", "db_id": "world_1", "question": "What is the average GNP and total population in all nations whose government is US territory?", "rationale": ["Identify the required data: average GNP and total population of countries with a specific government form.", "Determine the relevant table: the 'country' table contains the GNP and population data.", "Use the aggregate functions 'avg()' for average GNP and 'sum()' for total population.", "Filter the results using a WHERE clause to specify the government form as 'US territory'.", "Construct the SQL query to select the average GNP and total population from the 'country' table with the specified condition."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT avg(GNP) AS AverageGNP, sum(Population) AS TotalPopulation FROM country WHERE GovernmentForm = 'US territory'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.734", "db_id": "world_1", "question": "How many type of governments are in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and regions.", "Determine the specific region of interest: The question asks about Africa, so we will filter the results to only include countries in Africa.", "Count the distinct types of governments: We need to find out how many different types of governments exist in the African countries, which can be done using the DISTINCT keyword on the GovernmentForm column."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Region = 'Africa'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their forms of government and regions.", "Determine the specific requirement: We need to count the distinct forms of government in Africa.", "Use the COUNT function to count distinct values: We will use COUNT(DISTINCT GovernmentForm) to get the number of different forms of government.", "Filter the results to only include African countries: We will add a WHERE clause to filter the countries by the 'Region' column, specifically for 'Africa'."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(DISTINCT GovernmentForm) FROM country WHERE Region = 'Africa';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.742", "db_id": "world_1", "question": "Which continent has the most diverse languages?", "rationale": ["Identify the need to find the continent with the most diverse languages.", "To achieve this, we need to count the distinct languages spoken in each continent.", "We will join the 'country' table with the 'countrylanguage' table on the country code.", "We will group the results by continent and count the distinct languages for each continent.", "Finally, we will order the results in descending order based on the count of distinct languages and limit the result to the top entry."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT continent, COUNT(DISTINCT Language) AS language_count \nFROM country \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nGROUP BY continent \nORDER BY language_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.743", "db_id": "world_1", "question": "Which continent speaks the most languages?", "rationale": ["Identify the tables involved: We need to use the 'country' and 'countrylanguage' tables to find out which continent speaks the most languages.", "Join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' columns to get the languages spoken in each country.", "Group the results by 'Continent' to count the distinct languages spoken in each continent.", "Use COUNT(DISTINCT cl.Language) to count the number of unique languages for each continent.", "Order the results in descending order based on the count of languages to find the continent with the most languages.", "Limit the results to 1 to get only the continent that speaks the most languages."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT continent, COUNT(DISTINCT cl.Language) AS language_count \nFROM country c \nJOIN countrylanguage cl ON c.Code = cl.CountryCode \nGROUP BY continent \nORDER BY language_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.746", "db_id": "world_1", "question": "What are the names of nations speak both English and French?", "rationale": ["Identify the requirement: We need to find the names of nations that speak both English and French.", "Understand the schema: We have a 'country' table and a 'countrylanguage' table that links countries to their languages.", "Use the provided hint: The hint suggests using an INTERSECT query to find countries that speak both languages.", "Construct the first part of the query to select countries that speak English.", "Construct the second part of the query to select countries that speak French.", "Combine both parts using INTERSECT to get the countries that speak both languages.", "Select the 'Name' of the countries from the result of the INTERSECT operation."], "gold_sql": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'French'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'French'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["Identify the tables involved: We need to use the 'country' table to get country names and the 'countrylanguage' table to filter by languages.", "Determine the condition: We are looking for countries where either English or Dutch is an official language.", "Use a JOIN operation: We will join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' fields respectively.", "Filter the results: We will filter the results to include only those rows where the 'Language' is either 'English' or 'Dutch' and 'IsOfficial' is 'T' (true).", "Select the distinct country names: We will select the distinct names of the countries that meet the criteria."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language IN ('English', 'Dutch') AND T2.IsOfficial = 'T';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the requirement: We need to find the total population of countries that do not use English as a language.", "To achieve this, we will first identify the countries that do use English by querying the countrylanguage table.", "We will select the CountryCode from the countrylanguage table where the Language is 'English'.", "Next, we will use this list of CountryCodes to filter out these countries from the country table.", "Finally, we will sum the Population of the remaining countries that do not use English."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(Population) FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.767", "db_id": "world_1", "question": "How many people live in countries that do not speak English?", "rationale": ["Identify the requirement: We need to find the total population of countries that do not speak English.", "To achieve this, we will first identify the countries that do not have English as an official language.", "We can do this by selecting the CountryCode from the countrylanguage table where the Language is 'English'.", "Next, we will use this list of CountryCodes to filter the country table to find countries that are not in this list.", "Finally, we will sum the Population of these countries to get the total number of people living in countries that do not speak English."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(Population) FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.783", "db_id": "world_1", "question": "Return the codes of countries that do not speak English and do not have Republics for governments.", "rationale": ["Identify the countries that do not speak English by checking the countrylanguage table for entries where Language is 'English'.", "Use a subquery to select the CountryCode of countries that have English as an official language.", "Filter the main country table to exclude these CountryCodes using NOT IN.", "Additionally, filter the countries based on their GovernmentForm to exclude any that contain 'Republic' in their name.", "Combine these conditions in the WHERE clause of the main query to get the desired result."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English') AND GovernmentForm NOT LIKE '%Republic%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.784", "db_id": "world_1", "question": "Which cities are in European countries where English is not the official language?", "rationale": ["Identify the relevant tables: city, country, and countrylanguage.", "We need to find cities, so we will select from the city table.", "We need to join the city table with the country table to filter by continent (Europe).", "We also need to join the countrylanguage table to check the language spoken in those countries.", "The condition specifies that the country must be in Europe, and English should not be an official language.", "We will use the condition 'countrylanguage.IsOfficial = 'FALSE'' to filter out countries where English is an official language."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT city.Name \nFROM city \nJOIN country ON city.CountryCode = country.Code \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE country.Continent = 'Europe' \nAND countrylanguage.Language = 'English' \nAND countrylanguage.IsOfficial = 'FALSE';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.785", "db_id": "world_1", "question": "What are the names of cities in Europe for which English is not the official language?", "rationale": ["Identify the relevant tables: 'city', 'country', and 'countrylanguage'.", "We need to find cities in Europe, so we will filter the 'country' table by the continent 'Europe'.", "We need to check the language spoken in these countries, specifically looking for cities where English is not an official language.", "To achieve this, we will join the 'city' table with the 'country' table on 'CountryCode', and then join with the 'countrylanguage' table on 'CountryCode' as well.", "We will use a WHERE clause to filter for countries in Europe and ensure that the language is not English. We also need to account for cases where there may be no official language listed (NULL).", "The final query will select the names of the cities that meet these criteria."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT city.Name \nFROM city \nJOIN country ON city.CountryCode = country.Code \nLEFT JOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE country.Continent = 'Europe' \nAND (countrylanguage.Language != 'English' OR countrylanguage.Language IS NULL)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.788", "db_id": "world_1", "question": "What are the name, independence year, and surface area of the country with the smallest population?", "rationale": ["Identify the required fields: Name, Independence Year (IndepYear), and Surface Area from the country table.", "Determine the condition to find the country with the smallest population, which involves using the MIN function on the Population column.", "Construct a subquery to find the minimum population from the country table.", "Use the result of the subquery to filter the main query to get the desired fields for the country with the smallest population."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the required fields: Name, year of independence (IndepYear), and surface area (SurfaceArea) of the country.", "Determine the condition: We need the country with the lowest population.", "Use a subquery to find the minimum population from the country table.", "Select the country details where the population matches the minimum population found in the subquery."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["Identify the relevant tables: We need to use the 'country' table to get country names and the 'countrylanguage' table to count the languages spoken in each country.", "Join the 'country' and 'countrylanguage' tables on the 'Code' and 'CountryCode' columns respectively to associate countries with their languages.", "Use the COUNT function to count the number of languages spoken in each country.", "Group the results by country name to aggregate the language counts for each country.", "Use the HAVING clause to filter the results to only include countries that speak more than 2 languages."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Name, COUNT(cl.Language) AS LanguageCount \nFROM country AS c \nJOIN countrylanguage AS cl ON c.Code = cl.CountryCode \nGROUP BY c.Name \nHAVING COUNT(cl.Language) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.796", "db_id": "world_1", "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.", "rationale": ["Identify the relevant columns needed for the query: GovernmentForm and Population from the country table.", "We need to filter countries based on the condition that their average LifeExpectancy is greater than 72.", "To get the total population for each government form, we will use the SUM function on the Population column.", "We will group the results by GovernmentForm to get the total population for each distinct government form."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation\nFROM country\nWHERE LifeExpectancy > 72\nGROUP BY GovernmentForm;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the columns needed: GovernmentForm and Population from the country table.", "We need to filter countries based on the average life expectancy greater than 72.", "Use the SUM function to calculate the total population for each government form.", "Group the results by GovernmentForm to get the total population for each type of government."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation \nFROM country \nWHERE LifeExpectancy > 72 \nGROUP BY GovernmentForm;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.801", "db_id": "world_1", "question": "Return the names and surface areas of the 5 largest countries.", "rationale": ["Identify the required columns: 'Name' and 'SurfaceArea' from the 'country' table.", "Determine the sorting criteria: we need the largest countries, which means sorting by 'SurfaceArea' in descending order.", "Limit the results to the top 5 entries to get the 5 largest countries."], "gold_sql": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5", "source_tables": ["country"], "pred_sql": "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.810", "db_id": "world_1", "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?", "rationale": ["Identify the relevant table: The 'country' table contains the necessary information about countries, including population and surface area.", "Determine the required fields: We need to calculate the total population and the average surface area of countries.", "Apply the conditions: The countries must be in the continent of North America and have a surface area greater than 3000.", "Construct the SQL query: Use SUM() to get the total population and AVG() to get the average surface area, applying the conditions in the WHERE clause."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT SUM(Population) AS TotalPopulation, AVG(SurfaceArea) AS AverageArea FROM country WHERE Continent = 'North America' AND SurfaceArea > 3000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.811", "db_id": "world_1", "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .", "rationale": ["Identify the relevant tables: 'country' for country details, 'city' for city population, and the surface area is also in the 'country' table.", "We need to filter countries in North America with a surface area greater than 3000. This requires a WHERE clause on the 'country' table.", "We need to calculate the total population of cities in these countries, which requires a JOIN between 'country' and 'city' tables on the CountryCode.", "We also need to calculate the average surface area of these countries, which can be done using an AVG function on the surface area from the 'country' table.", "The final query will select the SUM of populations and the AVG of surface areas, grouping by the filtered countries."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation, AVG(ca.SurfaceArea) AS AverageSurfaceArea \nFROM country AS co \nJOIN city AS c ON co.Code = c.CountryCode \nJOIN (SELECT Code, SurfaceArea FROM country WHERE Continent = 'North America' AND SurfaceArea > 3000) AS ca ON co.Code = ca.Code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.\",\n        \"virtual_table\": \"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the table to query: The relevant table is 'city' which contains population data.", "Determine the condition for filtering: We need to find cities with a population between 160000 and 900000.", "Construct the SQL query: Use the SELECT statement to retrieve all columns from the 'city' table where the population falls within the specified range using the BETWEEN clause."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT * FROM city WHERE Population BETWEEN '160000' AND '900000';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of countries where two specific languages are spoken. The placeholders in the query represent the names of the languages being compared.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.921", "db_id": "dog_kennels", "question": "Find the average age of the dogs who went through treatments.", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to find the average age of dogs that have undergone treatments, so we will join the Dogs table with the Treatments table on the dog_id.", "Select the age of the dogs from the Dogs table and calculate the average using the AVG() function.", "Return the average age as a single result."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT AVG(D.age) AS average_age\nFROM Dogs D\nJOIN Treatments T ON D.dog_id = T.dog_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.924", "db_id": "dog_kennels", "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to find dogs that have not cost their owner more than 1000 for treatment, which involves summing the treatment costs for each dog.", "Use a LEFT JOIN to connect the Dogs table with the Treatments table on the dog_id.", "Group the results by dog_id to aggregate the treatment costs for each dog.", "Use the HAVING clause to filter the groups where the total treatment cost is less than or equal to 1000.", "Select the dog names from the Dogs table that meet the criteria."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.name \nFROM Dogs d \nLEFT JOIN Treatments t ON d.dog_id = t.dog_id \nGROUP BY d.dog_id \nHAVING SUM(t.cost_of_treatment) <= 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.937", "db_id": "dog_kennels", "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.", "rationale": ["Identify the relevant tables: Owners, Dogs, and Treatments.", "Join the Owners table with the Dogs table on owner_id to link owners to their dogs.", "Join the resulting table with the Treatments table on dog_id to link treatments to the respective dogs.", "Group the results by owner_id and last_name to aggregate treatment costs per owner.", "Use SUM to calculate the total cost of treatments for each owner.", "Order the results in descending order based on the total treatment cost to find the owner who spent the most.", "Limit the results to 1 to get only the top owner."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT Owners.owner_id, Owners.last_name\nFROM Owners\nJOIN Dogs ON Owners.owner_id = Dogs.owner_id\nJOIN Treatments ON Dogs.dog_id = Treatments.dog_id\nGROUP BY Owners.owner_id, Owners.last_name\nORDER BY SUM(Treatments.cost_of_treatment) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "We need to join these tables on the professional_id to link professionals with the treatments they have administered.", "We want to group the results by professional_id to count the number of distinct treatment types each professional has done.", "Use the HAVING clause to filter professionals who have administered at least two different types of treatments.", "Select the professional_id and cell_number from the filtered results."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT professional_id, cell_number \nFROM Professionals AS P \nJOIN Treatments AS T ON P.professional_id = T.professional_id \nGROUP BY P.professional_id \nHAVING COUNT(DISTINCT T.treatment_type_code) >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code\"\n    }\n}\n"}
{"sample_id": "dev.943", "db_id": "dog_kennels", "question": "Find the id and cell phone of the professionals who operate two or more types of treatments.", "rationale": ["We need to find professionals who operate two or more types of treatments.", "To do this, we will join the 'Professionals', 'Treatments', and 'Treatment_Types' tables to get the relevant data.", "We will count the distinct treatment types for each professional using COUNT(DISTINCT T3.treatment_type_code).", "We will group the results by professional_id to get the count of treatment types for each professional.", "Finally, we will filter the results to include only those professionals with a treatment count of 2 or more."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT professional_id, cell_number \nFROM (\n    SELECT T1.professional_id, COUNT(DISTINCT T3.treatment_type_code) AS treatment_count \n    FROM Professionals AS T1 \n    JOIN Treatments AS T2 ON T1.professional_id = T2.professional_id \n    JOIN Treatment_Types AS T3 ON T2.treatment_type_code = T3.treatment_type_code \n    GROUP BY T1.professional_id \n) AS treatment_counts \nWHERE treatment_count >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code\"\n    }\n}\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["We need to list each owner's first name and last name, which are found in the Owners table.", "We also need the size of the dog, which is found in the Sizes table.", "To get the size of the dog, we need to join the Dogs table with the Sizes table using the size_code.", "We also need to join the Owners table with the Dogs table using the owner_id to link each dog to its owner.", "The final query will select the first name and last name from the Owners table and the size description from the Sizes table."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.954", "db_id": "dog_kennels", "question": "List the names of the dogs of the rarest breed and the treatment dates of them.", "rationale": ["Identify the rarest breed by counting the number of dogs for each breed and selecting the breed with the least count.", "Use a subquery to find the breed_code of the rarest breed.", "Join the Dogs table with the Treatments table to get the treatment dates for the dogs of the rarest breed.", "Select the names of the dogs and their corresponding treatment dates."], "gold_sql": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.name, t.date_of_treatment \nFROM Dogs d \nJOIN Treatments t ON d.dog_id = t.dog_id \nWHERE d.breed_code = (SELECT breed_code \n                      FROM Breeds \n                      WHERE breed_code IN (SELECT breed_code \n                                          FROM Dogs \n                                          GROUP BY breed_code \n                                          ORDER BY COUNT(*) ASC \n                                          LIMIT 1))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need the arriving date and departing date of dogs, which are in the Dogs table.", "We also need to filter dogs that have gone through a treatment, which is indicated by the Treatments table.", "To link the Dogs and Treatments tables, we can use the dog_id column, which is common to both tables.", "Construct the SQL query to select the date_arrived and date_departed from the Dogs table, joining it with the Treatments table on dog_id."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.date_arrived, d.date_departed \nFROM Dogs d \nJOIN Treatments t ON d.dog_id = t.dog_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.960", "db_id": "dog_kennels", "question": "List the last name of the owner owning the youngest dog.", "rationale": ["Identify the relevant tables: Owners and Dogs.", "We need to find the youngest dog, which can be determined by the latest date of birth.", "Join the Owners table with the Dogs table on the owner_id to link owners with their dogs.", "Order the results by the date_of_birth in descending order to get the youngest dog first.", "Limit the results to 1 to get only the last name of the owner of the youngest dog."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.last_name \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nORDER BY Dogs.date_of_birth DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["The task is to find distinct combinations of breed types and size types for dogs.", "We need to select the breed_code and size_code from the Dogs table.", "Using the DISTINCT keyword will ensure that we only get unique combinations of breed_code and size_code.", "The final SQL query is constructed as 'SELECT DISTINCT breed_code, size_code FROM Dogs;'"], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT breed_code, size_code FROM Dogs;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.\",\n        \"virtual_table\": \"SELECT DISTINCT breed_code ,  size_code FROM dogs\"\n    }\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["Identify the tables needed: Professionals, Treatments, and Treatment_Types.", "Determine the columns to select: first_name from Professionals and treatment_type_description from Treatment_Types.", "Use JOINs to connect the tables based on their foreign key relationships: Treatments links to Professionals via professional_id, and Treatments links to Treatment_Types via treatment_type_code.", "Use DISTINCT to ensure unique combinations of professional names and treatment descriptions are returned."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT DISTINCT T1.first_name, T3.treatment_type_description \nFROM Professionals AS T1 \nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id \nJOIN Treatment_Types AS T3 ON T2.treatment_type_code = T3.treatment_type_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code\"\n    }\n}\n"}
