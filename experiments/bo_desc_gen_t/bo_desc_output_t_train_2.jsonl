{"sample_id": "train.1579", "db_id": "customers_and_invoices", "question": "How many transaction does each account have? Show the number and account id.", "rationale": ["The query identifies the relevant table, which is 'Financial_Transactions'.", "It selects a count of all transactions and groups them by 'account_id'.", "The use of count(*) allows for the aggregation of transaction records per account, providing a summary of transactions associated with each account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "description": "This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.", "virtual_table": "SELECT count(*) ,  account_id FROM Financial_transactions"}
{"sample_id": "train.1549", "db_id": "customers_and_invoices", "question": "How many customers have opened an account?", "rationale": ["The query is identifying the relevant table, which is 'Accounts'.", "The goal is to count the distinct 'customer_id' values to determine the number of unique customers with accounts.", "Using the COUNT function with DISTINCT ensures that only unique customer IDs are counted."], "gold_sql": "SELECT count(DISTINCT customer_id) FROM Accounts", "source_tables": ["accounts"], "description": "This virtual table provides the count of unique customers who have opened accounts in the 'Accounts' table. The placeholder in the SELECT statement allows for potential filtering or additional conditions to be applied if needed.", "virtual_table": "SELECT count(DISTINCT customer_id) FROM Accounts"}
{"sample_id": "dev.937", "db_id": "dog_kennels", "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.", "rationale": ["The query identifies the relevant tables: 'Owners', 'Dogs', and 'Treatments'.", "It selects the 'owner_id' and 'last_name' from the 'Owners' table, using an alias for clarity.", "The JOIN operation links 'Owners' to 'Dogs' based on the 'owner_id', and then links 'Dogs' to 'Treatments' based on 'dog_id'.", "The GROUP BY clause groups the results by 'owner_id' to aggregate the treatment counts for each owner.", "The ORDER BY clause sorts the results by the count of treatments in descending order, ensuring that owners with the most treatments appear first.", "The LIMIT clause uses a placeholder to allow the user to specify how many owners to return."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "description": "This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.", "virtual_table": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.998", "db_id": "dog_kennels", "question": "List the first name of all the professionals along with the description of the treatment they have done.", "rationale": ["The query identifies the relevant tables: 'Professionals', 'Treatments', and 'Treatment_Types'.", "It selects the 'first_name' from the 'Professionals' table and 'treatment_type_description' from the 'Treatment_Types' table.", "The JOIN operations link the 'Treatments' table to both the 'Professionals' and 'Treatment_Types' tables based on their respective foreign keys.", "The DISTINCT keyword ensures that only unique combinations of professional names and treatment descriptions are returned."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "description": "This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code"}
{"sample_id": "dev.954", "db_id": "dog_kennels", "question": "List the names of the dogs of the rarest breed and the treatment dates of them.", "rationale": ["The query identifies the relevant tables, 'Dogs' and 'Treatments', and establishes a join between them based on the dog_id.", "It selects the 'name' of the dog from the 'Dogs' table and the 'date_of_treatment' from the 'Treatments' table.", "A subquery is used to find the breed_code of the least common breed by grouping the dogs by breed_code, counting them, and ordering the results in ascending order, limiting to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )", "source_tables": ["dogs", "treatments"], "description": "This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.", "virtual_table": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "dev.943", "db_id": "dog_kennels", "question": "Find the id and cell phone of the professionals who operate two or more types of treatments.", "rationale": ["The query identifies the relevant tables, 'Professionals' and 'Treatments'.", "It selects the 'professional_id' and 'cell_number' from the 'Professionals' table.", "A JOIN operation is performed between 'Professionals' and 'Treatments' on the 'professional_id' to link treatments to the professionals who administered them.", "The results are grouped by 'professional_id' to aggregate the treatment counts for each professional.", "The HAVING clause filters the results to include only those professionals who have administered a specified minimum number of treatments, using a placeholder for numeric values."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "description": "This virtual table provides a list of professionals along with their cell numbers from the 'Professionals' table who have administered a specified number of treatments. The placeholder in the HAVING clause represents the minimum count of treatments that a professional must have administered.", "virtual_table": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.945", "db_id": "dog_kennels", "question": "Which professionals have operated a treatment that costs less than the average? Give me theor first names and last names.", "rationale": ["The query identifies the relevant tables, 'Professionals' and 'Treatments'.", "It selects distinct first and last names from the 'Professionals' table.", "A join is performed between 'Professionals' and 'Treatments' to link professionals with the treatments they administered.", "A condition is added to filter treatments based on their cost being less than the average cost of treatments, which is calculated using a subquery."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "description": "This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )"}
{"sample_id": "dev.924", "db_id": "dog_kennels", "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects the 'name' column to display the names of the dogs.", "The subquery filters out dogs that have received treatments by checking the 'treatments' table, grouping by 'dog_id', and summing the 'cost_of_treatment'.", "A condition is added to exclude dogs whose total treatment cost exceeds a specified amount using a placeholder for numeric values."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "description": "This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum allowable total cost for treatments.", "virtual_table": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "dev.925", "db_id": "dog_kennels", "question": "What are the names of the dogs for which the owner has not spend more than 1000 for treatment ?", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects the 'name' column to display the names of the dogs.", "The subquery filters out dogs that have received treatments by summing the 'cost_of_treatment' from the 'Treatments' table, grouping by 'dog_id'.", "A condition is added to exclude dogs whose total treatment cost exceeds a specified amount using a placeholder for numeric values."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "description": "This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum allowable total treatment cost.", "virtual_table": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "dev.921", "db_id": "dog_kennels", "question": "Find the average age of the dogs who went through treatments.", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects the average age of dogs using the AVG function.", "The WHERE clause filters the dogs to include only those that have treatment records, which is determined by a subquery that selects dog_ids from the 'Treatments' table."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "description": "This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers if needed.", "virtual_table": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )"}
{"sample_id": "dev.960", "db_id": "dog_kennels", "question": "List the last name of the owner owning the youngest dog.", "rationale": ["The query identifies the relevant tables, which are 'Owners' and 'Dogs'.", "It selects the 'last_name' column from the 'Owners' table.", "A join is performed between 'Owners' and 'Dogs' on the 'owner_id' to link owners to their dogs.", "A condition is added to filter the results to only include the dog(s) with the maximum age, which is determined by a subquery that selects the maximum age from the 'Dogs' table."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "description": "This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.", "virtual_table": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )"}
{"sample_id": "dev.996", "db_id": "dog_kennels", "question": "What are all the possible breed type and size type combinations?", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects distinct values for 'breed_code' and 'size_code' to ensure that each combination is unique.", "The use of DISTINCT ensures that duplicate entries are not included in the results."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "description": "This virtual table provides a unique list of breed codes and size codes for dogs from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.", "virtual_table": "SELECT DISTINCT breed_code ,  size_code FROM dogs"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["The query identifies the relevant tables, 'Student', 'Lives_in', and 'Has_amenity'.", "It selects the columns 'fname' and 'age' from the 'Student' table, aliased as T1.", "It joins the 'Lives_in' table, aliased as T2, to link students with their respective dormitories based on the student ID.", "A subquery is used to filter out dormitories that have a specific amenity by checking against the 'Has_amenity' and 'Dorm_amenity' tables.", "The placeholder in the subquery represents the amenity name that is being excluded from the results."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "description": "This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.", "virtual_table": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["The query identifies the relevant tables, which are 'Student', 'Lives_in', 'Dorm', 'Has_amenity', and 'Dorm_amenity'.", "It selects the 'fname' column from the 'Student' table.", "The query joins 'Student' with 'Lives_in' to find which students live in which dorms.", "A subquery is used to find dorms with the most amenities by joining 'Dorm', 'Has_amenity', and 'Dorm_amenity', counting the amenities for each dorm, and ordering them.", "The LIMIT clause uses a placeholder for the maximum number of dormitories to return."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "description": "This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.", "virtual_table": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.5739", "db_id": "dorm_1", "question": "For each dorm, how many amenities does it have?", "rationale": ["The query identifies the relevant tables, 'dorm' and 'has_amenity'.", "It selects the count of amenities and the dormitory ID from the 'dorm' table.", "A JOIN operation is performed between 'dorm' and 'has_amenity' on the dormitory ID to link dormitories with their amenities.", "A condition is added to filter dormitories based on their student capacity using a placeholder for numeric values.", "The results are grouped by the dormitory ID to provide a count of amenities for each qualifying dormitory."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "description": "This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.", "virtual_table": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["The query identifies the relevant tables, 'dorm' and 'has_amenity'.", "It selects the count of amenities and the dormitory ID from the 'dorm' table.", "A JOIN operation is performed between 'dorm' and 'has_amenity' on the dormitory ID to link dormitories with their amenities.", "A condition is added to filter dormitories based on their student capacity using a placeholder for numeric values.", "The results are grouped by the dormitory ID to provide a count of amenities for each dormitory."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "description": "This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.", "virtual_table": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the 'LName' column to display the last names of students.", "The first part of the query filters students by 'sex' and 'city_code' using placeholders for string values.", "The second part of the query filters students by 'sex' and 'age' using a placeholder for numeric values, and combines the results using UNION."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "description": "This virtual table provides a list of last names of students from the 'Student' table based on specific criteria. It includes students of a certain gender residing in a specific city, as well as students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age criteria.", "virtual_table": "SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND city_code  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5729", "db_id": "dorm_1", "question": "What is the average age and how many male students are there in each city?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the count of students and the average age, along with the city code.", "A condition is added to filter the results based on the 'Sex' column using a placeholder for string values.", "The results are grouped by 'city_code' to provide a summary for each city."], "gold_sql": "SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  'M' GROUP BY city_code", "source_tables": ["student"], "description": "This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.", "virtual_table": "SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city_code"}
{"sample_id": "train.5706", "db_id": "dorm_1", "question": "Find the last name of students who is either female (sex is F) and living in the city of code BAL or male (sex is M) and in age of below 20.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It selects the 'LName' column to display the last names of students.", "The first part of the query filters students by 'sex' and 'city_code' using placeholders for string values.", "The second part of the query filters students by 'sex' and 'age' using a placeholder for numeric values, and combines the results using UNION."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "description": "This virtual table provides a list of last names of students from the 'Student' table based on specific criteria. It includes students of a certain gender residing in a specific city, as well as students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age criteria.", "virtual_table": "SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND city_code  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6323", "db_id": "e_government", "question": "What is the last name of the contact individual from the Labour party organization who was contacted most recently?", "rationale": ["The query identifies the relevant tables: 'Organizations', 'Organization_Contact_Individuals', and 'Individuals'.", "It selects the 'individual_last_name' from the 'Individuals' table.", "The join conditions link the organization to its contact individuals through the 'Organization_Contact_Individuals' table.", "A filter is applied to the 'organization_name' column to specify which organization to query.", "The results are ordered by 'date_contact_to' in descending order to show the most recent contacts first.", "A limit is set to control the number of results returned."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  'Labour Party' ORDER BY t2.date_contact_to DESC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "description": "This virtual table provides the last names of individuals who have contacted a specific organization. It retrieves data from the 'Organizations', 'Organization_Contact_Individuals', and 'Individuals' tables, filtering based on the organization's name. The results are ordered by the end date of the contact period, and a limit is applied to the number of results returned.", "virtual_table": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY t2.date_contact_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6329", "db_id": "e_government", "question": "What are the names of the services that have never been used?", "rationale": ["The query identifies the relevant table, which is 'Services'.", "It selects the 'service_name' column to display the names of the services.", "The EXCEPT clause is used to filter out service names that are present in the 'Party_Services' table, indicating those services have been booked."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "description": "This virtual table lists the names of services from the 'Services' table that have not been booked by any party. The query uses an EXCEPT clause to exclude service names that are present in the 'Party_Services' table, indicating that those services have been booked. The placeholder in the query represents the service names that are being filtered out based on their booking status.", "virtual_table": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id"}
{"sample_id": "train.6313", "db_id": "e_government", "question": "What is the name of the party form that is most common?", "rationale": ["The query identifies the relevant tables, 'Forms' and 'Party_Forms'.", "It selects the 'form_name' from the 'Forms' table.", "A JOIN operation is performed between 'Forms' and 'Party_Forms' on the 'form_id' to link forms with their associated parties.", "The results are grouped by 'form_id' to aggregate the counts of each form's usage.", "The results are ordered by the count of associations in descending order to prioritize the most frequently used forms.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["forms", "party_forms"], "description": "This virtual table provides a list of form names from the 'Forms' table that are associated with parties through the 'Party_Forms' table. The results are grouped by form ID and ordered by the count of associations in descending order, allowing users to see the most frequently used forms. The placeholder in the LIMIT clause represents the maximum number of results to return.", "virtual_table": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6343", "db_id": "e_government", "question": "Give the state corresponding to the line number building \"6862 Kaitlyn Knolls\".", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "Select the column to display, 'state_province_county'.", "Add a condition to filter the 'line_1_number_building' column using a LIKE clause with a placeholder for string values."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "description": "This virtual table retrieves the state, province, or county information from the 'Addresses' table based on a specific address line that matches a given pattern. The placeholder in the LIKE clause allows for flexible searching of address lines.", "virtual_table": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6342", "db_id": "e_government", "question": "Which state can address \"6862 Kaitlyn Knolls\" possibly be in?", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "Select the column to display, 'state_province_county'.", "Add a condition to filter the 'line_1_number_building' column using the LIKE operator with a placeholder for string values."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "description": "This virtual table retrieves the state, province, or county information from the 'Addresses' table based on a specific address line that matches a given pattern. The placeholder in the LIKE clause allows for flexible searching of address lines.", "virtual_table": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["The query identifies the relevant tables: 'Employee', 'Certificate', and 'Aircraft'.", "It selects the 'name' column from the 'Employee' table.", "The query joins the 'Employee' table with the 'Certificate' table on the employee ID, and then joins the 'Certificate' table with the 'Aircraft' table on the aircraft ID.", "A condition is added to filter aircraft based on their maximum travel distance using a placeholder for numeric values.", "The results are grouped by employee ID to count the number of certificates held by each employee.", "The results are ordered in descending order based on the count of certificates, and a limit is applied to restrict the number of results returned."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "description": "This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.", "virtual_table": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["The query identifies the relevant table, which is 'Employee'.", "It selects the 'name' column from the 'Employee' table.", "The EXCEPT clause is used to exclude employees who hold a certificate for a specific aircraft model.", "To find employees with certificates, a JOIN is performed between 'Employee', 'Certificate', and 'Aircraft' tables based on their foreign key relationships.", "A condition is added to filter the aircraft model using a placeholder for string values."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "description": "This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.", "virtual_table": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["The query identifies the relevant tables, which are 'Certificate' and 'Aircraft'.", "It selects the 'name' column from the 'Aircraft' table.", "The query performs a JOIN operation between 'Certificate' and 'Aircraft' on the aircraft ID to link certificates to their respective aircraft.", "It groups the results by the aircraft ID to aggregate the count of certificates for each aircraft.", "The results are ordered by the count of certificates in descending order to prioritize aircraft with the most certifications.", "A placeholder is included in the LIMIT clause to allow the user to specify how many aircraft names to return."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "description": "This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' table with the 'Aircraft' table based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of aircraft names to retrieve.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["The query identifies the relevant tables, which are 'Flight' and 'Aircraft'.", "It selects the 'name' column from the 'Aircraft' table and counts the number of flights associated with each aircraft.", "A JOIN operation is performed on the 'aid' column to link flights with their respective aircraft.", "The results are grouped by the 'aid' to aggregate the flight counts for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "description": "This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.", "virtual_table": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid"}
{"sample_id": "train.432", "db_id": "flight_1", "question": "What are the names of the aircraft that the least people are certified to fly?", "rationale": ["The query identifies the relevant tables, which are 'Certificate' and 'Aircraft'.", "It selects the 'name' column from the 'Aircraft' table.", "The query performs a JOIN operation between 'Certificate' and 'Aircraft' on the aircraft ID to link certificates to their respective aircraft.", "It groups the results by the aircraft ID to aggregate the count of certificates for each aircraft.", "The results are ordered by the count of certificates in descending order to prioritize aircraft with the most certifications.", "A placeholder is included in the LIMIT clause to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "description": "This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.407", "db_id": "flight_1", "question": "Which origin has most number of flights?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "It selects the 'origin' column to display the starting locations of flights.", "The results are grouped by the 'origin' to aggregate the data based on unique starting locations.", "The query orders the results by the count of flights from each origin in descending order to show the most popular origins first.", "A limit is applied to restrict the number of origins returned, using a placeholder for numeric values."], "gold_sql": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "description": "This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.", "virtual_table": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "It selects the average of the 'price' column to calculate the average ticket price.", "Conditions are added to filter the results based on the specified 'origin' and 'destination' using placeholders for string values."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "description": "This virtual table calculates the average ticket price for flights originating from a specific location and heading to a specific destination. The placeholders in the WHERE clause represent the origin and destination of the flights.", "virtual_table": "SELECT avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING] AND destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.402", "db_id": "flight_1", "question": "What is the average distance and price for all flights from LA?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "It selects the average values of 'distance' and 'price' columns.", "A condition is added to filter the results based on the 'origin' column using a placeholder for string values."], "gold_sql": "SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  'Los Angeles'", "source_tables": ["flight"], "description": "This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.", "virtual_table": "SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "Select the column to display, 'origin'.", "Add a condition to filter the 'destination' column for the specified destination using a placeholder for string values."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "description": "This virtual table provides the starting locations of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.", "virtual_table": "SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2181", "db_id": "formula_1", "question": "What are the forenames and surnames of drivers who participated in the races named Australian Grand Prix but not the races named Chinese Grand Prix?", "rationale": ["The query identifies the relevant tables: 'races', 'results', and 'drivers'.", "It selects the 'forename' and 'surname' columns from the 'drivers' table.", "The query uses JOINs to connect the 'races' table with the 'results' and 'drivers' tables based on their relationships.", "It filters the results to include drivers from a specific race using a placeholder for the race name.", "The EXCEPT clause is used to exclude drivers from another specified race, again using a placeholder for the race name."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.", "virtual_table": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2176", "db_id": "formula_1", "question": "What are the names and years of all races that had a driver with the last name Lewis?", "rationale": ["The query identifies the relevant tables: 'results', 'races', and 'drivers'.", "It selects the 'name' from the 'races' table and 'year' from the 'races' table to display the race details.", "The JOIN operations link the 'results' table to the 'races' table using 'raceId' and to the 'drivers' table using 'driverId'.", "A condition is added to filter results based on the driver's first name using a placeholder for string values."], "gold_sql": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = 'Lewis'", "source_tables": ["results", "drivers", "races"], "description": "This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.", "virtual_table": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2186", "db_id": "formula_1", "question": "What are the first names of the different drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'driverStandings'.", "It selects distinct first names from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'driverStandings' on the driver ID to combine relevant data.", "Conditions are added to filter the results based on the driver's position, number of wins, and points using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "description": "This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the driver standings, a certain number of wins, and more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2221", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It selects the maximum value of 'fastestLapSpeed' from the 'results' table.", "A JOIN operation is performed between 'races' and 'results' on the 'raceId' to correlate race details with their results.", "Conditions are added to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "This virtual table provides the maximum fastest lap speed recorded during races in a specific year and for a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.", "virtual_table": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2168", "db_id": "formula_1", "question": "What is the id and last name of the driver with the longest laptime?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'lapTimes'.", "It selects the 'driverId' and 'surname' from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'lapTimes' on the 'driverId' to associate drivers with their lap times.", "The results are ordered by the 'milliseconds' column from the 'lapTimes' table in descending order to get the fastest times first.", "The LIMIT clause is included to allow the user to specify how many top results they want to retrieve."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "description": "This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.", "virtual_table": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2183", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who was in position 1 as standing and won?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'driverStandings'.", "It selects distinct first names from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'driverStandings' on the driver ID to correlate driver information with their standings.", "Conditions are added to filter the results based on the specified position and number of wins using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "description": "This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2184", "db_id": "formula_1", "question": "What are all the different first names of the drivers who are in position as standing and won?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'driverStandings'.", "It selects distinct first names from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'driverStandings' on the driver ID to combine relevant data.", "Conditions are added to filter the results based on the specified position and number of wins using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "description": "This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2225", "db_id": "formula_1", "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["The query identifies the relevant tables, 'races' and 'results', and establishes a join between them based on the race ID.", "It selects the average fastest lap speed from the 'results' table, the name of the race, and the year from the 'races' table.", "A condition is added to filter the results to only include races that occurred after a specified year using a placeholder for numeric values.", "The results are grouped by the race name to calculate the average speed for each race and ordered by the year of the race."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "description": "This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.", "virtual_table": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year"}
{"sample_id": "train.2173", "db_id": "formula_1", "question": "How many drivers did not participate in the races held in 2009?", "rationale": ["The query identifies the relevant table, which is 'results', to count distinct drivers.", "It uses a subquery to filter out race IDs from the 'races' table based on the specified year using a placeholder for numeric values.", "The final output is the count of distinct driver IDs from the 'results' table for races that are not in the specified year."], "gold_sql": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )", "source_tables": ["results", "races"], "description": "This virtual table provides the count of distinct drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.", "virtual_table": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.2185", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'driverStandings'.", "It selects distinct first names from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'driverStandings' on the driver ID to combine relevant data.", "Conditions are added to filter the results based on the driver's position, number of wins, and points using placeholders for numeric values."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "description": "This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the driver standings, a certain number of wins, and more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria for filtering the results.", "virtual_table": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2219", "db_id": "formula_1", "question": "What is the average fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It joins the 'races' table with the 'results' table on the race ID to correlate race data with results.", "The SELECT statement calculates the average of the 'fastestLapSpeed' from the 'results' table.", "A condition is added to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.", "virtual_table": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2226", "db_id": "formula_1", "question": "What is the average fastest lap speed for races held after 2004, for each race, ordered by year?", "rationale": ["The query identifies the relevant tables, 'races' and 'results', and uses a JOIN to combine them based on the race ID.", "It selects the average fastest lap speed from the 'results' table, the name of the race, and the year from the 'races' table.", "A condition is added to filter the results to only include races that occurred after a specified year using a placeholder for numeric values.", "The results are grouped by the race name to calculate the average speed for each race and ordered by the year of the race."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "description": "This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.", "virtual_table": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year"}
{"sample_id": "train.2189", "db_id": "formula_1", "question": "What are the numbers of races for each constructor id?", "rationale": ["The query identifies the relevant table, which is 'constructorStandings'.", "It selects a count of records and groups them by 'constructorId' to aggregate the standings for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "description": "This virtual table provides a count of the total number of constructor standings for each constructor from the 'constructorStandings' table. The placeholder in the SELECT statement represents the constructor's identifier, which is grouped to show the total standings for each constructor.", "virtual_table": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid"}
{"sample_id": "train.2202", "db_id": "formula_1", "question": "What are the different names of all the races in reverse alphabetical order?", "rationale": ["The query is identifying the relevant table, which is 'races'.", "Select the distinct column to display, 'name', to ensure unique race names are retrieved.", "Add an ORDER BY clause to sort the results in descending order based on the race names."], "gold_sql": "SELECT DISTINCT name FROM races ORDER BY name DESC", "source_tables": ["races"], "description": "This virtual table provides a distinct list of race names from the 'races' table, sorted in descending order. The placeholder in the ORDER BY clause indicates that the results will be organized based on the race names.", "virtual_table": "SELECT DISTINCT name FROM races ORDER BY name DESC"}
{"sample_id": "train.3940", "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["The query identifies the relevant tables: 'Physician', 'Prescribes', and 'Medication'.", "It selects distinct names from the 'Physician' table (aliased as T1).", "The query joins the 'Prescribes' table (aliased as T2) on the physician's identifier to link physicians with their prescriptions.", "It further joins the 'Medication' table (aliased as T3) to filter the results based on the medication's name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "description": "This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.", "virtual_table": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3981", "db_id": "hospital_1", "question": "What are the procedures that cost more than 1000 or are specialized in by physician John Wen?", "rationale": ["The query identifies the relevant tables, which are 'Procedures' and 'Physician' along with 'Trained_In'.", "The first part of the query selects procedure names from the 'Procedures' table where the cost exceeds a specified number using a placeholder.", "The second part of the query uses a JOIN to connect 'Physician' and 'Trained_In' tables to find procedures that a specific physician is trained in, filtering by the physician's name with a placeholder.", "The UNION operator combines the results of both queries to provide a comprehensive list of procedures based on the specified criteria."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "description": "This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.", "virtual_table": "SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3972", "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["The query identifies the relevant tables: 'Physician', 'Trained_In', and 'Procedures'.", "It selects the 'Name' column from the 'Physician' table.", "The query joins 'Physician' with 'Trained_In' on the 'EmployeeID' and 'Physician' identifiers to link physicians with their training.", "It further joins 'Trained_In' with 'Procedures' on the 'Code' and 'Treatment' identifiers to associate procedures with their costs.", "A condition is added to filter the results based on the cost of the procedures using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "description": "This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3980", "db_id": "hospital_1", "question": "Find all procedures which cost more than 1000 or which physician John Wen was trained in.", "rationale": ["The query identifies the relevant tables, which are 'Procedures', 'Physician', and 'Trained_In'.", "The first part of the query selects procedure names from the 'Procedures' table where the cost exceeds a specified number using a placeholder.", "The second part of the query uses a JOIN to connect 'Physician' and 'Trained_In' tables to find procedures that a specific physician is trained in, filtering by the physician's name with a placeholder."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "description": "This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.", "virtual_table": "SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3993", "db_id": "hospital_1", "question": "How many patients are not using Procrastin-X as medication?", "rationale": ["The query identifies the relevant table, which is 'Patient'.", "It uses a subquery to find patients who have been prescribed a specific medication by joining 'Prescribes' and 'Medication'.", "The main query counts the patients whose SSN is not in the list of patients returned by the subquery, indicating they have not received the medication."], "gold_sql": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )", "source_tables": ["patient", "prescribes", "medication"], "description": "This virtual table counts the number of patients who have not been prescribed a specific medication. It filters the patients based on their Social Security Number (SSN) and checks against a subquery that retrieves patients who have received the specified medication by joining the 'Prescribes' and 'Medication' tables. The placeholder in the query represents the name of the medication.", "virtual_table": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3941", "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["The query identifies the relevant tables: 'Physician', 'Prescribes', and 'Medication'.", "It selects distinct names from the 'Physician' table (aliased as T1).", "It joins the 'Prescribes' table (aliased as T2) on the physician's identifier to link prescriptions to physicians.", "It further joins the 'Medication' table (aliased as T3) on the medication code to filter by a specific medication name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "description": "This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.", "virtual_table": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3903", "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["The query identifies the relevant tables, which are 'Department' and 'Physician'.", "It selects the 'name' and 'position' columns from the 'Physician' table (aliased as T2).", "A JOIN operation is performed between the 'Department' table (aliased as T1) and the 'Physician' table based on the condition that the head of the department matches the physician's EmployeeID.", "The results are grouped by 'departmentID' to aggregate the data appropriately.", "The results are ordered by the count of 'departmentID' to prioritize departments with more heads, and a limit is applied to restrict the number of results returned."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "description": "This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results based on the count of departments, with a limit on the number of results returned as specified by the placeholder.", "virtual_table": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3911", "db_id": "hospital_1", "question": "What are the names of all the physicians who took appointments.", "rationale": ["The query identifies the relevant tables, which are 'Appointment' and 'Physician'.", "It selects the 'Name' column from the 'Physician' table, which contains the names of the physicians.", "The join condition links the 'Physician' column in the 'Appointment' table to the 'EmployeeID' column in the 'Physician' table, ensuring that only the names of physicians conducting appointments are retrieved."], "gold_sql": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID", "source_tables": ["physician", "appointment"], "description": "This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.", "virtual_table": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID"}
{"sample_id": "train.3962", "db_id": "hospital_1", "question": "List the names of departments where some physicians are primarily affiliated with.", "rationale": ["The query identifies the relevant tables, 'Affiliated_With' and 'Department'.", "It selects distinct department names from the 'Department' table.", "A JOIN operation is performed between 'Affiliated_With' and 'Department' on the department identifier.", "A condition is added to filter the results based on the primary affiliation status using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1", "source_tables": ["department", "affiliated_with"], "description": "This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.", "virtual_table": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3945", "db_id": "hospital_1", "question": "How many medications are prescribed for each brand?", "rationale": ["The query identifies the relevant tables, which are 'medication' and 'prescribes'.", "It selects a count of prescriptions and the name of the medication from the 'medication' table.", "The JOIN operation links the two tables based on the medication code, ensuring that only prescribed medications are counted.", "The GROUP BY clause organizes the results by the brand of the medication, allowing for a summary count per brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "description": "This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.", "virtual_table": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand"}
{"sample_id": "train.3910", "db_id": "hospital_1", "question": "List the name of physicians who took some appointment.", "rationale": ["The query identifies the relevant tables, which are 'Appointment' and 'Physician'.", "It selects the 'Name' column from the 'Physician' table, which contains the names of the physicians.", "The join condition links the 'Physician' column in the 'Appointment' table to the 'EmployeeID' column in the 'Physician' table, ensuring that only the names of physicians conducting appointments are retrieved."], "gold_sql": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID", "source_tables": ["physician", "appointment"], "description": "This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.", "virtual_table": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID"}
{"sample_id": "train.3963", "db_id": "hospital_1", "question": "What are the names of departments that have primarily affiliated physicians.", "rationale": ["The query identifies the relevant tables, 'Affiliated_With' and 'Department'.", "It selects distinct department names from the 'Department' table.", "A JOIN operation is performed between 'Affiliated_With' and 'Department' on the department identifier.", "A condition is added to filter the results based on the primary affiliation status using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1", "source_tables": ["department", "affiliated_with"], "description": "This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.", "virtual_table": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3958", "db_id": "hospital_1", "question": "What are the names of the physician who prescribed the highest dose?", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Prescribes'.", "It selects the 'Name' column from the 'Physician' table, aliased as T1.", "A JOIN operation is performed between 'Physician' and 'Prescribes' on the condition that the 'EmployeeID' from 'Physician' matches the 'Physician' identifier in 'Prescribes'.", "The results are ordered by the 'Dose' column from the 'Prescribes' table in descending order to show the highest dosages first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "description": "This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3928", "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Patient'.", "It selects the 'Name' column from the 'Physician' table and counts the number of patients associated with each physician.", "A join is performed between the 'Physician' table and the 'Patient' table using the physician's employee ID and the patient's PCP identifier.", "The results are grouped by the physician's employee ID to provide a count of patients for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "description": "This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.", "virtual_table": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid"}
{"sample_id": "train.3964", "db_id": "hospital_1", "question": "What nurses are on call with block floor 1 and block code 1? Tell me their names.", "rationale": ["The query identifies the relevant table, which is 'On_Call'.", "Select the column to display, 'nurse'.", "Add conditions to filter the 'blockfloor' and 'blockcode' columns using placeholders for numeric values."], "gold_sql": "SELECT nurse FROM on_call WHERE blockfloor  =  1 AND blockcode  =  1", "source_tables": ["on_call"], "description": "This virtual table provides a list of nurses who are on call, filtered by specific conditions related to blocked floors and blocked codes. The placeholders in the WHERE clause represent the identifiers for the blocked floor and blocked code statuses.", "virtual_table": "SELECT nurse FROM on_call WHERE blockfloor  =  [PLACEHOLDER-TYPE:NUMBER] AND blockcode  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3901", "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["The query identifies the relevant table, which is 'Department'.", "It selects the 'head' column to display the heads of the departments.", "The results are grouped by 'DepartmentID' to aggregate the data appropriately.", "The results are ordered by the count of 'DepartmentID' to prioritize departments with more occurrences.", "A placeholder is included to limit the number of results returned."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "description": "This virtual table provides a list of department heads from the 'Department' table, grouped by department ID. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.", "virtual_table": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3924", "db_id": "hospital_1", "question": "Find the patient who most recently stayed in room 111.", "rationale": ["The query identifies the relevant table, which is 'Stay'.", "It selects the 'patient' column to display the patients staying in the specified room.", "A condition is added to filter the 'room' column for the specified room number using a placeholder for numeric values.", "The results are ordered by 'StayStart' in descending order to show the most recent stays first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT patient FROM stay WHERE room  =  111 ORDER BY staystart DESC LIMIT 1", "source_tables": ["stay"], "description": "This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.", "virtual_table": "SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3949", "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["The query identifies the relevant table, which is 'Undergoes'.", "Select the 'patient' column to display the patients who have undergone procedures.", "Order the results by 'dateundergoes' to sort the patients based on when they underwent the procedures.", "Use a placeholder in the LIMIT clause to allow the user to specify how many patient records to return."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "description": "This virtual table provides a list of patients who have undergone medical procedures, sorted by the date of the procedures. The placeholder in the LIMIT clause allows for specifying the maximum number of patients to retrieve.", "virtual_table": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3900", "db_id": "hospital_1", "question": "What is the employee id of the head whose department has the least number of employees?", "rationale": ["The query identifies the relevant table, which is 'Department'.", "It selects the 'head' column to display the heads of the departments.", "The results are grouped by 'DepartmentID' to ensure unique department heads are listed.", "The results are ordered by the count of 'DepartmentID' to prioritize departments with more occurrences.", "A placeholder is included to limit the number of results returned."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "description": "This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.", "virtual_table": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3948", "db_id": "hospital_1", "question": "Find the patient who has the most recent undergoing treatment?", "rationale": ["The query identifies the relevant table, which is 'Undergoes'.", "Select the 'patient' column to display the patients who have undergone procedures.", "Order the results by 'dateundergoes' to show the most recent procedures first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "description": "This virtual table lists the patients who have undergone procedures, ordered by the date of the procedures. The placeholder in the LIMIT clause represents the maximum number of patients to be displayed.", "virtual_table": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3518", "db_id": "hr_1", "question": "What are the full names, departments, cities, and state provinces for each employee?", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', and 'locations'.", "It selects the columns to display: 'first_name' and 'last_name' from 'employees', 'department_name' from 'departments', and 'city' and 'state_province' from 'locations'.", "The JOIN operations link the 'employees' table to the 'departments' table using 'department_id', and then link the 'departments' table to the 'locations' table using 'location_id'."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id", "source_tables": ["employees", "departments", "locations"], "description": "The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.", "virtual_table": "SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id"}
{"sample_id": "train.3524", "db_id": "hr_1", "question": "What the full names, ids of each employee and the name of the country they are in?", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', 'locations', and 'countries'.", "It selects the 'first_name', 'last_name', and 'employee_id' from the 'employees' table (aliased as T1).", "It joins the 'departments' table (T2) on the 'department_id' to associate employees with their departments.", "It further joins the 'locations' table (T3) on 'location_id' to link departments to their locations.", "Finally, it joins the 'countries' table (T4) on 'country_id' to retrieve the country names associated with the locations."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "description": "This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.", "virtual_table": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', and 'locations'.", "It selects the columns to display: 'first_name', 'last_name', and 'salary'.", "The JOIN operations link the 'employees' table to the 'departments' table using 'department_id', and then to the 'locations' table using 'location_id'.", "A condition is added to filter the results based on the 'city' column from the 'locations' table, using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "description": "This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["The query identifies the relevant tables, which are 'job_history' and 'employees'.", "It selects all columns from the joined tables using the wildcard '*'.", "The JOIN condition links the 'employee_id' from 'job_history' to 'employee_id' in 'employees'.", "A condition is added to filter employees based on their salary, using a placeholder for numeric values."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "description": "This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.", "virtual_table": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3498", "db_id": "hr_1", "question": "What are the ids for employees who do not work in departments with managers that have ids between 100 and 200?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects all columns from the 'employees' table.", "A condition is added to filter out department IDs that are linked to manager IDs within a specified numeric range using placeholders."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "description": "This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs.", "virtual_table": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.3481", "db_id": "hr_1", "question": "get the details of employees who manage a department.", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It performs a JOIN operation on the 'department_id' to link employees with their respective departments.", "The WHERE clause filters the results to include only those employees whose 'employee_id' matches the 'manager_id' in the departments table."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "description": "This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that each employee-manager pair is unique.", "virtual_table": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id"}
{"sample_id": "train.3464", "db_id": "hr_1", "question": "Give the name of each department and the number of employees in each.", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It selects the 'department_name' from the 'departments' table and counts the number of employees from the 'employees' table.", "A JOIN operation is performed on the 'department_id' to link employees to their respective departments.", "The results are grouped by 'department_name' to provide a count of employees in each department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "description": "This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.", "virtual_table": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name"}
{"sample_id": "train.3466", "db_id": "hr_1", "question": "What is all the job history info done by employees earning a salary greater than or equal to 12000?", "rationale": ["The query identifies the relevant tables, which are 'job_history' and 'employees'.", "It selects all columns from the joined tables using the wildcard '*'.", "The JOIN condition links the 'employee_id' from 'job_history' to 'employee_id' from 'employees'.", "A condition is added to filter employees based on their salary, using a placeholder for numeric values."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "description": "This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.", "virtual_table": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3509", "db_id": "hr_1", "question": "display the employee number, name( first name and last name ) and job title for all employees whose salary is more than any salary of those employees whose job title is PU_MAN.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', 'last_name', and 'job_id'.", "Add a condition to filter employees based on their salary being greater than a maximum salary from a subquery.", "The subquery selects the maximum salary from the 'employees' table where the job identifier matches the specified job, using a placeholder for string values."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "description": "This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the 'department_id' and calculates the average salary using the AVG function.", "A condition is added to filter out employees with a null commission percentage using a placeholder for string values.", "The results are grouped by 'department_id' to provide the average salary for each department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table provides the average salary of employees grouped by their department. The placeholder in the WHERE clause indicates that only employees with a non-null commission percentage are included in the calculation.", "virtual_table": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', and 'last_name'.", "Add a condition to filter the 'department_id' based on a subquery that selects 'department_id' from the 'employees' table where the 'first_name' matches a specified pattern using a placeholder for string values."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "description": "This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["The query identifies the relevant table, which is 'locations'.", "Select the 'country_id' column to group the results by country.", "Use the COUNT function to count the number of locations for each country, grouping the results by 'country_id' to get the total count per country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "description": "This virtual table summarizes the number of locations associated with each country from the 'locations' table. The placeholder in the SELECT clause represents the unique identifier for each country, while the COUNT function aggregates the total number of locations per country.", "virtual_table": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id"}
{"sample_id": "train.3473", "db_id": "hr_1", "question": "Find the first name and last name and department id for those employees who earn such amount of salary which is the smallest salary of any of the departments.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'department_id'.", "Add a condition to filter employees whose salary is in the set of minimum salaries for each department, using a subquery that groups by 'department_id' to find the minimum salary for each department."], "gold_sql": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)", "source_tables": ["employees"], "description": "This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table. It specifically filters for employees who earn the minimum salary within their respective departments. The placeholder in the WHERE clause represents the salary criteria based on the minimum salary grouped by department.", "virtual_table": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)"}
{"sample_id": "train.3428", "db_id": "hr_1", "question": "Return the full names and salaries for employees with first names that end with the letter m.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'salary'.", "Add a condition to filter the 'first_name' column using a LIKE operator with a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE '%m'", "source_tables": ["employees"], "description": "This virtual table describes the first names, last names, and salaries of employees from the 'employees' table whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern for the first name.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the 'department_id' and calculates the average salary using the AVG() function.", "A condition is added to exclude employees with a specific commission percentage using a placeholder for string values.", "The results are grouped by 'department_id' to provide the average salary per department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table provides the average salary of employees grouped by their department. It filters out employees who have a specific commission percentage, represented by a placeholder for string values.", "virtual_table": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != [PLACEHOLDER-TYPE:STRING] GROUP BY department_id"}
{"sample_id": "train.3432", "db_id": "hr_1", "question": "What are the full names of employees who with in department 70 or 90?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display, 'first_name' and 'last_name'.", "Adds a condition to filter the 'department_id' column for the specified department identifiers using placeholders for numeric values."], "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE department_id  =  70 OR department_id  =  90", "source_tables": ["employees"], "description": "This virtual table provides the first and last names of employees from the 'employees' table who belong to specific departments. The placeholders in the WHERE clause represent the identifiers of the departments being queried.", "virtual_table": "SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'hire_date'.", "Add a condition to filter the 'department_id' using a subquery that retrieves the 'department_id' based on the specified 'first_name' using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "description": "This virtual table provides the first and last names, along with the hire date of employees from the 'employees' table who belong to a specific department. The department is identified by the first name of an employee, which is used as a filter in a subquery to find the corresponding department ID.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["The query is identifying the relevant table, which is 'employees'.", "Select the columns to display, 'first_name', 'last_name', and 'salary'.", "Add a condition to filter the 'salary' column for employees earning less than the specified salary using a placeholder for numeric values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "description": "This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3449", "db_id": "hr_1", "question": "display those departments where more than ten employees work who got a commission percentage.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the 'department_id' to group the results by department.", "The HAVING clause is used to filter groups based on the count of employees with a commission percentage, using a placeholder for numeric values."], "gold_sql": "SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > 10", "source_tables": ["employees"], "description": "This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.", "virtual_table": "SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects all columns from the 'employees' table.", "A condition is added to filter employees based on their salary, using a subquery to find the minimum salary and a placeholder for the upper limit of the salary range."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "description": "This virtual table retrieves all employee records from the 'employees' table whose salary falls within a specified range. The lower limit of the salary range is dynamically determined by selecting the minimum salary from the same table, while the upper limit is represented by a placeholder for numeric values.", "virtual_table": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3474", "db_id": "hr_1", "question": "What are the full names and department ids for the lowest paid employees across all departments.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'department_id'.", "Add a condition to filter employees whose salary matches the minimum salary in their department using a subquery that groups by 'department_id' and selects the minimum salary."], "gold_sql": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)", "source_tables": ["employees"], "description": "This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.", "virtual_table": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display: 'first_name', 'last_name', 'hire_date', 'salary', and 'department_id'.", "Adds a condition to filter out employees whose first names match a specified pattern using a placeholder for string values.", "Orders the results by 'department_id' to group employees by their respective departments."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "description": "This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY department_id"}
{"sample_id": "train.3508", "db_id": "hr_1", "question": "What are the employee ids and job ids for employees who make less than the lowest earning employee with title MK_MAN?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display, 'employee_id' and 'job_id'.", "Add a condition to filter employees whose salary is less than a certain value.", "The subquery retrieves the minimum salary for a specific job using a placeholder for the job identifier."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "description": "This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.", "virtual_table": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3504", "db_id": "hr_1", "question": "What are the ids and full names for employees who work in a department that has someone with a first name that contains the letter T?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', and 'last_name'.", "Add a condition to filter the 'department_id' based on a subquery that selects 'department_id' from the 'employees' table where the 'first_name' matches a specified pattern using a placeholder for string values."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "description": "This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3447", "db_id": "hr_1", "question": "display the employee ID for each employee and the date on which he ended his previous job.", "rationale": ["The query identifies the relevant table, which is 'job_history'.", "Select the column 'employee_id' to display the unique identifier for each employee.", "Use the MAX function to find the latest 'end_date' for each employee's job history.", "Group the results by 'employee_id' to ensure that we get the most recent end date for each employee."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "description": "This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the employee's unique identifier, while the MAX function is used to retrieve the latest end date for each employee's job history.", "virtual_table": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id"}
{"sample_id": "train.3408", "db_id": "hr_1", "question": "What are the full names and salaries for any employees earning less than 6000?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'salary'.", "Add a condition to filter the 'salary' column for employees earning less than the specified amount using a placeholder for numeric values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "description": "This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["The query identifies the relevant table, which is 'locations'.", "It selects the 'country_id' to group the results by each country.", "The COUNT function is used to count the number of locations for each country, and the results are grouped by 'country_id' to provide a summary count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "description": "This virtual table summarizes the number of locations associated with each country in the 'locations' table. The placeholder in the SELECT clause represents the unique identifier for each country, while the COUNT function aggregates the total number of locations per country.", "virtual_table": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects distinct 'department_id' to ensure unique entries.", "The results are grouped by 'department_id' and 'manager_id' to aggregate data based on these identifiers.", "A HAVING clause is used to filter groups that have a count of 'employee_id' greater than or equal to a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "description": "This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.", "virtual_table": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1522", "db_id": "insurance_and_eClaims", "question": "Which customer made the smallest amount of claim in one claim? Return the customer details.", "rationale": ["The query identifies the relevant tables: 'Claim_Headers', 'Policies', and 'Customers'.", "It selects the 'Customer_Details' from the 'Customers' table.", "The query uses JOINs to connect 'Claim_Headers' to 'Policies' and 'Policies' to 'Customers' based on their foreign key relationships.", "A subquery is used to find the minimum 'Amount_Piad' from the 'Claim_Headers' table, which is used as a condition in the WHERE clause."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "description": "This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.", "virtual_table": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)"}
{"sample_id": "train.1521", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the minimum amount of payment in one claim?", "rationale": ["The query identifies the relevant tables: 'Claim_Headers', 'Policies', and 'Customers'.", "It selects the 'customer_details' from the 'Customers' table.", "The query uses JOINs to connect 'Claim_Headers' to 'Policies' via 'policy_id', and 'Policies' to 'Customers' via 'customer_id'.", "A subquery is used to find the minimum 'amount_paid' from 'Claim_Headers', which is used as a condition in the WHERE clause."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "description": "This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.", "virtual_table": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)"}
{"sample_id": "train.1533", "db_id": "insurance_and_eClaims", "question": "Find the names of customers who either have an deputy policy or uniformed policy.", "rationale": ["The query identifies the relevant tables, which are 'Policies' and 'Customers'.", "It selects the 'customer_details' column from the 'Customers' table, ensuring that only distinct entries are returned.", "A JOIN operation is performed on the 'customer_id' to link the two tables based on the relationship defined in the foreign keys.", "The WHERE clause filters the results based on the 'policy_type_code', allowing for multiple policy types to be specified using placeholders."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy' OR t1.policy_type_code  =  'Uniform'", "source_tables": ["policies", "customers"], "description": "This virtual table provides a distinct list of customer details from the 'Customers' table for those customers who have specific types of insurance policies. The placeholders in the WHERE clause represent the policy type codes that the user can specify.", "virtual_table": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING] OR t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1536", "db_id": "insurance_and_eClaims", "question": "What are the names of the customers and staff members?", "rationale": ["The query is identifying the relevant tables, which are 'Customers' and 'Staff'.", "Using the UNION operator to combine results from both tables.", "Selecting the 'Customer_Details' from the 'Customers' table and 'Staff_Details' from the 'Staff' table to provide a unified view of details from both entities."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "description": "This virtual table combines detailed information about customers and staff members from the 'Customers' and 'Staff' tables. The placeholder in the SELECT statement allows for the retrieval of customer details and staff details, providing a comprehensive view of both entities.", "virtual_table": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff"}
{"sample_id": "train.1531", "db_id": "insurance_and_eClaims", "question": "Find the names of the customers who have an deputy policy.", "rationale": ["The query identifies the relevant tables, which are 'Policies' and 'Customers'.", "It uses a JOIN operation to link the 'Policies' table with the 'Customers' table based on the 'Customer_ID'.", "The SELECT DISTINCT statement is used to ensure that only unique customer details are returned.", "A condition is added to filter the results based on the 'Policy_Type_Code' using a placeholder for string values."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy'", "source_tables": ["policies", "customers"], "description": "This virtual table provides a distinct list of customer details from the 'Customers' table for those customers who hold a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code that is being queried.", "virtual_table": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
