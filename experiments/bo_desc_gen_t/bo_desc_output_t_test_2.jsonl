{"sample_id": "train.3697", "db_id": "baseball_1", "question": "List players' first name and last name who received salary from team Washington Nationals in both 2005 and 2007.", "rationale": ["The query identifies the relevant tables: 'salary', 'player', and 'team'.", "It selects the 'name_first' and 'name_last' columns from the 'player' table.", "The 'salary' table is joined with the 'player' table using the 'player_id' to link salary records to players.", "The 'team' table is joined to associate players with their respective teams using the 'team_id_br'.", "The WHERE clause filters results based on the specified year and team name using placeholders for user input.", "The INTERSECT operator is used to ensure that the results from both queries are the same, which is redundant in this case but indicates a specific requirement for the same year and team."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "description": "This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.", "virtual_table": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3699", "db_id": "baseball_1", "question": "How many home games did the team Boston Red Stockings play from 1990 to 2000 in total?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the sum of the 'games' column from the 'home_game' table.", "A join is performed between 'home_game' and 'team' on the 'team_id' to link the games to the specific team.", "A condition is added to filter by the team's name using a placeholder for string values.", "Another condition is added to filter the years using placeholders for numeric values."], "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"], "description": "This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.", "virtual_table": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the 'name' column from the 'team' table, which contains the names of the teams.", "A JOIN operation is performed between 'home_game' and 'team' on the 'team_id' to link home games with their respective teams.", "A condition is added to filter the results based on the specified year using a placeholder for numeric values.", "The results are ordered by the 'attendance' column in ascending order and limited to a specified number of results using placeholders."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "description": "This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.", "virtual_table": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3710", "db_id": "baseball_1", "question": "Which park did the most people attend in 2008?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It selects the 'park_name' from the 'park' table.", "A join is performed between 'home_game' and 'park' on the 'park_id' to link home games to their respective parks.", "A condition is added to filter the results for a specific year using a placeholder for numeric values.", "The results are ordered by attendance in descending order and limited to a specified number using placeholders."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "description": "This virtual table provides a list of park names where home games were played in a specific year, ordered by the total attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.", "virtual_table": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["The query identifies the relevant table, which is 'Department'.", "It selects the 'name' column to display the names of the departments.", "The results are grouped by 'departmentID' to aggregate the data based on unique department identifiers.", "The results are ordered by the count of 'departmentID' in descending order to show the most common departments first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "description": "The virtual table provides a list of department names from the 'Department' table, grouped by their unique identifiers. It orders the results by the count of each department's occurrences in descending order and limits the output to a specified number of results. The placeholder in the LIMIT clause represents the maximum number of department names to retrieve.", "virtual_table": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["The query identifies the relevant table, which is 'Department'.", "It selects the 'name' column to display the names of the departments.", "The GROUP BY clause is used to group the results by 'departmentID', ensuring that each department name appears only once in the results.", "The ORDER BY clause sorts the results based on the count of 'departmentID' in descending order, highlighting the most referenced departments.", "The LIMIT clause restricts the number of results returned, with a placeholder for the user to specify how many department names they want to see."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "description": "This virtual table provides a list of department names from the 'Department' table, grouped by their unique identifiers. The results are ordered by the count of occurrences of each department ID in descending order, allowing users to see the most frequently referenced departments. The placeholder in the LIMIT clause represents the maximum number of department names to return.", "virtual_table": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["The query identifies the relevant tables, which are 'Department' and 'Physician'.", "It selects the 'name' and 'position' columns from the 'Physician' table (aliased as T2).", "A JOIN operation is performed between 'Department' (aliased as T1) and 'Physician' (T2) on the condition that the head of the department matches the physician's EmployeeID.", "The results are grouped by 'departmentID' to aggregate the data appropriately.", "The results are ordered by the count of 'departmentID' to prioritize departments with more heads, and a limit is applied to control the number of results returned."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "description": "This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results based on the count of departments, with a limit on the number of results returned as specified by the placeholder.", "virtual_table": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["The query identifies the relevant tables, which are 'Appointment' and 'Patient'.", "It selects the 'name' column from the 'Patient' table.", "A join is performed between the 'Appointment' table and the 'Patient' table using the patient identifier and Social Security Number to associate appointments with patients."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "description": "This virtual table provides the names of patients associated with their appointments from the 'Appointment' and 'Patient' tables. The join condition links the patient identifier in the 'Appointment' table to the Social Security Number in the 'Patient' table.", "virtual_table": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn"}
{"sample_id": "train.3905", "db_id": "hospital_1", "question": "List the names of patients who have made appointments.", "rationale": ["The query identifies the relevant tables, which are 'Appointment' and 'Patient'.", "It selects the 'name' column from the 'Patient' table.", "A join is performed between the 'Appointment' table and the 'Patient' table using the patient identifier to match records, ensuring that only patients with appointments are included."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "description": "This virtual table provides the names of patients associated with their appointments from the 'Appointment' and 'Patient' tables. The join condition links the patient identifier in the 'Appointment' table to the Social Security Number in the 'Patient' table, allowing for the retrieval of patient names based on their scheduled appointments.", "virtual_table": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["The query identifies the relevant tables: 'Physician', 'Affiliated_With', and 'Department'.", "It selects the 'Name' column from the 'Physician' table and the 'Name' column from the 'Department' table.", "A JOIN operation is performed between 'Physician' and 'Affiliated_With' on the 'EmployeeID' and 'Physician' columns respectively.", "Another JOIN operation is performed between 'Affiliated_With' and 'Department' on the 'Department' and 'DepartmentID' columns respectively.", "A condition is added to filter the results based on the 'PrimaryAffiliation' column using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "description": "This virtual table describes the names of physicians along with the names of the departments they are affiliated with, specifically filtering for those whose affiliation is marked as primary. The placeholders in the WHERE clause represent the primary affiliation status.", "virtual_table": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3915", "db_id": "hospital_1", "question": "What are the name and primarily affiliated department name of each physician?", "rationale": ["The query identifies the relevant tables: 'Physician', 'Affiliated_With', and 'Department'.", "It selects the 'Name' column from the 'Physician' table and the 'Name' column from the 'Department' table.", "The JOIN operation connects 'Physician' and 'Affiliated_With' on the 'EmployeeID' and 'Physician' columns, respectively.", "Another JOIN connects 'Affiliated_With' and 'Department' on the 'Department' and 'DepartmentID' columns, respectively.", "A condition is added to filter the results based on the 'PrimaryAffiliation' column using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "description": "This virtual table describes the names of physicians along with the names of the departments they are affiliated with, specifically filtering for those whose affiliation is marked as primary. The placeholders in the WHERE clause represent the primary affiliation status.", "virtual_table": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3929", "db_id": "hospital_1", "question": "Return the name of each physician and the number of patients he or she treats.", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Patient'.", "It selects the 'Name' column from the 'Physician' table and counts the number of patients associated with each physician.", "A join is performed between the 'Physician' table and the 'Patient' table using the physician's employee ID and the patient's PCP identifier.", "The results are grouped by the physician's employee ID to provide a count of patients for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "description": "This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.", "virtual_table": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Patient'.", "It selects the 'Name' column from the 'Physician' table.", "A JOIN operation is performed between 'Physician' and 'Patient' on the condition that the physician's EmployeeID matches the patient's PCP identifier.", "The results are grouped by the physician's EmployeeID to aggregate the patient counts.", "The HAVING clause filters the results to include only those physicians who have more than a specified number of patients, using a placeholder for the numeric value."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "description": "This virtual table lists the names of physicians who are primary care physicians (PCP) for patients, specifically those who have more than a specified number of patients. The placeholder in the HAVING clause represents the minimum count of patients a physician must have to be included in the results.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3931", "db_id": "hospital_1", "question": "Which physicians are in charge of more than one patient? Give me their names.", "rationale": ["The query identifies the relevant tables, 'Physician' and 'Patient'.", "It selects the 'Name' column from the 'Physician' table.", "A JOIN operation is performed between 'Physician' and 'Patient' on the condition that the physician's EmployeeID matches the patient's PCP identifier.", "The results are grouped by the physician's EmployeeID to aggregate the patient counts.", "The HAVING clause filters the results to include only those physicians who have more patients than the specified number, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "description": "This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3934", "db_id": "hospital_1", "question": "Find the number of rooms for different block code?", "rationale": ["The query identifies the relevant tables, which are 'Block' and 'Room'.", "It selects a count of rooms and the block code from the 'Block' table.", "A JOIN operation is performed on the 'Block' and 'Room' tables based on matching block floor and block code values.", "The results are grouped by the block code to provide a summary count for each unique block code."], "gold_sql": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode", "source_tables": ["block", "room"], "description": "This virtual table provides a count of rooms grouped by their block code status from the 'Block' and 'Room' tables. The placeholders represent the block floor and block code statuses used for filtering the results.", "virtual_table": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["The query identifies the relevant tables, which are 'medication' and 'prescribes'.", "It selects a count of prescriptions and the name of the medication from the 'medication' table.", "The JOIN operation links the two tables based on the medication code, ensuring that only prescribed medications are counted.", "The GROUP BY clause organizes the results by the brand of the medication, allowing for a summary count per brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "description": "This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.", "virtual_table": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Prescribes'.", "It selects the 'Name' column from the 'Physician' table, aliased as T1.", "A JOIN operation is performed between 'Physician' (T1) and 'Prescribes' (T2) on the condition that the 'EmployeeID' from 'Physician' matches the 'Physician' identifier in 'Prescribes'.", "The results are ordered by the 'Dose' column from the 'Prescribes' table in descending order to show the highest dosages first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "description": "This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["The query identifies the relevant table, which is 'Affiliated_With'.", "Select the columns to display, 'physician' and 'department'.", "Add a condition to filter the 'primaryaffiliation' column for the specified status using a placeholder for numeric values."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "description": "This virtual table provides a list of physicians along with their associated departments from the 'Affiliated_With' table, filtered by whether the affiliation is marked as primary. The placeholder in the WHERE clause represents the primary affiliation status.", "virtual_table": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3961", "db_id": "hospital_1", "question": "What are each physician's employee id and department id primarily affiliated.", "rationale": ["The query identifies the relevant table, which is 'Affiliated_With'.", "Select the columns to display, 'physician' and 'department'.", "Add a condition to filter the 'primaryaffiliation' column for the specified status using a placeholder for numeric values."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "description": "This virtual table provides a list of physicians along with their associated departments from the 'Affiliated_With' table, filtered by whether the affiliation is marked as primary. The placeholder in the WHERE clause represents the primary affiliation status.", "virtual_table": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3970", "db_id": "hospital_1", "question": "Find the three most expensive procedures.", "rationale": ["The query identifies the relevant table, which is 'Procedures'.", "Select the column to display, 'name', which represents the names of the procedures.", "Order the results by the 'cost' column to sort the procedures based on their costs.", "Use a placeholder in the LIMIT clause to allow the user to specify how many procedure names they want to retrieve."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "description": "This virtual table lists the names of medical procedures from the 'Procedures' table, ordered by their associated costs. The placeholder in the LIMIT clause allows the user to specify the maximum number of procedure names to retrieve.", "virtual_table": "SELECT name FROM procedures ORDER BY cost LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["The query identifies the relevant table, which is 'Procedures'.", "Select the column to display, 'name', which represents the name of the medical procedure.", "Order the results by the 'cost' column to sort the procedures based on their associated costs.", "Use a placeholder in the LIMIT clause to allow the user to specify how many procedure names they want to retrieve."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "description": "This virtual table lists the names of medical procedures from the 'Procedures' table, ordered by their cost. The placeholder in the LIMIT clause allows the user to specify the maximum number of procedure names to retrieve.", "virtual_table": "SELECT name FROM procedures ORDER BY cost LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3973", "db_id": "hospital_1", "question": "Which physicians are trained in procedures that are more expensive than 5000?", "rationale": ["The query identifies the relevant tables: 'Physician', 'Trained_In', and 'Procedures'.", "It selects the 'Name' column from the 'Physician' table.", "The query joins 'Physician' with 'Trained_In' on the 'EmployeeID' and 'Physician' identifiers to link physicians with their training.", "It further joins 'Trained_In' with 'Procedures' on the 'Code' and 'Treatment' identifiers to associate procedures with their costs.", "A condition is added to filter procedures based on their cost, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "description": "This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["The query identifies the relevant tables: 'Physician', 'Trained_In', and 'Procedures'.", "It selects the 'Name' column from the 'Physician' table (aliased as T1).", "It joins the 'Trained_In' table (aliased as T2) on the condition that the 'EmployeeID' from 'Physician' matches the 'Physician' identifier in 'Trained_In'.", "It further joins the 'Procedures' table (aliased as T3) on the condition that the 'Code' from 'Procedures' matches the 'Treatment' identifier in 'Trained_In'.", "The results are ordered by the 'Cost' of the procedures in descending order, and a limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "description": "This virtual table lists the names of physicians who are trained in specific medical procedures, ordered by the cost of those procedures in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3985", "db_id": "hospital_1", "question": "What procedures cost less than 5000 and have John Wen as a trained physician?", "rationale": ["The query identifies the relevant table, which is 'Procedures', to select the names of procedures based on their cost.", "It uses a condition to filter procedures where the cost is less than a specified number using a placeholder.", "The query also intersects with another selection that involves joining the 'Physician' and 'Trained_In' tables to find procedures that a specific physician is trained in.", "The join condition links the physician's employee ID with the trained procedures, and the physician's name is filtered using a placeholder for string values."], "gold_sql": "SELECT name FROM procedures WHERE cost  <  5000 INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "description": "This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.", "virtual_table": "SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4321", "db_id": "tracking_grants_for_research", "question": "What are the different grant amounts for documents sent before '1986-08-26 20:49:27' and after the grant ended on '1989-03-16 18:27:16'?", "rationale": ["The query identifies the relevant tables, which are 'Grants' and 'Documents'.", "It selects the 'grant_amount' from the 'Grants' table.", "A JOIN operation is performed between 'Grants' and 'Documents' on the 'grant_id' to link the two tables.", "A condition is added to filter documents based on the 'sent_date' being earlier than a specified date using a placeholder for string values.", "An INTERSECT operation is used to ensure that the selected grant amounts are also from grants that have an 'end_date' later than another specified date, again using a placeholder for string values."], "gold_sql": "SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  '1986-08-26 20:49:27' INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  '1989-03-16 18:27:16'", "source_tables": ["grants", "documents"], "description": "This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.", "virtual_table": "SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4322", "db_id": "tracking_grants_for_research", "question": "List the project details of the project both producing patent and paper as outcomes.", "rationale": ["The query identifies the relevant table, which is 'Projects', and aliases it as T1.", "It joins the 'Project_Outcomes' table, aliased as T2, on the project_id to link projects with their outcomes.", "The WHERE clause filters the results based on the first outcome_code using a placeholder for string values.", "The INTERSECT operation is used to find projects that also meet a second outcome_code condition, again using a placeholder for string values."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.", "virtual_table": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["The query identifies the relevant tables: 'Grants', 'Organisations', and 'Organisation_Types'.", "It selects the sum of the 'grant_amount' from the 'Grants' table.", "The query joins 'Grants' with 'Organisations' on the 'organisation_id' to associate grants with their organisations.", "It further joins 'Organisations' with 'Organisation_Types' on 'organisation_type' to filter by organisation type.", "The WHERE clause uses a placeholder to specify the organisation type description for filtering the results."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "description": "This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter by the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.", "virtual_table": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects the columns 'date_from' and 'date_to' to show the involvement period of staff members.", "The first part of the query filters projects based on the count of staff members, using a subquery to get the top N projects.", "The second part of the query filters by a specific 'role_code', allowing for a focused view of staff involvement based on their roles."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "description": "This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the columns 'organisation_type' and 'organisation_id' from the 'Organisations' table.", "A JOIN operation is performed to connect 'Organisations' with 'Research_Staff' based on the employer organisation ID.", "The results are grouped by 'organisation_id' to aggregate the data.", "The results are ordered by the count of research staff in descending order to prioritize organisations with more staff.", "A LIMIT clause is added to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limiting the output to a specified number of results.", "virtual_table": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["The query identifies the relevant tables: 'Documents', 'Grants', 'Organisations', and 'Organisation_Types'.", "It selects the 'sent_date' from the 'Documents' table.", "Joins are established between 'Documents' and 'Grants' on 'grant_id', between 'Grants' and 'Organisations' on 'organisation_id', and between 'Organisations' and 'Organisation_Types' on 'organisation_type'.", "A condition is added to filter grants with a specified amount using a placeholder for numeric values.", "Another condition filters the organisation type description using a placeholder for string values."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "description": "This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter based on the type of organisation. The placeholders represent the grant amount and the organisation type description.", "virtual_table": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER] AND T4.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4338", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects which did not hire any staff for a researcher role.", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "It selects the 'project_details' column to display information about the projects.", "The WHERE clause filters out projects that have staff members with a specific role by using a subquery on the 'Project_Staff' table, where the role code is represented by a placeholder for string values."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "description": "This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.", "virtual_table": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4339", "db_id": "tracking_grants_for_research", "question": "What are the details for all projects that did not hire any staff in a research role?", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "It selects the 'project_details' column to display information about the projects.", "The WHERE clause filters out projects that have staff members with a specific role by using a subquery on the 'Project_Staff' table, where the role code is represented by a placeholder for string values."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "description": "This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.", "virtual_table": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4342", "db_id": "tracking_grants_for_research", "question": "When do all the researcher role staff start to work, and when do they stop working?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "Select the columns to display, 'date_from' and 'date_to', which represent the involvement period of staff members.", "Add a condition to filter the 'role_code' column for the specified role using a placeholder for string values."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "description": "This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4350", "db_id": "tracking_grants_for_research", "question": "How many staff does each project has? List the project id and the number in an ascending order.", "rationale": ["The query identifies the relevant tables, which are 'Project_Staff' and 'Projects'.", "It selects the 'project_id' from 'Project_Staff' and counts the number of staff members associated with each project.", "The JOIN operation links 'Project_Staff' to 'Projects' using the 'project_id' to ensure that the count corresponds to the correct project.", "The results are grouped by 'project_id' to aggregate the count of staff members for each project.", "Finally, the results are ordered in ascending order based on the count of staff members."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "description": "This virtual table provides a count of staff members associated with each project from the 'Project_Staff' table, grouped by project ID. The results are ordered in ascending order based on the number of staff members per project.", "virtual_table": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC"}
{"sample_id": "train.4351", "db_id": "tracking_grants_for_research", "question": "For each project id, how many staff does it have? List them in increasing order.", "rationale": ["The query identifies the relevant tables, which are 'Project_Staff' and 'Projects'.", "It selects the 'project_id' from 'Project_Staff' and counts the number of staff members associated with each project.", "The JOIN operation links 'Project_Staff' to 'Projects' using the 'project_id' to ensure that the count corresponds to the correct project.", "The results are grouped by 'project_id' to aggregate the count of staff members for each project.", "Finally, the results are ordered in ascending order based on the count of staff members."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "description": "This virtual table provides a count of staff members associated with each project from the 'Project_Staff' table, grouped by project ID. The results are ordered in ascending order based on the number of staff members per project.", "virtual_table": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["The query identifies the relevant tables, 'Projects' and 'Project_Outcomes'.", "It selects the 'project_details' and 'project_id' from the 'Projects' table.", "A JOIN operation is performed between 'Projects' and 'Project_Outcomes' on the 'project_id' to link projects with their outcomes.", "The results are grouped by 'project_id' to aggregate the outcomes for each project.", "The results are ordered by the count of outcomes in descending order to prioritize projects with more outcomes.", "A LIMIT clause is included to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.", "virtual_table": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4359", "db_id": "tracking_grants_for_research", "question": "What are the details of the project with no outcomes?", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "It selects the 'project_details' column to display information about the projects.", "A subquery is used to filter out project IDs that exist in the 'Project_Outcomes' table, ensuring that only projects without outcomes are included in the results."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated outcomes in the 'Project_Outcomes' table. The query uses a subquery to filter out projects that have recorded outcomes, ensuring that only projects without outcomes are displayed.", "virtual_table": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the columns 'organisation_id', 'organisation_type', and 'organisation_details' from the 'Organisations' table.", "A JOIN operation is performed between 'Organisations' and 'Research_Staff' on the condition that the organisation ID matches the employer organisation ID.", "The results are grouped by 'organisation_id' to aggregate the data for each organisation.", "The results are ordered by the count of research staff in descending order to prioritize organisations with more staff.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned as specified by the placeholder.", "virtual_table": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["The query identifies the relevant tables: 'Staff_Roles', 'Project_Staff', and 'Project_Outcomes'.", "It selects the 'role_description' from 'Staff_Roles' and 'staff_id' from 'Project_Staff'.", "The JOIN operation connects 'Staff_Roles' and 'Project_Staff' on the 'role_code'.", "Another JOIN connects 'Project_Staff' to 'Project_Outcomes' on 'project_id'.", "The results are grouped by 'staff_id' to aggregate the data.", "The results are ordered by the count of outcomes associated with each staff member in descending order.", "A LIMIT clause is added to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "description": "This virtual table provides a list of staff members along with their role descriptions from the 'Staff_Roles' and 'Project_Staff' tables. It joins these tables based on the role code and further connects to the 'Project_Outcomes' table to group the results by staff ID. The results are ordered by the count of associated outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.", "virtual_table": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4364", "db_id": "tracking_grants_for_research", "question": "Which document type is described with the prefix 'Initial'?", "rationale": ["The query identifies the relevant table, which is 'Document_Types'.", "It selects the column 'document_type_code' to display the unique codes.", "A condition is added to filter the results based on the 'document_description' using a placeholder for string values."], "gold_sql": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'", "source_tables": ["document_types"], "description": "This virtual table retrieves the unique document type codes from the 'Document_Types' table based on a specific description of the document type. The placeholder in the WHERE clause allows for filtering the results according to the desired document description.", "virtual_table": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It selects the 'grant_id' and counts the number of documents associated with each grant using the COUNT function.", "The results are grouped by 'grant_id' to aggregate the document counts for each grant.", "The results are ordered in descending order based on the count of documents to show the grants with the most documents first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "description": "This virtual table summarizes the number of documents associated with each grant from the 'Documents' table. It groups the results by 'grant_id' and orders them in descending order based on the count of documents, allowing the user to specify a limit on the number of results returned.", "virtual_table": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4374", "db_id": "tracking_grants_for_research", "question": "How many Patent outcomes are generated from all the projects?", "rationale": ["The query identifies the relevant table, which is 'Project_Outcomes'.", "It uses the COUNT function to count the number of records that meet the specified condition.", "A condition is added to filter the results based on the 'outcome_code' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  'Patent'", "source_tables": ["project_outcomes"], "description": "This virtual table provides the count of project outcomes from the 'Project_Outcomes' table that match a specific outcome code. The placeholder in the WHERE clause represents the outcome code being queried.", "virtual_table": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4376", "db_id": "tracking_grants_for_research", "question": "How many project staff worked as leaders or started working before '1989-04-24 23:51:54'?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects a count of all records in the table.", "The WHERE clause includes conditions to filter by 'role_code' and 'date_from', using placeholders for string values."], "gold_sql": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'", "source_tables": ["project_staff"], "description": "This virtual table provides a count of staff members associated with projects, filtered by a specific role code or a start date that is earlier than a specified date. The placeholders in the WHERE clause represent the role code and the date for filtering the results.", "virtual_table": "SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["The query identifies the relevant tables: 'Research_Outcomes', 'Project_Outcomes', and 'Projects'.", "It selects the 'outcome_description' from the 'Research_Outcomes' table.", "The JOIN operations link the 'Research_Outcomes' to 'Project_Outcomes' using the 'outcome_code', and 'Project_Outcomes' to 'Projects' using the 'project_id'.", "A condition is added to filter the results based on the 'project_details' column from the 'Projects' table, using a placeholder for string values."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "description": "This virtual table describes the outcome descriptions of research outcomes associated with specific projects. The query joins the 'Research_Outcomes' table with the 'Project_Outcomes' table and the 'Projects' table to filter the results based on the project details. The placeholder in the WHERE clause represents the specific project details being queried.", "virtual_table": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["The query identifies the relevant tables: 'Research_Outcomes', 'Project_Outcomes', and 'Projects'.", "It selects the 'outcome_description' from the 'Research_Outcomes' table.", "The JOIN operations link the 'Research_Outcomes' to 'Project_Outcomes' using the 'outcome_code', and 'Project_Outcomes' to 'Projects' using the 'project_id'.", "A condition is added to filter the results based on the 'project_details' column from the 'Projects' table, using a placeholder for string values."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "description": "This virtual table describes the outcome descriptions of research outcomes associated with specific projects. The query joins the 'Research_Outcomes' table with the 'Project_Outcomes' table and the 'Projects' table to filter the results based on the project details. The placeholder in the WHERE clause represents the specific project details being queried.", "virtual_table": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4385", "db_id": "tracking_grants_for_research", "question": "What are the details for the projects which were launched by the organization with the most projects?", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "It selects the 'project_details' column to display information about the projects.", "The WHERE clause filters the results to include only those organisations that have the highest number of projects, using a subquery that groups by 'organisation_id' and orders by the count of projects in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many top organisations to include in the results."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "description": "This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.", "virtual_table": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.4391", "db_id": "tracking_grants_for_research", "question": "For each project id, how many tasks are there?", "rationale": ["The query identifies the relevant tables, which are 'Projects' and 'Tasks'.", "It selects the count of tasks and the project details from the 'Projects' table.", "A JOIN operation is performed on the 'project_id' to link tasks to their respective projects.", "The results are grouped by 'project_id' to aggregate the task counts for each project."], "gold_sql": "SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id", "source_tables": ["tasks", "projects"], "description": "This virtual table provides a count of tasks associated with each project from the 'Projects' table, along with the project details. The count is grouped by the unique project identifier, allowing users to see how many tasks are linked to each project.", "virtual_table": "SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "Select the column to display, 'role_code'.", "Add conditions to filter the 'date_from' and 'date_to' columns for the specified date range using placeholders for string values."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "description": "This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.", "virtual_table": "SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects the 'role_code' column to display unique role codes.", "The results are grouped by 'role_code' to ensure uniqueness.", "The results are ordered by the count of occurrences of each role code in descending order to prioritize the most common roles.", "A placeholder is included in the LIMIT clause to allow the user to specify how many role codes they want to retrieve."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "description": "This virtual table provides a list of unique role codes from the 'Project_Staff' table, grouped by the role code and ordered by the number of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of role codes to retrieve.", "virtual_table": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["The query identifies the relevant table, which is 'Products'.", "It uses the COUNT function to count the number of products that meet specific criteria.", "The WHERE clause filters products based on the 'product_category_code' and checks if the 'typical_buying_price' is greater than a specified value, using placeholders for both the category code and the price."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "description": "This virtual table provides the count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.", "virtual_table": "SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["The query identifies the relevant tables, which are 'Ref_Product_Categories' and 'Products'.", "It selects the 'product_category_description' from 'Ref_Product_Categories'.", "A JOIN is performed between 'Ref_Product_Categories' and 'Products' on the 'product_category_code' to link the product categories with their respective products.", "A condition is added to filter the results based on the 'product_description' using a placeholder for string values."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "description": "This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.", "virtual_table": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5576", "db_id": "products_gen_characteristics", "question": "Count the products that have the color description \"white\" or have the characteristic name \"hot\".", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors'.", "It uses JOIN operations to connect these tables based on their foreign key relationships.", "The SELECT statement counts the total number of products that meet the specified conditions.", "The WHERE clause filters the results based on the color description or characteristic name, using placeholders for string values."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "description": "This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from the 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors' tables, using joins to link the relevant identifiers and applying filters based on the provided placeholders.", "virtual_table": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["The query identifies the relevant table, which is 'Ref_Product_Categories'.", "Select the column to display, 'unit_of_measure'.", "Add a condition to filter the 'product_category_code' column for the specified product category using a placeholder for string values."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "description": "This virtual table provides the unit of measure for a specific product category from the 'Ref_Product_Categories' table. The placeholder in the WHERE clause represents the unique code for the product category.", "virtual_table": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["The query identifies the relevant tables, 'Products' and 'Ref_Product_Categories'.", "It selects the columns 'unit_of_measure' and 'product_category_code' from the 'Ref_Product_Categories' table.", "A JOIN operation is performed on the 'product_category_code' to link the 'Products' table with the 'Ref_Product_Categories' table.", "A condition is added to filter the results based on the specified product name using a placeholder for string values."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "description": "This virtual table provides the unit of measure and product category code for a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.", "virtual_table": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5589", "db_id": "products_gen_characteristics", "question": "What are the names of products that are not 'white' in color and are not measured by the unit 'Handful'?", "rationale": ["The query identifies the relevant tables: 'Products', 'Ref_Product_Categories', and 'Ref_Colors'.", "It selects the 'product_name' from the 'Products' table.", "The JOIN operations link the 'Products' table with 'Ref_Product_Categories' and 'Ref_Colors' based on their respective codes.", "The WHERE clause filters the results based on the specified color description and excludes products with a certain unit of measure using placeholders."], "gold_sql": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  'white' AND t2.unit_of_measure != 'Handful'", "source_tables": ["products", "ref_colors", "ref_product_categories"], "description": "This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure that should be excluded.", "virtual_table": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["The query identifies the relevant tables, 'Products' and 'Ref_Colors'.", "It selects the 'color_description' from the 'Ref_Colors' table.", "A JOIN operation is performed on the 'color_code' to link products with their respective colors.", "The results are grouped by 'color_description' to aggregate the data based on color.", "The ORDER BY clause sorts the results by the count of products associated with each color in ascending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many color descriptions to return."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "description": "This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the count of products associated with each color. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.", "virtual_table": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', and 'Characteristics'.", "It selects the 'characteristic_name' from the 'Characteristics' table.", "The JOIN operations link the 'Products' table to 'Product_Characteristics' and then to 'Characteristics' based on their respective IDs.", "The results are grouped by 'characteristic_name' to aggregate the data.", "The HAVING clause filters the results to include only those characteristic names that have a count of associated products greater than or equal to a specified number using a placeholder."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "description": "This virtual table describes the names of characteristics associated with products from the 'Products' table. It retrieves characteristic names by joining the 'Products', 'Product_Characteristics', and 'Characteristics' tables. The results are grouped by characteristic name, and only those with a count of associated products greater than or equal to a specified number are included. The placeholder in the HAVING clause represents the minimum count of products for the characteristic names to be displayed.", "virtual_table": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5669", "db_id": "dorm_1", "question": "What are the names of the all-female dorms?", "rationale": ["The query is identifying the relevant table, which is 'Dorm'.", "Select the column to display, 'dorm_name'.", "Add a condition to filter the 'gender' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT dorm_name FROM dorm WHERE gender  =  'F'", "source_tables": ["dorm"], "description": "This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.", "virtual_table": "SELECT dorm_name FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5688", "db_id": "dorm_1", "question": "Find the average and total capacity of dorms for the students with gender X.", "rationale": ["The query identifies the relevant table, which is 'Dorm'.", "It selects the average and sum of the 'student_capacity' column.", "A condition is added to filter the 'gender' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  'X'", "source_tables": ["dorm"], "description": "This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.", "virtual_table": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5699", "db_id": "dorm_1", "question": "What are the names and types of the dorms that have a capacity greater than 300 or less than 100?", "rationale": ["The query identifies the relevant table, which is 'Dorm'.", "Select the columns to display, 'dorm_name' and 'gender'.", "Add a condition to filter the 'student_capacity' column for values greater than or less than the specified number using placeholders for numeric values."], "gold_sql": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100", "source_tables": ["dorm"], "description": "This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.", "virtual_table": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] OR student_capacity  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["The query identifies the relevant tables: 'student', 'lives_in', and 'dorm'.", "It joins the 'student' table with the 'lives_in' table on the student ID to associate students with their dormitory.", "Then, it joins the 'dorm' table to access the gender designation of the dormitories.", "Finally, it counts the number of students filtered by the specified gender using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "description": "This virtual table provides the count of students residing in dormitories based on gender designation. The placeholders in the WHERE clause represent the gender of the dormitory.", "virtual_table": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5755", "db_id": "dorm_1", "question": "What is the most common amenity in the dorms?", "rationale": ["The query identifies the relevant tables, 'dorm_amenity' and 'has_amenity'.", "It selects the 'amenity_name' from the 'dorm_amenity' table.", "A JOIN operation is performed on 'has_amenity' to link amenities to dormitories using their identifiers.", "The results are grouped by the amenity identifier to aggregate the data.", "The results are ordered by the count of occurrences in descending order to show the most common amenities first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_amenity", "dorm_amenity"], "description": "The virtual table describes the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to be displayed.", "virtual_table": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5757", "db_id": "dorm_1", "question": "What are the first names of all students who live in the dorm with the most amenities?", "rationale": ["The query identifies the relevant tables, which are 'Student', 'Lives_in', 'Dorm', 'Has_amenity', and 'Dorm_amenity'.", "It selects the 'fname' column from the 'Student' table.", "The query joins 'Student' with 'Lives_in' to find which students live in which dorms.", "A subquery is used to find dorms with the most amenities by joining 'Dorm', 'Has_amenity', and 'Dorm_amenity', counting the amenities for each dorm, and ordering them.", "The LIMIT clause uses a placeholder for the maximum number of dormitories to return."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "description": "This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.", "virtual_table": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.5776", "db_id": "customer_complaints", "question": "Find the emails of customers who has filed a complaints of the product with the most complaints.", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Complaints'.", "It selects the 'email_address' from the 'Customers' table.", "A JOIN operation is performed between 'Customers' and 'Complaints' on the 'customer_id' to link customers with their complaints.", "The results are grouped by 'customer_id' to aggregate the complaints per customer.", "The results are ordered by the count of complaints to prioritize customers with more complaints.", "A LIMIT clause is included to restrict the number of results returned based on a numeric placeholder."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "description": "This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited by a specified numeric placeholder.", "virtual_table": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Complaints'.", "It selects the 'email_address' from the 'Customers' table, aliased as 't1'.", "A JOIN operation is performed between 'Customers' and 'Complaints' on the 'customer_id' to link customers with their complaints.", "The results are grouped by 'customer_id' to ensure unique email addresses are returned for each customer.", "The results are ordered by the count of complaints to prioritize customers with more complaints.", "A LIMIT clause is included to restrict the number of results returned based on a specified number."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "description": "This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited by a specified number.", "virtual_table": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5779", "db_id": "customer_complaints", "question": "Return the names of products that have had complaints filed by the customer who has filed the fewest complaints.", "rationale": ["The query identifies the relevant tables: 'Products', 'Complaints', and 'Customers'.", "It selects distinct product names from the 'Products' table.", "The join condition links the 'Products' table to the 'Complaints' table using the product identifier.", "The query groups the results by customer identifiers to ensure unique customer counts.", "The results are ordered by the count of complaints associated with each product, and a placeholder is included to limit the number of results returned."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "description": "This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers to ensure that each customer is counted only once. The results are ordered by the count of complaints, and a placeholder is included to limit the number of results returned.", "virtual_table": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["The query identifies the relevant tables: 'staff', 'complaints', and 'products'.", "It selects the 'last_name' column from the 'staff' table.", "The query joins the 'staff' table with the 'complaints' table on the 'staff_id' to link staff members to the complaints they handle.", "It further joins the 'complaints' table with the 'products' table on the 'product_id' to associate complaints with the respective products.", "The results are ordered by the 'product_price' from the 'products' table, ensuring that the staff names are listed according to the price of the products involved in the complaints.", "The LIMIT clause uses a placeholder for a numeric value to allow users to specify how many results they want."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "description": "This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5800", "db_id": "customer_complaints", "question": "How many customers are there in the customer type with the most customers?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It uses the COUNT function to count the number of customers for each type, grouping the results by 'customer_type_code'.", "The results are ordered in descending order based on the count of customers, allowing the most common customer types to appear first.", "A LIMIT clause is included to restrict the number of results returned, with a placeholder for the user to specify the desired number."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.", "virtual_table": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["The query identifies the relevant tables, 'Staff' and 'Complaints'.", "It selects the 'first_name' column from the 'Staff' table, aliased as 't1'.", "A JOIN operation is performed between 'Staff' and 'Complaints' on the 'staff_id' column to link staff members to the complaints they handle.", "The results are grouped by 'staff_id' to aggregate the data for each staff member.", "The results are ordered by the count of complaints handled by each staff member, allowing us to see who has the most complaints.", "A LIMIT clause is included to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "description": "This virtual table provides the first names of staff members from the 'Staff' table who are associated with complaints in the 'Complaints' table. The results are grouped by staff member and ordered by the number of complaints they have handled, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5812", "db_id": "customer_complaints", "question": "Which state has the most customers?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'state' column to display the states of customers.", "The results are grouped by 'state' to aggregate customer counts per state.", "The results are ordered by the count of customers in each state to prioritize states with more customers.", "The LIMIT clause uses a placeholder to allow the user to specify how many states to return."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "description": "This virtual table summarizes the states where customers reside, grouping the results by state and ordering them by the number of customers in each state. The placeholder in the LIMIT clause allows for specifying the maximum number of states to return.", "virtual_table": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5813", "db_id": "customer_complaints", "question": "Give the state that has the most customers.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'state' column to display the states of the customers.", "The results are grouped by 'state' to aggregate customer counts per state.", "The results are ordered by the count of customers in each state to prioritize states with more customers.", "The LIMIT clause uses a placeholder to allow the user to specify how many states to return."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "description": "This virtual table summarizes the states where customers reside, grouping the results by state and ordering them by the number of customers in each state. The placeholder in the LIMIT clause allows for specifying the maximum number of states to return.", "virtual_table": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5865", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions whose share count is bigger than 100 and whose type code is \"PUR\"?", "rationale": ["The query identifies the relevant tables: 'Lots', 'Transactions_Lots', and 'Transactions'.", "It selects the 'lot_details' from the 'Lots' table.", "The query uses JOINs to connect 'Lots' with 'Transactions_Lots' and 'Transactions' based on their respective identifiers.", "A condition is added to filter the results based on the 'share_count' and 'transaction_type_code', using placeholders for numeric and string values."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  100 AND T3.transaction_type_code  =  'PUR'", "source_tables": ["lots", "transactions_lots", "transactions"], "description": "This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.", "virtual_table": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "It selects the 'transaction_type_code' to categorize the transactions.", "The query calculates the average of 'amount_of_transaction' for each transaction type.", "The GROUP BY clause is used to group the results by 'transaction_type_code' to get the average amount for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "description": "This virtual table summarizes the average amount of transactions grouped by their respective transaction types from the 'Transactions' table. The placeholder in the SELECT clause represents the transaction type code, while the average amount is calculated for each type.", "virtual_table": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code"}
{"sample_id": "train.5873", "db_id": "tracking_share_transactions", "question": "Show the number of transactions with transaction type code \"SALE\" for different investors if it is larger than 0.", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "It selects the 'investor_id' and counts the number of transactions for each investor.", "A condition is added to filter the transactions based on the specified transaction type using a placeholder for string values.", "The results are grouped by 'investor_id' to provide a count of transactions per investor."], "gold_sql": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  'SALE' GROUP BY investor_id", "source_tables": ["transactions"], "description": "This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.", "virtual_table": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY investor_id"}
{"sample_id": "train.5876", "db_id": "tracking_share_transactions", "question": "Show the transaction type code that occurs the most frequently.", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "It selects the 'transaction_type_code' to display the unique types of transactions.", "The GROUP BY clause is used to group the results by 'transaction_type_code'.", "The ORDER BY clause sorts the grouped results based on the count of each transaction type in descending order.", "The LIMIT clause restricts the number of results returned to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["transactions"], "description": "This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.", "virtual_table": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5884", "db_id": "tracking_share_transactions", "question": "What are the details of the lots which are not used in any transactions?", "rationale": ["The query identifies the relevant table, which is 'Lots'.", "It selects the 'lot_details' column from the 'Lots' table.", "The EXCEPT clause is used to filter out lot details that are linked to transactions by joining the 'Lots' table with the 'Transactions_Lots' table on the 'lot_id' column."], "gold_sql": "SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id", "source_tables": ["lots", "transactions_lots"], "description": "This virtual table provides the details of lots from the 'Lots' table that are not associated with any transactions. The query uses an EXCEPT clause to exclude lot details that are linked to transactions through the 'Transactions_Lots' table.", "virtual_table": "SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id"}
{"sample_id": "train.5893", "db_id": "cre_Theme_park", "question": "Show details of all visitors.", "rationale": ["The query identifies the relevant table, which is 'Visitors'.", "Select the column to display, 'Tourist_Details'."], "gold_sql": "SELECT Tourist_Details FROM VISITORS", "source_tables": ["visitors"], "description": "This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.", "virtual_table": "SELECT Tourist_Details FROM VISITORS"}
{"sample_id": "train.5901", "db_id": "cre_Theme_park", "question": "What is the detail of the location UK Gallery?", "rationale": ["The query identifies the relevant table, which is 'Locations'.", "Select the column to display, 'Other_Details'.", "Add a condition to filter the 'Location_Name' column for the specified location using a placeholder for string values."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "description": "This virtual table provides additional information about a specific location from the 'Locations' table based on the location's name. The placeholder in the WHERE clause represents the name of the location being queried.", "virtual_table": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5902", "db_id": "cre_Theme_park", "question": "Return the detail of the location named \"UK Gallery\".", "rationale": ["The query identifies the relevant table, which is 'Locations'.", "Select the column to display, 'Other_Details'.", "Add a condition to filter the 'Location_Name' column for the specified location using a placeholder for string values."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "description": "This virtual table provides additional information about a specific location from the 'Locations' table based on the location's name. The placeholder in the WHERE clause represents the name of the location being queried.", "virtual_table": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5914", "db_id": "cre_Theme_park", "question": "Give me the star rating descriptions of the hotels that cost more than 10000.", "rationale": ["The query identifies the relevant tables, which are 'Hotels' and 'Ref_Hotel_Star_Ratings'.", "It selects the 'star_rating_description' from the 'Ref_Hotel_Star_Ratings' table.", "A JOIN operation is performed on the 'star_rating_code' to link the two tables based on their relationship.", "A condition is added to filter hotels based on their 'price_range', using a placeholder for numeric values."], "gold_sql": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  10000", "source_tables": ["ref_hotel_star_ratings", "hotels"], "description": "This virtual table describes the star rating descriptions of hotels from the 'Ref_Hotel_Star_Ratings' table that have a price range above a specified value. The placeholder in the WHERE clause represents the price range threshold.", "virtual_table": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["The query identifies the relevant tables, which are 'Museums' and 'Tourist_Attractions'.", "It selects the 'Museum_Details' from the 'Museums' table and 'Opening_Hours' from the 'Tourist_Attractions' table.", "A JOIN operation is performed on the 'Museum_ID' from the 'Museums' table and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table to link the two tables based on their relationship."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "description": "This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.", "virtual_table": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["The query identifies the relevant tables, which are 'Royal_Family' and 'Tourist_Attractions'.", "It selects the 'Royal_Family_Details' from the 'Royal_Family' table and 'How_to_Get_There' from the 'Tourist_Attractions' table.", "A join operation is performed on the 'Royal_Family_ID' from the 'Royal_Family' table and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table to link the two tables based on their relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "description": "This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The join operation links the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for royal family entries and the tourist attraction ID.", "virtual_table": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.5924", "db_id": "cre_Theme_park", "question": "Find the details of the shops that can be reached by walk.", "rationale": ["The query identifies the relevant tables, which are 'SHOPS' and 'TOURIST_ATTRACTIONS'.", "It selects the 'Shop_Details' column from the 'SHOPS' table.", "A JOIN operation is performed to link 'SHOPS' with 'TOURIST_ATTRACTIONS' based on the matching 'Shop_ID' and 'Tourist_Attraction_ID'.", "A condition is added to filter the results based on the 'How_to_Get_There' column from the 'TOURIST_ATTRACTIONS' table, using a placeholder for string values."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "description": "This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.", "virtual_table": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5927", "db_id": "cre_Theme_park", "question": "What are the details of the markets that can be accessed by walk or bus?", "rationale": ["The query identifies the relevant tables, 'Street_Markets' and 'Tourist_Attractions'.", "It selects the 'Market_Details' from the 'Street_Markets' table.", "A JOIN operation is performed to link 'Street_Markets' with 'Tourist_Attractions' using the 'Market_ID' and 'Tourist_Attraction_ID'.", "Conditions are added to filter the results based on the 'How_to_Get_There' column from 'Tourist_Attractions', allowing for two different sets of instructions using placeholders."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "description": "This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.", "virtual_table": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5928", "db_id": "cre_Theme_park", "question": "Find the details of all the markets that are accessible by walk or bus.", "rationale": ["The query identifies the relevant tables, 'Street_Markets' and 'Tourist_Attractions'.", "It selects the 'Market_Details' from the 'Street_Markets' table.", "A JOIN operation is performed to link 'Street_Markets' with 'Tourist_Attractions' based on the matching 'Market_ID' and 'Tourist_Attraction_ID'.", "The WHERE clause filters the results based on the 'How_to_Get_There' column from 'Tourist_Attractions', allowing for two different methods of access using placeholders."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "description": "This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access using placeholders.", "virtual_table": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Select the column to display, 'other_hotel_details'.", "Order the results by 'price_range' in descending order to show the most expensive hotels first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "description": "This virtual table provides additional details about hotels from the 'Hotels' table, sorted by their price range in descending order. The placeholder in the LIMIT clause represents the maximum number of hotel details to retrieve.", "virtual_table": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5943", "db_id": "cre_Theme_park", "question": "Show the details and star ratings of the 3 least expensive hotels.", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Selects the columns 'other_hotel_details' and 'star_rating_code' to display information about the hotels.", "Orders the results by 'price_range' in ascending order to show cheaper hotels first.", "Limits the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "description": "This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["The query identifies the relevant table, which is 'Tourist_Attractions'.", "Select the column 'How_to_Get_There' to display the instructions for reaching attractions.", "Group the results by 'How_to_Get_There' to consolidate similar instructions.", "Order the results by the count of occurrences of each instruction in descending order to prioritize the most common ones.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "description": "This virtual table provides a list of instructions on how to reach various tourist attractions, grouped by the unique directions available. The results are ordered by the frequency of each instruction, allowing users to see the most common ways to get to attractions. The placeholder in the LIMIT clause represents the maximum number of instructions to retrieve.", "virtual_table": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["The query identifies the relevant table, which is 'Tourist_Attractions'.", "Select the column 'How_to_Get_There' to display the instructions for reaching attractions.", "Group the results by 'How_to_Get_There' to consolidate similar instructions.", "Order the results by the count of occurrences of each instruction in descending order to prioritize the most common ones.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "description": "This virtual table provides a list of instructions on how to reach various tourist attractions, grouped by the unique directions available. The results are ordered by the frequency of each instruction, allowing users to see the most common ways to get to attractions. The placeholder in the LIMIT clause represents the maximum number of instructions to retrieve.", "virtual_table": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5951", "db_id": "cre_Theme_park", "question": "Show different tourist attractions' names, ids, and the corresponding number of visits.", "rationale": ["The query identifies the relevant tables, which are 'Tourist_Attractions' and 'Visits'.", "It selects the 'Name' of the tourist attraction from 'Tourist_Attractions' and the 'Tourist_Attraction_ID' from 'Visits'.", "The COUNT function is used to count the number of visits for each attraction.", "The JOIN operation links the two tables on the 'Tourist_Attraction_ID' to associate visits with their respective attractions.", "Finally, the results are grouped by 'Tourist_Attraction_ID' to aggregate the visit counts for each attraction."], "gold_sql": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID", "source_tables": ["visits", "tourist_attractions"], "description": "This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.", "virtual_table": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Tourist_Attraction_Features', and 'Features'.", "It selects the 'Name' column from the 'Tourist_Attractions' table.", "The JOIN operations link the tables based on their foreign key relationships, ensuring that only attractions with the specified features are included.", "The WHERE clause filters the results based on the feature details, using placeholders for the specific feature descriptions. The UNION operator allows for combining results from two similar queries, each filtering by a different feature detail."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "description": "This virtual table lists the names of tourist attractions that feature specific characteristics. The query combines results from the 'Tourist_Attractions', 'Tourist_Attraction_Features', and 'Features' tables, filtering based on the details of the features. The placeholders in the WHERE clause represent the specific feature details being queried.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Tourist_Attraction_Features', and 'Features'.", "It selects the 'Name' column from the 'Tourist_Attractions' table.", "The JOIN operations link the tables based on their foreign key relationships, ensuring that only attractions with the specified features are included.", "The WHERE clause filters the results based on the feature details, using placeholders for the specific feature descriptions. The UNION operator allows for combining results from two similar queries, each filtering by a different feature detail."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "description": "This virtual table lists the names of tourist attractions that feature specific characteristics. The query combines results from the 'Tourist_Attractions', 'Tourist_Attraction_Features', and 'Features' tables, filtering based on the details of the features. The placeholders in the WHERE clause represent the specific feature details being queried.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5964", "db_id": "cre_Theme_park", "question": "Which tourist attractions do the tourists Vincent and Marcelle visit? Tell me the names of the attractions.", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Visitors', and 'Visits'.", "It selects the 'Name' of the tourist attractions from the 'Tourist_Attractions' table.", "The JOIN operations link the 'Tourist_Attractions' with 'Visitors' and 'Visits' to filter the attractions based on the tourists' details.", "The WHERE clause uses placeholders to specify the details of the tourists being compared.", "The INTERSECT operator is used to find common attractions visited by both tourists."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of the tourists being compared.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6059", "db_id": "customers_and_addresses", "question": "What is the average amount of items ordered in each order?", "rationale": ["The query identifies the relevant table, which is 'Order_Items'.", "It selects the average of the 'order_quantity' column to provide a summary statistic.", "The use of the aggregate function 'avg()' indicates that we are interested in the average value of the specified column."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "description": "This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The placeholder in the SELECT clause represents the average of the order quantities.", "virtual_table": "SELECT avg(order_quantity) FROM order_items"}
{"sample_id": "train.6066", "db_id": "customers_and_addresses", "question": "Find the payment method that is used most frequently.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'payment_method' column to display the preferred payment methods.", "The results are grouped by 'payment_method' to aggregate the data.", "The query orders the results by the count of each payment method in descending order to show the most popular methods first.", "A limit is applied to restrict the number of payment methods returned, using a placeholder for numeric values."], "gold_sql": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "This virtual table summarizes the preferred payment methods used by customers from the 'Customers' table. It groups the results by payment method and orders them by the frequency of each method, allowing the user to specify a limit on the number of payment methods returned.", "virtual_table": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["The query identifies the relevant tables: 'Customers', 'Customer_Addresses', and 'Addresses'.", "It selects the 'city' column from the 'Addresses' table.", "The query joins the 'Customers' table with 'Customer_Addresses' on 'customer_id' and then joins 'Customer_Addresses' with 'Addresses' on 'address_id'.", "The results are grouped by 'city' to aggregate the number of customers in each city.", "The results are ordered by the count of customers in descending order, and a limit is applied to restrict the number of cities returned based on a placeholder for numeric values."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "description": "This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.", "virtual_table": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6098", "db_id": "customers_and_addresses", "question": "Find the contact channel code that was used by the customer named \"Tillman Ernser\".", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It selects distinct values from the 'channel_code' column to avoid duplicates.", "A JOIN operation is performed on 'customer_id' to link the two tables based on the customer.", "A condition is added to filter the results based on the specified customer's name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.", "virtual_table": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6099", "db_id": "customers_and_addresses", "question": "What is the \"active to date\" of the latest contact channel used by \"Tillman Ernser\"?", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It selects the maximum value of 'active_to_date' from 'Customer_Contact_Channels' to find the most recent deactivation date.", "A JOIN operation is performed on 'customer_id' to link the two tables based on the customer.", "A condition is added to filter the results based on the specified customer's name using a placeholder for string values."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table retrieves the most recent deactivation date of a contact channel for a specific customer from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the customer's name.", "virtual_table": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It uses a JOIN operation to link the two tables based on the 'customer_id'.", "The SELECT statement retrieves the maximum 'active_to_date' from the 'Customer_Contact_Channels' table.", "A condition is added to filter the results based on the specified customer's name using a placeholder for string values."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table retrieves the most recent deactivation date of a contact channel for a specific customer from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the customer's name.", "virtual_table": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["The query identifies the relevant table, which is 'Customer_Contact_Channels'.", "It calculates the average duration by subtracting 'active_from_date' from 'active_to_date'.", "The result is aggregated using the AVG function to provide the average duration of active contact channels."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "description": "This virtual table calculates the average duration that contact channels remain active for customers in the 'Customer_Contact_Channels' table. The placeholder in the SELECT clause represents the calculation of the difference between the active dates.", "virtual_table": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels"}
