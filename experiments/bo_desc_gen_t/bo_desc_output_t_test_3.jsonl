{"sample_id": "train.6102", "db_id": "customers_and_addresses", "question": "Compute the average active time span of contact channels.", "rationale": ["The query identifies the relevant table, which is 'Customer_Contact_Channels'.", "It calculates the average duration of active contact channels by subtracting 'active_from_date' from 'active_to_date'.", "The result is aggregated using the AVG function to provide the average duration of active contact channels."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "description": "This virtual table calculates the average duration that contact channels remain active for customers in the 'Customer_Contact_Channels' table. The placeholder in the SELECT clause represents the calculation of the difference between the active dates.", "virtual_table": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels"}
{"sample_id": "train.6104", "db_id": "customers_and_addresses", "question": "Return the channel code and contact number of the customer contact channel whose active duration was the longest.", "rationale": ["The query identifies the relevant table, which is 'Customer_Contact_Channels'.", "Select the columns to display, 'channel_code' and 'contact_number'.", "Add a condition to filter the active contact channels based on their active duration, comparing it to the maximum active duration found in a subquery.", "The subquery calculates the longest active duration by ordering the active durations in descending order and limiting the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "description": "This virtual table provides the channel codes and contact numbers of customer contact channels that have been active for a duration equal to the longest active duration found in the 'Customer_Contact_Channels' table. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.", "virtual_table": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.6105", "db_id": "customers_and_addresses", "question": "Find the name and active date of the customer that use email as the contact channel.", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It selects the 'customer_name' from the 'Customers' table and 'active_from_date' from the 'Customer_Contact_Channels' table.", "A JOIN operation is performed on the 'customer_id' to link the two tables together.", "A condition is added to filter the results based on the 'channel_code' using a placeholder for string values."], "gold_sql": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table provides the names of customers along with the activation dates of their preferred contact channels from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the specific contact channel code being queried.", "virtual_table": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6127", "db_id": "customers_and_addresses", "question": "Who made the latest order?", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Orders'.", "It selects the 'customer_name' column from the 'Customers' table.", "A JOIN operation is performed to link 'Customers' with 'Customer_Orders' based on the 'customer_id'.", "The results are ordered by 'order_date' in descending order to show the most recent orders first.", "The LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT 1", "source_tables": ["customer_orders", "customers"], "description": "This virtual table provides a list of customer names from the 'Customers' table who have placed orders, sorted by the date of their most recent order. The placeholder in the LIMIT clause allows for specifying the maximum number of customer names to retrieve.", "virtual_table": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["The query identifies the relevant tables, 'Order_Items' and 'Products'.", "It selects the 'product_details' and 'product_id' from the 'Products' table.", "A JOIN operation is performed between 'Order_Items' and 'Products' on the 'product_id' to link ordered items with their details.", "The results are grouped by 'product_id' to aggregate the order quantities for each product.", "The results are ordered by the sum of 'order_quantity' to show the most ordered products first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "description": "This virtual table provides a summary of product details and their identifiers from the 'Products' table, based on the quantities ordered from the 'Order_Items' table. The results are grouped by product ID and ordered by the total quantity ordered, with a limit specified by a placeholder for numeric values.", "virtual_table": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects the 'address_content' column to display the detailed description of the addresses.", "The query includes two conditions to filter the results based on the specified city and state, using placeholders for string values.", "The UNION operator is used to combine results from two identical queries, allowing for flexibility in retrieving addresses from two different locations."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "description": "This virtual table retrieves the detailed address content from the 'Addresses' table for specific cities and states, allowing for the combination of results from two different queries based on the same criteria. The placeholders in the WHERE clauses represent the city and state names.", "virtual_table": "SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6134", "db_id": "customers_and_addresses", "question": "What are all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects the 'address_content' column to display the detailed description of the addresses.", "The query includes a condition to filter the results based on the 'city' and 'state_province_county' columns using placeholders for string values.", "The UNION operator is used to combine results from two identical queries, allowing for flexibility in retrieving addresses from two different locations."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "description": "This virtual table retrieves the detailed address content from the 'Addresses' table for specific cities and states, allowing for the combination of results from two different queries based on the same criteria. The placeholders in the WHERE clauses represent the city and state names.", "virtual_table": "SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["The query is identifying the relevant table, which is 'match'.", "Select the column to display, 'match_id'.", "Add a condition to filter the 'competition' column for the specified competition using a placeholder for string values."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "description": "This virtual table describes the unique identifiers of matches from the 'match' table that are part of a specific competition. The placeholder in the WHERE clause represents the competition's identifier.", "virtual_table": "SELECT match_id FROM MATCH WHERE competition = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6275", "db_id": "city_record", "question": "Find the city that hosted the most events.", "rationale": ["The query identifies the relevant tables, 'city' and 'hosting_city'.", "It selects the 'city' from the 'city' table, using an alias for clarity.", "A JOIN operation is performed between 'city' and 'hosting_city' on the condition that the city ID matches the host city ID.", "The results are grouped by the host city to count the number of matches hosted in each city.", "The results are ordered in descending order based on the count of matches, and a placeholder is used in the LIMIT clause to specify the number of results to return."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "description": "This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6282", "db_id": "city_record", "question": "Which three cities have the largest regional population?", "rationale": ["The query identifies the relevant table, which is 'city'.", "Select the column to display, 'city'.", "Order the results by 'regional_population' in descending order to show the most populated cities first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "description": "This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.", "virtual_table": "SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6283", "db_id": "city_record", "question": "What are the three largest cities in terms of regional population?", "rationale": ["The query identifies the relevant table, which is 'city'.", "Select the column to display, 'city'.", "Order the results by 'regional_population' in descending order to show the most populated cities first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "description": "This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.", "virtual_table": "SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["The query identifies the relevant tables, which are 'city' and 'temperature'.", "It selects the 'city' column from the 'city' table, aliased as T1.", "A JOIN operation is performed between 'city' and 'temperature' on the 'city_id' to combine data from both tables.", "The results are ordered by the average temperature in February from the 'temperature' table in descending order.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "description": "This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["The query identifies the relevant tables, which are 'city' and 'temperature'.", "It selects the 'city' column from the 'city' table, aliased as T1.", "A JOIN operation is performed between 'city' (T1) and 'temperature' (T2) on the 'city_id' to combine data from both tables.", "The WHERE clause applies conditions to filter cities based on their average temperatures in March, July, and October using placeholders for the temperature values."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "description": "This virtual table lists the names of cities from the 'city' table that have a March average temperature lower than July or higher than October. The placeholders in the WHERE clause represent the temperature values for the respective months.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct"}
{"sample_id": "train.6290", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in July and which have also served as host cities?", "rationale": ["The query is identifying the relevant tables, which are 'city', 'temperature', and 'hosting_city'.", "It selects the 'city' from the 'city' table where the average temperature in March is less than that in July, using a join with the 'temperature' table.", "The INTERSECT clause is used to find cities that also appear in the 'hosting_city' table, indicating they have hosted a match."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["The query starts by selecting the 'city' from the 'city' table, aliased as T1.", "It joins the 'temperature' table, aliased as T2, on the 'city_id' to access temperature data.", "The WHERE clause filters cities where the average temperature in March is less than that in December.", "The EXCEPT clause is used to exclude cities that are found in the 'hosting_city' table, which indicates they have hosted a match. This is done by joining the 'city' table again, aliased as T3, with the 'hosting_city' table, aliased as T4, on the 'city_id' and 'host_city'."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table identifies cities that have a higher average temperature in March compared to December, while excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6295", "db_id": "city_record", "question": "Which cities have higher temperature in Feb than in Jun or have once served as host cities?", "rationale": ["The query identifies the relevant tables, which are 'city', 'temperature', and 'hosting_city'.", "It selects the 'city' column from the 'city' table.", "The first part of the query joins 'city' and 'temperature' tables to filter cities based on the condition that the average temperature in February is greater than in June.", "The second part of the query selects cities from the 'hosting_city' table that have hosted matches, ensuring that the results include cities from both conditions.", "The use of UNION combines the results from both queries into a single list of cities."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than that in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6324", "db_id": "e_government", "question": "Find the last name of the first ever contact person of the organization with the highest UK Vat number.", "rationale": ["The query identifies the relevant tables: 'organizations', 'organization_contact_individuals', and 'individuals'.", "It selects the 'individual_last_name' from the 'individuals' table.", "The query joins the 'organizations' table with 'organization_contact_individuals' on 'organization_id' and then joins with 'individuals' on 'individual_id'.", "A subquery is used to find the organization with the maximum 'uk_vat_number'.", "The results are ordered by 'date_contact_to' in ascending order, and a placeholder is included to limit the number of results returned."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.uk_vat_number  =  (SELECT max(uk_vat_number) FROM organizations) ORDER BY t2.date_contact_to ASC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "description": "This virtual table provides the last names of individuals who have contacted the organization with the highest VAT registration number. The results are ordered by the end date of the contact period, and a placeholder is included to limit the number of results returned.", "virtual_table": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.uk_vat_number  =  (SELECT max(uk_vat_number) FROM organizations) ORDER BY t2.date_contact_to ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6328", "db_id": "e_government", "question": "Find name of the services that has never been used.", "rationale": ["The query identifies the relevant table, which is 'Services'.", "It selects the 'service_name' column to display the names of the services.", "The EXCEPT clause is used to filter out service names that are linked to any bookings in the 'Party_Services' table by joining the 'Services' table with the 'Party_Services' table on the 'service_id' column."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "description": "This virtual table lists the names of services from the 'Services' table that are not booked by any party in the 'Party_Services' table. The query uses an EXCEPT clause to exclude service names that are present in the 'Party_Services' table, ensuring only unbooked services are displayed.", "virtual_table": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects the 'town_city' column and the 'state_province_county' column.", "The UNION operator is used to combine the results from both columns, ensuring that the final output contains unique values from both selections."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "description": "This virtual table provides a combined list of town/city names and state/province/county names from the 'Addresses' table. The use of UNION allows for the retrieval of unique entries from both columns, ensuring that any duplicates are removed.", "virtual_table": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses"}
{"sample_id": "train.6331", "db_id": "e_government", "question": "What are the names of all cities and states?", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects the 'town_city' column to retrieve names of towns or cities.", "It also selects the 'state_province_county' column to retrieve names of states, provinces, or counties.", "The UNION operator is used to combine the results from both selections, ensuring that only unique values are returned."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "description": "This virtual table provides a combined list of town or city names and state, province, or county names from the 'Addresses' table. The use of UNION allows for the retrieval of unique entries from both columns, ensuring that the results do not contain duplicates.", "virtual_table": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["The query identifies the relevant tables, which are 'Individuals' and 'Organization_Contact_Individuals'.", "It selects the 'individual_last_name' column from the 'Individuals' table.", "A JOIN operation is performed on the 'individual_id' to link individuals with their corresponding organization contacts.", "The DISTINCT keyword is used to ensure that only unique last names are included in the result."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "description": "This virtual table provides a list of unique last names of individuals who have contacted organizations. It combines data from the 'Individuals' table and the 'Organization_Contact_Individuals' table, ensuring that only distinct last names are returned.", "virtual_table": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id"}
{"sample_id": "train.6723", "db_id": "activity_1", "question": "Show the first name, last name, and phone number for all female faculty members.", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the columns to display, 'Fname', 'Lname', and 'phone'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'", "source_tables": ["faculty"], "description": "This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.", "virtual_table": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the column to display, 'FacID'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "description": "This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.", "virtual_table": "SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6738", "db_id": "activity_1", "question": "Find the building that has the largest number of faculty members.", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'building' column to display the names of the buildings.", "The results are grouped by 'building' to aggregate the data.", "The query orders the results by the count of faculty members in each building in descending order.", "A limit is applied to restrict the number of buildings returned, using a placeholder for numeric values."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "description": "This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The results are ordered by the number of faculty members in each building in descending order, with a limit on the number of buildings returned as specified by the placeholder.", "virtual_table": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6740", "db_id": "activity_1", "question": "In which buildings are there at least ten professors?", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "Select the 'building' column to display the locations of faculty offices.", "Add a condition to filter the 'rank' column for the specified academic rank using a placeholder for string values.", "Group the results by 'building' to aggregate the data based on the location.", "Use the HAVING clause to filter the grouped results to include only those buildings with a count of faculty members greater than or equal to a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT building FROM Faculty WHERE rank  =  'Professor' GROUP BY building HAVING count(*)  >=  10", "source_tables": ["faculty"], "description": "This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.", "virtual_table": "SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'sex' column and counts the number of occurrences for each gender.", "A condition is added to filter the results based on the specified 'rank' using a placeholder for string values.", "The results are grouped by the 'sex' column to provide a count for each gender."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "description": "This virtual table summarizes the count of faculty members by gender from the 'Faculty' table, filtered by a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty members.", "virtual_table": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sex"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the columns to display, 'fname' and 'lname' from the 'Faculty' table.", "A JOIN operation is performed between 'Faculty' and 'Student' on the condition that the faculty member's ID matches the student's advisor ID.", "Conditions are added to filter the results based on the specified first and last names of the student using placeholders for string values."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "description": "This virtual table describes the first names and last names of faculty members who are academic advisors to a specific student. The placeholders in the WHERE clause represent the first and last names of the student.", "virtual_table": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  [PLACEHOLDER-TYPE:STRING] AND T2.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["The query is identifying the relevant tables, which are 'Faculty' and 'Student'.", "A JOIN operation is performed to connect the 'Faculty' table with the 'Student' table based on the advisor relationship.", "The SELECT statement specifies that we want to retrieve the 'StuID' from the 'Student' table.", "A condition is added to filter faculty members based on their rank using a placeholder for string values."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "description": "This virtual table identifies the unique identifiers of students who are advised by faculty members of a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.", "virtual_table": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the columns to display, 'fname' and 'lname' from the 'Student' table.", "A JOIN operation is performed between 'Faculty' and 'Student' on the advisor relationship.", "Conditions are added to filter the faculty member by their first and last names using placeholders for string values."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "description": "This virtual table describes the first and last names of students who are advised by a specific faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member.", "virtual_table": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6759", "db_id": "activity_1", "question": "What are the first and last name of the faculty who has the most students?", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the first name and last name of faculty members (aliased as T1) who are advisors to students (aliased as T2).", "A JOIN operation is performed on the Faculty and Student tables using the advisor relationship.", "The results are grouped by the faculty ID to aggregate the number of students each faculty member advises.", "The results are ordered in descending order based on the count of students advised, and a limit is applied to restrict the number of faculty members returned using a placeholder for numeric values."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty", "student"], "description": "This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.", "virtual_table": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6765", "db_id": "activity_1", "question": "What activities do we have?", "rationale": ["The query is identifying the relevant table, which is 'Activity'.", "Select the column to display, 'activity_name'.", "No conditions are applied, so all activity names will be retrieved."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "description": "This virtual table describes the names of activities from the 'Activity' table. The query retrieves all activity names without any filtering conditions.", "virtual_table": "SELECT activity_name FROM Activity"}
{"sample_id": "train.6766", "db_id": "activity_1", "question": "List all the activities we have.", "rationale": ["The query identifies the relevant table, which is 'Activity'.", "Select the column to display, 'activity_name'.", "No filtering conditions are applied, so all activity names will be retrieved."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "description": "This virtual table describes the names of activities from the 'Activity' table. The query retrieves all activity names without any filtering conditions.", "virtual_table": "SELECT activity_name FROM Activity"}
{"sample_id": "train.6780", "db_id": "activity_1", "question": "What is the first and last name of the faculty members who participated in at least one activity? For each of them, also show the number of activities they participated in.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Faculty_Participates_in'.", "It selects the first name and last name of faculty members from the 'Faculty' table.", "It counts the number of activities each faculty member participates in by using the COUNT function.", "The JOIN operation links the 'Faculty' table with the 'Faculty_Participates_in' table based on the faculty identifier.", "The results are grouped by the unique identifier of each faculty member to aggregate the count of activities."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "description": "This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and the 'Faculty_Participates_in' table, grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.", "virtual_table": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID"}
{"sample_id": "train.6781", "db_id": "activity_1", "question": "Show all the activity names and the number of faculty involved in each activity.", "rationale": ["The query identifies the relevant tables, which are 'Activity' and 'Faculty_Participates_in'.", "It selects the 'activity_name' from the 'Activity' table and counts the number of faculty members participating in each activity.", "The JOIN operation links the two tables based on the activity identifier 'actID'.", "The GROUP BY clause is used to aggregate the results by each activity, allowing for a count of faculty members per activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "description": "This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the SELECT statement represents the activity name, and the count reflects the total number of faculty involved in each activity.", "virtual_table": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID"}
{"sample_id": "train.6782", "db_id": "activity_1", "question": "How many faculty members participate in each activity? Return the activity names and the number of faculty members.", "rationale": ["The query identifies the relevant tables, which are 'Activity' and 'Faculty_Participates_in'.", "It selects the 'activity_name' from the 'Activity' table and counts the number of faculty members participating in each activity.", "The JOIN operation links the two tables based on the activity identifier, ensuring that only relevant records are counted.", "The GROUP BY clause is used to aggregate the results by activity, allowing for a count of faculty members for each distinct activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "description": "This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the SELECT statement represents the activity name, and the count function aggregates the number of faculty members for each activity.", "virtual_table": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["The query is identifying the relevant tables, which are 'Participates_in' and 'Student'.", "The INTERSECT operator is used to find common student IDs from both tables.", "The first SELECT statement retrieves student IDs from the 'Participates_in' table, indicating participation in activities.", "The second SELECT statement retrieves student IDs from the 'Student' table, applying a condition to filter students based on age using a placeholder for numeric values."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "description": "This virtual table identifies students who participate in activities and are younger than a specified age. The placeholder in the WHERE clause represents the age limit for filtering the students.", "virtual_table": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6795", "db_id": "activity_1", "question": "Find the first names of the faculty members who are playing Canoeing or Kayaking.", "rationale": ["The query identifies the relevant tables: 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "It selects distinct last names from the 'Faculty' table.", "The JOIN operations link faculty members to their respective activities through the 'Faculty_Participates_in' table and the 'Activity' table.", "The WHERE clause filters the activities based on their names, using placeholders for the specific activity names."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.", "virtual_table": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6796", "db_id": "activity_1", "question": "Which faculty members are playing either Canoeing or Kayaking? Tell me their first names.", "rationale": ["The query identifies the relevant tables: 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "It selects distinct last names from the 'Faculty' table.", "The JOIN operations link faculty members to their respective activities through the 'Faculty_Participates_in' table and the 'Activity' table.", "The WHERE clause filters the results based on the specified activity names using placeholders for string values."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The query joins the 'Faculty' table with the 'Faculty_Participates_in' table to link faculty members to their activities, and then further joins with the 'Activity' table to filter based on the names of the activities. The placeholders in the WHERE clause represent the names of the activities of interest.", "virtual_table": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'lname' column to display the last names of faculty members.", "A condition is added to filter faculty members based on their 'rank' using a placeholder for string values.", "The EXCEPT clause is used to exclude faculty members who participate in activities, which is determined by joining the 'Faculty' table with 'Faculty_Participates_in' and 'Activity' tables.", "The activities to be excluded are specified using placeholders for string values in the WHERE clause."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.", "virtual_table": "SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["The query is identifying the relevant tables, which are 'Participates_in' and 'Activity'.", "It selects the 'stuid' column from the 'Participates_in' table.", "The query uses a JOIN to connect 'Participates_in' with 'Activity' based on the 'actid'.", "It filters the results based on the 'activity_name' for two different activities using placeholders.", "The INTERSECT operator is used to find students who participate in both activities."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "description": "This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clauses represent the names of the activities being queried.", "virtual_table": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'Model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the condition that 'MakeId' from 'car_names' matches 'Id' from 'cars_data'.", "The results are ordered by the 'horsepower' column from 'cars_data' in ascending order.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.97", "db_id": "car_1", "question": "Find the model of the car whose weight is below the average weight.", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the 'MakeId' and 'Id' columns to link car models with their respective data.", "A condition is added to filter the results where the weight of the cars is less than the average weight calculated from the 'cars_data' table using a subquery."], "gold_sql": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "source_tables": ["car_names", "cars_data"], "description": "The virtual table describes the car models from the 'car_names' table that have a weight less than the average weight of all cars in the 'cars_data' table. The query uses a subquery to calculate the average weight, ensuring that only lighter models are selected.", "virtual_table": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["The query identifies the relevant tables, which are 'cars_data' and 'car_names'.", "It selects the 'Accelerate' column from the 'cars_data' table.", "A JOIN operation is performed to link 'cars_data' with 'car_names' based on the matching 'Id' and 'MakeId'.", "A condition is added to filter the results based on the specified car make using a placeholder for string values."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "description": "The virtual table describes the acceleration times of cars from the 'cars_data' table, filtered by a specific car make from the 'car_names' table. The placeholder in the WHERE clause represents the name of the car make.", "virtual_table": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.112", "db_id": "car_1", "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?", "rationale": ["The query identifies the relevant tables, 'cars_data' and 'car_names'.", "It selects the 'Accelerate' column from the 'cars_data' table.", "A JOIN operation is performed between 'cars_data' and 'car_names' on the 'Id' and 'MakeId' columns to link car entries with their respective makes.", "A condition is added to filter the results based on the car make using a placeholder for string values."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "description": "This virtual table provides the acceleration times of cars from the 'cars_data' table, specifically focusing on the time taken to accelerate from 0 to 60 mph. The data is filtered based on the car make, which is specified by a placeholder in the WHERE clause.", "virtual_table": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["The query identifies the relevant tables, which are 'car_makers' and 'countries'.", "It uses a JOIN operation to connect these tables based on the country identifier.", "The SELECT statement counts the number of car makers that match the specified country name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "description": "This virtual table provides the count of car makers based in a specific country. It joins the 'car_makers' table with the 'countries' table using the country identifier, and filters the results based on the specified country name.", "virtual_table": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.121", "db_id": "car_1", "question": "What are all the makers and models?", "rationale": ["The query identifies the relevant table, which is 'model_list'.", "Select the columns to display, 'Maker' and 'Model'.", "This query provides a list of car makers along with their corresponding car models without any filtering conditions."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "description": "The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.", "virtual_table": "SELECT Maker ,  Model FROM MODEL_LIST;"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["The query identifies the relevant tables: 'countries', 'continents', and 'car_makers'.", "It selects the 'CountryName' from the 'countries' table.", "The JOIN operation connects 'countries' with 'continents' based on the continent identifier, allowing filtering by continent.", "Another JOIN connects 'countries' with 'car_makers' to ensure that only countries with car makers are included.", "The GROUP BY clause groups the results by 'CountryName' to aggregate the data.", "The HAVING clause filters the grouped results to include only those countries that have a count of car makers greater than or equal to a specified number."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "description": "This virtual table lists the names of countries from the 'countries' table that belong to a specific continent. It joins the 'continents' table to filter countries by continent and the 'car_makers' table to ensure that the countries have associated car makers. The placeholders in the WHERE clause represent the continent's name and the minimum count of car makers per country.", "virtual_table": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.CountryName HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.130", "db_id": "car_1", "question": "What are the names of all European countries with at least 3 manufacturers?", "rationale": ["The query identifies the relevant tables: 'countries', 'continents', and 'car_makers'.", "It selects the 'CountryName' from the 'countries' table.", "The JOIN operation connects 'countries' with 'continents' based on the continent identifier to filter by a specific continent.", "Another JOIN connects 'countries' with 'car_makers' to ensure that only countries with car makers are included.", "The GROUP BY clause is used to group the results by 'CountryName'.", "The HAVING clause filters the grouped results to include only those countries that have a count of car makers greater than or equal to a specified number."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "description": "This virtual table lists the names of countries from the 'countries' table that belong to a specific continent. It joins the 'continents' table to filter countries by continent and the 'car_makers' table to ensure that the countries have associated car makers. The placeholders in the WHERE clause represent the continent's name and the minimum count of car makers per country.", "virtual_table": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.CountryName HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'Make' from 'car_names' and 'horsepower' from 'cars_data'.", "A JOIN operation is performed on 'MakeId' from 'car_names' and 'Id' from 'cars_data' to combine the data.", "A condition is added to filter the results based on the number of cylinders using a placeholder for numeric values.", "The results are ordered by 'horsepower' in descending order to show the most powerful cars first.", "A LIMIT clause is included to restrict the number of results returned, using another placeholder for numeric values."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table provides a list of car makes along with their horsepower from the 'car_names' and 'cars_data' tables. The results are filtered to include only those cars with a specific number of cylinders, represented by a placeholder for numeric values. The output is ordered by horsepower in descending order, and the number of results returned is limited by another numeric placeholder.", "virtual_table": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.141", "db_id": "car_1", "question": "Which model has the most version(make) of cars?", "rationale": ["The query identifies the relevant table, which is 'car_names'.", "It selects the 'Model' column to display the names of car models.", "The results are grouped by 'Model' to aggregate the data based on unique model names.", "The query orders the results by the count of each model in descending order to show the most common models first.", "Finally, it limits the output to a specified number of top models using a placeholder for numeric values."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "description": "The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.", "virtual_table": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.142", "db_id": "car_1", "question": "What model has the most different versions?", "rationale": ["The query identifies the relevant table, which is 'car_names'.", "Select the 'Model' column to display the car models.", "Group the results by 'Model' to aggregate the data based on unique car models.", "Order the results by the count of each model in descending order to show the most common models first.", "Limit the output to a specified number of results using a placeholder for numeric values."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "description": "The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of results. The placeholder in the LIMIT clause represents the maximum number of models to return.", "virtual_table": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["The query identifies the relevant tables, which are 'car_makers' and 'model_list'.", "It selects the 'FullName' and 'Id' columns from the 'car_makers' table.", "A JOIN operation is performed between 'car_makers' and 'model_list' on the 'Id' and 'Maker' columns respectively to associate car makers with their models.", "The results are grouped by the 'Id' of the car makers to aggregate the number of models each maker has.", "The HAVING clause is used to filter the grouped results to include only those car makers that have produced more than a specified number of models, using a placeholder for numeric values."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "description": "This virtual table provides a list of car makers along with their unique identifiers from the 'car_makers' table. It filters the results to include only those car makers that have produced more than a specified number of car models, as indicated by the placeholder in the HAVING clause.", "virtual_table": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.161", "db_id": "car_1", "question": "How many countries has more than 2 car makers ?", "rationale": ["The query identifies the relevant tables, which are 'countries' and 'car_makers'.", "It performs a join operation on the 'countryid' from 'countries' and 'country' from 'car_makers' to associate car makers with their respective countries.", "The count of car makers is calculated for each country using the COUNT function.", "The results are grouped by 'countryid' to aggregate the counts per country.", "A HAVING clause is added to filter the results, only including countries that have more than a specified number of car makers, represented by a placeholder for numeric values."], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "source_tables": ["car_makers", "countries"], "description": "This virtual table provides a count of car makers grouped by their respective countries from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers that must be associated with a country for it to be included in the results.", "virtual_table": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'Model' column from the 'car_names' table.", "A join is performed between 'car_names' and 'cars_data' on the 'MakeId' and 'Id' columns to combine relevant data.", "A condition is added to filter the results based on the number of cylinders using a placeholder for numeric values.", "The results are ordered by the 'horsepower' column in descending order to show the most powerful cars first.", "A limit is applied to restrict the number of results returned, using another placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table lists the car models from the 'car_names' table that have a specific number of cylinders. The results are ordered by the horsepower of the cars in descending order, and the number of results returned is limited by a placeholder value.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.171", "db_id": "car_1", "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?", "rationale": ["The query identifies the relevant tables: 'model_list', 'car_names', 'cars_data', and 'car_makers'.", "It selects distinct car models from the 'model_list' table.", "The JOIN operations link the tables based on their relationships, ensuring that the correct models are associated with their respective car data and makers.", "A condition is added to filter the results based on the weight of the cars, using a placeholder for numeric values.", "Another condition excludes car makers based on their full name, using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';", "source_tables": ["car_makers", "model_list", "car_names", "cars_data"], "description": "This virtual table provides a list of distinct car models from the 'model_list' table that meet specific criteria. It filters the results based on the weight of the cars from the 'cars_data' table, ensuring that only cars lighter than a specified weight are included. Additionally, it excludes car makers based on their full name from the 'car_makers' table, allowing users to focus on models from specific manufacturers. The placeholders in the WHERE clause represent the maximum weight and the name of the car maker to exclude.", "virtual_table": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  [PLACEHOLDER-TYPE:NUMBER] AND T4.FullName != [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.175", "db_id": "car_1", "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .", "rationale": ["The query starts by selecting the 'id' and 'maker' from the 'car_makers' table, aliased as t1.", "It joins the 'model_list' table, aliased as t2, on the condition that the 'id' from 'car_makers' matches the 'maker' in 'model_list'.", "The results are grouped by 'id' and filtered using the HAVING clause to ensure that the count of models is greater than or equal to a specified number, represented by a placeholder.", "The second part of the query performs a similar operation but includes an additional join with the 'car_names' table, aliased as t3, to ensure that the models are associated with specific car names.", "Again, the results are grouped by 'id' and filtered with a HAVING clause to ensure that the count of names is greater than a specified number, also represented by a placeholder.", "The use of INTERSECT ensures that only car makers meeting both criteria are included in the final result."], "gold_sql": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "description": "This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.", "virtual_table": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["The query identifies the relevant tables, which are 'CAR_MAKERS', 'MODEL_LIST', and 'CAR_NAMES'.", "It selects the 'Id' and 'Maker' from 'CAR_MAKERS' and joins it with 'MODEL_LIST' to count the number of models for each maker.", "The first part of the query uses a HAVING clause to filter makers with a count of models greater than or equal to a specified number.", "The second part of the query intersects with another selection that counts the number of car names associated with the models, filtering those with a count greater than a specified number."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "description": "This virtual table identifies car makers who have produced a significant number of car models, as well as those who have a specific number of car names associated with their models. The placeholders in the HAVING clauses represent the minimum counts of models and names, respectively.", "virtual_table": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.526", "db_id": "student_transcripts_tracking", "question": "What are the names and ids of every course with less than 2 sections?", "rationale": ["The query identifies the relevant tables, which are 'Courses' and 'Sections'.", "It selects the 'course_name' and 'course_id' from the 'Courses' table, aliased as T1.", "A JOIN operation is performed between 'Courses' and 'Sections' on the 'course_id' to link courses with their sections.", "The results are grouped by 'course_id' to aggregate the sections for each course.", "The HAVING clause is used to filter the results based on the count of sections, using a placeholder for the maximum number of sections."], "gold_sql": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2", "source_tables": ["courses", "sections"], "description": "This virtual table provides a list of course names and their corresponding identifiers from the 'Courses' table, specifically for those courses that have a number of sections less than or equal to a specified threshold. The placeholder in the HAVING clause represents the maximum number of sections allowed for the courses listed.", "virtual_table": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.534", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?", "rationale": ["The query identifies the relevant tables, 'Students' and 'Student_Enrolment'.", "It selects the columns to display: 'first_name', 'middle_name', 'last_name', and 'student_id' from the 'Students' table.", "The JOIN operation is used to link 'Students' with 'Student_Enrolment' based on the 'student_id'.", "The GROUP BY clause is applied to group the results by 'student_id'.", "The HAVING clause filters the results to include only those students who are enrolled in a specific number of courses, represented by a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "description": "This virtual table provides the first name, middle name, last name, and student ID of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.", "virtual_table": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.535", "db_id": "student_transcripts_tracking", "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.", "rationale": ["The query identifies the relevant tables: 'Students', 'Student_Enrolment', and 'Degree_Programs'.", "It selects distinct names (first, middle, last) from the 'Students' table.", "The JOIN operations link the 'Students' table to 'Student_Enrolment' and then to 'Degree_Programs' based on their respective identifiers.", "A condition is added to filter the results based on the specified degree program name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "description": "This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["The query identifies the relevant tables, 'Degree_Programs' and 'Student_Enrolment'.", "It selects the degree program ID and name from the 'Degree_Programs' table.", "A JOIN operation is performed between 'Degree_Programs' and 'Student_Enrolment' on the degree program ID to link degree programs with their enrolled students.", "The results are grouped by the degree program ID to aggregate the count of students enrolled in each program.", "The results are ordered by the count of students in descending order to show the most popular programs first.", "A LIMIT clause is added to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "description": "This virtual table provides a list of degree programs along with their unique identifiers from the 'Degree_Programs' table. It joins with the 'Student_Enrolment' table to count how many students are enrolled in each degree program. The results are grouped by the degree program ID and ordered by the number of students enrolled in descending order, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["The query identifies the relevant tables, 'Students' and 'Student_Enrolment'.", "It selects the student ID, first name, middle name, and last name from the 'Students' table.", "It counts the number of courses each student is enrolled in by joining 'Students' with 'Student_Enrolment' on the student ID.", "The results are grouped by the student ID to aggregate the course counts.", "Finally, the results are ordered by the count of courses in descending order, and a placeholder is used in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "description": "This virtual table provides a list of students along with their first, middle, and last names, and the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.", "virtual_table": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Enrolment_Courses'.", "It selects the 'course_name' from the 'Courses' table.", "A JOIN operation is performed between 'Courses' and 'Student_Enrolment_Courses' on the 'course_id' to link courses with their enrolments.", "The results are grouped by 'course_name' to aggregate the data based on course popularity.", "The results are ordered by the count of enrolments in descending order to show the most popular courses first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "description": "This virtual table provides a list of course names from the 'Courses' table that are associated with student enrolments. The results are grouped by course name and ordered by the number of enrolments in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of course names to return.", "virtual_table": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.548", "db_id": "student_transcripts_tracking", "question": "What is the name of the course with the most students enrolled?", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Enrolment_Courses'.", "It selects the 'course_name' from the 'Courses' table.", "A JOIN operation is performed to link 'Courses' with 'Student_Enrolment_Courses' based on the course identifier.", "The results are grouped by 'course_name' to aggregate enrolment counts.", "The results are ordered by the count of enrolments in descending order to highlight the most popular courses.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "description": "This virtual table provides a list of course names from the 'Courses' table that are associated with student enrolments. The results are grouped by course name and ordered by the number of enrolments in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of course names to return.", "virtual_table": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["The query identifies the relevant tables, which are 'Students' and 'Addresses'.", "It selects the 'last_name' column from the 'Students' table.", "A JOIN is performed between 'Students' and 'Addresses' on the 'current_address_id' to filter students based on their current address.", "A WHERE clause is added to filter the results based on the 'state_province_county' of the address using a placeholder for string values.", "An EXCEPT clause is used to exclude students who are enrolled in any degree program by joining 'Students' with 'Student_Enrolment' and selecting distinct last names."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "description": "This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.", "virtual_table": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["The query identifies the relevant table, which is 'Students'.", "Select the column to display, 'cell_mobile_number'.", "Add conditions to filter the 'first_name' and 'last_name' columns for the specified student using placeholders for string values."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "description": "This virtual table provides the mobile phone numbers of students from the 'Students' table based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.", "virtual_table": "select cell_mobile_number from students where first_name  =  [PLACEHOLDER-TYPE:STRING] and last_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["The query identifies the relevant tables, 'Addresses' and 'Students'.", "It selects the 'address_id', 'line_1', and 'line_2' columns from the 'Addresses' table.", "A JOIN operation is performed to link 'Addresses' with 'Students' based on the current address ID.", "The results are grouped by 'address_id' to ensure uniqueness of addresses.", "The results are ordered by the count of students associated with each address in descending order.", "A LIMIT clause is added to restrict the number of results based on a placeholder for numeric values."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "description": "This virtual table provides a list of unique addresses that are currently associated with students, including the address ID and primary and secondary address lines. The results are grouped by address ID and ordered by the number of students linked to each address, with a limit on the number of addresses returned based on a specified numeric value.", "virtual_table": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.578", "db_id": "student_transcripts_tracking", "question": "What are the different addresses that have students living there?", "rationale": ["The query is identifying the relevant table, which is 'Students'.", "The goal is to count the distinct current addresses, so the COUNT function is used with DISTINCT on the 'current_address_id' column."], "gold_sql": "SELECT count(DISTINCT current_address_id) FROM Students", "source_tables": ["students"], "description": "This virtual table provides the count of distinct current addresses associated with students from the 'Students' table. The placeholder in the SELECT clause represents the unique current address identifiers.", "virtual_table": "SELECT count(DISTINCT current_address_id) FROM Students"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The query identifies the relevant table, which is 'Sections'.", "Select the column to display, 'section_description'.", "Add a condition to filter the 'section_name' column for the specified section using a placeholder for string values."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "description": "This virtual table provides the description of a specific section from the 'Sections' table based on the section's name. The placeholder in the WHERE clause represents the name of the section being queried.", "virtual_table": "SELECT section_description FROM Sections WHERE section_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects a count of all entries in the table.", "A condition is added to filter the results based on the 'GovernmentForm' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "description": "This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.", "virtual_table": "SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.723", "db_id": "world_1", "question": "How many people live in Asia, and what is the largest GNP among them?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the sum of the 'Population' column and the maximum value of the 'GNP' column to provide aggregate data.", "A condition is added to filter the results based on the 'Continent' column using a placeholder for string values."], "gold_sql": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  'Asia'", "source_tables": ["country"], "description": "This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.", "virtual_table": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.724", "db_id": "world_1", "question": "What is the average life expectancy in African countries that are republics?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the average of the 'LifeExpectancy' column to compute the average life expectancy.", "Conditions are added to filter the results based on the specified continent and government form using placeholders for string values."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "description": "This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.", "virtual_table": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.725", "db_id": "world_1", "question": "Give the average life expectancy for countries in Africa which are republics?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the average of the 'LifeExpectancy' column to compute the average life expectancy.", "Conditions are added to filter the results based on the specified continent and government form using placeholders for string values."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "description": "This virtual table calculates the average life expectancy of countries from the 'country' table that belong to a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and government form criteria.", "virtual_table": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.731", "db_id": "world_1", "question": "Give the mean GNP and total population of nations which are considered US territory.", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the average GNP and the sum of the population columns to provide aggregate data.", "A condition is added to filter the results based on the 'GovernmentForm' column using a placeholder for string values."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "description": "This virtual table calculates the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.", "virtual_table": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the count of distinct values in the 'GovernmentForm' column.", "A condition is added to filter the results based on the 'Continent' column using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "description": "This virtual table provides the count of distinct government forms present in countries located within a specific continent. The placeholder in the WHERE clause represents the continent's name.", "virtual_table": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.754", "db_id": "world_1", "question": "What are the countries where either English or Dutch is the official language ?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It selects the 'name' column from the 'country' table.", "The join condition links the 'country' table with the 'countrylanguage' table based on the country code.", "The WHERE clause filters the results to include only those countries where the specified language is spoken and is marked as official, using placeholders for both the language and its official status."], "gold_sql": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'english' and isofficial  =  't' union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'dutch' and isofficial  =  't'", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.", "virtual_table": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING] union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It performs a JOIN operation on these tables using the country code to combine related data.", "The WHERE clause filters the results based on the specified language and its official status, using placeholders for these values.", "The UNION operator is used to combine results from two similar queries, allowing for flexibility in the language and official status criteria."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a comprehensive view of countries and their languages by joining the 'country' and 'countrylanguage' tables. It filters the results to show only those countries where a specific language is spoken, and whether that language is official or not. The placeholders in the WHERE clause represent the language name and its official status.", "virtual_table": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] AND IsOfficial  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] AND IsOfficial  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.758", "db_id": "world_1", "question": "Which languages are spoken by only one country in republic governments?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It performs a JOIN operation on the country code to link the two tables.", "The SELECT statement retrieves the 'Language' from the 'countrylanguage' table.", "A condition is added to filter countries based on their government form using a placeholder for string values.", "The results are grouped by language, and a HAVING clause is used to filter languages that are spoken in a specific number of countries, using a placeholder for numeric values."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "description": "This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.", "virtual_table": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.759", "db_id": "world_1", "question": "What languages are only used by a single country with a republic government?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It performs a JOIN operation on the country code to link the two tables.", "The WHERE clause filters the countries based on a specific government form using a placeholder for string values.", "The GROUP BY clause groups the results by language to aggregate the data.", "The HAVING clause ensures that only languages spoken in a specified number of countries are included, using a placeholder for numeric values."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "description": "This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. It filters the results to include only those countries with a specified government form and groups the results by language, ensuring that only languages spoken in a certain number of countries are included. The placeholders in the WHERE and HAVING clauses represent the government form and the count of countries, respectively.", "virtual_table": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.760", "db_id": "world_1", "question": "Find the city with the largest population that uses English.", "rationale": ["The query identifies the relevant tables, 'city' and 'countrylanguage'.", "It selects the 'Name' and 'Population' columns from the 'city' table (aliased as T1).", "A JOIN operation is performed between 'city' and 'countrylanguage' on the 'CountryCode' to link cities with their respective languages.", "A condition is added to filter the results based on the specified language using a placeholder for string values.", "The results are ordered by the 'Population' column in descending order, and a limit is set to control the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  'English' ORDER BY T1.Population DESC LIMIT 1", "source_tables": ["city", "countrylanguage"], "description": "This virtual table provides the names and populations of cities from the 'city' table that have a specific language spoken, as indicated in the 'countrylanguage' table. The placeholder in the WHERE clause represents the language of interest, while the LIMIT placeholder allows for specifying the maximum number of results to return, sorted by population in descending order.", "virtual_table": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It uses the SUM function to calculate the total population of countries.", "A subquery is included to filter out countries that have the specified language as an official language.", "The placeholder in the subquery represents the language name that is being checked against the countries."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "description": "This virtual table calculates the total population of countries that do not have a specific language as an official language. The placeholder in the subquery represents the language name that is being checked against the countries.", "virtual_table": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.774", "db_id": "world_1", "question": "What are the African countries that have a  population less than any country in Asia?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the 'Name' column to display the names of the countries.", "A condition is added to filter countries based on the specified continent using a placeholder for string values.", "Another condition is included to ensure the population of the country is less than the maximum population of any country in the same continent, which is determined by a subquery."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Africa'  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  'Asia')", "source_tables": ["country"], "description": "This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.", "virtual_table": "SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.777", "db_id": "world_1", "question": "What are the Asian countries which have a population larger than that of any country in Africa?", "rationale": ["The query identifies the relevant table, which is 'country'.", "Select the column to display, 'Name', which represents the country's name.", "Add conditions to filter the 'Continent' column for the specified continent using a placeholder for string values.", "Include a subquery to find the minimum population of countries within the same continent, ensuring that only countries with a greater population are selected."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Asia'  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  'Africa')", "source_tables": ["country"], "description": "This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.", "virtual_table": "SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.778", "db_id": "world_1", "question": "What are the country codes for countries that do not speak English?", "rationale": ["The query is identifying the relevant table, which is 'countrylanguage'.", "Select the 'CountryCode' column to display the country codes.", "Use the EXCEPT clause to exclude country codes where the specified language is an official language, using a placeholder for string values in the WHERE clause."], "gold_sql": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["countrylanguage"], "description": "This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.", "virtual_table": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.786", "db_id": "world_1", "question": "Which unique cities are in Asian countries where Chinese is the official language ?", "rationale": ["The query identifies the relevant tables: 'country', 'countrylanguage', and 'city'.", "It uses JOIN operations to connect these tables based on their foreign key relationships, specifically linking country codes.", "The SELECT statement retrieves distinct city names from the 'city' table.", "The WHERE clause applies filters to ensure that only cities from countries where a specified language is official, and that belong to a specified continent, are included. Placeholders are used for the official status of the language, the language name, and the continent."], "gold_sql": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  't' and t2.language  =  'chinese' and t1.continent  =  'asia'", "source_tables": ["country", "city", "countrylanguage"], "description": "This virtual table provides a list of distinct city names from the 'city' table that are located in countries where a specific language is spoken officially. The query filters based on whether the language is official, the name of the language, and the continent the country belongs to, using placeholders for these criteria.", "virtual_table": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  [PLACEHOLDER-TYPE:STRING] and t2.language  =  [PLACEHOLDER-TYPE:STRING] and t1.continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["The query identifies the relevant table, which is 'country'.", "Select the columns to display: 'Name', 'SurfaceArea', and 'IndepYear'.", "Order the results by the 'Population' column to sort countries based on their population size.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "description": "This virtual table provides a list of countries, displaying their names, surface areas, and the year they gained independence. The results are ordered by the population of the countries, and the number of entries returned is limited by a specified placeholder for numeric values.", "virtual_table": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It selects the count of languages (T2.Language) and the name of the country (T1.Name).", "A JOIN operation is performed on the country code to link the two tables.", "The results are grouped by the country's name to aggregate the language counts.", "A HAVING clause is used to filter the results to include only those countries with a language count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a count of languages spoken in each country from the 'country' table, along with the country's name. The query filters the results to only include countries where the number of languages spoken exceeds a specified threshold, represented by a placeholder for numeric values.", "virtual_table": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the sum of the 'Population' column and the 'GovernmentForm' column.", "The results are grouped by 'GovernmentForm' to aggregate the population for each type of government.", "A condition is added to filter the results using the HAVING clause, which checks if the average 'LifeExpectancy' is greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "description": "This virtual table summarizes the total population of countries grouped by their government form, filtering for those government forms where the average life expectancy exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average life expectancy value.", "virtual_table": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["The query is identifying the relevant table, which is 'city'.", "Select the column to display, 'name'.", "Add a condition to filter the 'Population' column for values between the specified range using placeholders for numeric values."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "description": "This virtual table describes the names of cities from the 'city' table that have a population within a specified range. The placeholders in the WHERE clause represent the lower and upper limits of the population range.", "virtual_table": "SELECT name FROM city WHERE Population BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.820", "db_id": "world_1", "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?", "rationale": ["The query identifies the relevant table, which is 'countrylanguage'.", "Select the 'CountryCode' and the maximum 'Percentage' of speakers for the specified language.", "Add a condition to filter the 'Language' column for the specified language using a placeholder for string values.", "Group the results by 'CountryCode' to get the maximum percentage of speakers for each country."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "description": "This virtual table provides the country codes and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name that the user wants to query.", "virtual_table": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode"}
{"sample_id": "dev.821", "db_id": "world_1", "question": "Return the codes of countries for which Spanish is the predominantly spoken language.", "rationale": ["The query identifies the relevant table, which is 'countrylanguage'.", "Select the 'CountryCode' and the maximum 'Percentage' of speakers for the specified language.", "Add a condition to filter the 'Language' column for the specified language using a placeholder for string values.", "Group the results by 'CountryCode' to aggregate the maximum percentage of speakers for each country."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "description": "This virtual table provides the country codes and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.", "virtual_table": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode"}
{"sample_id": "dev.920", "db_id": "dog_kennels", "question": "What is the average age of the dogs who have gone through any treatments?", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects the average age of dogs using the AVG function.", "The WHERE clause filters the dogs to include only those that have treatment records by using a subquery that selects dog_ids from the 'Treatments' table."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "description": "This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers that have treatment records.", "virtual_table": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )"}
{"sample_id": "dev.936", "db_id": "dog_kennels", "question": "Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.", "rationale": ["The query identifies the relevant tables: 'Owners', 'Dogs', and 'Treatments'.", "It selects the 'owner_id' and 'last_name' from the 'Owners' table, using an alias for clarity.", "The JOIN operation links 'Owners' to 'Dogs' based on the 'owner_id', and then links 'Dogs' to 'Treatments' based on 'dog_id'.", "The GROUP BY clause groups the results by 'owner_id' to aggregate the number of treatments per owner.", "The ORDER BY clause sorts the results by the count of treatments in descending order, ensuring that owners with the most treatments appear first.", "The LIMIT clause uses a placeholder to allow the user to specify how many owners to return."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "description": "This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.", "virtual_table": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["The query identifies the relevant tables, which are 'Professionals' and 'Treatments'.", "It selects the 'professional_id' and 'cell_number' from the 'Professionals' table.", "A JOIN operation is performed between 'Professionals' and 'Treatments' on the 'professional_id' to link treatments to the professionals who administered them.", "The results are grouped by 'professional_id' to aggregate the treatment counts for each professional.", "The HAVING clause filters the results to include only those professionals who have administered a specified minimum number of treatments, using a placeholder for numeric values."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "description": "This virtual table provides a list of professionals along with their cell numbers who have administered a minimum number of treatments. The placeholder in the HAVING clause represents the minimum count of treatments that a professional must have administered to be included in the results.", "virtual_table": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.944", "db_id": "dog_kennels", "question": "What are the first name and last name of the professionals who have done treatment with cost below average?", "rationale": ["The query identifies the relevant tables, which are 'Professionals' and 'Treatments'.", "It selects distinct first and last names from the 'Professionals' table.", "A join is performed between 'Professionals' and 'Treatments' to link professionals with the treatments they administered.", "A condition is added to filter treatments where the cost is less than the average cost of treatments, calculated using a subquery."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "description": "This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The query joins the 'Professionals' table with the 'Treatments' table to filter based on treatment costs, using a subquery to calculate the average treatment cost.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["The query identifies the relevant tables, which are 'Owners' and 'Dogs'.", "It selects the columns 'first_name' and 'last_name' from the 'Owners' table (aliased as T1) and 'size_code' from the 'Dogs' table (aliased as T2).", "The JOIN operation is used to link the two tables on the 'owner_id' column, ensuring that only the owners of the dogs are included in the results."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "description": "This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' and 'Dogs' tables, linking them through the owner_id. The placeholders in the SELECT statement allow for dynamic querying of owner names and their corresponding dog's size category.", "virtual_table": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id"}
{"sample_id": "dev.951", "db_id": "dog_kennels", "question": "What are each owner's first name, last name, and the size of their dog?", "rationale": ["The query identifies the relevant tables, which are 'Owners' and 'Dogs'.", "It selects the columns 'first_name' and 'last_name' from the 'Owners' table (aliased as T1) and 'size_code' from the 'Dogs' table (aliased as T2).", "A JOIN operation is performed on the 'owner_id' to link the two tables, allowing for the retrieval of owner information alongside their dog's size code."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "description": "This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the specific values that can be modified to filter or retrieve specific information about owners and their dogs.", "virtual_table": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["The query identifies the relevant tables, which are 'Dogs' and 'Treatments'.", "It selects distinct values for the 'date_arrived' and 'date_departed' columns from the 'Dogs' table.", "A JOIN operation is performed on the 'dog_id' to link the 'Dogs' table with the 'Treatments' table, ensuring that only dogs with treatments are included."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "description": "This virtual table provides a list of unique arrival and departure dates for dogs from the 'Dogs' table, along with their associated treatments from the 'Treatments' table. The placeholders in the JOIN clause represent the relationships between the dogs and their treatments.", "virtual_table": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id"}
{"sample_id": "dev.961", "db_id": "dog_kennels", "question": "Who owns the youngest dog? Give me his or her last name.", "rationale": ["The query identifies the relevant tables, which are 'Owners' and 'Dogs'.", "It selects the 'last_name' column from the 'Owners' table.", "A JOIN operation is performed between 'Owners' and 'Dogs' on the 'owner_id' to link owners with their dogs.", "A subquery is used to find the maximum age of dogs in the 'Dogs' table, which is then used to filter the results in the WHERE clause."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "description": "This virtual table provides the last names of owners who own the oldest dog in the database. It joins the 'Owners' table with the 'Dogs' table based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.", "virtual_table": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects distinct values for 'breed_code' and 'size_code' to ensure that each combination is unique.", "The use of DISTINCT ensures that duplicate entries are not included in the result set."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "description": "This virtual table provides a unique list of breed codes and size codes from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.", "virtual_table": "SELECT DISTINCT breed_code ,  size_code FROM dogs"}
