{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["The query is identifying the relevant table, which is 'Student_Course_Attendance'.", "Select the column to display, 'student_id'.", "No additional conditions or filters are applied in this query, so it retrieves all student identifiers from the attendance records."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "description": "This virtual table describes the identifiers of students who have attended courses from the 'Student_Course_Attendance' table. The placeholder in the SELECT clause represents the unique student identifiers.", "virtual_table": "SELECT student_id FROM student_course_attendance"}
{"sample_id": "train.68", "db_id": "student_assessment", "question": "What details do we have on the students who registered for courses most recently?", "rationale": ["The query identifies the relevant tables, 'Student_Course_Registrations' and 'Students'.", "It selects the 'student_details' column from the 'Students' table.", "A JOIN operation is performed to link 'Student_Course_Registrations' with 'Students' using the 'student_id'.", "The results are ordered by 'registration_date' in descending order to show the most recent registrations first.", "A placeholder is included to limit the number of records returned."], "gold_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of records returned.", "virtual_table": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["The query identifies the relevant table, which is 'Candidate_Assessments'.", "It selects the 'candidate_id' column to display the identifiers of candidates.", "The results are ordered by 'assessment_date' in descending order to show the most recent assessments first.", "A placeholder is used in the LIMIT clause to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "description": "This virtual table provides a list of candidate identifiers from the 'Candidate_Assessments' table, ordered by the date of assessment in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.78", "db_id": "student_assessment", "question": "What are the details of the student who registered for the most number of courses?", "rationale": ["The query identifies the relevant tables, 'Students' and 'Student_Course_Registrations'.", "It selects the 'student_details' column from the 'Students' table.", "A JOIN operation is performed to link students with their course registrations based on the 'student_id'.", "The results are grouped by 'student_id' to avoid duplicates and to count the number of registrations per student.", "The results are ordered by the count of registrations in descending order to prioritize students with the most registrations.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.", "virtual_table": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["The query identifies the relevant tables: 'Students', 'Student_Course_Registrations', and 'Courses'.", "It selects the 'course_name' from the 'Courses' table and counts the number of students registered for each course.", "The join conditions link students to their course registrations and then to the course details.", "The results are grouped by 'course_id' to aggregate the count of students for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "description": "This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.", "virtual_table": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id"}
{"sample_id": "train.89", "db_id": "student_assessment", "question": "What is the id of the student who most recently registered course 301?", "rationale": ["The query identifies the relevant table, which is 'Student_Course_Attendance'.", "Select the column to display, 'student_id'.", "Add a condition to filter the 'course_id' column for the specified course using a placeholder for numeric values.", "Order the results by 'date_of_attendance' in descending order to show the most recent attendance first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "description": "This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.92", "db_id": "student_assessment", "question": "What are the different cities where people live?", "rationale": ["The query identifies the relevant tables, which are 'Addresses' and 'People_Addresses'.", "It selects distinct cities from the 'Addresses' table to avoid duplicates.", "A JOIN operation is performed between 'Addresses' and 'People_Addresses' on the 'address_id' to link addresses with people."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id", "source_tables": ["addresses", "people_addresses"], "description": "This virtual table provides a list of unique cities from the 'Addresses' table that are associated with people through the 'People_Addresses' table. The placeholder in the JOIN clause represents the relationship between addresses and people.", "virtual_table": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Course_Registrations'.", "It selects the 'student_id' from the 'Student_Course_Registrations' table.", "A JOIN operation is performed between 'Courses' and 'Student_Course_Registrations' on the 'course_id' to link students to their respective courses.", "A condition is added to filter the results based on the specified course name using a placeholder for string values.", "The results are ordered by the 'registration_date' to show the order of student registrations."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "description": "This virtual table lists the identifiers of students who are registered for a specific course from the 'Courses' table. The placeholder in the WHERE clause represents the name of the course, allowing users to filter the results based on their input.", "virtual_table": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = [PLACEHOLDER-TYPE:STRING] ORDER BY T2.registration_date"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Course_Registrations'.", "It selects the 'student_id' from the 'Student_Course_Registrations' table.", "A JOIN operation is performed to link 'Courses' and 'Student_Course_Registrations' based on the 'course_id'.", "A condition is added to filter the results by the specified 'course_name' using a placeholder for string values.", "The results are ordered by the 'registration_date' to show the most recent registrations first."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "description": "This virtual table lists the unique identifiers of students who are registered for a specific course from the 'Courses' table. The placeholder in the WHERE clause represents the name of the course, allowing users to filter the results based on their input.", "virtual_table": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = [PLACEHOLDER-TYPE:STRING] ORDER BY T2.registration_date"}
{"sample_id": "train.387", "db_id": "flight_1", "question": "Show origins of all flights with destination Honolulu.", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "Select the column to display, 'origin'.", "Add a condition to filter the 'destination' column for the specified destination using a placeholder for string values."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "description": "This virtual table provides the starting locations of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.", "virtual_table": "SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "Select the columns to display, 'departure_date' and 'arrival_date'.", "Add conditions to filter the 'origin' and 'destination' columns for the specified locations using placeholders for string values."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "description": "This virtual table provides the scheduled departure and arrival dates of flights from the 'Flight' table that originate from a specific location and are destined for another specific location. The placeholders in the WHERE clause represent the origin and destination of the flight.", "virtual_table": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING] AND destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.400", "db_id": "flight_1", "question": "What are the numbers of the shortest flights?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "Select the column to display, 'flno', which represents the flight number.", "Order the results by the 'distance' column in ascending order to show the shortest flights first.", "Limit the number of results returned using a placeholder for numeric values to specify how many flight numbers to retrieve."], "gold_sql": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT 3", "source_tables": ["flight"], "description": "This virtual table lists the flight numbers from the 'Flight' table, ordered by the distance of each flight in ascending order. The placeholder in the LIMIT clause represents the maximum number of flight numbers to be returned.", "virtual_table": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.408", "db_id": "flight_1", "question": "What place has the most flights coming from there?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "It selects the 'origin' column to display the starting locations of flights.", "The results are grouped by the 'origin' to aggregate the data based on unique starting locations.", "The query orders the results by the count of flights from each origin in descending order to show the most popular origins first.", "A limit is applied to restrict the number of origins returned, using a placeholder for numeric values."], "gold_sql": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "description": "This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.", "virtual_table": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["The query identifies the relevant tables, which are 'Flight' and 'Aircraft'.", "It selects the 'name' column from the 'Aircraft' table and counts the number of flights associated with each aircraft.", "A JOIN operation is performed on the 'aid' column to link flights with their respective aircraft.", "The results are grouped by the 'aid' to aggregate the flight counts for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "description": "This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.", "virtual_table": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid"}
{"sample_id": "train.429", "db_id": "flight_1", "question": "Show names for all employees who do not have certificate of Boeing 737-800.", "rationale": ["The query identifies the relevant table, which is 'Employee'.", "It selects the 'name' column to display the names of employees.", "The EXCEPT clause is used to exclude employees who hold a certificate for a specific aircraft model.", "A JOIN operation is performed between 'Employee', 'Certificate', and 'Aircraft' to filter out employees based on the aircraft model using a placeholder for string values."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "description": "This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.", "virtual_table": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.433", "db_id": "flight_1", "question": "Show the name and distance of the aircrafts with more than 5000 distance and which at least 5 people have its certificate.", "rationale": ["The query identifies the relevant tables, 'Certificate' and 'Aircraft', and establishes a join between them based on the aircraft ID.", "It selects the 'name' column from the 'Aircraft' table.", "A condition is added to filter aircraft based on their maximum travel distance using a placeholder for numeric values.", "The results are grouped by aircraft ID to aggregate the data appropriately.", "An ordering condition is applied to filter the results based on the count of certifications that meet a specified threshold using another placeholder for numeric values."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "description": "This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.434", "db_id": "flight_1", "question": "What is the name and distance of every aircraft that can cover a distance of more than 5000 and which at least 5 people can fly?", "rationale": ["The query identifies the relevant tables, 'Certificate' and 'Aircraft', and establishes a join between them based on the aircraft ID.", "It selects the 'name' column from the 'Aircraft' table.", "A condition is added to filter aircraft based on their maximum travel distance using a placeholder for numeric values.", "The results are grouped by aircraft ID to aggregate the data appropriately.", "An ordering condition is applied to ensure that only those aircraft with a count of certifications greater than or equal to a specified number are included."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "description": "This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.437", "db_id": "flight_1", "question": "What is the salary and name of the employee who has the most number of certificates on aircrafts with distance more than 5000?", "rationale": ["The query identifies the relevant tables: 'Employee', 'Certificate', and 'Aircraft'.", "It selects the 'name' column from the 'Employee' table, which is aliased as T1.", "The query joins the 'Certificate' table (aliased as T2) on the employee ID to link employees with their certificates.", "It further joins the 'Aircraft' table (aliased as T3) on the aircraft ID to filter based on the aircraft's distance capability.", "A condition is added to filter aircraft with a distance greater than a specified number using a placeholder for numeric values.", "The results are grouped by employee ID to count the number of certificates each employee holds.", "Finally, the results are ordered by the count of certificates in descending order and limited to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "description": "This virtual table lists the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.", "virtual_table": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "Select the distinct values of the 'allergy' column to avoid duplicates.", "Add a condition to filter the 'allergytype' column for the specified type using a placeholder for string values."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "description": "This virtual table provides a list of distinct allergies from the 'Allergy_Type' table that belong to a specific category of allergy. The placeholder in the WHERE clause represents the type of allergy being queried.", "virtual_table": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.456", "db_id": "allergy_1", "question": "Which allergy type is most common?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects the 'allergytype' column to display the types of allergies.", "The query groups the results by 'allergytype' to aggregate the data.", "It orders the results by the count of occurrences in descending order to show the most common types first.", "The LIMIT clause uses a placeholder for numeric values to specify how many types to return."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "description": "This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.", "virtual_table": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects the 'allergytype' column to display the types of allergies.", "The results are grouped by 'allergytype' to aggregate similar types together.", "The results are ordered by the count of occurrences in ascending order to show the least common allergy types first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "description": "This virtual table provides a list of allergy types from the 'Allergy_Type' table, grouped by their category. The results are ordered by the count of occurrences in ascending order, with a limit set by a placeholder for numeric values.", "virtual_table": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["The query is identifying the relevant table, which is 'Student'.", "Select the columns to display, 'Fname' and 'Lname'.", "The query can be expanded to include additional conditions or filters as needed."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "description": "This virtual table describes the first and last names of students from the 'Student' table. The query can be further modified to include conditions or filters based on specific criteria such as age, major, or city code.", "virtual_table": "SELECT Fname ,  Lname FROM Student"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["The query is identifying the relevant table, which is 'Student'.", "Select the column to display, 'StuID'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "description": "This virtual table lists the unique identifiers of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT StuID FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the column to display, 'major'.", "Group the results by 'major' to aggregate the data.", "Order the results by the count of students in each major in descending order to show the most popular majors first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of academic majors from the 'Student' table, grouped by the major and ordered by the number of students in each major in descending order. The placeholder in the LIMIT clause represents the maximum number of majors to return.", "virtual_table": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.501", "db_id": "allergy_1", "question": "Which advisor has most number of students?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the column to display, 'advisor'.", "Group the results by the 'advisor' column to aggregate the data.", "Order the results by the count of students associated with each advisor in descending order.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of academic advisors from the 'Student' table, grouped by the advisor's name. The results are ordered by the number of students assigned to each advisor in descending order, with a limit on the number of advisors returned, specified by a placeholder for numeric values.", "virtual_table": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["The query identifies the relevant table, which is 'Has_Allergy'.", "It selects the count of records to determine how many students have a specific allergy.", "A condition is added to filter the 'Allergy' column for the specified allergy using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "description": "This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.", "virtual_table": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.508", "db_id": "allergy_1", "question": "Which students are unaffected by allergies?", "rationale": ["The query starts by selecting the 'StuID' from the 'Student' table, which contains all students.", "Then, it uses the EXCEPT clause to remove any 'StuID' that appears in the 'Has_Allergy' table, which lists students with allergies."], "gold_sql": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy", "source_tables": ["has_allergy", "student"], "description": "This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.", "virtual_table": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy"}
{"sample_id": "train.509", "db_id": "allergy_1", "question": "How many female students have milk or egg allergies?", "rationale": ["The query identifies the relevant tables, 'Has_Allergy' and 'Student', and uses a JOIN to combine them based on the student ID.", "It selects the count of students who meet the specified criteria.", "The WHERE clause filters the results based on the gender of the students and checks for specific allergies using placeholders for string values."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies being queried.", "virtual_table": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["The query identifies the relevant tables, which are 'Has_Allergy' and 'Student'.", "It uses a JOIN operation to combine records from both tables based on the student ID (StuID).", "The SELECT statement counts the number of records that meet the specified conditions.", "The WHERE clause filters the results based on the gender of the students and checks for specific allergies using placeholders for string values."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies being queried.", "virtual_table": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.513", "db_id": "allergy_1", "question": "Which allergy has most number of students affected?", "rationale": ["The query identifies the relevant table, which is 'Has_Allergy'.", "It selects the 'Allergy' column to display the names of allergies.", "The GROUP BY clause is used to group the results by the 'Allergy' name.", "The ORDER BY clause sorts the results based on the count of occurrences in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many results they want to see."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "description": "This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.", "virtual_table": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.518", "db_id": "allergy_1", "question": "How many students are affected by each allergy type?", "rationale": ["The query identifies the relevant tables, which are 'Has_Allergy' and 'Allergy_Type'.", "It performs a JOIN operation on the 'Allergy' column to combine data from both tables.", "The SELECT statement retrieves the 'allergytype' from the 'Allergy_Type' table and counts the number of occurrences from the 'Has_Allergy' table.", "The GROUP BY clause is used to aggregate the results by 'allergytype', allowing us to see the count of students for each type of allergy."], "gold_sql": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype", "source_tables": ["has_allergy", "allergy_type"], "description": "This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.", "virtual_table": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'lname' and 'age'.", "Add a condition to filter students based on their allergies by using a subquery that checks for students with both specified allergies using the INTERSECT operator. The placeholders represent the names of the allergies."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.", "virtual_table": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.522", "db_id": "allergy_1", "question": "What are the allergies the girl named Lisa has? And what are the types of them? Order the result by allergy names.", "rationale": ["The query identifies the relevant tables: 'Allergy_Type', 'Has_Allergy', and 'Student'.", "It selects the columns 'Allergy' and 'AllergyType' from the 'Allergy_Type' table.", "The JOIN operations link the 'Has_Allergy' table to the 'Allergy_Type' table and the 'Student' table based on the foreign key relationships.", "A condition is added to filter results by the student's first name using a placeholder for string values.", "The results are ordered by the 'Allergy' column."], "gold_sql": "SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  'Lisa' ORDER BY T1.Allergy", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.", "virtual_table": "SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["The query identifies the relevant table, which is 'Student', to calculate the average age.", "It uses a subquery to find students who have allergies of a specific type by joining 'Has_Allergy' and 'Allergy_Type'.", "The INTERSECT operator is used to ensure that only students with both specified allergy types are considered.", "Finally, the average age is calculated for the filtered list of students."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.", "virtual_table": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.527", "db_id": "allergy_1", "question": "List the first and last name of the students who do not have any food type allergy.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'lname'.", "Add a condition to filter out students whose IDs are in a subquery.", "The subquery selects student IDs from 'Has_Allergy' joined with 'Allergy_Type' where the allergy type matches the specified placeholder."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.", "virtual_table": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.529", "db_id": "allergy_1", "question": "Find the number of male (sex is 'M') students who have some food type allery.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It counts the total number of students that meet certain criteria.", "The first condition filters students based on their gender using a placeholder for string values.", "The second condition checks if the student's ID is in a subquery that joins 'Has_Allergy' and 'Allergy_Type' to filter by a specific allergy type, using another placeholder for string values."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a specific type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy.", "virtual_table": "SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["The query identifies the relevant tables, which are 'Student' and 'Has_Allergy'.", "It selects distinct values for the 'fname' and 'city_code' columns from the 'Student' table.", "A JOIN operation is performed between 'Student' and 'Has_Allergy' on the 'StuID' column to link students with their allergies.", "The WHERE clause filters the results based on the specified allergies using placeholders for string values."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.", "virtual_table": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.533", "db_id": "allergy_1", "question": "Find the number of students who are older than 18 and do not have allergy to either food or animal.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It counts the total number of students that meet the specified criteria.", "A condition is added to filter students based on their age using a placeholder for numeric values.", "A subquery is used to exclude students who have allergies of specified types by joining 'Has_Allergy' and 'Allergy_Type' tables, with placeholders for the allergy types."], "gold_sql": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' OR T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age threshold and the allergy types to be excluded.", "virtual_table": "SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.535", "db_id": "allergy_1", "question": "Find the first name and major of the students who are not allegry to soy.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'Fname' and 'Major'.", "Add a condition to filter out students who have a specific allergy by using a subquery that checks the 'StuID' in the 'Has_Allergy' table for the specified allergy, using a placeholder for string values."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy being checked against the 'Has_Allergy' table.", "virtual_table": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_country' and calculates the average of the 'total' column.", "The results are grouped by 'billing_country' to aggregate the totals for each country.", "The results are ordered by the average total in descending order to show the highest averages first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "description": "This virtual table provides the average total amount of invoices grouped by billing country. The results are ordered in descending order based on the average total, and a placeholder is included to limit the number of results returned.", "virtual_table": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.553", "db_id": "store_1", "question": "List every album ordered by album title in ascending order.", "rationale": ["The query identifies the relevant table, which is 'albums'.", "Select the column to display, 'title'.", "Add an ORDER BY clause to sort the results by the 'title' column in ascending order."], "gold_sql": "SELECT title FROM albums ORDER BY title;", "source_tables": ["albums"], "description": "This virtual table lists the titles of all albums from the 'albums' table, sorted in alphabetical order. The query retrieves the 'title' column and orders the results by the album title.", "virtual_table": "SELECT title FROM albums ORDER BY title;"}
{"sample_id": "train.560", "db_id": "store_1", "question": "What are the total amount of money in the invoices billed from Chicago, Illinois?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the sum of the 'total' column to calculate the total amount of invoices.", "A condition is added to filter the results based on the 'billing_city' and 'billing_state' columns using placeholders for string values."], "gold_sql": "SELECT sum(total) FROM invoices WHERE billing_city  =  'Chicago' AND billing_state  =  'IL';", "source_tables": ["invoices"], "description": "This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.", "virtual_table": "SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' column and counts the number of invoices for each state.", "A condition is added to filter the results based on the 'billing_country' using a placeholder for string values.", "The results are grouped by 'billing_state' to provide a count of invoices per state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "description": "This virtual table summarizes the number of invoices issued in each state within a specific country. The placeholder in the WHERE clause represents the name of the country for which the invoice data is being aggregated.", "virtual_table": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state;"}
{"sample_id": "train.565", "db_id": "store_1", "question": "List the state in the US with the most invoices.", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' and counts the number of invoices for each state.", "A condition is added to filter the results based on the specified 'billing_country' using a placeholder for string values.", "The results are grouped by 'billing_state' to aggregate the counts.", "The results are ordered by the count of invoices in descending order to show the states with the most invoices first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "description": "This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country for which the invoice counts are being aggregated, while the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.", "virtual_table": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' and counts the number of invoices for each state.", "A condition is added to filter the results based on the specified 'billing_country' using a placeholder for string values.", "The results are grouped by 'billing_state' to aggregate the counts.", "The results are ordered by the count of invoices in descending order to show the states with the most invoices first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "description": "This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country name, while the placeholder in the LIMIT clause indicates the maximum number of states to return, sorted by the count of invoices in descending order.", "virtual_table": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.567", "db_id": "store_1", "question": "List the number of invoices and the invoice total from California.", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' column along with a count of invoices and the sum of the total amounts.", "A condition is added to filter the results based on the specified 'billing_state' using a placeholder for string values."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "description": "This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.", "virtual_table": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["The query identifies the relevant table, which is 'customers'.", "Select the columns to display, 'email' and 'phone'.", "Add conditions to filter the 'first_name' and 'last_name' columns for the specified customer using placeholders for string values."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "description": "This virtual table describes the email addresses and phone numbers of customers from the 'customers' table who have a specific first and last name. The placeholders in the WHERE clause represent the customer's first and last names.", "virtual_table": "SELECT email ,  phone FROM customers WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'customers'.", "It selects the 'first_name' and 'last_name' columns from the 'employees' table, aliased as T1.", "A JOIN operation is performed between 'employees' (T1) and 'customers' (T2) on the condition that the employee's ID matches the support representative ID in the customers table.", "The results are grouped by the employee's ID to aggregate the number of customers each representative supports.", "The results are ordered in descending order based on the count of customers, and a limit is applied to restrict the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "description": "This virtual table provides a list of support representatives' first and last names from the 'employees' table, who are associated with customers in the 'customers' table. The results are grouped by the representative's ID and ordered by the number of customers they support, with a limit on the number of representatives returned based on a specified number.", "virtual_table": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.594", "db_id": "store_1", "question": "What is the full name of the employee who has the most customers?", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'customers'.", "It selects the 'first_name' and 'last_name' columns from the 'employees' table, aliased as T1.", "A JOIN operation is performed between 'employees' and 'customers' on the condition that the employee's ID matches the support representative ID in the customers table.", "The results are grouped by the employee's ID to aggregate the data based on the number of customers they support.", "The results are ordered in descending order based on the count of customers associated with each employee.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "description": "This virtual table provides the first and last names of employees who serve as support representatives for customers. The data is aggregated by the employee's ID, and the results are ordered by the number of customers they support in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.604", "db_id": "store_1", "question": "How many employees who are IT staff are from each city?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the count of employees and the city they reside in.", "A condition is added to filter employees based on their job title using a placeholder for string values.", "The results are grouped by city to provide a count of employees in each city for the specified job title."], "gold_sql": "SELECT count(*) ,  city FROM employees WHERE title  =  'IT Staff' GROUP BY city", "source_tables": ["employees"], "description": "This virtual table provides a count of employees grouped by their city, specifically for those who hold a certain job title. The placeholder in the WHERE clause represents the job title of the employees.", "virtual_table": "SELECT count(*) ,  city FROM employees WHERE title  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city"}
{"sample_id": "train.624", "db_id": "store_1", "question": "What is the name of the album that has the track Ball to the Wall?", "rationale": ["The query identifies the relevant tables, which are 'albums' and 'tracks'.", "It selects the 'title' column from the 'albums' table.", "A JOIN is performed between 'albums' and 'tracks' on the condition that the album's ID matches the genre ID of the track, which is likely a mistake since it should match the album ID instead.", "A condition is added to filter the tracks by their name using a placeholder for string values."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "description": "This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.", "virtual_table": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["The query identifies the relevant tables: 'genres', 'tracks', and 'media_types'.", "It selects the 'name' column from the 'tracks' table (aliased as T2).", "It joins the 'genres' table (aliased as T1) on the genre ID to filter tracks by genre.", "It also joins the 'media_types' table (aliased as T3) on the media type ID to filter tracks by media type.", "The WHERE clause includes conditions to filter by the specified genre name or media type name using placeholders for string values."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "description": "This virtual table describes the names of tracks from the 'tracks' table that belong to a specific genre or media type. The placeholders in the WHERE clause represent the genre's name and the media type's name.", "virtual_table": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = [PLACEHOLDER-TYPE:STRING] OR T3.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.946", "db_id": "medicine_enzyme_interaction", "question": "What are the names and trade names of the medcines that are FDA approved?", "rationale": ["The query is identifying the relevant table, which is 'medicine'.", "Select the columns to display, 'name' and 'Trade_Name'.", "Add a condition to filter the 'FDA_approved' column for the specified approval status using a placeholder for string values."], "gold_sql": "SELECT name ,  trade_name FROM medicine WHERE FDA_approved  =  'Yes'", "source_tables": ["medicine"], "description": "This virtual table describes the names and trade names of medicines from the 'medicine' table that have a specific FDA approval status. The placeholder in the WHERE clause represents the FDA approval status of the medicine.", "virtual_table": "SELECT name ,  trade_name FROM medicine WHERE FDA_approved  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.951", "db_id": "medicine_enzyme_interaction", "question": "What are the ids, names and FDA approval status of medicines in descending order of the number of enzymes that it can interact with.", "rationale": ["The query identifies the relevant tables, 'medicine' and 'medicine_enzyme_interaction'.", "It selects the columns 'id', 'name', and 'FDA_approved' from the 'medicine' table, aliased as T1.", "A JOIN operation is performed between 'medicine' (T1) and 'medicine_enzyme_interaction' (T2) on the condition that the medicine IDs match.", "The results are grouped by the medicine ID to aggregate the interaction counts.", "Finally, the results are ordered by the count of interactions in descending order."], "gold_sql": "SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC", "source_tables": ["medicine", "medicine_enzyme_interaction"], "description": "This virtual table provides a list of medicines along with their unique identifiers and FDA approval status, sorted by the number of interactions they have with enzymes. The placeholders in the query allow for dynamic filtering and sorting based on the interaction count.", "virtual_table": "SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC"}
{"sample_id": "train.953", "db_id": "medicine_enzyme_interaction", "question": "What is the id and name of the enzyme with most number of medicines that can interact as 'activator'?", "rationale": ["The query identifies the relevant tables, which are 'enzyme' and 'medicine_enzyme_interaction'.", "It selects the columns 'id' and 'name' from the 'enzyme' table, aliased as T1.", "A JOIN operation is performed between 'enzyme' (T1) and 'medicine_enzyme_interaction' (T2) on the enzyme ID to link the two tables.", "A condition is added to filter the results based on the specified 'interaction_type' using a placeholder for string values.", "The results are grouped by the enzyme ID to aggregate the data, and ordered by the count of interactions in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  'activitor' GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["enzyme", "medicine_enzyme_interaction"], "description": "This virtual table provides a list of enzyme identifiers and their names from the 'enzyme' table that are involved in a specific type of interaction with medicines. The interaction type is specified by a placeholder, and the results are grouped by enzyme ID, ordered by the frequency of interactions in descending order, with a limit on the number of results returned.", "virtual_table": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.968", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that can interact as an inhibitor and activitor with enzymes?", "rationale": ["The query identifies the relevant tables, which are 'medicine' and 'medicine_enzyme_interaction'.", "It selects the columns to display, 'name' and 'trade_name' from the 'medicine' table.", "The query uses a JOIN to connect the 'medicine' table with the 'medicine_enzyme_interaction' table based on the medicine's ID.", "It adds a condition to filter the results based on the 'interaction_type' column using placeholders for string values.", "The INTERSECT operator is used to find common medicines that meet the specified interaction types in two separate queries."], "gold_sql": "SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'inhibitor' INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'activitor'", "source_tables": ["medicine", "medicine_enzyme_interaction"], "description": "This virtual table describes the names and trade names of medicines that have specific types of interactions with enzymes. The placeholders in the WHERE clause represent the types of interactions being queried.", "virtual_table": "SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.970", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that cannot interact with the enzyme with the product 'Heme'?", "rationale": ["The query identifies the relevant table, which is 'medicine'.", "Select the columns to display, 'name' and 'trade_name'.", "Use the EXCEPT clause to filter out medicines that interact with a specific enzyme product.", "Join the 'medicine' table with 'medicine_enzyme_interaction' and 'enzyme' tables to find the medicines that have interactions with the specified enzyme product using a placeholder for string values."], "gold_sql": "SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  'Protoporphyrinogen IX'", "source_tables": ["enzyme", "medicine", "medicine_enzyme_interaction"], "description": "This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product name of the enzyme.", "virtual_table": "SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1355", "db_id": "college_2", "question": "What is the name of the department with an instructure who has a name like 'Soisalon'?", "rationale": ["The query identifies the relevant table, which is 'instructor'.", "Select the column to display, 'dept_name'.", "Add a condition to filter the 'name' column using a LIKE operator for pattern matching with a placeholder for string values."], "gold_sql": "SELECT dept_name FROM instructor WHERE name LIKE '%Soisalon%'", "source_tables": ["instructor"], "description": "This virtual table provides the names of academic departments associated with instructors whose names match a specified pattern. The placeholder in the WHERE clause allows for flexible searching of instructor names.", "virtual_table": "SELECT dept_name FROM instructor WHERE name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1365", "db_id": "college_2", "question": "What are the titles of courses that are in the Statistics department but not the Psychology department?", "rationale": ["The query identifies the relevant table, which is 'course'.", "It selects the 'title' column to display the names of the courses.", "The first WHERE clause filters the courses by the first specified department using a placeholder for string values.", "The EXCEPT clause is used to exclude the titles of courses from the second specified department, also using a placeholder for string values."], "gold_sql": "SELECT title FROM course WHERE dept_name  =  'Statistics' EXCEPT SELECT title FROM course WHERE dept_name  =  'Psychology'", "source_tables": ["course"], "description": "This virtual table lists the titles of courses offered by one academic department that are not offered by another academic department. The placeholders in the WHERE clause represent the names of the departments being compared.", "virtual_table": "SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1424", "db_id": "college_2", "question": "Find the title of course whose prerequisite is course Differential Geometry.", "rationale": ["The query identifies the relevant table, which is 'course'.", "It selects the 'title' column to display the names of the courses.", "A subquery is used to find the 'course_id' of courses that have prerequisites, joining the 'prereq' table with the 'course' table based on the prerequisite course ID.", "The condition in the subquery filters the courses based on the title of the prerequisite course using a placeholder for string values."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  =  'Differential Geometry')", "source_tables": ["course", "prereq"], "description": "This virtual table lists the titles of courses from the 'course' table that have prerequisites. The prerequisite courses are identified by their titles, which are specified using a placeholder in the subquery.", "virtual_table": "SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.1426", "db_id": "college_2", "question": "Find the names of students who have taken any course in the fall semester of year 2003.", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the 'name' column to display the names of the students.", "A subquery is used to filter students based on their enrollment in courses during a specified semester and year, using placeholders for these values."], "gold_sql": "SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  'Fall' AND YEAR  =  2003)", "source_tables": ["student", "takes"], "description": "This virtual table describes the names of students who are enrolled in courses during a specific semester and year. The placeholders in the WHERE clause represent the semester and year for which the student enrollment is being queried.", "virtual_table": "SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.1435", "db_id": "college_2", "question": "What are the names of all instructors who advise students in the math depart sorted by total credits of the student.", "rationale": ["The query identifies the relevant tables: 'advisor', 'instructor', and 'student'.", "It selects the 'name' column from the 'instructor' table (aliased as T2).", "The JOIN operations link the 'advisor' table (T1) with the 'instructor' table (T2) based on the instructor's ID, and with the 'student' table (T3) based on the student's ID.", "A condition is added to filter the results based on the department name from the 'student' table using a placeholder for string values.", "Finally, the results are ordered by the total credits earned by the students."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id WHERE T3.dept_name  =  'Math' ORDER BY T3.tot_cred", "source_tables": ["instructor", "student", "advisor"], "description": "This virtual table lists the names of instructors who are advising students from a specific department. The placeholder in the WHERE clause represents the department's name, and the results are ordered by the total credits earned by the students.", "virtual_table": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id WHERE T3.dept_name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T3.tot_cred"}
{"sample_id": "train.1436", "db_id": "college_2", "question": "What is the course title of the prerequisite of course Mobile Computing?", "rationale": ["The query identifies the relevant table, which is 'course'.", "It selects the 'title' column to display the names of the courses.", "The WHERE clause filters the courses based on their IDs, which are obtained from a subquery.", "The subquery joins the 'prereq' table with the 'course' table to find the prerequisite IDs for the specified course title, using a placeholder for the course title."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  'Mobile Computing')", "source_tables": ["course", "prereq"], "description": "This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.", "virtual_table": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.1439", "db_id": "college_2", "question": "What is the name of the instructor who advises the student with the greatest number of total credits?", "rationale": ["The query identifies the relevant tables: 'advisor', 'instructor', and 'student'.", "It selects the 'name' column from the 'instructor' table (aliased as T2).", "The JOIN operation connects the 'advisor' table (T1) with the 'instructor' table (T2) based on the instructor's ID, and with the 'student' table (T3) based on the student's ID.", "The results are ordered by the 'tot_cred' column from the 'student' table in descending order to prioritize students with the most credits.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT 1", "source_tables": ["instructor", "student", "advisor"], "description": "This virtual table lists the names of instructors who are advising students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.", "virtual_table": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1448", "db_id": "college_2", "question": "Find the number and averaged salary of all instructors who are in the department with the highest budget.", "rationale": ["The query identifies the relevant tables, which are 'instructor' and 'department'.", "It selects the average salary from the 'instructor' table and counts the number of instructors.", "A join is performed on the 'dept_name' column to associate instructors with their departments.", "The results are ordered by the 'budget' column from the 'department' table in descending order.", "A limit is applied to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "description": "This virtual table calculates the average salary of instructors grouped by their respective departments, and counts the number of instructors in each department. The results are ordered by the department's budget in descending order, with a limit on the number of departments returned based on a specified number.", "virtual_table": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1449", "db_id": "college_2", "question": "How many instructors are in the department with the highest budget, and what is their average salary?", "rationale": ["The query identifies the relevant tables, which are 'instructor' and 'department'.", "It selects the average salary from the 'instructor' table and counts the number of instructors.", "A JOIN operation is performed on the 'dept_name' column to associate instructors with their respective departments.", "The results are ordered by the 'budget' column from the 'department' table in descending order.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "description": "This virtual table provides the average salary of instructors along with the count of instructors in each department, sorted by the department's budget in descending order. The placeholder in the LIMIT clause represents the maximum number of departments to be displayed.", "virtual_table": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1452", "db_id": "college_2", "question": "Find the name of students who didn't take any course from Biology department.", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the 'name' column to display the names of students.", "The condition filters out students whose IDs are found in a subquery that checks for enrollment in courses from a specified department, using a placeholder for the department's name."], "gold_sql": "SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  'Biology')", "source_tables": ["course", "student", "takes"], "description": "This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.", "virtual_table": "SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.1458", "db_id": "college_2", "question": "Find the name and salary of instructors whose salary is below the average salary of the instructors in the Physics department.", "rationale": ["The query identifies the relevant table, which is 'instructor'.", "Select the columns to display, 'name' and 'salary'.", "Add a condition to filter the instructors based on their salary being less than the average salary of instructors in a specific department.", "The subquery calculates the average salary for instructors in the specified department using a placeholder for string values."], "gold_sql": "SELECT name ,  salary FROM instructor WHERE salary  <  (SELECT avg(salary) FROM instructor WHERE dept_name  =  'Physics')", "source_tables": ["instructor"], "description": "This virtual table provides the names and salaries of instructors from the 'instructor' table who earn less than the average salary of instructors within a specified department. The placeholder in the subquery represents the department's name.", "virtual_table": "SELECT name ,  salary FROM instructor WHERE salary  <  (SELECT avg(salary) FROM instructor WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.1461", "db_id": "college_2", "question": "What are the names of students who have taken Statistics courses?", "rationale": ["The query identifies the relevant tables: 'course', 'takes', and 'student'.", "It selects the 'name' column from the 'student' table.", "The JOIN operations link the 'course' table to the 'takes' table using 'course_id', and the 'takes' table to the 'student' table using 'ID'.", "A condition is added to filter the results based on the 'dept_name' column in the 'course' table, using a placeholder for the department's name."], "gold_sql": "SELECT T3.name FROM course AS T1 JOIN takes AS T2 ON T1.course_id  =  T2.course_id JOIN student AS T3 ON T2.id  =  T3.id WHERE T1.dept_name  =  'Statistics'", "source_tables": ["course", "student", "takes"], "description": "This virtual table lists the names of students who are enrolled in courses offered by a specific academic department. The placeholder in the WHERE clause represents the name of the department.", "virtual_table": "SELECT T3.name FROM course AS T1 JOIN takes AS T2 ON T1.course_id  =  T2.course_id JOIN student AS T3 ON T2.id  =  T3.id WHERE T1.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1464", "db_id": "college_2", "question": "Find the names of all instructors in computer science department", "rationale": ["The query is identifying the relevant table, which is 'instructor'.", "Select the column to display, 'name'.", "Add a condition to filter the 'dept_name' column for the specified department using a placeholder for string values."], "gold_sql": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'", "source_tables": ["instructor"], "description": "This virtual table describes the names of instructors from the 'instructor' table who belong to a specific academic department. The placeholder in the WHERE clause represents the department's name.", "virtual_table": "SELECT name FROM instructor WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1480", "db_id": "college_2", "question": "Find courses that ran in Fall 2009 but not in Spring 2010.", "rationale": ["The query is identifying the relevant table, which is 'SECTION'.", "Select the 'course_id' column to display the course identifiers.", "Add a condition to filter the results based on the specified semester and year using placeholders for string and numeric values.", "Use the EXCEPT clause to exclude course IDs from another specified semester and year."], "gold_sql": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 EXCEPT SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010", "source_tables": ["section"], "description": "This virtual table identifies the course IDs from the 'SECTION' table that are offered in a specific semester and year, excluding those that are offered in another specified semester and year. The placeholders in the query represent the semester and year values for filtering the results.", "virtual_table": "SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER] EXCEPT SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1489", "db_id": "college_2", "question": "What are the names of instructors who earn more than at least one instructor from the Biology department?", "rationale": ["The query identifies the relevant table, which is 'instructor'.", "Select the column to display, 'name'.", "Add a condition to filter the instructors based on their salary being greater than a subquery result.", "The subquery selects the minimum salary from the 'instructor' table filtered by the specified department using a placeholder for string values."], "gold_sql": "SELECT name FROM instructor WHERE salary  >  (SELECT min(salary) FROM instructor WHERE dept_name  =  'Biology')", "source_tables": ["instructor"], "description": "This virtual table lists the names of instructors from the 'instructor' table who earn a salary greater than the minimum salary of instructors in a specified department. The placeholder in the subquery represents the department's name.", "virtual_table": "SELECT name FROM instructor WHERE salary  >  (SELECT min(salary) FROM instructor WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.1515", "db_id": "insurance_and_eClaims", "question": "Find the total and average amount paid in claim headers.", "rationale": ["The query identifies the relevant table, which is 'Claim_Headers'.", "It selects the sum and average of the 'amount_paid' column to provide a summary of the payments made for claims."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "description": "This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the total and average of the 'amount_paid' column.", "virtual_table": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["The query identifies the relevant table, which is 'Claim_Headers'.", "It selects the sum and average of the 'amount_piad' column to provide a summary of the amounts paid.", "The use of aggregate functions allows for a concise representation of the total and average values."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "description": "This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the aggregated values of the amounts paid.", "virtual_table": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers"}
{"sample_id": "train.1517", "db_id": "insurance_and_eClaims", "question": "Find the total amount claimed in the most recently created document.", "rationale": ["The query identifies the relevant tables, 'Claim_Headers' and 'Claims_Documents'.", "It uses a JOIN to link the claims with their corresponding documents based on the claim ID.", "The SUM function is applied to the 'amount_claimed' column to calculate the total amount for the claims.", "A subquery is used to filter the documents based on their creation date, with a placeholder indicating the limit for the selection."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "description": "This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.", "virtual_table": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["The query identifies the relevant tables: 'Claim_Headers', 'Policies', and 'Customers'.", "It selects the 'customer_details' from the 'Customers' table.", "The join conditions link 'Claim_Headers' to 'Policies' using 'policy_id', and 'Policies' to 'Customers' using 'customer_id'.", "The WHERE clause filters the results to only include the claim with the maximum amount claimed, using a subquery to determine this maximum value."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "description": "This virtual table provides detailed information about the customer associated with the claim that has the highest amount claimed. It retrieves the customer details from the 'Customers' table by joining it with the 'Policies' and 'Claim_Headers' tables based on their relationships. The placeholder in the WHERE clause is used to filter for the maximum claimed amount.", "virtual_table": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)"}
{"sample_id": "train.1527", "db_id": "insurance_and_eClaims", "question": "What is the name of the claim processing stage that most of the claims are on?", "rationale": ["The query identifies the relevant tables, which are 'claims_processing' and 'claims_processing_stages'.", "It selects the 'claim_status_name' from the 'claims_processing_stages' table.", "A JOIN operation is performed on the 'claim_stage_id' to link the two tables together.", "The results are grouped by 'claim_stage_id' to aggregate the data appropriately.", "The results are ordered by the count of occurrences in descending order to prioritize the most common statuses.", "A placeholder is included to allow the user to specify the limit on the number of statuses returned."], "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"], "description": "This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.", "virtual_table": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1535", "db_id": "insurance_and_eClaims", "question": "Find the names of all the customers and staff members.", "rationale": ["The query is identifying the relevant tables, which are 'Customers' and 'Staff'.", "It selects the 'Customer_Details' from the 'Customers' table and 'Staff_Details' from the 'Staff' table.", "The UNION operator is used to combine the results from both tables into a single result set."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "description": "This virtual table combines detailed information about customers and staff members from the 'Customers' and 'Staff' tables. The result will include all customer details and staff details in a single unified list.", "virtual_table": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff"}
{"sample_id": "train.1545", "db_id": "insurance_and_eClaims", "question": "Which customer is associated with the latest policy?", "rationale": ["The query identifies the relevant tables, which are 'Policies' and 'Customers'.", "It selects the 'Customer_Details' from the 'Customers' table.", "A JOIN operation is performed on 'Policies' and 'Customers' using the 'Customer_ID' to link them.", "The WHERE clause filters the results to only include the customer details for the policy that has the maximum start date, using a subquery to find this date."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "description": "This virtual table retrieves the detailed information about customers who have the most recently started insurance policy from the 'Policies' table. The placeholder in the WHERE clause represents the condition to find the latest start date of the policy.", "virtual_table": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["The query identifies the relevant tables, which are 'Policies' and 'Customers'.", "It selects the 'Customer_Details' from the 'Customers' table.", "A JOIN operation is performed on 'Policies' and 'Customers' using the 'Customer_ID' to link them.", "The WHERE clause filters the results to only include the customer details for the policy that has the maximum start date, using a subquery to find this date."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "description": "This virtual table retrieves the detailed information about customers who have the most recently started insurance policy from the 'Policies' table. The placeholder in the WHERE clause represents the condition to find the latest start date of the policy.", "virtual_table": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["The query identifies the relevant tables, which are 'Accounts' and 'Customers'.", "It selects the columns to display from the 'Accounts' table: 'account_id', 'date_account_opened', 'account_name', and 'other_account_details'.", "A JOIN operation is performed between 'Accounts' and 'Customers' on the 'customer_id' to link accounts to their respective customers.", "A condition is added to filter the results based on the 'customer_first_name' from the 'Customers' table using a placeholder for string values."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "description": "This virtual table provides details about customer accounts from the 'Accounts' table, including the account ID, the date the account was opened, the account name, and any additional account details. The results are filtered based on the first name of the customer from the 'Customers' table, represented by a placeholder for string values.", "virtual_table": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["The query identifies the relevant tables, which are 'Accounts' and 'Customers'.", "It selects the columns to display, 'account_name' and 'other_account_details' from the 'Accounts' table.", "A JOIN operation is performed to link 'Accounts' with 'Customers' based on the 'customer_id'.", "Conditions are added to filter the results based on the specified first and last names of the customer using placeholders for string values."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "description": "This virtual table describes the account names and additional details of accounts associated with customers from the 'Accounts' table, filtered by the first and last names of the customers. The placeholders in the WHERE clause represent the customer's first and last names.", "virtual_table": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.customer_last_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["The query identifies the relevant tables, which are 'Accounts' and 'Customers'.", "It selects the columns to display, 'customer_first_name' and 'customer_last_name'.", "A JOIN operation is performed on 'customer_id' to link the two tables based on the relationship defined in the schema.", "A condition is added to filter the 'account_name' column for the specified account using a placeholder for string values."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "description": "This virtual table describes the first and last names of customers associated with a specific account from the 'Accounts' and 'Customers' tables. The placeholder in the WHERE clause represents the name of the account.", "virtual_table": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1569", "db_id": "customers_and_invoices", "question": "Show id, first name and last name for all customers and the number of accounts.", "rationale": ["The query identifies the relevant tables, 'Accounts' and 'Customers'.", "It selects the 'customer_id', 'customer_first_name', and 'customer_last_name' from the 'Customers' table.", "It counts the number of accounts associated with each customer using the COUNT function.", "The JOIN operation links the 'Accounts' table to the 'Customers' table based on the 'customer_id'.", "The GROUP BY clause is used to aggregate the results by 'customer_id', ensuring that the count reflects the number of accounts per customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "description": "This virtual table provides a summary of customers and their associated accounts. It displays the unique customer identifier, first name, and last name of each customer, along with a count of the number of accounts they hold. The data is aggregated by customer, allowing for insights into customer account distribution.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id"}
{"sample_id": "train.1570", "db_id": "customers_and_invoices", "question": "What are the the full names and ids for all customers, and how many accounts does each have?", "rationale": ["The query identifies the relevant tables, 'Accounts' and 'Customers'.", "It selects the 'customer_id', 'customer_first_name', and 'customer_last_name' from the 'Customers' table.", "It counts the number of accounts for each customer using the COUNT function.", "The JOIN operation links the 'Accounts' table with the 'Customers' table based on the 'customer_id'.", "The GROUP BY clause groups the results by 'customer_id' to aggregate the account counts for each customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "description": "This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id"}
{"sample_id": "train.1580", "db_id": "customers_and_invoices", "question": "Count the number of financial transactions that correspond to each account id.", "rationale": ["The query identifies the relevant table, which is 'Financial_Transactions'.", "It selects a count of all transactions and groups them by 'account_id'.", "The use of count(*) allows for the aggregation of transaction records associated with each account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "description": "This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.", "virtual_table": "SELECT count(*) ,  account_id FROM Financial_transactions"}
{"sample_id": "train.1607", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of invoices for each order.", "rationale": ["The query identifies the relevant table, which is 'Invoices'.", "It selects the 'order_id' to group the results by each order.", "The count function is used to calculate the total number of invoices for each order, and the results are grouped by 'order_id' to provide a summary for each unique order."], "gold_sql": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id", "source_tables": ["invoices"], "description": "This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.", "virtual_table": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["The query identifies the relevant table, which is 'Order_Items'.", "Select the 'order_id' to group the results by each order.", "Use the count function to calculate the total number of items for each order, grouping the results by 'order_id'."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "description": "This virtual table summarizes the total number of items in each order from the 'Order_Items' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function calculates the total number of items associated with each order.", "virtual_table": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id"}
{"sample_id": "train.1622", "db_id": "customers_and_invoices", "question": "What are teh names of the different products, as well as the number of customers who have ordered each product.", "rationale": ["The query identifies the relevant tables: 'Order_Items', 'Products', and 'Orders'.", "It selects the 'product_name' from the 'Products' table and counts the occurrences of each product ordered.", "The JOIN operations link 'Order_Items' to 'Products' using 'product_id' and to 'Orders' using 'order_id'.", "The GROUP BY clause groups the results by 'product_name' to provide a count for each unique product."], "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"], "description": "This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.", "virtual_table": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name"}
{"sample_id": "train.2050", "db_id": "party_people", "question": "Which ministers are not a part of the Progress Party?", "rationale": ["The query identifies the relevant table, which is 'party'.", "Select the column to display, 'minister'.", "Add a condition to filter the 'party_name' column to exclude a specific party using a placeholder for string values."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "description": "This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.", "virtual_table": "SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2057", "db_id": "party_people", "question": "Show all party names and the number of members in each party.", "rationale": ["The query identifies the relevant tables, which are 'Member' and 'Party'.", "It selects the 'party_name' from the 'Party' table and counts the number of members from the 'Member' table.", "A JOIN operation is performed on the 'party_id' to link members to their respective parties.", "The results are grouped by 'party_id' to aggregate the count of members for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "description": "This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement allows for the retrieval of the party name and the count of members belonging to that party.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2072", "db_id": "party_people", "question": "How many events are there for each party?", "rationale": ["The query identifies the relevant tables, which are 'party_events' and 'party'.", "It uses a JOIN operation to connect 'party_events' with 'party' based on the 'party_id'.", "The SELECT statement retrieves the 'party_name' from the 'party' table and counts the number of events from the 'party_events' table.", "The GROUP BY clause groups the results by 'party_id' to ensure the count is calculated for each individual party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "description": "This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT statement represents the party names, while the count function aggregates the total number of events for each party.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["The query identifies the relevant tables: 'region', 'party', and 'party_events'.", "It uses JOIN operations to connect these tables based on their foreign key relationships: 'region_id' from 'party' and 'party_id' from 'party_events'.", "The SELECT statement counts the number of events that match the specified criteria.", "The WHERE clause filters the results based on the region name and event name using placeholders for string values."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "description": "This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.", "virtual_table": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2167", "db_id": "formula_1", "question": "What is the id and family name of the driver who has the longest laptime?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'lapTimes'.", "It selects the 'driverId' and 'surname' from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'lapTimes' on the 'driverId' to associate drivers with their lap times.", "The results are ordered by the 'milliseconds' column from the 'lapTimes' table in descending order to show the fastest lap times first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "description": "This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.", "virtual_table": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2174", "db_id": "formula_1", "question": "How many drivers did not race in 2009?", "rationale": ["The query identifies the relevant table, which is 'results', to count the distinct drivers.", "It uses a subquery to filter out race IDs from the 'races' table based on the specified year using a placeholder for numeric values.", "The final output is the count of distinct driver IDs from the 'results' table that are not associated with the excluded races."], "gold_sql": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )", "source_tables": ["results", "races"], "description": "This virtual table counts the distinct number of drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.", "virtual_table": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.2179", "db_id": "formula_1", "question": "Find the id and forenames of drivers who participated both the races with name Australian Grand Prix and the races with name Chinese Grand Prix?", "rationale": ["The query identifies the relevant tables: 'races', 'results', and 'drivers'.", "It selects the 'driverId' and 'forename' columns to display the driver's unique identifier and first name.", "The query uses JOIN operations to connect the 'races' table with the 'results' and 'drivers' tables based on their relationships.", "The WHERE clause filters the results based on the names of the races, using placeholders for the race names.", "The INTERSECT operator is used to find drivers who participated in both specified races."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.", "virtual_table": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2180", "db_id": "formula_1", "question": "What is the id and first name of all the drivers who participated in the Australian Grand Prix and the Chinese Grand Prix?", "rationale": ["The query identifies the relevant tables: 'races', 'results', and 'drivers'.", "It selects the 'driverId' and 'forename' columns to display the unique identifiers and first names of the drivers.", "The query uses JOIN operations to connect the 'races' table with the 'results' and 'drivers' tables based on their relationships.", "The WHERE clause filters the results based on the names of the races, using placeholders for the race names.", "The INTERSECT operator is used to find drivers who participated in both specified races."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.", "virtual_table": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["The query identifies the relevant tables: 'races', 'results', and 'drivers'.", "It selects the 'forename' and 'surname' columns from the 'drivers' table.", "The query uses JOINs to connect the 'races' and 'results' tables to the 'drivers' table based on their respective IDs.", "It filters the results to include drivers from a specific race using a placeholder for the race name.", "The EXCEPT clause is used to exclude drivers from another specified race, again using a placeholder for the race name."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.", "virtual_table": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2190", "db_id": "formula_1", "question": "For each constructor id, how many races are there?", "rationale": ["The query identifies the relevant table, which is 'constructorStandings'.", "It selects a count of records and groups them by 'constructorId' to summarize the standings for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "description": "This virtual table provides a count of the total number of constructor standings for each constructor from the 'constructorStandings' table. The placeholder in the SELECT statement represents the constructor's identifier, which is grouped to show the total standings for each constructor.", "virtual_table": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid"}
{"sample_id": "train.2194", "db_id": "formula_1", "question": "What are the names of all races held after 2000 in Spain?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'circuits'.", "It selects distinct race names from the 'races' table.", "A JOIN operation is performed between 'races' and 'circuits' on the circuitId to link races to their respective circuits.", "Conditions are added to filter the results based on the specified country and year using placeholders for string and numeric values."], "gold_sql": "SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = 'Spain' AND T1.year > 2000", "source_tables": ["races", "circuits"], "description": "This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.", "virtual_table": "SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]"}
