{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["We need to list the IDs of students who have attended courses.", "The relevant table for attendance is 'Student_Course_Attendance', which contains the 'student_id' of students who attended courses.", "To ensure we get unique student IDs, we will use the DISTINCT keyword in our SQL query."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.\",\n    \"1\": \"This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.\",\n    \"2\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.68", "db_id": "student_assessment", "question": "What details do we have on the students who registered for courses most recently?", "rationale": ["Identify the relevant tables: Students and Student_Course_Registrations are needed to get student details and their registration information.", "Join the Students table with the Student_Course_Registrations table on the student_id to link students with their course registrations.", "Select the necessary columns: student_id, student_details from Students, and registration_date from Student_Course_Registrations.", "Order the results by registration_date in descending order to get the most recent registrations at the top."], "gold_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT s.student_id, s.student_details, scr.registration_date \nFROM Students s \nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id \nORDER BY scr.registration_date DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.\",\n    \"1\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n    \"2\": \"This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.\"\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["To find the candidate who most recently accessed a course, we need to look at the attendance records of students.", "The 'Student_Course_Attendance' table contains records of student attendance, including the date of attendance.", "We will join the 'Candidates' table with the 'Student_Course_Attendance' table on the candidate ID and student ID.", "We will order the results by the date of attendance in descending order to get the most recent attendance first.", "Finally, we will limit the results to 1 to get only the most recent candidate."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT c.candidate_id\nFROM Candidates c\nJOIN Student_Course_Attendance sca ON c.candidate_id = sca.student_id\nORDER BY sca.date_of_attendance DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.\",\n    \"1\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.78", "db_id": "student_assessment", "question": "What are the details of the student who registered for the most number of courses?", "rationale": ["Identify the relevant tables: Students and Student_Course_Registrations are needed to get student details and their course registrations.", "Join the Students table with the Student_Course_Registrations table on the student_id to link students with their registered courses.", "Group the results by student_id to aggregate the number of courses each student has registered for.", "Use COUNT(scr.course_id) to count the number of courses registered by each student.", "Order the results in descending order based on the count of course registrations to find the student with the most registrations.", "Limit the results to 1 to get only the student who registered for the most number of courses."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT s.student_id, s.student_details\nFROM Students s\nJOIN Student_Course_Registrations scr ON s.student_id = scr.student_id\nGROUP BY s.student_id\nORDER BY COUNT(scr.course_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.\",\n    \"1\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n    \"2\": \"This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.\"\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["Identify the tables involved: We need to get course names and the count of registered students, which involves the 'Courses' and 'Student_Course_Registrations' tables.", "Join the tables: We will perform a LEFT JOIN between 'Courses' and 'Student_Course_Registrations' on the course_id to get the relevant data.", "Select the required fields: We need to select the course_id, course_name from 'Courses', and count of student_id from 'Student_Course_Registrations'.", "Group the results: We will group the results by course_id and course_name to get the count of students for each course.", "Order the results: Finally, we will order the results by the count of students in descending order to see the most popular courses first."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT Courses.course_id, Courses.course_name, COUNT(Student_Course_Registrations.student_id) AS student_count\nFROM Courses\nLEFT JOIN Student_Course_Registrations ON Courses.course_id = Student_Course_Registrations.course_id\nGROUP BY Courses.course_id, Courses.course_name\nORDER BY student_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.\",\n    \"1\": \"This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.\",\n    \"2\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\"\n}\n"}
{"sample_id": "train.89", "db_id": "student_assessment", "question": "What is the id of the student who most recently registered course 301?", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Filter the records in 'Student_Course_Registrations' to only include those with course_id '301'.", "Order the results by 'registration_date' in descending order to get the most recent registration first.", "Limit the results to 1 to get only the most recent student registration for course 301."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n    \"1\": \"This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.\",\n    \"2\": \"This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.\"\n}\n"}
{"sample_id": "train.92", "db_id": "student_assessment", "question": "What are the different cities where people live?", "rationale": ["Identify the relevant table: The question asks about cities where people live, which relates to the Addresses table.", "Select the appropriate column: The 'city' column in the Addresses table contains the city names.", "Use DISTINCT to avoid duplicate city names: Since we want different cities, we will use the DISTINCT keyword to ensure each city is listed only once."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id", "source_tables": ["addresses", "people_addresses"], "pred_sql": "SELECT DISTINCT city FROM Addresses;", "hint": "\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant tables: 'Student_Course_Registrations' for student registrations and 'Courses' for course details.", "Join the 'Student_Course_Registrations' table with the 'Courses' table on the course_id to filter for the course named 'Statistics'.", "Select the student_id from the joined tables where the course name matches 'Statistics'.", "Order the results by the registration_date to get the students in the order they registered for the course."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT sr.student_id\nFROM Student_Course_Registrations sr\nJOIN Courses c ON sr.course_id = c.course_id\nWHERE c.course_name = 'Statistics'\nORDER BY sr.registration_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n    \"1\": \"This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.\",\n    \"2\": \"This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.\"\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant tables: We need to look at the 'Student_Course_Registrations' table to find students who registered for courses, and the 'Courses' table to filter for the course named 'Statistics'.", "Join the 'Student_Course_Registrations' table with the 'Courses' table on the course_id to get the course details along with the student registrations.", "Filter the results to only include registrations for the course 'Statistics'.", "Select the student_id from the filtered results.", "Order the results by the registration_date to get the ids in the order of registration."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT sr.student_id \nFROM Student_Course_Registrations sr \nJOIN Courses c ON sr.course_id = c.course_id \nWHERE c.course_name = 'Statistics' \nORDER BY sr.registration_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of results returned.\",\n    \"1\": \"This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.\",\n    \"2\": \"This virtual table provides a list of course names from the 'Courses' table, which are associated with student registrations. The results are grouped by course ID and ordered by the number of registrations in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of courses to return.\"\n}\n"}
{"sample_id": "train.387", "db_id": "flight_1", "question": "Show origins of all flights with destination Honolulu.", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including their origins and destinations.", "Determine the required columns: We need the 'origin' column from the 'flight' table.", "Specify the condition: We want to filter the results to only include flights that have 'Honolulu' as their destination.", "Construct the SQL query: Using the SELECT statement to retrieve the 'origin' where the 'destination' is 'Honolulu'."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight WHERE destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\"\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the columns needed: We need 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We want flights that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query: Use a SELECT statement to retrieve the specified columns from the 'flight' table with the appropriate WHERE clause."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\"\n}\n"}
{"sample_id": "train.400", "db_id": "flight_1", "question": "What are the numbers of the shortest flights?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their distances.", "Determine the required information: The question asks for the numbers of the shortest flights, which implies we need to sort the flights by distance.", "Construct the SQL query: We will select the flight number (flno) from the flight table and order the results by distance in ascending order to get the shortest flights first.", "Limit the results to the shortest flight(s) using the LIMIT clause."], "gold_sql": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT 3", "source_tables": ["flight"], "pred_sql": "SELECT flno FROM flight ORDER BY distance ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\",\n    \"1\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' table with the 'Aircraft' table based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of aircraft names to retrieve.\",\n    \"2\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.408", "db_id": "flight_1", "question": "What place has the most flights coming from there?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their origin.", "Determine the required information: We need to find the place (origin) with the most flights.", "Use the COUNT function: To count the number of flights from each origin, we will use COUNT(*) and group the results by the 'origin' column.", "Group the results: Use GROUP BY origin to aggregate the flight counts for each unique origin.", "Order the results: To find the origin with the most flights, we will order the results in descending order based on the flight count.", "Limit the results: Since we only want the place with the most flights, we will use LIMIT 1 to get the top result."], "gold_sql": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "pred_sql": "SELECT origin, COUNT(*) as flight_count \nFROM flight \nGROUP BY origin \nORDER BY flight_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\",\n    \"1\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' table with the 'Aircraft' table based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of aircraft names to retrieve.\",\n    \"2\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables involved: 'aircraft' for aircraft names and 'flight' for flight counts.", "Use a LEFT JOIN to connect the 'aircraft' table with the 'flight' table on the aircraft ID (aid).", "Select the aircraft name from the 'aircraft' table and count the number of flights (flno) associated with each aircraft.", "Group the results by the aircraft ID to ensure we get a count for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT aircraft.name, COUNT(flight.flno) AS flight_count\nFROM aircraft\nLEFT JOIN flight ON aircraft.aid = flight.aid\nGROUP BY aircraft.aid;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\",\n    \"1\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' table with the 'Aircraft' table based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of aircraft names to retrieve.\",\n    \"2\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.429", "db_id": "flight_1", "question": "Show names for all employees who do not have certificate of Boeing 737-800.", "rationale": ["Identify the employees who do not have a certificate for the Boeing 737-800.", "To do this, we need to find the aircraft ID (aid) for the Boeing 737-800 from the aircraft table.", "Next, we will find all employee IDs (eid) from the certificate table that are associated with this aircraft ID.", "Finally, we will select the names of employees from the employee table whose IDs are not in the list of IDs obtained from the previous step."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT name FROM employee WHERE eid NOT IN (SELECT eid FROM certificate WHERE aid = (SELECT aid FROM aircraft WHERE name = 'Boeing 737-800'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' table with the 'Aircraft' table based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of aircraft names to retrieve.\",\n    \"1\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n    \"2\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\"\n}\n"}
{"sample_id": "train.433", "db_id": "flight_1", "question": "Show the name and distance of the aircrafts with more than 5000 distance and which at least 5 people have its certificate.", "rationale": ["Identify the tables needed: We need data from the 'aircraft' and 'certificate' tables.", "Join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid) to link aircraft with their certificates.", "Group the results by aircraft ID to count the number of certificates for each aircraft.", "Use the HAVING clause to filter for aircraft that have more than 5 certificates and a distance greater than 5000.", "Select the name and distance of the aircraft that meet these criteria."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name, a.distance \nFROM aircraft a \nJOIN certificate c ON a.aid = c.aid \nGROUP BY a.aid \nHAVING COUNT(c.eid) >= 5 AND a.distance > 5000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' table with the 'Aircraft' table based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of aircraft names to retrieve.\",\n    \"1\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n    \"2\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\"\n}\n"}
{"sample_id": "train.434", "db_id": "flight_1", "question": "What is the name and distance of every aircraft that can cover a distance of more than 5000 and which at least 5 people can fly?", "rationale": ["Identify the relevant table: The 'aircraft' table contains the information about aircraft names and their distances.", "Determine the conditions: We need aircraft that can cover a distance of more than 5000 and have at least 5 certificates (indicating they can carry at least 5 people).", "Use a subquery to count the number of certificates for each aircraft: This will help us filter aircraft based on the number of certificates they have.", "Construct the SQL query: Select the name and distance from the 'aircraft' table where the distance is greater than 5000 and the count of certificates is at least 5."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name, a.distance \nFROM aircraft a \nWHERE a.distance > 5000 \nAND (SELECT COUNT(*) \n     FROM certificate c \n     WHERE c.aid = a.aid) >= 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' table with the 'Aircraft' table based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of aircraft names to retrieve.\",\n    \"1\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\",\n    \"2\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\"\n}\n"}
{"sample_id": "train.437", "db_id": "flight_1", "question": "What is the salary and name of the employee who has the most number of certificates on aircrafts with distance more than 5000?", "rationale": ["Identify the tables needed: employee, certificate, and aircraft.", "Join the employee table with the certificate table on employee ID (eid) to get the employees who hold certificates.", "Join the result with the aircraft table on aircraft ID (aid) to filter by aircraft distance.", "Use a WHERE clause to filter aircraft with a distance greater than 5000.", "Group the results by employee ID to count the number of certificates each employee has.", "Order the results by the count of certificates in descending order to get the employee with the most certificates.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.name, e.salary\nFROM employee e\nJOIN certificate c ON e.eid = c.eid\nJOIN aircraft a ON c.aid = a.aid\nWHERE a.distance > 5000\nGROUP BY e.eid\nORDER BY COUNT(c.aid) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' table with the 'Aircraft' table based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of aircraft names to retrieve.\",\n    \"1\": \"This virtual table provides the names of aircraft that have the most certificates associated with them. The query joins the 'Certificate' and 'Aircraft' tables based on the aircraft ID, groups the results by aircraft ID, and orders them by the count of certificates in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n    \"2\": \"This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.\"\n}\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The question asks for all the different food allergies, which implies we need to retrieve unique allergy names.", "We will use the 'Allergy_Type' table since it contains the 'Allergy' column that lists the names of allergies.", "To ensure we get only unique allergy names, we will use the DISTINCT keyword in our SQL query."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Allergy_Type;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n    \"1\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n    \"2\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\"\n}\n"}
{"sample_id": "train.456", "db_id": "allergy_1", "question": "Which allergy type is most common?", "rationale": ["Identify the tables involved: We need to look at the 'Has_Allergy' table to find students with allergies and the 'Allergy_Type' table to categorize those allergies.", "Join the 'Has_Allergy' table with the 'Allergy_Type' table on the Allergy column to get the type of allergy for each student.", "Count the number of students (StuID) for each type of allergy using COUNT() function and group the results by AllergyType.", "Order the results in descending order based on the count of students to find the most common allergy type.", "Limit the results to 1 to get only the most common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(StuID) AS StudentCount\nFROM Has_Allergy\nJOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy\nGROUP BY AllergyType\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n    \"1\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n    \"2\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\"\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["We need to find the least common allergy type, which means we need to count how many students have each type of allergy.", "To do this, we will join the 'Has_Allergy' table with the 'Allergy_Type' table to get the allergy types associated with each allergy.", "We will group the results by the allergy name and count the number of students (StuID) for each allergy.", "Next, we will order the results by the count in ascending order to find the least common allergy.", "Finally, we will limit the results to 1 to get the least common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType FROM Allergy_Type WHERE Allergy IN (SELECT Allergy FROM Has_Allergy GROUP BY Allergy ORDER BY COUNT(StuID) ASC LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n    \"1\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n    \"2\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\"\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student names, which is the 'Student' table.", "To get the full names, we need to concatenate the first name (Fname) and last name (LName) of each student.", "Use the SQL SELECT statement to retrieve the concatenated names from the 'Student' table."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName FROM Student;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\"\n}\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the table that contains the information about students, which is the 'Student' table.", "Determine the relevant column for filtering male students, which is the 'Sex' column.", "Construct a SQL SELECT statement to retrieve the 'StuID' of students where 'Sex' is equal to 'Male'."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male';", "hint": "\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the major information, which is the 'Student' table.", "To find the largest major, we need to count the number of students in each major.", "We will use the COUNT function to count the number of students for each major.", "We will group the results by the 'Major' column to get the count for each major.", "To find the largest major, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.501", "db_id": "allergy_1", "question": "Which advisor has most number of students?", "rationale": ["Identify the relevant table: The 'Student' table contains the 'Advisor' and 'StuID' columns.", "Count the number of students for each advisor: Use COUNT(StuID) to count the number of students associated with each advisor.", "Group the results by advisor: Use GROUP BY Advisor to aggregate the counts for each advisor.", "Order the results to find the advisor with the most students: Use ORDER BY StudentCount DESC to sort the counts in descending order.", "Limit the results to the top advisor: Use LIMIT 1 to get only the advisor with the highest count."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(StuID) AS StudentCount\nFROM Student\nGROUP BY Advisor\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the relevant tables: We need to find students with cat allergies, so we will use the 'Has_Allergy' table which links students to their allergies.", "Determine the specific allergy: The question specifies 'cat allergies', so we will filter the results based on this allergy name.", "Count the distinct students: We need to count how many unique students (StuID) have this allergy, hence we will use COUNT(DISTINCT StuID).", "Construct the SQL query: We will select the count from the 'Has_Allergy' table where the allergy is 'cat'."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(DISTINCT Has_Allergy.StuID) AS StudentCount\nFROM Has_Allergy\nWHERE Allergy = 'cat';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n    \"1\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n    \"2\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\"\n}\n"}
{"sample_id": "train.508", "db_id": "allergy_1", "question": "Which students are unaffected by allergies?", "rationale": ["Identify the main table to query from, which is the 'Student' table, as we want to find students.", "We need to select the first name (Fname), last name (LName), and major of the students.", "To find students who are unaffected by allergies, we need to exclude those who have entries in the 'Has_Allergy' table.", "We can achieve this by using a subquery that selects all StuID from the 'Has_Allergy' table.", "The main query will then select from the 'Student' table where the StuID is not in the list of StuIDs returned by the subquery."], "gold_sql": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, LName, Major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy being checked against the 'Has_Allergy' table.\",\n    \"1\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n    \"2\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\"\n}\n"}
{"sample_id": "train.509", "db_id": "allergy_1", "question": "How many female students have milk or egg allergies?", "rationale": ["Identify the relevant tables: We need to gather information from the 'Student' table for female students and the 'Has_Allergy' table to check for specific allergies.", "Determine the criteria: We are looking for female students who have either milk or egg allergies.", "Join the tables: We will join 'Student' and 'Has_Allergy' on the StuID to link students with their allergies.", "Filter the results: We will filter the results to include only female students and those with allergies to either milk or eggs.", "Count the distinct students: Finally, we will count the distinct student IDs that meet the criteria."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nWHERE Student.Sex = 'Female' \nAND Has_Allergy.Allergy IN ('Milk', 'Egg');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n    \"1\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n    \"2\": \"This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.\"\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the relevant tables: We need to gather information from the 'Student' table for female students and the 'Has_Allergy' table to check for specific allergies (milk and eggs).", "Join the 'Student' table with the 'Has_Allergy' table on the StuID to link students with their allergies.", "Filter the results to include only female students by adding a condition in the WHERE clause: s.Sex = 'Female'.", "Add another condition to check if the allergy is either 'milk' or 'eggs' using the OR operator in the WHERE clause.", "Count the distinct student IDs (StuID) to get the number of unique female students who are allergic to either milk or eggs."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT COUNT(DISTINCT s.StuID) \nFROM Student s \nJOIN Has_Allergy ha ON s.StuID = ha.StuID \nWHERE s.Sex = 'Female' \nAND (ha.Allergy = 'milk' OR ha.Allergy = 'eggs');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n    \"1\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n    \"2\": \"This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.\"\n}\n"}
{"sample_id": "train.513", "db_id": "allergy_1", "question": "Which allergy has most number of students affected?", "rationale": ["We need to find out which allergy has the most number of students affected.", "To do this, we will count the number of students (StuID) associated with each allergy in the Has_Allergy table.", "We will group the results by the Allergy column to get the count for each allergy.", "Next, we will order the results in descending order based on the count of students affected.", "Finally, we will limit the results to just one entry to get the allergy with the highest count."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT Allergy, COUNT(StuID) AS StudentCount\nFROM Has_Allergy\nGROUP BY Allergy\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n    \"1\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n    \"2\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\"\n}\n"}
{"sample_id": "train.518", "db_id": "allergy_1", "question": "How many students are affected by each allergy type?", "rationale": ["We need to count the number of students affected by each allergy type.", "To do this, we will join the 'Allergy_Type' table with the 'Has_Allergy' table on the 'Allergy' column.", "The 'Allergy_Type' table contains the allergy types, while the 'Has_Allergy' table links students to their allergies.", "We will use the COUNT function to count the number of unique student IDs (StuID) for each allergy type.", "Finally, we will group the results by 'AllergyType' to get the count for each type of allergy."], "gold_sql": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype", "source_tables": ["has_allergy", "allergy_type"], "pred_sql": "SELECT at.AllergyType, COUNT(ha.StuID) AS StudentCount\nFROM Allergy_Type at\nJOIN Has_Allergy ha ON at.Allergy = ha.Allergy\nGROUP BY at.AllergyType;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n    \"1\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n    \"2\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\"\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the tables needed: We need to get last names and ages from the 'Student' table and check for allergies from the 'Has_Allergy' table.", "We need to join the 'Student' table with the 'Has_Allergy' table twice to check for two different allergies (milk and cat).", "Use INNER JOIN to connect 'Student' with 'Has_Allergy' for both allergies, ensuring we only get students who have both allergies.", "In the WHERE clause, specify the conditions for the allergies: one for 'milk' and another for 'cat'.", "Select the required columns: last names (LName) and ages (Age) from the 'Student' table."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.LName, S.Age \nFROM Student S \nJOIN Has_Allergy HA1 ON S.StuID = HA1.StuID \nJOIN Has_Allergy HA2 ON S.StuID = HA2.StuID \nWHERE HA1.Allergy = 'milk' AND HA2.Allergy = 'cat';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n    \"1\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n    \"2\": \"This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.\"\n}\n"}
{"sample_id": "train.522", "db_id": "allergy_1", "question": "What are the allergies the girl named Lisa has? And what are the types of them? Order the result by allergy names.", "rationale": ["Identify the relevant tables: Student, Has_Allergy, and Allergy_Type.", "We need to find allergies for a student named Lisa, so we will filter the Student table by first name and gender (female).", "Join the Has_Allergy table to link students to their allergies using StuID.", "Join the Allergy_Type table to get the allergy types corresponding to the allergies.", "Select the Allergy and AllergyType columns from the Allergy_Type table.", "Order the results by the Allergy names."], "gold_sql": "SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  'Lisa' ORDER BY T1.Allergy", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT a.Allergy, a.AllergyType \nFROM Student s \nJOIN Has_Allergy ha ON s.StuID = ha.StuID \nJOIN Allergy_Type a ON ha.Allergy = a.Allergy \nWHERE s.Fname = 'Lisa' AND s.Sex = 'Female' \nORDER BY a.Allergy;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n    \"1\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n    \"2\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\"\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["We need to find the average age of students with specific allergies, which are categorized as 'food' and 'animal'.", "To do this, we will join the 'Student' table with the 'Has_Allergy' table to link students to their allergies using the StuID.", "Next, we will join the 'Allergy_Type' table to categorize the allergies and filter them based on the types we are interested in ('food' and 'animal').", "We will use the AVG() function to calculate the average age of the students who meet the criteria.", "Since the Age column is stored as text, we will cast it to INTEGER for the average calculation."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT AVG(CAST(S.Age AS INTEGER)) AS Average_Age\nFROM Student S\nJOIN Has_Allergy HA ON S.StuID = HA.StuID\nJOIN Allergy_Type AT ON HA.Allergy = AT.Allergy\nWHERE AT.AllergyType IN ('food', 'animal');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n    \"1\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n    \"2\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\"\n}\n"}
{"sample_id": "train.527", "db_id": "allergy_1", "question": "List the first and last name of the students who do not have any food type allergy.", "rationale": ["Identify the main goal: to list the first and last names of students without any food type allergy.", "To achieve this, we need to select the first name (Fname) and last name (LName) from the Student table.", "We need to filter out students who have food allergies. This can be done using a subquery that selects student IDs (StuID) from the Has_Allergy table where the allergy type is 'Food'.", "The subquery will join the Has_Allergy table with the Allergy_Type table to filter allergies by type.", "The main query will use a NOT IN clause to exclude any student IDs returned by the subquery from the final result."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname, LName \nFROM Student \nWHERE StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    JOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy \n    WHERE AllergyType = 'Food'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy being checked against the 'Has_Allergy' table.\",\n    \"1\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n    \"2\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\"\n}\n"}
{"sample_id": "train.529", "db_id": "allergy_1", "question": "Find the number of male (sex is 'M') students who have some food type allery.", "rationale": ["Identify the tables needed: We need to count male students with food allergies, so we will use the 'Student', 'Has_Allergy', and 'Allergy_Type' tables.", "Join the tables: We will join 'Student' with 'Has_Allergy' on 'StuID' and 'Has_Allergy' with 'Allergy_Type' on 'Allergy'. This will allow us to access student information along with their allergies.", "Filter for male students: We will add a WHERE clause to filter for students where 'Sex' is 'M'.", "Filter for food allergies: We will also add a condition to check that the 'AllergyType' in the 'Allergy_Type' table is 'Food'.", "Count distinct students: Finally, we will use COUNT(DISTINCT Student.StuID) to count the number of unique male students with food allergies."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT COUNT(DISTINCT Student.StuID) \nFROM Student \nJOIN Has_Allergy ON Student.StuID = Has_Allergy.StuID \nJOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy \nWHERE Student.Sex = 'M' \nAND Allergy_Type.AllergyType = 'Food';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n    \"1\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\",\n    \"2\": \"This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.\"\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables involved: We need to get student information (first names and city codes) and their allergies, which involves the 'Student' and 'Has_Allergy' tables.", "Determine the relationship: The 'Has_Allergy' table links students to their allergies via the 'StuID' column.", "Select the required fields: We need distinct first names (Fname) and city codes from the 'Student' table.", "Filter the results: We want students who have allergies to either 'milk' or 'cat', so we will use a WHERE clause with an IN condition to specify these allergies."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code \nFROM Student S \nJOIN Has_Allergy HA ON S.StuID = HA.StuID \nWHERE HA.Allergy IN ('milk', 'cat');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n    \"1\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n    \"2\": \"This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.\"\n}\n"}
{"sample_id": "train.533", "db_id": "allergy_1", "question": "Find the number of students who are older than 18 and do not have allergy to either food or animal.", "rationale": ["Identify the main requirement: count students older than 18 without allergies to food or animals.", "Use the 'Student' table to filter students based on age.", "Use a subquery to find students with allergies to food or animals by checking the 'Has_Allergy' table against the 'Allergy_Type' table.", "The subquery selects 'StuID' from 'Has_Allergy' where the 'Allergy' matches any allergy in the 'Allergy_Type' table that is categorized as 'food' or 'animal'.", "The main query counts all students whose 'StuID' is not in the list returned by the subquery, ensuring they do not have the specified allergies."], "gold_sql": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' OR T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT COUNT(*) FROM Student WHERE Age > 18 AND StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy IN (SELECT Allergy FROM Allergy_Type WHERE AllergyType IN ('food', 'animal')));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.\",\n    \"1\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy being checked against the 'Has_Allergy' table.\",\n    \"2\": \"This virtual table provides a count of students who have a specific type of allergy. It joins the 'Has_Allergy' table, which links students to their allergies, with the 'Allergy_Type' table, which categorizes those allergies. The placeholder in the WHERE clause represents the type of allergy being queried.\"\n}\n"}
{"sample_id": "train.535", "db_id": "allergy_1", "question": "Find the first name and major of the students who are not allegry to soy.", "rationale": ["Identify the required fields: first name (Fname) and major from the Student table.", "Determine the condition: we need students who do not have an allergy to soy.", "To find students without a specific allergy, we can use a subquery that selects student IDs (StuID) from the Has_Allergy table where the allergy is 'soy'.", "The main query will select Fname and Major from the Student table where the StuID is not in the list of IDs returned by the subquery."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Major \nFROM Student \nWHERE StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    WHERE Allergy = 'soy'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy being checked against the 'Has_Allergy' table.\",\n    \"1\": \"This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.\",\n    \"2\": \"This virtual table provides the first names and gender of students from the 'Student' table who have a specific allergy but do not have another specified allergy. The placeholders in the subquery represent the names of the allergies being filtered.\"\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["We need to find the names of the countries and the average invoice size for those countries.", "To do this, we will join the 'customers' table with the 'invoices' table on the customer ID.", "We will select the 'country' from the 'customers' table and calculate the average of the 'total' from the 'invoices' table.", "We will group the results by 'country' to get the average invoice size for each country.", "Finally, we will order the results by the average invoice size in descending order to get the top countries."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT c.country, AVG(i.total) AS average_invoice_size\nFROM customers c\nJOIN invoices i ON c.id = i.customer_id\nGROUP BY c.country\nORDER BY AVG(i.total) DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.\"\n}\n"}
{"sample_id": "train.553", "db_id": "store_1", "question": "List every album ordered by album title in ascending order.", "rationale": ["Identify the table needed: The 'albums' table contains the album titles.", "Determine the required output: We need to list every album title.", "Specify the order: The albums should be ordered by title in ascending order.", "Construct the SQL query: Use SELECT to get the title from albums and ORDER BY to sort the results."], "gold_sql": "SELECT title FROM albums ORDER BY title;", "source_tables": ["albums"], "pred_sql": "SELECT title FROM albums ORDER BY title ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.\",\n    \"1\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n    \"2\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\"\n}\n"}
{"sample_id": "train.560", "db_id": "store_1", "question": "What are the total amount of money in the invoices billed from Chicago, Illinois?", "rationale": ["We need to find the total amount of money in the invoices that are billed from customers located in Chicago, Illinois.", "To do this, we will first filter the customers based on their city and state using the 'customers' table.", "We will select the 'id' of customers who are in Chicago, Illinois.", "Next, we will use this list of customer IDs to filter the 'invoices' table to find the relevant invoices.", "Finally, we will sum the 'total' amounts from these filtered invoices to get the total amount of money billed."], "gold_sql": "SELECT sum(total) FROM invoices WHERE billing_city  =  'Chicago' AND billing_state  =  'IL';", "source_tables": ["invoices"], "pred_sql": "SELECT SUM(total) AS total_amount\nFROM invoices\nWHERE customer_id IN (\n    SELECT id\n    FROM customers\n    WHERE city = 'Chicago' AND state = 'Illinois'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.\"\n}\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["We need to count the number of invoices for each state.", "The invoices are linked to customers through the customer_id field in the invoices table.", "We will join the invoices table with the customers table on the customer_id field.", "We will group the results by the state of the customers to get the count of invoices per state.", "Finally, we will select the state and the count of invoices for that state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT customers.state, COUNT(invoices.id) AS invoice_count\nFROM invoices\nJOIN customers ON invoices.customer_id = customers.id\nGROUP BY customers.state;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.\"\n}\n"}
{"sample_id": "train.565", "db_id": "store_1", "question": "List the state in the US with the most invoices.", "rationale": ["We need to find the state in the US with the most invoices.", "To do this, we will count the number of invoices grouped by the billing state.", "We will join the invoices table with the customers table to ensure we have access to the billing state information.", "We will use the COUNT function to count the number of invoices for each state.", "We will group the results by billing state using GROUP BY.", "To get the state with the most invoices, we will order the results in descending order by the count of invoices.", "Finally, we will limit the results to just one entry using LIMIT 1."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) as invoice_count \nFROM invoices \nJOIN customers ON invoices.customer_id = customers.id \nGROUP BY billing_state \nORDER BY invoice_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.\"\n}\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["Identify the relevant table: invoices, which contains billing information including states.", "We need to count the number of invoices per state, so we will use the COUNT() function.", "Group the results by billing_state to get the count for each state.", "Order the results in descending order to find the states with the most invoices."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state\nORDER BY invoice_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.\"\n}\n"}
{"sample_id": "train.567", "db_id": "store_1", "question": "List the number of invoices and the invoice total from California.", "rationale": ["We need to count the number of invoices and sum the total of those invoices for customers located in California.", "To achieve this, we will join the 'invoices' table with the 'customers' table on the customer ID.", "We will filter the results to include only those customers whose state is 'California'.", "Finally, we will select the count of invoice IDs and the sum of the total amounts from the invoices."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(invoices.id) AS number_of_invoices, SUM(invoices.total) AS invoice_total\nFROM invoices\nJOIN customers ON invoices.customer_id = customers.id\nWHERE customers.state = 'California';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.\"\n}\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the table that contains the information needed: the 'employees' table has the email and phone number of employees.", "Determine the specific columns to select: we need 'email' and 'phone'.", "Filter the results to find the specific employee: use a WHERE clause to match the first name 'Astrid' and last name 'Gruber'."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["We need to find the employee who supported the most customers, which means we need to count the number of customers each employee has supported.", "The 'customers' table has a foreign key 'support_rep_id' that links to the 'employees' table, allowing us to join these two tables.", "We will perform a JOIN between the 'employees' table and the 'customers' table on the condition that the employee's ID matches the customer's support representative ID.", "Next, we will group the results by the employee's ID to count how many customers each employee has supported.", "We will use the COUNT function to count the number of customers for each employee.", "To find the employee with the most customers, we will order the results in descending order based on the count of customers.", "Finally, we will limit the results to just one record to get the employee who has supported the most customers."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.\"\n}\n"}
{"sample_id": "train.594", "db_id": "store_1", "question": "What is the full name of the employee who has the most customers?", "rationale": ["Identify the relevant tables: employees and customers.", "We need to find the employee who has the most customers, which means we need to count the number of customers each employee supports.", "Join the employees table with the customers table on the support_rep_id to link employees to their customers.", "Group the results by employee ID to count the number of customers for each employee.", "Order the results in descending order based on the count of customers to find the employee with the most customers.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of invoices associated with customers from the 'customers' table, filtered by the customer's first and last name. The placeholders in the WHERE clause represent the first and last names of the customer.\"\n}\n"}
{"sample_id": "train.604", "db_id": "store_1", "question": "How many employees who are IT staff are from each city?", "rationale": ["Identify the relevant table: The 'employees' table contains information about employees, including their job titles and cities.", "Determine the criteria: We need to filter employees who are in IT staff positions. This can be done by checking if the 'title' column contains 'IT'.", "Count the number of employees: We will use the COUNT() function to count the number of employees that meet the criteria.", "Group the results: We will group the results by 'city' to get the count of IT staff from each city."], "gold_sql": "SELECT count(*) ,  city FROM employees WHERE title  =  'IT Staff' GROUP BY city", "source_tables": ["employees"], "pred_sql": "SELECT city, COUNT(*) AS employee_count \nFROM employees \nWHERE title LIKE '%IT%'\nGROUP BY city;", "hint": "\n"}
{"sample_id": "train.624", "db_id": "store_1", "question": "What is the name of the album that has the track Ball to the Wall?", "rationale": ["Identify the relevant tables: 'albums' and 'tracks'.", "We need to find the album title from the 'albums' table that contains a specific track name, 'Ball to the Wall'.", "Join the 'albums' table with the 'tracks' table on the album ID to link tracks to their respective albums.", "Use a WHERE clause to filter the results to only include tracks with the name 'Ball to the Wall'.", "Select the title of the album from the resulting joined table."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT albums.title \nFROM albums \nJOIN tracks ON albums.id = tracks.album_id \nWHERE tracks.name = 'Ball to the Wall';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.\",\n    \"1\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n    \"2\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\"\n}\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the relevant tables: 'tracks', 'genres', and 'media_types'.", "We need to filter tracks based on their genre and media type.", "Join the 'tracks' table with the 'genres' table on the genre_id to get the genre names.", "Join the 'tracks' table with the 'media_types' table on the media_type_id to get the media type names.", "Use a WHERE clause to filter for tracks where the genre is 'Rock' and the media type is 'MPEG'.", "Select the 'name' column from the 'tracks' table to get the names of the tracks that meet the criteria."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN genres ON tracks.genre_id = genres.id \nJOIN media_types ON tracks.media_type_id = media_types.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n    \"1\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific album title in the 'albums' table. The placeholder in the WHERE clause represents the title of the album.\",\n    \"2\": \"This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.\"\n}\n"}
{"sample_id": "train.946", "db_id": "medicine_enzyme_interaction", "question": "What are the names and trade names of the medcines that are FDA approved?", "rationale": ["Identify the relevant table: The 'medicine' table contains the information about medicines, including their names, trade names, and FDA approval status.", "Determine the columns needed: We need the 'name' and 'Trade_Name' columns from the 'medicine' table.", "Specify the condition: We want only those medicines that are FDA approved, which is indicated by the 'FDA_approved' column being equal to 'yes'.", "Construct the SQL query: Using the SELECT statement to retrieve the specified columns from the 'medicine' table with the appropriate WHERE clause for FDA approval."], "gold_sql": "SELECT name ,  trade_name FROM medicine WHERE FDA_approved  =  'Yes'", "source_tables": ["medicine"], "pred_sql": "SELECT name, Trade_Name FROM medicine WHERE FDA_approved = 'yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of medicines along with their unique identifiers and FDA approval status, sorted by the number of interactions they have with enzymes. The placeholder in the query allows for dynamic filtering based on the specific criteria of interest.\",\n    \"1\": \"This virtual table describes the names and trade names of medicines that have specific types of interactions with enzymes. The placeholders in the WHERE clause represent the types of interactions being queried.\",\n    \"2\": \"This virtual table provides a list of enzyme identifiers and their names from the 'enzyme' table that are involved in a specific type of interaction with medicines. The interaction type is specified by a placeholder, and the results are grouped by enzyme ID, ordered by the frequency of interactions in descending order, with a limit on the number of results returned, specified by another placeholder.\"\n}\n"}
{"sample_id": "train.951", "db_id": "medicine_enzyme_interaction", "question": "What are the ids, names and FDA approval status of medicines in descending order of the number of enzymes that it can interact with.", "rationale": ["Identify the required columns: ids, names, and FDA approval status of medicines.", "The data is in the 'medicine' table, so we will select from this table.", "To count the number of enzymes each medicine interacts with, we need to join the 'medicine' table with the 'medicine_enzyme_interaction' table.", "We will use a JOIN operation on the 'medicine' table and the 'medicine_enzyme_interaction' table using the medicine_id.", "We need to group the results by medicine id, name, and FDA approval status to count the interactions correctly.", "Finally, we will order the results in descending order based on the count of enzyme interactions."], "gold_sql": "SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC", "source_tables": ["medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT m.id, m.name, m.FDA_approved \nFROM medicine m \nJOIN medicine_enzyme_interaction mei ON m.id = mei.medicine_id \nGROUP BY m.id, m.name, m.FDA_approved \nORDER BY COUNT(mei.enzyme_id) DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of medicines along with their unique identifiers and FDA approval status, sorted by the number of interactions they have with enzymes. The placeholder in the query allows for dynamic filtering based on the specific criteria of interest.\",\n    \"1\": \"This virtual table provides a list of enzyme identifiers and their names from the 'enzyme' table that are involved in a specific type of interaction with medicines. The interaction type is specified by a placeholder, and the results are grouped by enzyme ID, ordered by the frequency of interactions in descending order, with a limit on the number of results returned, specified by another placeholder.\",\n    \"2\": \"This virtual table describes the names and trade names of medicines that have specific types of interactions with enzymes. The placeholders in the WHERE clause represent the types of interactions being queried.\"\n}\n"}
{"sample_id": "train.953", "db_id": "medicine_enzyme_interaction", "question": "What is the id and name of the enzyme with most number of medicines that can interact as 'activator'?", "rationale": ["Identify the relevant tables: 'enzyme' for enzyme details and 'medicine_enzyme_interaction' for interaction details.", "We need to find the enzyme with the most medicines that can interact as 'activator'.", "Join the 'enzyme' table with the 'medicine_enzyme_interaction' table on the enzyme ID.", "Filter the results to only include interactions where the interaction type is 'activator'.", "Group the results by enzyme ID and name to count the number of medicines interacting with each enzyme.", "Order the results by the count of interacting medicines in descending order to get the enzyme with the most interactions at the top.", "Limit the results to 1 to get only the enzyme with the highest count."], "gold_sql": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  'activitor' GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["enzyme", "medicine_enzyme_interaction"], "pred_sql": "SELECT e.id, e.name\nFROM enzyme e\nJOIN medicine_enzyme_interaction mei ON e.id = mei.enzyme_id\nWHERE mei.interaction_type = 'activator'\nGROUP BY e.id, e.name\nORDER BY COUNT(mei.medicine_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of enzyme identifiers and their names from the 'enzyme' table that are involved in a specific type of interaction with medicines. The interaction type is specified by a placeholder, and the results are grouped by enzyme ID, ordered by the frequency of interactions in descending order, with a limit on the number of results returned, specified by another placeholder.\",\n    \"1\": \"This virtual table provides a list of medicines along with their unique identifiers and FDA approval status, sorted by the number of interactions they have with enzymes. The placeholder in the query allows for dynamic filtering based on the specific criteria of interest.\",\n    \"2\": \"This virtual table describes the names and trade names of medicines that have specific types of interactions with enzymes. The placeholders in the WHERE clause represent the types of interactions being queried.\"\n}\n"}
{"sample_id": "train.968", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that can interact as an inhibitor and activitor with enzymes?", "rationale": ["Identify the tables involved: medicine, medicine_enzyme_interaction.", "Determine the columns needed: medicine name and trade name from the medicine table.", "Establish the relationship between the medicine and enzyme interaction through the medicine_enzyme_interaction table.", "Filter the results based on the interaction types specified: 'inhibitor' and 'activator'.", "Construct the SQL query using JOIN to combine the relevant tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'inhibitor' INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'activitor'", "source_tables": ["medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT m.name, m.Trade_Name \nFROM medicine m \nJOIN medicine_enzyme_interaction mei ON m.id = mei.medicine_id \nWHERE mei.interaction_type IN ('inhibitor', 'activator');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and trade names of medicines that have specific types of interactions with enzymes. The placeholders in the WHERE clause represent the types of interactions being queried.\",\n    \"1\": \"This virtual table provides a list of medicines along with their unique identifiers and FDA approval status, sorted by the number of interactions they have with enzymes. The placeholder in the query allows for dynamic filtering based on the specific criteria of interest.\",\n    \"2\": \"This virtual table provides a list of enzyme identifiers and their names from the 'enzyme' table that are involved in a specific type of interaction with medicines. The interaction type is specified by a placeholder, and the results are grouped by enzyme ID, ordered by the frequency of interactions in descending order, with a limit on the number of results returned, specified by another placeholder.\"\n}\n"}
{"sample_id": "train.970", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that cannot interact with the enzyme with the product 'Heme'?", "rationale": ["Identify the relevant tables: medicine, enzyme, and medicine_enzyme_interaction.", "We need to find medicines that do not interact with the enzyme that produces 'Heme'.", "This requires a LEFT JOIN between the medicine table and the medicine_enzyme_interaction table to include all medicines, even those without interactions.", "Next, we join the enzyme table to access the product information related to the interactions.", "In the WHERE clause, we filter out any interactions with the enzyme that has the product 'Heme'.", "We select the medicine name and trade name from the medicine table."], "gold_sql": "SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  'Protoporphyrinogen IX'", "source_tables": ["enzyme", "medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT m.name, m.Trade_Name \nFROM medicine m \nLEFT JOIN medicine_enzyme_interaction mei ON m.id = mei.medicine_id \nLEFT JOIN enzyme e ON mei.enzyme_id = e.id \nWHERE e.Product != 'Heme' OR e.Product IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and trade names of medicines that have specific types of interactions with enzymes. The placeholders in the WHERE clause represent the types of interactions being queried.\",\n    \"1\": \"This virtual table provides a list of medicines along with their unique identifiers and FDA approval status, sorted by the number of interactions they have with enzymes. The placeholder in the query allows for dynamic filtering based on the specific criteria of interest.\",\n    \"2\": \"This virtual table provides a distinct list of enzyme names, their geographical locations, and the products they produce, specifically for those enzymes that interact with medicines in a certain way. The placeholder in the WHERE clause represents the type of interaction being queried.\"\n}\n"}
{"sample_id": "train.1355", "db_id": "college_2", "question": "What is the name of the department with an instructure who has a name like 'Soisalon'?", "rationale": ["Identify the relevant tables: We need to find the department name and the instructor's name, so we will use the 'department' and 'instructor' tables.", "Determine the relationship: The 'instructor' table has a foreign key 'dept_name' that relates to the 'department' table's 'dept_name'.", "Formulate the SQL query: We will perform a JOIN between the 'department' and 'instructor' tables on the 'dept_name' column.", "Add the condition: We need to filter the results where the instructor's name matches the pattern 'Soisalon', using the LIKE operator."], "gold_sql": "SELECT dept_name FROM instructor WHERE name LIKE '%Soisalon%'", "source_tables": ["instructor"], "pred_sql": "SELECT department.dept_name \nFROM department \nJOIN instructor ON department.dept_name = instructor.dept_name \nWHERE instructor.name LIKE '%Soisalon%';", "hint": "\n"}
{"sample_id": "train.1365", "db_id": "college_2", "question": "What are the titles of courses that are in the Statistics department but not the Psychology department?", "rationale": ["Identify the relevant table: The 'course' table contains the titles of courses and their associated departments.", "Filter for courses in the Statistics department: Use a WHERE clause to specify that dept_name must be 'Statistics'.", "Exclude courses from the Psychology department: Since we want courses that are not in the Psychology department, we can use a condition that checks for dept_name not equal to 'Psychology'.", "Combine the conditions in the WHERE clause: Use AND to combine the two conditions to ensure we only get courses that are in the Statistics department and not in the Psychology department."], "gold_sql": "SELECT title FROM course WHERE dept_name  =  'Statistics' EXCEPT SELECT title FROM course WHERE dept_name  =  'Psychology'", "source_tables": ["course"], "pred_sql": "SELECT title FROM course WHERE dept_name = 'Statistics' AND dept_name != 'Psychology';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.\",\n    \"1\": \"This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.\",\n    \"2\": \"This virtual table lists the titles of courses from the 'course' table that have prerequisites. The prerequisite courses are identified by their titles, which are specified using a placeholder in the subquery.\"\n}\n"}
{"sample_id": "train.1424", "db_id": "college_2", "question": "Find the title of course whose prerequisite is course Differential Geometry.", "rationale": ["Identify the course whose prerequisite is 'Differential Geometry'.", "To find this, we need to join the 'course' table with the 'prereq' table to link courses with their prerequisites.", "We also need to join the 'course' table again to get the title of the prerequisite course, which is 'Differential Geometry'.", "The final query selects the title of the course that has 'Differential Geometry' as a prerequisite."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  =  'Differential Geometry')", "source_tables": ["course", "prereq"], "pred_sql": "SELECT c.title \nFROM course c \nJOIN prereq p ON c.course_id = p.course_id \nJOIN course prereq_course ON p.prereq_id = prereq_course.course_id \nWHERE prereq_course.title = 'Differential Geometry';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.\",\n    \"1\": \"This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.\",\n    \"2\": \"This virtual table lists the titles of courses from the 'course' table that have prerequisites. The prerequisite courses are identified by their titles, which are specified using a placeholder in the subquery.\"\n}\n"}
{"sample_id": "train.1426", "db_id": "college_2", "question": "Find the names of students who have taken any course in the fall semester of year 2003.", "rationale": ["Identify the relevant tables: We need to find student names and their course enrollment details, so we will use the 'student' and 'takes' tables.", "Determine the relationship: The 'takes' table contains the course enrollment information, which links to the 'student' table through the student ID.", "Specify the conditions: We are interested in students who have taken courses in the fall semester of the year 2003, so we will filter the results based on these criteria.", "Construct the SQL query: We will select the names of students from the 'student' table, joining it with the 'takes' table on the student ID, and applying the specified semester and year conditions."], "gold_sql": "SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  'Fall' AND YEAR  =  2003)", "source_tables": ["student", "takes"], "pred_sql": "SELECT student.name \nFROM student \nJOIN takes ON student.ID = takes.ID \nWHERE takes.semester = 'Fall' AND takes.year = '2003';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of students who are enrolled in courses during a specific semester and year. The placeholders in the WHERE clause represent the semester and year for which the student enrollment is being queried.\"\n}\n"}
{"sample_id": "train.1435", "db_id": "college_2", "question": "What are the names of all instructors who advise students in the math depart sorted by total credits of the student.", "rationale": ["Identify the tables needed: instructor, advisor, and student.", "We need to find instructors who advise students, so we will join the instructor table with the advisor table on the instructor's ID.", "Next, we join the advisor table with the student table on the student's ID to get the students being advised.", "We need to filter the results to only include students from the math department, so we add a WHERE clause for student.dept_name.", "Finally, we want to sort the results by the total credits of the students, so we add an ORDER BY clause for student.tot_cred."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id WHERE T3.dept_name  =  'Math' ORDER BY T3.tot_cred", "source_tables": ["instructor", "student", "advisor"], "pred_sql": "SELECT instructor.name \nFROM instructor \nJOIN advisor ON instructor.ID = advisor.i_ID \nJOIN student ON advisor.s_ID = student.ID \nWHERE student.dept_name = 'math' \nORDER BY student.tot_cred;", "hint": "\n"}
{"sample_id": "train.1436", "db_id": "college_2", "question": "What is the course title of the prerequisite of course Mobile Computing?", "rationale": ["Identify the course for which we want to find the prerequisite, which is 'Mobile Computing'.", "Use the 'course' table to find the course_id of 'Mobile Computing'.", "Join the 'prereq' table to find the prerequisite course_id associated with 'Mobile Computing'.", "Join the 'course' table again to get the title of the prerequisite course using the prerequisite course_id.", "Select the title of the prerequisite course from the result."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  'Mobile Computing')", "source_tables": ["course", "prereq"], "pred_sql": "SELECT c2.title\nFROM course c1\nJOIN prereq p ON c1.course_id = p.course_id\nJOIN course c2 ON p.prereq_id = c2.course_id\nWHERE c1.title = 'Mobile Computing';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.\",\n    \"1\": \"This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.\",\n    \"2\": \"This virtual table lists the titles of courses from the 'course' table that have prerequisites. The prerequisite courses are identified by their titles, which are specified using a placeholder in the subquery.\"\n}\n"}
{"sample_id": "train.1439", "db_id": "college_2", "question": "What is the name of the instructor who advises the student with the greatest number of total credits?", "rationale": ["Identify the tables needed: instructor, advisor, and student.", "We need to find the instructor's name who advises a specific student.", "The student with the greatest number of total credits can be found using a subquery that selects the maximum total credits from the student table.", "Join the instructor table with the advisor table on the instructor's ID, and then join with the student table on the student's ID.", "Filter the results to only include the student with the maximum total credits found in the subquery."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT 1", "source_tables": ["instructor", "student", "advisor"], "pred_sql": "SELECT instructor.name \nFROM instructor \nJOIN advisor ON instructor.ID = advisor.i_ID \nJOIN student ON advisor.s_ID = student.ID \nWHERE student.tot_cred = (SELECT MAX(tot_cred) FROM student);", "hint": "\n"}
{"sample_id": "train.1448", "db_id": "college_2", "question": "Find the number and averaged salary of all instructors who are in the department with the highest budget.", "rationale": ["Identify the department with the highest budget by selecting the 'dept_name' from the 'department' table and ordering by 'budget' in descending order, limiting the result to 1.", "Use the result of the above subquery to filter the 'instructor' table to find instructors belonging to that department.", "Count the number of instructors in that department using COUNT(ID) and calculate the average salary using AVG(salary).", "Select both the count and average salary in the final output."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "pred_sql": "SELECT COUNT(ID) AS number_of_instructors, AVG(salary) AS average_salary\nFROM instructor\nWHERE dept_name = (\n    SELECT dept_name\n    FROM department\n    ORDER BY budget DESC\n    LIMIT 1\n);", "hint": "\n"}
{"sample_id": "train.1449", "db_id": "college_2", "question": "How many instructors are in the department with the highest budget, and what is their average salary?", "rationale": ["Identify the department with the highest budget by using a subquery that selects the maximum budget from the department table.", "Join the instructor table with the department table on the dept_name to associate instructors with their respective departments.", "Filter the results to only include instructors from the department that has the highest budget, as determined by the subquery.", "Count the number of instructors in that department and calculate their average salary using COUNT() and AVG() functions."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "pred_sql": "SELECT COUNT(i.ID) AS instructor_count, AVG(i.salary) AS average_salary\nFROM instructor i\nJOIN department d ON i.dept_name = d.dept_name\nWHERE d.budget = (SELECT MAX(budget) FROM department);", "hint": "\n"}
{"sample_id": "train.1452", "db_id": "college_2", "question": "Find the name of students who didn't take any course from Biology department.", "rationale": ["Identify the students who are enrolled in the Biology department by checking the 'dept_name' in the 'student' table.", "To find students who didn't take any course from the Biology department, we need to exclude those who have taken courses offered by that department.", "We can achieve this by using a subquery to find all course IDs from the 'course' table where the 'dept_name' is 'Biology'.", "Then, we can use another subquery to find all student IDs from the 'takes' table that correspond to those course IDs.", "Finally, we select the names of students from the 'student' table whose IDs are not in the list of IDs obtained from the previous subquery, ensuring they are not enrolled in any Biology courses."], "gold_sql": "SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  'Biology')", "source_tables": ["course", "student", "takes"], "pred_sql": "SELECT name FROM student WHERE dept_name != 'Biology' AND ID NOT IN (SELECT ID FROM takes WHERE course_id IN (SELECT course_id FROM course WHERE dept_name = 'Biology'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of students who are enrolled in courses during a specific semester and year. The placeholders in the WHERE clause represent the semester and year for which the student enrollment is being queried.\"\n}\n"}
{"sample_id": "train.1458", "db_id": "college_2", "question": "Find the name and salary of instructors whose salary is below the average salary of the instructors in the Physics department.", "rationale": ["Identify the relevant table: The 'instructor' table contains the information about instructors, including their names and salaries.", "Determine the condition: We need to find instructors whose salary is below the average salary of instructors in the Physics department.", "Calculate the average salary: Use a subquery to calculate the average salary of instructors in the Physics department.", "Combine the conditions: Use a SELECT statement to retrieve the names and salaries of instructors in the Physics department who meet the salary condition."], "gold_sql": "SELECT name ,  salary FROM instructor WHERE salary  <  (SELECT avg(salary) FROM instructor WHERE dept_name  =  'Physics')", "source_tables": ["instructor"], "pred_sql": "SELECT name, salary \nFROM instructor \nWHERE dept_name = 'Physics' \nAND salary < (SELECT AVG(salary) FROM instructor WHERE dept_name = 'Physics');", "hint": "\n"}
{"sample_id": "train.1461", "db_id": "college_2", "question": "What are the names of students who have taken Statistics courses?", "rationale": ["Identify the relevant tables: student, takes, and course.", "We need to find students who have taken courses related to Statistics, so we will join the student table with the takes table on the student ID.", "Next, we will join the takes table with the course table on the course ID to access course titles.", "We will filter the results using a WHERE clause to find courses that have 'Statistics' in their title."], "gold_sql": "SELECT T3.name FROM course AS T1 JOIN takes AS T2 ON T1.course_id  =  T2.course_id JOIN student AS T3 ON T2.id  =  T3.id WHERE T1.dept_name  =  'Statistics'", "source_tables": ["course", "student", "takes"], "pred_sql": "SELECT student.name \nFROM student \nJOIN takes ON student.ID = takes.ID \nJOIN course ON takes.course_id = course.course_id \nWHERE course.title LIKE '%Statistics%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of students who are enrolled in courses during a specific semester and year. The placeholders in the WHERE clause represent the semester and year for which the student enrollment is being queried.\"\n}\n"}
{"sample_id": "train.1464", "db_id": "college_2", "question": "Find the names of all instructors in computer science department", "rationale": ["Identify the table that contains instructor information, which is the 'instructor' table.", "Determine the relevant column for instructor names, which is 'name'.", "Identify the condition needed to filter instructors by department, which is 'dept_name'.", "Specify the department of interest, which is 'computer science'.", "Construct the SQL query to select the names of instructors from the 'instructor' table where the 'dept_name' matches 'computer science'."], "gold_sql": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'", "source_tables": ["instructor"], "pred_sql": "SELECT name FROM instructor WHERE dept_name = 'computer science';", "hint": "\n"}
{"sample_id": "train.1480", "db_id": "college_2", "question": "Find courses that ran in Fall 2009 but not in Spring 2010.", "rationale": ["Identify the courses that were offered in Fall 2009.", "Use the section table to filter courses based on semester and year.", "Select distinct course titles to avoid duplicates.", "Use a subquery to find courses that were offered in Spring 2010.", "Exclude the courses found in the Spring 2010 subquery from the Fall 2009 results."], "gold_sql": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 EXCEPT SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010", "source_tables": ["section"], "pred_sql": "SELECT DISTINCT c.title \nFROM course c \nJOIN section s ON c.course_id = s.course_id \nWHERE s.semester = 'Fall' AND s.year = '2009' \nAND c.course_id NOT IN (\n    SELECT c2.course_id \n    FROM course c2 \n    JOIN section s2 ON c2.course_id = s2.course_id \n    WHERE s2.semester = 'Spring' AND s2.year = '2010'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of students who are enrolled in courses during a specific semester and year. The placeholders in the WHERE clause represent the semester and year for which the student enrollment is being queried.\",\n    \"1\": \"This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.\"\n}\n"}
{"sample_id": "train.1489", "db_id": "college_2", "question": "What are the names of instructors who earn more than at least one instructor from the Biology department?", "rationale": ["Identify the main requirement: we need the names of instructors who earn more than at least one instructor from the Biology department.", "To find this, we need to compare the salaries of instructors in general with those in the Biology department.", "We can use a subquery to find the maximum salary of instructors in the Biology department.", "The outer query will select the names of instructors whose salary is greater than the maximum salary found in the subquery.", "We use DISTINCT to ensure that we only get unique names in case multiple instructors meet the criteria."], "gold_sql": "SELECT name FROM instructor WHERE salary  >  (SELECT min(salary) FROM instructor WHERE dept_name  =  'Biology')", "source_tables": ["instructor"], "pred_sql": "SELECT DISTINCT i1.name \nFROM instructor i1 \nWHERE i1.salary > (SELECT MAX(i2.salary) \n                   FROM instructor i2 \n                   WHERE i2.dept_name = 'Biology');", "hint": "\n"}
{"sample_id": "train.1515", "db_id": "insurance_and_eClaims", "question": "Find the total and average amount paid in claim headers.", "rationale": ["Identify the relevant table: The 'Claim_Headers' table contains the 'Amount_Paid' column which is needed to calculate the total and average amount paid.", "Use aggregate functions: To find the total amount paid, use the SUM() function, and to find the average amount paid, use the AVG() function.", "Construct the SQL query: Combine the aggregate functions in a SELECT statement, specifying the 'Amount_Paid' column from the 'Claim_Headers' table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid \nFROM Claim_Headers;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\",\n    \"1\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\"\n}\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["Identify the relevant table: The 'Claim_Headers' table contains the 'Amount_Paid' column which is needed for the calculations.", "Determine the required calculations: We need to calculate the total amount paid and the average amount paid.", "Construct the SQL query: Use the SUM() function to calculate the total amount and the AVG() function to calculate the average amount from the 'Amount_Paid' column in the 'Claim_Headers' table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\",\n    \"1\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\"\n}\n"}
{"sample_id": "train.1517", "db_id": "insurance_and_eClaims", "question": "Find the total amount claimed in the most recently created document.", "rationale": ["Identify the relevant tables: Claim_Headers for the amount claimed and Claims_Documents for the document creation date.", "Join Claim_Headers and Claims_Documents on Claim_Header_ID and Claim_ID to link claims with their documents.", "Use a subquery to find the most recent Created_Date from the Claims_Documents table.", "Filter the results to only include claims that have documents created on the most recent date.", "Sum the Amount_Claimed from the filtered results to get the total amount claimed."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT SUM(ch.Amount_Claimed) AS Total_Amount_Claimed\nFROM Claim_Headers ch\nJOIN Claims_Documents cd ON ch.Claim_Header_ID = cd.Claim_ID\nWHERE cd.Created_Date = (\n    SELECT MAX(Created_Date)\n    FROM Claims_Documents\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\",\n    \"1\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\"\n}\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Customers, Claim_Headers, and Policies are needed to find the customer details and the claims they made.", "Join the Claim_Headers table with the Policies table on Policy_ID to link claims to their respective policies.", "Join the resulting table with the Customers table on Customer_ID to get customer details associated with each claim.", "Order the results by the Amount_Claimed in descending order to find the claim with the largest amount.", "Limit the results to 1 to get only the customer who made the largest claim."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT Customers.Customer_Details \nFROM Claim_Headers \nJOIN Policies ON Claim_Headers.Policy_ID = Policies.Policy_ID \nJOIN Customers ON Policies.Customer_ID = Customers.Customer_ID \nORDER BY Claim_Headers.Amount_Claimed DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\",\n    \"1\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\",\n    \"2\": \"This virtual table provides a distinct list of customer details from the 'Customers' table for those customers who have specific types of insurance policies. The placeholders in the WHERE clause represent the policy type codes that the user can specify.\"\n}\n"}
{"sample_id": "train.1527", "db_id": "insurance_and_eClaims", "question": "What is the name of the claim processing stage that most of the claims are on?", "rationale": ["We need to find the claim processing stage that most claims are currently on.", "To do this, we will join the 'Claims_Processing' table with the 'Claims_Processing_Stages' table using the 'Claim_Stage_ID'.", "Next, we will group the results by 'Claim_Status_Name' to count how many claims are in each stage.", "We will then order the results by the count of claims in descending order to get the most common stage at the top.", "Finally, we will limit the results to just one entry to get the name of the claim processing stage with the highest count."], "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"], "pred_sql": "SELECT cps.Claim_Status_Name\nFROM Claims_Processing cp\nJOIN Claims_Processing_Stages cps ON cp.Claim_Stage_ID = cps.Claim_Stage_ID\nGROUP BY cps.Claim_Status_Name\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.\",\n    \"1\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\",\n    \"2\": \"This virtual table provides a distinct list of customer details from the 'Customers' table for those customers who have specific types of insurance policies. The placeholders in the WHERE clause represent the policy type codes that the user can specify.\"\n}\n"}
{"sample_id": "train.1535", "db_id": "insurance_and_eClaims", "question": "Find the names of all the customers and staff members.", "rationale": ["Identify the tables involved: Customers and Staff.", "Determine the columns to retrieve: Customer_Details from Customers and Staff_Details from Staff.", "Use a SELECT statement to specify the columns to retrieve.", "Combine the two tables in the FROM clause to get data from both Customers and Staff."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "pred_sql": "SELECT Customers.Customer_Details, Staff.Staff_Details FROM Customers, Staff;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table combines detailed information about customers and staff members from the 'Customers' and 'Staff' tables. The placeholder in the SELECT statement allows for the retrieval of customer details and staff details, providing a comprehensive view of both entities.\"\n}\n"}
{"sample_id": "train.1545", "db_id": "insurance_and_eClaims", "question": "Which customer is associated with the latest policy?", "rationale": ["Identify the relevant tables: Customers and Policies are needed to find the customer associated with a policy.", "Join the Customers table with the Policies table on Customer_ID to link customers with their policies.", "To find the latest policy, we need to look for the maximum Start_Date in the Policies table.", "Use a subquery to get the maximum Start_Date from the Policies table and filter the results accordingly."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Start_Date = (SELECT MAX(Start_Date) FROM Policies);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of customer details from the 'Customers' table for those customers who have specific types of insurance policies. The placeholders in the WHERE clause represent the policy type codes that the user can specify.\",\n    \"1\": \"This virtual table provides a distinct list of customer details from the 'Customers' table for those customers who hold a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code that is being queried.\",\n    \"2\": \"This virtual table combines detailed information about customers and staff members from the 'Customers' and 'Staff' tables. The placeholder in the SELECT statement allows for the retrieval of customer details and staff details, providing a comprehensive view of both entities.\"\n}\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: Customers and Policies are needed to find customer details and their policy start dates.", "Join the Customers table with the Policies table on the Customer_ID to link customers with their policies.", "Order the results by the Start_Date of the policies in descending order to get the most recent policy first.", "Limit the results to 1 to get only the customer with the most recently started policy."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nORDER BY Policies.Start_Date DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of customer details from the 'Customers' table for those customers who have specific types of insurance policies. The placeholders in the WHERE clause represent the policy type codes that the user can specify.\",\n    \"1\": \"This virtual table provides a distinct list of customer details from the 'Customers' table for those customers who hold a specific type of insurance policy. The placeholder in the WHERE clause represents the policy type code that is being queried.\"\n}\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "We need to retrieve account details, so we will select columns from the Accounts table: account_id, account_name, and other_account_details.", "To link the Accounts table with the Customers table, we will use the customer_id foreign key.", "We need to filter the results to only include accounts belonging to the customer with the first name 'Meaghan'.", "Construct the SQL query using a JOIN to combine the Accounts and Customers tables, and apply the WHERE clause for filtering."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT a.account_id, a.account_name, a.other_account_details \nFROM Accounts a \nJOIN Customers c ON a.customer_id = c.customer_id \nWHERE c.customer_first_name = 'Meaghan';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n    \"2\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\"\n}\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Accounts and Customers.", "We need to join the Accounts table with the Customers table to get account details for a specific customer.", "The join condition is based on the customer_id present in both tables.", "Filter the results to only include the customer named Meaghan Keeling by using the WHERE clause with the first and last name conditions.", "Select the desired columns from the Accounts table, which include account_id, account_name, date_account_opened, and other_account_details."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT a.account_id, a.account_name, a.date_account_opened, a.other_account_details \nFROM Accounts a \nJOIN Customers c ON a.customer_id = c.customer_id \nWHERE c.customer_first_name = 'Meaghan' AND c.customer_last_name = 'Keeling';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n    \"2\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\"\n}\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to join these tables on the customer_id to link customers with their accounts.", "The query should filter accounts to only include those with the account name '900'.", "Select the full names of the customers by concatenating their first and last names."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name \nFROM Customers \nJOIN Accounts ON Customers.customer_id = Accounts.customer_id \nWHERE Accounts.account_name = '900';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.1569", "db_id": "customers_and_invoices", "question": "Show id, first name and last name for all customers and the number of accounts.", "rationale": ["We need to select the customer ID, first name, and last name from the Customers table.", "We also need to count the number of accounts associated with each customer, which requires joining the Accounts table.", "The join will be a LEFT JOIN to ensure we include customers even if they have no accounts.", "We will group the results by customer ID, first name, and last name to get the count of accounts for each customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name, COUNT(a.account_id) AS number_of_accounts\nFROM Customers c\nLEFT JOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n    \"2\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\"\n}\n"}
{"sample_id": "train.1570", "db_id": "customers_and_invoices", "question": "What are the the full names and ids for all customers, and how many accounts does each have?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to retrieve customer IDs and full names, which requires selecting from the Customers table.", "To get the number of accounts for each customer, we will join the Accounts table on customer_id.", "Use a LEFT JOIN to ensure we include customers even if they have no accounts.", "Select the customer_id, concatenate first and last names for the full name, and count the number of accounts for each customer.", "Group the results by customer_id and full name to aggregate the account counts correctly.", "Order the results by the account count in descending order to see customers with the most accounts first."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name, COUNT(a.account_id) AS account_count\nFROM Customers c\nLEFT JOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name\nORDER BY account_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n    \"2\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\"\n}\n"}
{"sample_id": "train.1580", "db_id": "customers_and_invoices", "question": "Count the number of financial transactions that correspond to each account id.", "rationale": ["We need to count the number of financial transactions for each account ID.", "The relevant tables are 'Accounts' and 'Financial_Transactions'.", "We will perform a LEFT JOIN between 'Accounts' and 'Financial_Transactions' on the account_id field to include all accounts even if they have no transactions.", "We will use COUNT() to count the number of transactions for each account.", "Finally, we will group the results by account_id to get the count for each account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT a.account_id, COUNT(ft.transaction_id) AS transaction_count\nFROM Accounts a\nLEFT JOIN Financial_Transactions ft ON a.account_id = ft.account_id\nGROUP BY a.account_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n    \"1\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n    \"2\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.1607", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of invoices for each order.", "rationale": ["We need to retrieve order IDs and the count of invoices associated with each order.", "To achieve this, we will use a SQL SELECT statement to select the order_id from the Orders table.", "We will also count the number of invoices for each order, which requires a JOIN between the Orders table and the Invoices table based on the order_id.", "A LEFT JOIN is appropriate here to ensure we include all orders, even those without any associated invoices.", "We will group the results by order_id to get the count of invoices for each order."], "gold_sql": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id", "source_tables": ["invoices"], "pred_sql": "SELECT Orders.order_id, COUNT(Invoices.invoice_number) AS number_of_invoices\nFROM Orders\nLEFT JOIN Invoices ON Orders.order_id = Invoices.order_id\nGROUP BY Orders.order_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of order IDs and their corresponding details from the 'Orders' table, specifically for those orders that are associated with invoices. The results are grouped by order ID, and only those orders that have more than a specified number of associated invoices are included. The placeholder in the HAVING clause represents the minimum count of invoices required for an order to be displayed.\",\n    \"1\": \"This virtual table provides a list of invoice numbers and their corresponding invoice dates from the 'Invoices' table, filtered by the number of financial transactions associated with each invoice. The placeholder in the LIMIT clause represents the maximum number of records to return.\",\n    \"2\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["We need to retrieve the order IDs and the number of items in each order.", "To do this, we will select the 'order_id' from the 'Orders' table.", "We will also count the number of items associated with each order, which can be done using the COUNT function on 'order_item_id' from the 'Order_Items' table.", "To link the orders with their items, we will perform a JOIN operation between the 'Orders' table and the 'Order_Items' table on the 'order_id'.", "Finally, we will group the results by 'order_id' to get the count of items for each order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT Orders.order_id, COUNT(Order_Items.order_item_id) AS number_of_items\nFROM Orders\nJOIN Order_Items ON Orders.order_id = Order_Items.order_id\nGROUP BY Orders.order_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of order IDs and their corresponding details from the 'Orders' table, specifically for those orders that are associated with invoices. The results are grouped by order ID, and only those orders that have more than a specified number of associated invoices are included. The placeholder in the HAVING clause represents the minimum count of invoices required for an order to be displayed.\",\n    \"1\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\"\n}\n"}
{"sample_id": "train.1622", "db_id": "customers_and_invoices", "question": "What are teh names of the different products, as well as the number of customers who have ordered each product.", "rationale": ["Identify the relevant tables: Products, Orders, and Order_Items are needed to get product names and customer orders.", "Join the Products table with Order_Items on product_id to link products to their orders.", "Join the resulting table with Orders on order_id to associate orders with customers.", "Count the distinct customer IDs for each product to get the number of customers who ordered each product.", "Group the results by product name to aggregate the customer counts for each product."], "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"], "pred_sql": "SELECT Products.product_name, COUNT(DISTINCT Orders.customer_id) AS customer_count\nFROM Products\nJOIN Order_Items ON Products.product_id = Order_Items.product_id\nJOIN Orders ON Order_Items.order_id = Orders.order_id\nGROUP BY Products.product_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for those customers who have accounts. The results are grouped by customer ID and ordered by the number of accounts each customer has, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.2050", "db_id": "party_people", "question": "Which ministers are not a part of the Progress Party?", "rationale": ["Identify the relevant tables: We need to look at the 'party' table to find ministers and their associated parties.", "Determine the condition: We want to find ministers who are not part of the 'Progress Party'.", "Construct the SQL query: We will select distinct ministers from the 'party' table where the party name is not 'Progress Party'."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT DISTINCT minister FROM party WHERE Party_name != 'Progress Party';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement allows for the retrieval of the party name and the count of members belonging to that party.\",\n    \"1\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT statement represents the party names, while the count function aggregates the total number of events for each party.\"\n}\n"}
{"sample_id": "train.2057", "db_id": "party_people", "question": "Show all party names and the number of members in each party.", "rationale": ["Identify the tables involved: 'party' and 'member'.", "We need to retrieve the party names from the 'party' table and count the number of members from the 'member' table.", "Join the 'party' table with the 'member' table on the Party_ID to associate members with their respective parties.", "Use COUNT() function to count the number of members for each party.", "Group the results by party name to get the count for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT party.Party_name, COUNT(member.Member_ID) AS Number_of_Members\nFROM party\nLEFT JOIN member ON party.Party_ID = member.Party_ID\nGROUP BY party.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement allows for the retrieval of the party name and the count of members belonging to that party.\",\n    \"1\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT statement represents the party names, while the count function aggregates the total number of events for each party.\"\n}\n"}
{"sample_id": "train.2072", "db_id": "party_people", "question": "How many events are there for each party?", "rationale": ["Identify the tables involved: 'party' and 'party_events'.", "We need to count the number of events for each party, so we will use the COUNT() function on the 'Event_ID' from the 'party_events' table.", "Join the 'party' table with the 'party_events' table on the 'Party_ID' to associate events with their respective parties.", "Use a LEFT JOIN to ensure that parties with no events are still included in the results with a count of zero.", "Group the results by 'Party_name' to get the count of events for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT p.Party_name, COUNT(pe.Event_ID) AS Event_Count\nFROM party p\nLEFT JOIN party_events pe ON p.Party_ID = pe.Party_ID\nGROUP BY p.Party_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT statement represents the party names, while the count function aggregates the total number of events for each party.\",\n    \"1\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement allows for the retrieval of the party name and the count of members belonging to that party.\"\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the relevant tables: 'party_events', 'party', and 'region'.", "We need to count the number of events, so we will use the COUNT() function.", "Join the 'party_events' table with the 'party' table on Party_ID to get the party names associated with the events.", "Join the 'party' table with the 'region' table on Region_ID to filter by the United Kingdom region.", "Add a WHERE clause to filter for events named 'Annual Meeting' and for the region named 'United Kingdom'.", "Select the count of these filtered events."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT COUNT(*) AS Annual_Meeting_Count \nFROM party_events pe \nJOIN party p ON pe.Party_ID = p.Party_ID \nJOIN region r ON p.Region_ID = r.Region_ID \nWHERE pe.Event_Name = 'Annual Meeting' \nAND r.Region_name = 'United Kingdom';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT statement represents the party names, while the count function aggregates the total number of events for each party.\"\n}\n"}
{"sample_id": "train.2167", "db_id": "formula_1", "question": "What is the id and family name of the driver who has the longest laptime?", "rationale": ["We need to find the driver with the longest lap time, which means we will be looking for the maximum value in the lapTimes table.", "To do this, we will join the drivers table with the lapTimes table on the driverId column, as this will allow us to access the driver's surname along with their lap times.", "We will then order the results by the lap time in descending order to get the longest lap time at the top.", "Finally, we will limit the results to just one entry to get the driver with the longest lap time."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "pred_sql": "SELECT d.driverId, d.surname \nFROM drivers d \nJOIN lapTimes lt ON d.driverId = lt.driverId \nORDER BY lt.time DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The placeholder in the LIMIT clause allows the user to specify the number of top results to retrieve based on the fastest lap times.\",\n    \"1\": \"This virtual table provides the maximum fastest lap speed recorded during races in a specific year and for a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.\",\n    \"2\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\"\n}\n"}
{"sample_id": "train.2174", "db_id": "formula_1", "question": "How many drivers did not race in 2009?", "rationale": ["We need to count the number of drivers who did not race in the year 2009.", "To do this, we will first identify all drivers who participated in races in 2009 by joining the 'results' and 'races' tables.", "We will select distinct driverIds from the results of races that occurred in 2009.", "Next, we will count all distinct driverIds from the 'drivers' table that are not in the list of drivers who raced in 2009.", "The final SQL query will use a subquery to filter out the drivers who raced in 2009 and count the remaining drivers."], "gold_sql": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )", "source_tables": ["results", "races"], "pred_sql": "SELECT COUNT(DISTINCT driverId) AS drivers_not_in_2009\nFROM drivers\nWHERE driverId NOT IN (\n    SELECT DISTINCT driverId\n    FROM results\n    JOIN races ON results.raceId = races.raceId\n    WHERE races.year = 2009\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of distinct drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.\",\n    \"1\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n    \"2\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\"\n}\n"}
{"sample_id": "train.2179", "db_id": "formula_1", "question": "Find the id and forenames of drivers who participated both the races with name Australian Grand Prix and the races with name Chinese Grand Prix?", "rationale": ["Identify the tables needed: We need the 'drivers' table for driver information and the 'results' and 'races' tables to find which drivers participated in specific races.", "Join the 'drivers' table with the 'results' table to link drivers to their race results.", "Join the 'results' table with the 'races' table to filter results based on race names.", "Use a subquery to find drivers who participated in the 'Chinese Grand Prix' and filter the main query to only include those drivers who also participated in the 'Australian Grand Prix'.", "Select the required fields: driverId and forename from the 'drivers' table."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.driverId, d.forename \nFROM drivers d \nJOIN results r1 ON d.driverId = r1.driverId \nJOIN races ra ON r1.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' \nAND d.driverId IN (\n    SELECT r2.driverId \n    FROM results r2 \n    JOIN races rb ON r2.raceId = rb.raceId \n    WHERE rb.name = 'Chinese Grand Prix'\n)\nGROUP BY d.driverId, d.forename;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n    \"1\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n    \"2\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the driver standings, a certain number of wins, and more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria.\"\n}\n"}
{"sample_id": "train.2180", "db_id": "formula_1", "question": "What is the id and first name of all the drivers who participated in the Australian Grand Prix and the Chinese Grand Prix?", "rationale": ["Identify the tables needed: 'drivers', 'results', and 'races' are required to get driver information and their race participation.", "Join the 'drivers' table with the 'results' table on 'driverId' to link drivers with their race results.", "Join the 'results' table with the 'races' table on 'raceId' to filter results based on specific races.", "Use a WHERE clause to filter for the races named 'Australian Grand Prix' and 'Chinese Grand Prix'.", "Select the 'driverId' and 'forename' from the 'drivers' table for the filtered results."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.driverId, d.forename \nFROM drivers d \nJOIN results r ON d.driverId = r.driverId \nJOIN races ra ON r.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' \n   OR ra.name = 'Chinese Grand Prix' \nGROUP BY d.driverId, d.forename;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n    \"1\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n    \"2\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the driver standings, a certain number of wins, and more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria.\"\n}\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the tables needed: We need the 'drivers', 'results', and 'races' tables to get the required information about drivers and the races they participated in.", "We need to find drivers who participated in the 'Australian Grand Prix'. This requires joining the 'drivers' table with the 'results' table and then with the 'races' table to filter by the race name.", "Next, we need to exclude drivers who participated in the 'Chinese Grand Prix'. This can be done using a subquery that selects driver IDs from the same tables but filters for the 'Chinese Grand Prix'.", "The final SQL query selects the first and last names of drivers who meet the criteria of participating in the Australian Grand Prix but not in the Chinese Grand Prix."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT d.forename, d.surname \nFROM drivers d \nJOIN results r1 ON d.driverId = r1.driverId \nJOIN races ra ON r1.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' \nAND d.driverId NOT IN (\n    SELECT d2.driverId \n    FROM drivers d2 \n    JOIN results r2 ON d2.driverId = r2.driverId \n    JOIN races rb ON r2.raceId = rb.raceId \n    WHERE rb.name = 'Chinese Grand Prix'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n    \"1\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n    \"2\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the driver standings, a certain number of wins, and more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria.\"\n}\n"}
{"sample_id": "train.2190", "db_id": "formula_1", "question": "For each constructor id, how many races are there?", "rationale": ["We need to count the number of races for each constructor id.", "The relevant table for this information is 'constructorResults', which links constructors to races.", "We will select the 'constructorId' and count the 'raceId' for each constructor.", "To get the count of races per constructor, we will use the GROUP BY clause on 'constructorId'."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(raceId) AS race_count \nFROM constructorResults \nGROUP BY constructorId;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of distinct drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.\",\n    \"1\": \"This virtual table provides the maximum fastest lap speed recorded during races in a specific year and for a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.\",\n    \"2\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\"\n}\n"}
{"sample_id": "train.2194", "db_id": "formula_1", "question": "What are the names of all races held after 2000 in Spain?", "rationale": ["Identify the relevant tables: 'races' for race information and 'circuits' for circuit location.", "We need to find races held after the year 2000, so we will filter the 'year' column in the 'races' table.", "We also need to filter for races held in Spain, which requires joining the 'circuits' table to access the 'country' column.", "The SQL query will select the 'name' of the races from the 'races' table where the year is greater than 2000 and the country is Spain."], "gold_sql": "SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = 'Spain' AND T1.year > 2000", "source_tables": ["races", "circuits"], "pred_sql": "SELECT races.name \nFROM races \nJOIN circuits ON races.circuitId = circuits.circuitId \nWHERE races.year > 2000 AND circuits.country = 'Spain';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n    \"1\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n    \"2\": \"This virtual table provides the count of distinct drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.\"\n}\n"}
{"sample_id": "train.2217", "db_id": "formula_1", "question": "Find the names of Japanese constructors that have once earned more than 5 points?", "rationale": ["Identify the relevant tables: constructors and constructorResults.", "We need to find constructors that are Japanese, so we will filter the constructors table by nationality.", "We also need to check the points earned by these constructors, which is found in the constructorResults table.", "We will join the constructors table with the constructorResults table on the constructorId to access points data.", "Finally, we will select distinct names of constructors where the nationality is Japanese and points are greater than 5."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT DISTINCT constructors.name \nFROM constructors \nJOIN constructorResults ON constructors.constructorId = constructorResults.constructorId \nWHERE constructors.nationality = 'Japanese' \nAND constructorResults.points > 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the driver standings, a certain number of wins, and more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria.\",\n    \"1\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n    \"2\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\"\n}\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the relevant table: We need to retrieve information about constructors, so we will use the 'constructors' table.", "Join with the constructorResults table: To find out how many points each constructor has earned, we need to join the 'constructors' table with the 'constructorResults' table using the constructorId.", "Filter by nationality: We are specifically looking for Japanese constructors, so we will add a WHERE clause to filter constructors by their nationality.", "Filter by points: We need to ensure that the constructors have earned more than 5 points, so we will add another condition in the WHERE clause to check that constructorResults.points is greater than 5.", "Select distinct names: Finally, we will select the distinct names of the constructors that meet the criteria."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT DISTINCT constructors.name \nFROM constructors \nJOIN constructorResults ON constructors.constructorId = constructorResults.constructorId \nWHERE constructors.nationality = 'Japanese' \nAND constructorResults.points > 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have a specific position in the driver standings, a certain number of wins, and more points than a specified threshold. The placeholders in the WHERE clause represent the position, number of wins, and points criteria.\",\n    \"1\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n    \"2\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\"\n}\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races and lapTimes are needed to get the race information and the fastest lap speeds.", "We need to calculate the average fastest lap speed, so we will use the AVG() function on the fastestLapSpeed column from the lapTimes table.", "To filter the results for the Monaco Grand Prix in 2008, we will use a WHERE clause that specifies the year and the race name.", "We will join the races table with the lapTimes table on the raceId to link the race information with the lap times.", "The final SQL query will select the average fastest lap speed for the specified race and year."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(lapTimes.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races\nJOIN lapTimes ON races.raceId = lapTimes.raceId\nWHERE races.year = 2008 AND races.name = 'Monaco Grand Prix';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum fastest lap speed recorded during races in a specific year and for a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.\",\n    \"1\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n    \"2\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\"\n}\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: lapTimes, races, and circuits are needed to find the fastest lap speed for a specific race in a specific year.", "The lapTimes table contains the fastest lap speed, while the races table contains the year and the race name, and the circuits table contains the circuit name.", "Join the lapTimes table with the races table on raceId to link lap times to specific races.", "Join the resulting table with the circuits table on circuitId to filter by the circuit name (Monaco Grand Prix).", "Use a WHERE clause to specify the year (2008) and the race name (Monaco Grand Prix).", "Select the maximum fastest lap speed from the filtered results."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(fastestLapSpeed) AS max_fastest_lap_speed \nFROM lapTimes \nJOIN races ON lapTimes.raceId = races.raceId \nJOIN circuits ON races.circuitId = circuits.circuitId \nWHERE circuits.name = 'Monaco Grand Prix' AND races.year = 2008;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum fastest lap speed recorded during races in a specific year and for a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.\",\n    \"1\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n    \"2\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\"\n}\n"}
{"sample_id": "train.2223", "db_id": "formula_1", "question": "What are the maximum fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to get race names, results, and fastest lap speeds.", "Join the races table with the results table on raceId to link races with their results.", "Join the results table with the lapTimes table on raceId and driverId to get the fastest lap speeds for each driver in each race.", "Filter the results to include only races held after the year 2004 using the WHERE clause.", "Group the results by race name and year to calculate the maximum fastest lap speed for each race.", "Select the race name, year, and the maximum fastest lap speed, and order the results by year."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name AS race_name, r.year, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN lapTimes l ON res.raceId = l.raceId AND res.driverId = l.driverId\nWHERE r.year > 2004\nGROUP BY r.name, r.year\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum fastest lap speed recorded during races in a specific year and for a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.\",\n    \"1\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n    \"2\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\"\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["Identify the tables needed: races, results, and lapTimes.", "We need to get the race name and the maximum fastest lap speed for races after 2004.", "Join the races table with the results table on raceId to link races with their results.", "Join the results table with the lapTimes table on raceId to access the fastest lap speeds.", "Filter the results to include only races that occurred after 2004 using the WHERE clause.", "Group the results by race name and year to calculate the maximum fastest lap speed for each race.", "Order the final results by year to meet the requirement of the query."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name AS race_name, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN lapTimes l ON r.raceId = l.raceId\nWHERE r.year > 2004\nGROUP BY r.name, r.year\nORDER BY r.year;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the maximum fastest lap speed recorded during races in a specific year and for a specific race name. The placeholders in the WHERE clause represent the year of the race and the official name of the race.\",\n    \"1\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\",\n    \"2\": \"This virtual table provides the average fastest lap speed of races held in a specific year or later, along with the official name of each race and the year it took place. The placeholders in the WHERE clause allow users to specify the year from which they want to retrieve the data.\"\n}\n"}
{"sample_id": "train.2325", "db_id": "csu_1", "question": "What campuses are located in the county of Los Angeles?", "rationale": ["Identify the relevant table: The question asks about campuses, which are listed in the 'Campuses' table.", "Determine the filtering criteria: The user is interested in campuses located in 'Los Angeles', which is a specific value in the 'County' column.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'Campuses' table where the 'County' matches 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT * FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses from the 'Campuses' table that have faculty data for a specific year. The campuses are ordered by the number of faculty members in descending order, and the result is limited to a specified number of campuses. The placeholders in the WHERE clause represent the year of the faculty data and the limit on the number of campuses to return.\",\n    \"1\": \"This virtual table lists the campuses from the 'Campuses' table that have total enrollments exceeding a specified number and full-time equivalent enrollments exceeding another specified number for a given academic year. The placeholders in the WHERE clause represent the year and the enrollment thresholds.\",\n    \"2\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\"\n}\n"}
{"sample_id": "train.2347", "db_id": "csu_1", "question": "In what year was the most degrees conferred?", "rationale": ["Identify the relevant table: The 'degrees' table contains information about the years when degrees were awarded.", "We need to find the year with the most degrees conferred, which requires aggregating the data by year.", "Use the SUM function to count the total degrees awarded for each year.", "Group the results by year to get the total degrees for each year.", "Order the results in descending order to get the year with the highest total degrees at the top.", "Limit the results to 1 to get only the year with the most degrees conferred."], "gold_sql": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Year, SUM(CASE WHEN Degrees IS NOT NULL THEN 1 ELSE 0 END) AS TotalDegrees\nFROM degrees\nGROUP BY Year\nORDER BY TotalDegrees DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"2\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\"\n}\n"}
{"sample_id": "train.2348", "db_id": "csu_1", "question": "Which campus has the most degrees conferred in all times?", "rationale": ["Identify the table that contains information about degrees awarded, which is the 'degrees' table.", "To find the campus with the most degrees conferred, we need to count the number of degrees for each campus.", "We will use the COUNT function to aggregate the number of degrees awarded per campus.", "We will group the results by the 'Campus' column to get the total count for each campus.", "To find the campus with the highest count, we will order the results in descending order based on the total degrees.", "Finally, we will limit the results to 1 to get only the campus with the most degrees conferred."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Campus, COUNT(Degrees) AS TotalDegrees\nFROM degrees\nGROUP BY Campus\nORDER BY TotalDegrees DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"2\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\"\n}\n"}
{"sample_id": "train.2349", "db_id": "csu_1", "question": "What campus has the most degrees  conferrred over its entire existence?", "rationale": ["Identify the table that contains information about degrees awarded, which is the 'degrees' table.", "To find the campus with the most degrees conferred, we need to count the number of degrees for each campus.", "We will use the COUNT function to aggregate the number of degrees awarded per campus.", "We will group the results by the 'Campus' column to get the total count for each campus.", "Finally, we will order the results in descending order based on the total count of degrees and limit the result to 1 to get the campus with the most degrees."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Campus, COUNT(Degrees) AS TotalDegrees\nFROM degrees\nGROUP BY Campus\nORDER BY TotalDegrees DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"2\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\"\n}\n"}
{"sample_id": "train.2351", "db_id": "csu_1", "question": "What campus has the most faculties in 2003?", "rationale": ["Identify the relevant tables: 'Campuses' and 'faculty'.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Filter the results to only include records from the year 2003.", "Order the results by the number of faculty members in descending order to find the campus with the most faculty.", "Limit the results to 1 to get only the campus with the highest number of faculty."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Campuses.Campus, faculty.Faculty \nFROM Campuses \nJOIN faculty ON Campuses.Id = faculty.Campus \nWHERE faculty.Year = 2003 \nORDER BY faculty.Faculty DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses from the 'Campuses' table that have faculty data for a specific year. The campuses are ordered by the number of faculty members in descending order, and the result is limited to a specified number of campuses. The placeholders in the WHERE clause represent the year of the faculty data and the limit on the number of campuses to return.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\",\n    \"2\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\"\n}\n"}
{"sample_id": "train.2358", "db_id": "csu_1", "question": "For each Orange county campus, report the number of degrees granted after 2000.", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to filter campuses located in Orange County, so we will use the County column from the Campuses table.", "We need to count the number of degrees granted after the year 2000, so we will filter the degrees table based on the Year column.", "Join the Campuses table with the degrees table on the Campus identifier to get the relevant data for Orange County campuses.", "Use COUNT to aggregate the number of degrees granted for each campus and group the results by campus name."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT Campuses.Campus, COUNT(degrees.Degrees) AS DegreesGranted\nFROM Campuses\nJOIN degrees ON Campuses.Id = degrees.Campus\nWHERE Campuses.County = 'Orange' AND degrees.Year > '2000'\nGROUP BY Campuses.Campus;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"2\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\"\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to count the total number of degrees granted, so we will use the COUNT function on the Degrees column from the degrees table.", "We need to filter the results to only include campuses in Orange County, which is done by checking the County column in the Campuses table.", "We also need to filter the degrees awarded after the year 2000, which is done by checking the Year column in the degrees table.", "We will join the Campuses table with the degrees table on the campus identifier (Id in Campuses and Campus in degrees).", "Finally, we will group the results by campus to get the total number of degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT c.Campus, COUNT(d.Degrees) AS TotalDegrees\nFROM Campuses c\nJOIN degrees d ON c.Id = d.Campus\nWHERE c.County = 'Orange' AND d.Year > '2000'\nGROUP BY c.Campus;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"2\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\"\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant table: The 'enrollments' table contains the total enrollment and full-time equivalent enrollment data.", "Specify the year: We need to filter the data for the year 1956.", "Set the conditions: We need to find campuses with total enrollment greater than 400 and full-time equivalent enrollment greater than 200.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' from the 'enrollments' table with the specified conditions."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT Campus FROM enrollments WHERE Year = '1956' AND TotalEnrollment_AY > 400 AND FTE_AY > 200;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses from the 'Campuses' table that have total enrollments exceeding a specified number and full-time equivalent enrollments exceeding another specified number for a given academic year. The placeholders in the WHERE clause represent the year and the enrollment thresholds.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\"\n}\n"}
{"sample_id": "train.2367", "db_id": "csu_1", "question": "What campuses are in Los Angeles county?", "rationale": ["Identify the relevant table: The question asks about campuses, which are listed in the 'Campuses' table.", "Determine the filtering criteria: The question specifies 'Los Angeles county', so we need to filter the results based on the 'County' column.", "Construct the SQL query: We will select all columns from the 'Campuses' table where the 'County' is 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT * FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses from the 'Campuses' table that have total enrollments exceeding a specified number and full-time equivalent enrollments exceeding another specified number for a given academic year. The placeholders in the WHERE clause represent the year and the enrollment thresholds.\",\n    \"1\": \"This virtual table lists the campuses from the 'Campuses' table that have faculty data for a specific year. The campuses are ordered by the number of faculty members in descending order, and the result is limited to a specified number of campuses. The placeholders in the WHERE clause represent the year of the faculty data and the limit on the number of campuses to return.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\"\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: degrees and Campuses.", "We need to count the number of degrees conferred, so we will use the COUNT function on the Degrees column from the degrees table.", "To filter the results for 'San Jose State University', we will join the degrees table with the Campuses table on the Campus identifier.", "We will also filter the results for the year 2000 by adding a condition in the WHERE clause for degrees.Year.", "The final SQL query will select the count of degrees from the joined tables with the specified conditions."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT COUNT(Degrees) AS TotalDegrees\nFROM degrees\nJOIN Campuses ON degrees.Campus = Campuses.Id\nWHERE Campuses.Campus = 'San Jose State University' AND degrees.Year = '2000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"2\": \"This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.\"\n}\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "We need to find the number of faculty lines for a specific campus ('San Francisco State University') in a specific year (2004).", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to access the campus name.", "Filter the results using a WHERE clause to specify the campus name and the year.", "Select the 'Faculty' column from the 'faculty' table to get the number of faculty members."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Faculty FROM faculty INNER JOIN Campuses ON faculty.Campus = Campuses.Id WHERE Campuses.Campus = 'San Francisco State University' AND faculty.Year = 2004;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\",\n    \"2\": \"This virtual table lists the campuses from the 'Campuses' table that have faculty data for a specific year. The campuses are ordered by the number of faculty members in descending order, and the result is limited to a specified number of campuses. The placeholders in the WHERE clause represent the year of the faculty data and the limit on the number of campuses to return.\"\n}\n"}
{"sample_id": "train.2378", "db_id": "csu_1", "question": "List the campus that have between 600 and 1000 faculty lines in year 2004.", "rationale": ["Identify the relevant tables: 'Campuses' for campus names and 'faculty' for faculty data.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Filter the results to include only those records from the year 2004.", "Apply a condition to select campuses with faculty counts between 600 and 1000."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT c.Campus \nFROM Campuses c \nJOIN faculty f ON c.Id = f.Campus \nWHERE f.Year = 2004 AND f.Faculty BETWEEN 600 AND 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses from the 'Campuses' table that have faculty data for a specific year. The campuses are ordered by the number of faculty members in descending order, and the result is limited to a specified number of campuses. The placeholders in the WHERE clause represent the year of the faculty data and the limit on the number of campuses to return.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\",\n    \"2\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\"\n}\n"}
{"sample_id": "train.2379", "db_id": "csu_1", "question": "What are the campuses that had between 600 and 1000 faculty members in 2004?", "rationale": ["Identify the relevant tables: 'Campuses' and 'faculty'.", "We need to find campuses with faculty data for the year 2004, so we will filter the 'faculty' table by the year.", "We need to check the number of faculty members, which is in the 'Faculty' column of the 'faculty' table.", "We will use a JOIN to connect 'Campuses' and 'faculty' on the campus identifier.", "The condition for the number of faculty members is that it should be between 600 and 1000, which we will specify in the WHERE clause."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT Campuses.Campus \nFROM Campuses \nJOIN faculty ON Campuses.Id = faculty.Campus \nWHERE faculty.Year = 2004 \nAND faculty.Faculty BETWEEN 600 AND 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses from the 'Campuses' table that have faculty data for a specific year. The campuses are ordered by the number of faculty members in descending order, and the result is limited to a specified number of campuses. The placeholders in the WHERE clause represent the year of the faculty data and the limit on the number of campuses to return.\",\n    \"1\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\",\n    \"2\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\"\n}\n"}
{"sample_id": "train.2380", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the most number of degrees in year 2002?", "rationale": ["Identify the year of interest, which is 2002, to filter the degrees awarded.", "Use the degrees table to find out which campus conferred the most degrees in 2002 by grouping by campus and counting the degrees.", "Order the results by the count of degrees in descending order and limit the result to the top campus.", "Use the identified campus from the degrees table to filter the faculty table to count the number of faculty members associated with that campus."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(*) AS FacultyCount\nFROM faculty\nWHERE Campus = (\n    SELECT Campus\n    FROM degrees\n    WHERE Year = '2002'\n    GROUP BY Campus\n    ORDER BY COUNT(Degrees) DESC\n    LIMIT 1\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"2\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\"\n}\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the year of interest, which is 2001, for the degrees awarded.", "Determine the campus that awarded the least number of degrees in 2001 by using a subquery to find the minimum number of degrees awarded.", "Join the 'faculty' table with the 'degrees' table on the campus identifier to get the faculty count for the campus with the least degrees awarded.", "Select the faculty count from the 'faculty' table where the campus matches the one with the least degrees awarded in 2001."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty f \nJOIN degrees d ON f.Campus = d.Campus \nWHERE d.Year = '2001' \nAND d.Degrees = (SELECT MIN(Degrees) \n                FROM degrees \n                WHERE Year = '2001');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"2\": \"This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.\"\n}\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "Determine the specific campus of interest, which is 'San Jose State'.", "Use a subquery to find the 'Id' of 'San Jose State' from the 'Campuses' table.", "Sum the 'Undergraduate' column from the 'discipline_enrollments' table where the 'Campus' matches the 'Id' of 'San Jose State'."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT SUM(Undergraduate) AS TotalUndergraduates\nFROM discipline_enrollments\nWHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Jose State');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the campuses from the 'Campuses' table that have total enrollments exceeding a specified number and full-time equivalent enrollments exceeding another specified number for a given academic year. The placeholders in the WHERE clause represent the year and the enrollment thresholds.\",\n    \"1\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\",\n    \"2\": \"This virtual table summarizes the total number of degrees awarded at each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the data.\"\n}\n"}
{"sample_id": "train.3131", "db_id": "assets_maintenance", "question": "Which engineer has visited the most times? Show the engineer id, first name and last name.", "rationale": ["Identify the relevant tables: Engineer_Visits and Maintenance_Engineers.", "We need to count the number of visits for each engineer, so we will use COUNT(*) to aggregate the visits.", "Join the Engineer_Visits table with the Maintenance_Engineers table on the engineer_id to get the first and last names of the engineers.", "Group the results by engineer_id, first_name, and last_name to get the count of visits for each engineer.", "Order the results by visit_count in descending order to find the engineer with the most visits.", "Limit the results to 1 to get only the engineer with the highest visit count."], "gold_sql": "SELECT T1.engineer_id ,  T1.first_name ,  T1.last_name FROM Maintenance_Engineers AS T1 JOIN Engineer_Visits AS T2 GROUP BY T1.engineer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["maintenance_engineers", "engineer_visits"], "pred_sql": "SELECT engineer_id, first_name, last_name, COUNT(*) as visit_count\nFROM Engineer_Visits\nJOIN Maintenance_Engineers ON Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id\nGROUP BY engineer_id, first_name, last_name\nORDER BY visit_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3139", "db_id": "assets_maintenance", "question": "How many fault status codes are recorded in the fault log parts table?", "rationale": ["The question asks for the number of unique fault status codes recorded in the Fault_Log_Parts table.", "To find the unique fault status codes, we need to count distinct values in the 'fault_status' column of the Fault_Log_Parts table.", "The SQL query uses the COUNT function along with DISTINCT to ensure that only unique fault status codes are counted."], "gold_sql": "SELECT DISTINCT fault_status FROM Fault_Log_Parts", "source_tables": ["fault_log_parts"], "pred_sql": "SELECT COUNT(DISTINCT fault_status) AS unique_fault_status_count FROM Fault_Log_Parts;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of fault descriptions and their corresponding statuses from the 'Fault_Log' and 'Fault_Log_Parts' tables. The join operation links the fault log entries with the parts associated with those faults, allowing users to see the details of each fault alongside its current status.\"\n}\n"}
{"sample_id": "train.3143", "db_id": "assets_maintenance", "question": "Which part fault requires the most number of skills to fix? List part id and name.", "rationale": ["Identify the relevant tables: Part_Faults, Skills_Required_To_Fix, and Parts.", "Join Part_Faults with Skills_Required_To_Fix to associate each part fault with its required skills.", "Join the result with Parts to get the part name corresponding to each part fault.", "Group the results by part_id and part_name to count the number of skills required for each part fault.", "Order the results by the count of skills in descending order to find the part fault that requires the most skills.", "Limit the results to 1 to get only the part fault with the highest number of required skills."], "gold_sql": "SELECT T1.part_id ,  T1.part_name FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id  =  T2.part_id JOIN Skills_Required_To_Fix AS T3 ON T2.part_fault_id  =  T3.part_fault_id GROUP BY T1.part_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["part_faults", "parts", "skills_required_to_fix"], "pred_sql": "SELECT pf.part_id, p.part_name\nFROM Part_Faults pf\nJOIN Skills_Required_To_Fix srf ON pf.part_fault_id = srf.part_fault_id\nJOIN Parts p ON pf.part_id = p.part_id\nGROUP BY pf.part_id, p.part_name\nORDER BY COUNT(srf.skill_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of fault descriptions and their corresponding statuses from the 'Fault_Log' and 'Fault_Log_Parts' tables. The join operation links the fault log entries with the parts associated with those faults, allowing users to see the details of each fault alongside its current status.\"\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: We need to find professors and the classes they teach, so we will use the PROFESSOR and CLASS tables.", "Determine the relationship: The PROFESSOR table is linked to the CLASS table through the PROF_NUM column in CLASS, which corresponds to EMP_NUM in PROFESSOR.", "Filter the results: We need to filter the classes to only those with the code 'ACCT-211'.", "Count the distinct professors: We want to count how many unique professors are teaching this class, so we will use COUNT(DISTINCT p.EMP_NUM).", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) AS professor_count\nFROM PROFESSOR p\nJOIN CLASS c ON p.EMP_NUM = c.PROF_NUM\nWHERE c.CRS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n    \"1\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3180", "db_id": "college_1", "question": "What are the first names and birthdates of the professors in charge of ACCT-211?", "rationale": ["Identify the tables needed: We need information from the EMPLOYEE table for professors' first names and birthdates, and the CLASS table to filter by the course code ACCT-211.", "Join the EMPLOYEE table with the CLASS table on the professor's identifier (PROF_NUM) to get the relevant professors for the specified course.", "Filter the results using a WHERE clause to specify the course code 'ACCT-211'.", "Select the first names (EMP_FNAME) and birthdates (EMP_DOB) of the professors who teach the specified course."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, EMPLOYEE.EMP_DOB \nFROM EMPLOYEE \nJOIN CLASS ON EMPLOYEE.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n    \"1\": \"This virtual table provides a distinct list of first names and dates of birth of professors who teach a specific course. The data is retrieved from the 'employee' table, which contains information about professors, and is joined with the 'class' table to filter by the course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n    \"2\": \"This virtual table provides the first names of professors along with the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\"\n}\n"}
{"sample_id": "train.3189", "db_id": "college_1", "question": "How many different locations does the school with code BUS has?", "rationale": ["Identify the relevant table: The question pertains to the locations associated with a specific school code, which is found in the DEPARTMENT table.", "Determine the specific school code: The school code in question is 'BUS'.", "Count distinct locations: We need to count the unique addresses (DEPT_ADDRESS) for the departments that belong to the school with code 'BUS'.", "Construct the SQL query: Use COUNT(DISTINCT DEPT_ADDRESS) to count unique addresses, and filter the results using WHERE SCHOOL_CODE = 'BUS'."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT COUNT(DISTINCT DEPT_ADDRESS) AS different_locations \nFROM DEPARTMENT \nWHERE SCHOOL_CODE = 'BUS';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows for specifying the maximum number of school codes to return.\",\n    \"1\": \"This virtual table provides a list of school codes from the 'department' table, grouped by school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows for specifying the maximum number of school codes to return.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the relevant table: The question asks for locations associated with a specific school code, which relates to the DEPARTMENT table.", "Determine the necessary columns: We need the DEPT_ADDRESS column to get the locations of the departments.", "Apply the filter: We need to filter the results to only include departments that belong to the school with the code 'BUS'.", "Use DISTINCT to ensure that we only get unique addresses, as there may be multiple departments with the same address."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows for specifying the maximum number of school codes to return.\",\n    \"1\": \"This virtual table provides a list of school codes from the 'department' table, grouped by school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows for specifying the maximum number of school codes to return.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3206", "db_id": "college_1", "question": "How many classes are held in each department?", "rationale": ["We need to count the number of classes held in each department.", "The relevant tables are CLASS, COURSE, and DEPARTMENT.", "CLASS contains the class information, COURSE links classes to departments, and DEPARTMENT contains department details.", "We will join CLASS and COURSE on CRS_CODE to get the department code for each class.", "Then, we will join the result with DEPARTMENT on DEPT_CODE to access department information.", "Finally, we will group the results by DEPARTMENT.DEPT_CODE and count the number of CLASS.CLASS_CODE for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, COUNT(CLASS.CLASS_CODE) AS class_count\nFROM CLASS\nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE\nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\",\n    \"1\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3209", "db_id": "college_1", "question": "What is the number of professors for different school?", "rationale": ["The question asks for the number of professors for different schools, which implies a need to group the results by school code.", "To get the number of professors, we will count the unique professor identifiers (EMP_NUM) from the PROFESSOR table.", "We need to join the PROFESSOR table with the DEPARTMENT table to access the SCHOOL_CODE associated with each professor.", "The SQL query will select the SCHOOL_CODE from the DEPARTMENT table and count the EMP_NUM from the PROFESSOR table, grouping the results by SCHOOL_CODE."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "pred_sql": "SELECT DEPARTMENT.SCHOOL_CODE, COUNT(PROFESSOR.EMP_NUM) AS NUMBER_OF_PROFESSORS\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.SCHOOL_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"1\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"2\": \"This virtual table provides a list of school codes from the 'department' table, grouped by school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows for specifying the maximum number of school codes to return.\"\n}\n"}
{"sample_id": "train.3210", "db_id": "college_1", "question": "How many different professors are there for the different schools?", "rationale": ["Identify the relevant tables: PROFESSOR and DEPARTMENT are needed to find the number of different professors and their associated schools.", "Join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE to associate professors with their respective departments.", "Use COUNT(DISTINCT p.EMP_NUM) to count the unique professors, ensuring that each professor is only counted once regardless of how many departments they may belong to.", "Group the results by SCHOOL_CODE to ensure that the count reflects the number of different professors across different schools."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) AS different_professors\nFROM PROFESSOR p\nJOIN DEPARTMENT d ON p.DEPT_CODE = d.DEPT_CODE\nGROUP BY d.SCHOOL_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"1\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"2\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\"\n}\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["To find the number of students for each department, we need to count the students grouped by their department.", "The relevant tables are DEPARTMENT and STUDENT, where DEPARTMENT contains department information and STUDENT contains student information including their department code.", "We will perform a JOIN operation between DEPARTMENT and STUDENT on the DEPT_CODE column to associate students with their respective departments.", "We will use the COUNT function to count the number of students (STU_NUM) for each department.", "Finally, we will group the results by DEPARTMENT.DEPT_NAME to get the count of students for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(STUDENT.STU_NUM) AS STUDENT_COUNT\nFROM DEPARTMENT\nJOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\",\n    \"1\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3218", "db_id": "college_1", "question": "How many students are in each department?", "rationale": ["We need to find out how many students are in each department, which requires us to count the number of students grouped by their department.", "The relevant tables for this query are DEPARTMENT and STUDENT. We will join these tables on the DEPT_CODE column, which is common to both tables.", "We will use a LEFT JOIN to ensure that we include all departments, even those that may not have any students enrolled.", "We will select the department name from the DEPARTMENT table and count the number of students from the STUDENT table, labeling this count as STUDENT_COUNT.", "Finally, we will group the results by the department name to get the count of students in each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(STUDENT.STU_NUM) AS STUDENT_COUNT\nFROM DEPARTMENT\nLEFT JOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"1\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"2\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\"\n}\n"}
{"sample_id": "train.3220", "db_id": "college_1", "question": "How many hours do the students spend studying in each department?", "rationale": ["The question asks for the total hours students spend studying in each department, which can be interpreted as the total credit hours of courses offered by each department.", "To find this information, we need to join several tables: COURSE (to get course credit hours), CLASS (to link courses to classes), DEPARTMENT (to get department names), ENROLL (to link students to classes), and STUDENT (to ensure we are counting only enrolled students).", "We will use the SUM function to aggregate the total credit hours for each department.", "The results should be grouped by department name to get the total credit hours for each department."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, SUM(COURSE.CRS_CREDIT) AS TOTAL_CREDIT_HOURS\nFROM COURSE\nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE\nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE\nJOIN ENROLL ON CLASS.CLASS_CODE = ENROLL.CLASS_CODE\nJOIN STUDENT ON ENROLL.STU_NUM = STUDENT.STU_NUM\nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping.\",\n    \"1\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3222", "db_id": "college_1", "question": "What is the highest, lowest, and average student GPA for every department?", "rationale": ["We need to find the highest, lowest, and average GPA for students in each department.", "To do this, we will join the STUDENT table with the DEPARTMENT table on the DEPT_CODE column, which is common to both tables.", "We will select the department name from the DEPARTMENT table and the GPA statistics (MAX, MIN, AVG) from the STUDENT table.", "We will group the results by department name to get the statistics for each department."], "gold_sql": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT D.DEPT_NAME, MAX(S.STU_GPA) AS Highest_GPA, MIN(S.STU_GPA) AS Lowest_GPA, AVG(S.STU_GPA) AS Average_GPA\nFROM STUDENT S\nJOIN DEPARTMENT D ON S.DEPT_CODE = D.DEPT_CODE\nGROUP BY D.DEPT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n    \"1\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3234", "db_id": "college_1", "question": "How many courses does the department of Computer Information Systmes offer?", "rationale": ["Identify the relevant tables: We need to find the number of courses offered by a specific department, which involves the COURSE and DEPARTMENT tables.", "Determine the relationship: The COURSE table has a DEPT_CODE that links to the DEPARTMENT table, allowing us to filter courses by department.", "Formulate the query: We will count the number of courses in the COURSE table where the DEPT_CODE matches the DEPT_CODE of the Computer Information Systems department from the DEPARTMENT table."], "gold_sql": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "department"], "pred_sql": "SELECT COUNT(*) AS course_count \nFROM COURSE \nWHERE DEPT_CODE = (SELECT DEPT_CODE FROM DEPARTMENT WHERE DEPT_NAME = 'Computer Information Systems');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping.\",\n    \"1\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3238", "db_id": "college_1", "question": "What are the total number of credits offered by each department?", "rationale": ["We need to find the total number of credits offered by each department.", "The relevant tables for this query are COURSE and DEPARTMENT, as COURSE contains the credit information and DEPARTMENT contains the department names.", "We will join the COURSE table with the DEPARTMENT table on the DEPT_CODE column, which is common to both tables.", "We will use the SUM function to calculate the total credits from the CRS_CREDIT column in the COURSE table.", "To group the results by department, we will use the GROUP BY clause on DEPARTMENT.DEPT_CODE and DEPARTMENT.DEPT_NAME."], "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, DEPARTMENT.DEPT_NAME, SUM(COURSE.CRS_CREDIT) AS TOTAL_CREDITS\nFROM COURSE\nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE, DEPARTMENT.DEPT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping.\",\n    \"1\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the tables involved: STUDENT, ENROLL, and CLASS.", "Determine the relationship between the tables: STUDENT is linked to ENROLL through STU_NUM, and ENROLL is linked to CLASS through CLASS_CODE.", "Select the first name of students (STU_FNAME) from the STUDENT table.", "Filter the results to include only those students enrolled in the class with the course code 'ACCT-211'.", "Construct the SQL query using INNER JOIN to combine the relevant tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STU_FNAME FROM STUDENT INNER JOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM INNER JOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE WHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of students from the 'student' table who have received specific grades in their enrolled classes. The placeholders in the WHERE clause represent the grades being queried.\",\n    \"1\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n    \"2\": \"This virtual table provides the first names of professors along with the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\"\n}\n"}
{"sample_id": "train.3253", "db_id": "college_1", "question": "What is the name of the department that has the largest number of students enrolled?", "rationale": ["Identify the relevant tables: DEPARTMENT and STUDENT are needed to find the department names and the number of students enrolled.", "Join the DEPARTMENT table with the STUDENT table on the DEPT_CODE to associate students with their respective departments.", "Group the results by DEPARTMENT.DEPT_CODE to count the number of students in each department.", "Order the results in descending order based on the count of students to find the department with the largest number of students.", "Limit the results to 1 to get only the department with the highest enrollment."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME\nFROM DEPARTMENT\nJOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE\nORDER BY COUNT(STUDENT.STU_NUM) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"1\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"2\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\"\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["We need to find the department with the most students enrolled.", "To do this, we will join the DEPARTMENT table with the STUDENT table on the DEPT_CODE column.", "We will group the results by DEPARTMENT.DEPT_CODE to count the number of students in each department.", "Next, we will order the results in descending order based on the count of students to get the department with the most students at the top.", "Finally, we will limit the results to 1 to get only the top department."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME\nFROM DEPARTMENT\nJOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE\nORDER BY COUNT(STUDENT.STU_NUM) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n    \"1\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about class locations and course codes.", "Determine the required columns: We need the course codes (CRS_CODE) from the CLASS table.", "Specify the condition: We want to filter the results to only include classes held in room 'KLR209'.", "Use DISTINCT to ensure that we only get unique course codes, as multiple classes may share the same course code in that room."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE\nFROM CLASS\nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping.\",\n    \"1\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n    \"2\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows for specifying the maximum number of school codes to return.\"\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed to find students and their grades.", "Determine the relationship: STUDENT is linked to ENROLL through the STU_NUM column.", "Specify the condition: We want students who received a grade of 'C'.", "Construct the SQL query: Use an INNER JOIN to combine STUDENT and ENROLL, selecting the first names of students with the specified grade."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT STU_FNAME FROM STUDENT INNER JOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM WHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of students from the 'student' table who have received specific grades in their enrolled classes. The placeholders in the WHERE clause represent the grades being queried.\",\n    \"1\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n    \"2\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\"\n}\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["Identify the table that contains professor information, which is the EMPLOYEE table.", "Determine the relevant column for the first names of professors, which is EMP_FNAME.", "To find professors who do not teach a class, we need to check which professors are not present in the CLASS table.", "Use a subquery to select the PROF_NUM from the CLASS table, which represents professors who are teaching classes.", "Use the NOT IN clause to filter out those professors from the EMPLOYEE table, ensuring we only get professors who do not teach any class."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME \nFROM EMPLOYEE \nWHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n    \"1\": \"This virtual table provides a distinct list of first names and dates of birth of professors who teach a specific course. The data is retrieved from the 'employee' table, which contains information about professors, and is joined with the 'class' table to filter by the course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n    \"2\": \"This virtual table provides the first names of professors along with the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\"\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the table that contains professor information, which is the EMPLOYEE table.", "We need to find professors who are not teaching any classes, so we will look for professors whose EMP_NUM is not present in the CLASS table.", "The CLASS table contains the PROF_NUM column that links to the EMP_NUM in the EMPLOYEE table, indicating which professors are teaching classes.", "We will use a subquery to select all PROF_NUM from the CLASS table and use the NOT IN clause to filter out those professors from the EMPLOYEE table.", "Finally, we will select the first names (EMP_FNAME) of the remaining professors who are not teaching any classes."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME \nFROM EMPLOYEE \nWHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n    \"1\": \"This virtual table provides a distinct list of first names and dates of birth of professors who teach a specific course. The data is retrieved from the 'employee' table, which contains information about professors, and is joined with the 'class' table to filter by the course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n    \"2\": \"This virtual table provides the first names of professors along with the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\"\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors, including their highest degree obtained.", "Determine the criteria: We need to count professors who have either a Ph.D. or a Masters degree.", "Construct the SQL query: Use the COUNT function to count the number of professors that meet the criteria, filtering with a WHERE clause that checks if the PROF_HIGH_DEGREE is either 'Ph.D.' or 'Masters'."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) AS total_professors\nFROM PROFESSOR\nWHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"1\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"2\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\"\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the tables needed: STUDENT, ENROLL, CLASS, COURSE, and DEPARTMENT.", "Join the STUDENT table with ENROLL to get the classes each student is enrolled in.", "Join the ENROLL table with CLASS to get the class details.", "Join the CLASS table with COURSE to get the course details.", "Join the COURSE table with DEPARTMENT to filter by department names.", "Use a WHERE clause to filter for the departments 'Accounting' and 'Computer Info. Systems'.", "Group the results by student first name to ensure we get unique names.", "Use HAVING to ensure that we only select students who are enrolled in classes from both departments."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nJOIN CLASS C ON E.CLASS_CODE = C.CLASS_CODE \nJOIN COURSE CR ON C.CRS_CODE = CR.CRS_CODE \nJOIN DEPARTMENT D ON CR.DEPT_CODE = D.DEPT_CODE \nWHERE D.DEPT_NAME IN ('Accounting', 'Computer Info. Systems') \nGROUP BY S.STU_FNAME \nHAVING COUNT(DISTINCT D.DEPT_NAME) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n    \"1\": \"This virtual table describes the first and last names of students from the 'student' table who have received specific grades in their enrolled classes. The placeholders in the WHERE clause represent the grades being queried.\",\n    \"2\": \"This virtual table provides the first names of professors along with the course codes they teach from the 'CLASS' and 'EMPLOYEE' tables. The join condition links the professor's identifier in the 'CLASS' table to the corresponding identifier in the 'EMPLOYEE' table.\"\n}\n"}
{"sample_id": "train.3300", "db_id": "college_1", "question": "What is the name of the department with the student that has the lowest GPA?", "rationale": ["Identify the relevant tables: STUDENT and DEPARTMENT.", "We need to find the department name associated with the student who has the lowest GPA.", "Join the STUDENT table with the DEPARTMENT table on the DEPT_CODE to get the department names.", "Order the results by the GPA in ascending order to get the lowest GPA first.", "Limit the results to 1 to get only the department of the student with the lowest GPA."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME \nFROM STUDENT \nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE \nORDER BY STUDENT.STU_GPA ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names associated with students, ordered by their GPA. The placeholder in the LIMIT clause allows for specifying the maximum number of department names to retrieve.\",\n    \"1\": \"This virtual table describes the first and last names of students from the 'student' table who have received specific grades in their enrolled classes. The placeholders in the WHERE clause represent the grades being queried.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3314", "db_id": "college_1", "question": "What are the first names, office locations of all lecturers who have taught some course?", "rationale": ["Identify the relevant tables: EMPLOYEE and PROFESSOR for lecturer information, and CLASS to find courses taught.", "Join the EMPLOYEE table with the PROFESSOR table on EMP_NUM to get the office locations of professors.", "Join the resulting table with the CLASS table on the PROFESSOR's EMP_NUM to ensure we only get professors who have taught courses.", "Select the first names (EMP_FNAME) and office locations (PROF_OFFICE) of the professors.", "Group the results by first name and office location to avoid duplicates."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num", "source_tables": ["course", "employee", "professor", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nGROUP BY EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n    \"1\": \"This virtual table provides a distinct list of first names and dates of birth of professors who teach a specific course. The data is retrieved from the 'employee' table, which contains information about professors, and is joined with the 'class' table to filter by the course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3315", "db_id": "college_1", "question": "Find the first names and offices of all instructors who have taught some course and the course description and the department name.", "rationale": ["Identify the required fields: first names of instructors, their office locations, course descriptions, and department names.", "The relevant tables are PROFESSOR (for instructor details), EMPLOYEE (for first names), CLASS (to link professors to courses), COURSE (for course descriptions), and DEPARTMENT (for department names).", "Join the PROFESSOR table with the EMPLOYEE table to get the first names of the instructors.", "Join the CLASS table to associate professors with the classes they teach.", "Join the COURSE table to get the descriptions of the courses associated with those classes.", "Join the DEPARTMENT table to get the names of the departments offering those courses.", "Construct the SELECT statement to retrieve the desired fields from the joined tables."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code", "source_tables": ["course", "department", "professor", "class", "employee"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE, COURSE.CRS_DESCRIPTION, DEPARTMENT.DEPT_NAME \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of professors who teach classes associated with a specific course code. The query uses an INTERSECT operation to find professors who are teaching the same course in two different instances, as indicated by the placeholders for the course code.\",\n    \"1\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"2\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\"\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: DEPARTMENT, COURSE, and CLASS are needed to find the department name for a specific class description.", "The relationship between these tables is established through foreign keys: CLASS.CRS_CODE links to COURSE.CRS_CODE, and COURSE.DEPT_CODE links to DEPARTMENT.DEPT_CODE.", "To find the department offering a class with a description containing 'Statistics', we need to filter the COURSE table based on the CRS_DESCRIPTION column.", "Use a JOIN operation to combine the DEPARTMENT, COURSE, and CLASS tables based on their relationships.", "The WHERE clause will filter the results to only include courses with descriptions that contain the word 'Statistics'.", "Finally, select the DEPARTMENT.DEPT_NAME to get the name of the department."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME \nFROM DEPARTMENT \nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE \nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE \nWHERE COURSE.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"1\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n    \"2\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\"\n}\n"}
{"sample_id": "train.3417", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "The data is sourced from the 'employees' table.", "The condition specifies that the first name should not contain the letter 'M', which can be checked using the NOT LIKE operator with a wildcard."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%';", "hint": "\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: FULL_NAME (concatenation of FIRST_NAME and LAST_NAME), HIRE_DATE, SALARY, and DEPARTMENT_ID.", "The data is sourced from the 'employees' table.", "To filter employees without the letter 'M' in their first name, use the NOT LIKE operator with a wildcard pattern '%M%'.", "Construct the SQL SELECT statement to retrieve the specified fields from the employees table with the appropriate WHERE clause."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%';", "hint": "\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the columns needed: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter employees whose first name does not contain the letter 'M'. This can be done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by DEPARTMENT_ID.", "Construct the SQL SELECT statement with the identified columns, filtering condition, and ordering."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs.\"\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant tables: 'employees' for salary and 'jobs' for job titles.", "Join the 'employees' table with the 'jobs' table on the JOB_ID to access job titles corresponding to employees' salaries.", "Filter the results to include only those employees whose salary is greater than 9000.", "Select distinct job titles to avoid duplicates in the results."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT DISTINCT jobs.JOB_TITLE \nFROM employees \nJOIN jobs ON employees.JOB_ID = jobs.JOB_ID \nWHERE employees.SALARY > 9000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n    \"1\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\"\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The question asks for job titles and salary ranges, which are found in the 'jobs' table.", "Select the required columns: We need to select 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY' from the 'jobs' table.", "Apply the filter condition: The question specifies that we need jobs with a maximum salary between 12000 and 18000, so we will use a WHERE clause to filter 'MAX_SALARY' accordingly.", "Construct the SQL query: Combine the selected columns, the table name, and the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY \nFROM jobs \nWHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n    \"1\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\"\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["Identify the relevant tables: employees and job_history.", "We need to retrieve employee IDs and the final dates of employment, which are found in the employees and job_history tables respectively.", "Join the employees table with the job_history table on the EMPLOYEE_ID column to link employees with their job history.", "To get the final date of employment for each employee, we need to filter the job_history records to only include the maximum END_DATE for each employee.", "Use a subquery to find the maximum END_DATE for each employee in the job_history table.", "Select the EMPLOYEE_ID from the employees table and the corresponding END_DATE from the job_history table."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT e.EMPLOYEE_ID, jh.END_DATE\nFROM employees e\nJOIN job_history jh ON e.EMPLOYEE_ID = jh.EMPLOYEE_ID\nWHERE jh.END_DATE = (SELECT MAX(END_DATE) FROM job_history WHERE EMPLOYEE_ID = e.EMPLOYEE_ID);", "hint": "\n"}
{"sample_id": "train.3451", "db_id": "hr_1", "question": "Find the ids of the departments where any manager is managing 4 or more employees.", "rationale": ["We need to find departments where any manager is managing 4 or more employees.", "To do this, we will first identify managers who have 4 or more employees reporting to them. This can be done by grouping the employees by their manager ID and counting the number of employees for each manager.", "We will use a subquery to get the manager IDs that meet the criteria of having 4 or more employees.", "Next, we will join the 'departments' table with the 'employees' table to get the department IDs where the manager ID matches those identified in the subquery.", "Finally, we will select the department IDs from the resulting joined table."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nWHERE d.MANAGER_ID IN (\n    SELECT e2.MANAGER_ID\n    FROM employees e2\n    GROUP BY e2.MANAGER_ID\n    HAVING COUNT(e2.EMPLOYEE_ID) >= 4\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that each employee-manager pair is unique.\",\n    \"1\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs.\",\n    \"2\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3457", "db_id": "hr_1", "question": "display job ID for those jobs that were done by two or more for more than 300 days.", "rationale": ["We need to display the job ID for jobs that were done by two or more employees for more than 300 days.", "To achieve this, we will use the 'job_history' table, which contains records of employees' job durations.", "We will group the results by 'JOB_ID' to aggregate the data for each job.", "We will use the HAVING clause to filter the groups:", "1. We need to ensure that the count of 'EMPLOYEE_ID' for each job is 2 or more, which indicates that two or more employees have held that job.", "2. We will calculate the total duration of each job by summing the difference between 'END_DATE' and 'START_DATE' using the JULIANDAY function, and filter for those that exceed 300 days."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "pred_sql": "SELECT JOB_ID\nFROM job_history\nGROUP BY JOB_ID\nHAVING COUNT(EMPLOYEE_ID) >= 2 AND SUM(JULIANDAY(END_DATE) - JULIANDAY(START_DATE)) > 300;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n    \"1\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\"\n}\n"}
{"sample_id": "train.3458", "db_id": "hr_1", "question": "What are the job ids for jobs done more than once for a period of more than 300 days?", "rationale": ["Identify the relevant table: The 'job_history' table contains records of jobs held by employees, including start and end dates.", "Group by JOB_ID: To find jobs done more than once, we need to group the records by JOB_ID.", "Count occurrences: Use COUNT(*) to count how many times each JOB_ID appears in the job history.", "Calculate the duration: Use the difference between END_DATE and START_DATE to calculate the total duration for each job.", "Filter results: Use HAVING to filter groups where the count of jobs is greater than 1 and the total duration exceeds 300 days."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "pred_sql": "SELECT JOB_ID\nFROM job_history\nGROUP BY JOB_ID\nHAVING COUNT(*) > 1 AND SUM(JULIANDAY(END_DATE) - JULIANDAY(START_DATE)) > 300;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n    \"1\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n    \"2\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs.\"\n}\n"}
{"sample_id": "train.3463", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["Identify the tables needed: 'departments' for department names and 'employees' for counting employees.", "Use a LEFT JOIN to connect 'departments' and 'employees' on the DEPARTMENT_ID column, ensuring all departments are included even if they have no employees.", "Select the department name from the 'departments' table and count the number of employees from the 'employees' table using COUNT function.", "Group the results by department name to get the count of employees per department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3470", "db_id": "hr_1", "question": "Provide the full names of employees earning more than the employee with id 163.", "rationale": ["Identify the requirement: We need to find the full names of employees earning more than the employee with ID 163.", "Determine the necessary tables: The 'employees' table contains the relevant information about employees and their salaries.", "Construct a subquery to find the salary of the employee with ID 163: This will be used to compare against other employees' salaries.", "Use a SELECT statement to retrieve the first and last names of employees whose salary is greater than the salary obtained from the subquery."], "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = 163 )", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME, LAST_NAME \nFROM employees \nWHERE SALARY > (SELECT SALARY FROM employees WHERE EMPLOYEE_ID = '163');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n    \"1\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\"\n}\n"}
{"sample_id": "train.3471", "db_id": "hr_1", "question": "return the smallest salary for every departments.", "rationale": ["We need to return the smallest salary for every department.", "To achieve this, we will need to join the 'departments' table with the 'employees' table since the salary information is stored in the 'employees' table.", "We will select the department name from the 'departments' table and the minimum salary from the 'employees' table.", "The MIN() function will be used to find the smallest salary for each department.", "We will group the results by the department name to ensure we get the minimum salary for each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_NAME, MIN(e.SALARY) AS MIN_SALARY\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3472", "db_id": "hr_1", "question": "What is the minimum salary in each department?", "rationale": ["We need to find the minimum salary in each department, which requires us to aggregate salary data by department.", "To achieve this, we will join the 'employees' table with the 'departments' table using the DEPARTMENT_ID as the linking key.", "We will select the department name from the 'departments' table and the minimum salary from the 'employees' table.", "The MIN() function will be used to calculate the minimum salary for each department.", "Finally, we will group the results by department name to ensure we get the minimum salary for each distinct department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_NAME, MIN(e.SALARY) AS MIN_SALARY\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n    \"1\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n    \"2\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\"\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the requirement: We need to find all information regarding employees who are managers.", "Understand the relationship: An employee is considered a manager if their EMPLOYEE_ID matches the MANAGER_ID in the departments table.", "Construct the SQL query: We will select all columns from the employees table and join it with the departments table on the condition that the employee's ID matches the manager ID.", "Use the JOIN clause to combine the employees and departments tables based on the manager relationship."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT e.*\nFROM employees e\nJOIN departments d ON e.EMPLOYEE_ID = d.MANAGER_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that each employee-manager pair is unique.\",\n    \"1\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs.\",\n    \"2\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\"\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find distinct department IDs where a manager oversees 4 or more employees.", "To do this, we first need to identify managers and count how many employees report to each manager.", "We can achieve this by grouping the employees by their MANAGER_ID and using the COUNT function to count the number of EMPLOYEE_IDs for each manager.", "We will use the HAVING clause to filter out managers who have less than 4 employees.", "Next, we will select the DEPARTMENT_IDs from the employees table where the MANAGER_ID is in the list of managers identified in the previous step.", "Finally, we will ensure that the DEPARTMENT_IDs are distinct by using the DISTINCT keyword."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DEPARTMENT_ID\nFROM employees\nWHERE MANAGER_ID IN (\n    SELECT MANAGER_ID\n    FROM employees\n    GROUP BY MANAGER_ID\n    HAVING COUNT(EMPLOYEE_ID) >= 4\n) \nGROUP BY DEPARTMENT_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that each employee-manager pair is unique.\",\n    \"1\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs.\",\n    \"2\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3497", "db_id": "hr_1", "question": "Find the ids of the employees who does not work in those departments where some employees works whose manager id within the range 100 and 200.", "rationale": ["Identify the main requirement: Find employee IDs who do not work in departments where some employees have a manager ID between 100 and 200.", "To achieve this, we need to first identify the departments that have employees with manager IDs in the specified range.", "We can create a subquery that selects distinct DEPARTMENT_IDs from the employees table where the MANAGER_ID is between 100 and 200.", "The main query will then select EMPLOYEE_IDs from the employees table where the DEPARTMENT_ID is not in the list of departments identified in the subquery."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "pred_sql": "SELECT EMPLOYEE_ID \nFROM employees \nWHERE DEPARTMENT_ID NOT IN (\n    SELECT DISTINCT DEPARTMENT_ID \n    FROM employees \n    WHERE MANAGER_ID BETWEEN '100' AND '200'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs.\",\n    \"1\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that each employee-manager pair is unique.\",\n    \"2\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the requirement: We need the full names and hire dates of employees who work in the same department as an employee named Clara, excluding Clara herself.", "To get the full names, we will concatenate the FIRST_NAME and LAST_NAME of the employees.", "We need to join the employees table with itself to find employees in the same department as Clara. This is a self-join where one instance of the table represents Clara and the other represents the other employees.", "The join condition will be that the DEPARTMENT_ID of both instances of the employees table must match.", "We will filter the results to only include those employees whose FIRST_NAME is not 'Clara'.", "Finally, we will select the concatenated full name and hire date from the resulting set."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE\nFROM employees e\nJOIN employees c ON e.DEPARTMENT_ID = c.DEPARTMENT_ID\nWHERE c.FIRST_NAME = 'Clara' AND e.FIRST_NAME != 'Clara';", "hint": "\n"}
{"sample_id": "train.3506", "db_id": "hr_1", "question": "What are the ids, full names, and salaries for employees making more than average and who work in a department with employees who have the letter J in their first name?", "rationale": ["Identify the required fields: employee IDs, full names (first and last), and salaries.", "To get the full name, concatenate the first and last names using '||' operator.", "Filter employees whose salary is greater than the average salary. This requires a subquery to calculate the average salary from the employees table.", "Additionally, filter employees based on their department. We need to find departments that have employees with 'J' in their first name. This requires another subquery that selects distinct department IDs from the employees table where the first name contains 'J'.", "Combine these conditions in the main query to get the desired results."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%J%')", "source_tables": ["employees"], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY > (SELECT AVG(SALARY) FROM employees) \nAND e.DEPARTMENT_ID IN (\n    SELECT DISTINCT d.DEPARTMENT_ID \n    FROM employees e2 \n    JOIN departments d ON e2.DEPARTMENT_ID = d.DEPARTMENT_ID \n    WHERE e2.FIRST_NAME LIKE '%J%'\n);", "hint": "\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the main requirement: We need to display the employee number (EMPLOYEE_ID) and job id (JOB_ID) for employees whose salary is less than any salary of those employees whose job title is MK_MAN.", "To achieve this, we will use a subquery to find the minimum salary of employees with the job title MK_MAN.", "The subquery will select the minimum salary from the employees table, joining it with the jobs table to filter by job title.", "The main query will select EMPLOYEE_ID and JOB_ID from the employees table where the salary is less than the result of the subquery."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID FROM employees WHERE SALARY < (SELECT MIN(SALARY) FROM employees JOIN jobs ON employees.JOB_ID = jobs.JOB_ID WHERE JOB_TITLE = 'MK_MAN');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\",\n    \"1\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary to filter the results.\",\n    \"2\": \"This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs.\"\n}\n"}
{"sample_id": "train.3510", "db_id": "hr_1", "question": "What are the employee ids, full names, and job ids for employees who make more than the highest earning employee with title PU_MAN?", "rationale": ["Identify the columns needed: employee ids, full names, and job ids.", "To get the full names, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter employees based on their salary being greater than a certain value.", "Determine the value to compare against: the highest salary of employees with the job title 'PU_MAN'.", "Use a subquery to find the maximum salary of employees with the job title 'PU_MAN'.", "Combine the main query with the subquery to filter employees accordingly."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, JOB_ID \nFROM employees \nWHERE SALARY > (SELECT MAX(SALARY) \n                  FROM employees \n                  WHERE JOB_ID = (SELECT JOB_ID \n                                  FROM jobs \n                                  WHERE JOB_TITLE = 'PU_MAN'));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\"\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To do this, we will join the 'employees' table with the 'departments' table on the 'DEPARTMENT_ID'.", "We will use the SUM function to calculate the total salaries for each department.", "We will group the results by 'DEPARTMENT_ID' to aggregate the salaries for each department.", "To filter the departments that have more than 2 employees, we will use the HAVING clause with COUNT to count the number of employees in each department."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, SUM(e.SALARY) AS total_salaries\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_ID\nHAVING COUNT(e.EMPLOYEE_ID) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n    \"1\": \"This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that each employee-manager pair is unique.\"\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To achieve this, we will select the DEPARTMENT_ID, concatenate FIRST_NAME and LAST_NAME to create FULL_NAME, and select the SALARY from the employees table.", "To find the highest salary in each department, we will use a subquery that selects the MAX(SALARY) from the employees table, filtering by the DEPARTMENT_ID of the outer query.", "The outer query will return the records where the employee's salary matches the maximum salary found in the subquery for their respective department."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                  FROM employees \n                  WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3516", "db_id": "hr_1", "question": "What are the department ids, full names, and salaries for employees who make the most in their departments?", "rationale": ["We need to find the department ids, full names, and salaries of employees who make the most in their departments.", "To do this, we will select the DEPARTMENT_ID from the employees table.", "We will also concatenate the FIRST_NAME and LAST_NAME to create a FULL_NAME for each employee.", "Next, we need to filter the employees to only include those who have the maximum salary in their respective departments.", "To find the maximum salary for each department, we can use a subquery that selects the MAX(SALARY) from the employees table, grouped by DEPARTMENT_ID.", "The main query will then compare each employee's salary to the maximum salary for their department using a WHERE clause."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                  FROM employees \n                  WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the required information: full names and cities of employees with 'Z' in their first names.", "To get the full names, concatenate FIRST_NAME and LAST_NAME from the employees table.", "To get the city, we need to join the employees table with the departments table using DEPARTMENT_ID, and then join the departments table with the locations table using LOCATION_ID.", "Use a WHERE clause to filter employees whose FIRST_NAME contains the letter 'Z' using the LIKE operator."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, CITY \nFROM employees \nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID \nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID \nWHERE FIRST_NAME LIKE '%Z%';", "hint": "\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed: employees for employee details and countries for country names.", "We need to join the employees table with the countries table to get the country name where the employee is currently working.", "The employee's full name can be constructed by concatenating the FIRST_NAME and LAST_NAME fields from the employees table.", "To find the country, we need to link the employees to their respective departments and then to countries, which is done through the DEPARTMENT_ID.", "The query should filter for a specific employee using their EMPLOYEE_ID."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, c.COUNTRY_NAME \nFROM employees e \nJOIN countries c ON e.DEPARTMENT_ID = (SELECT d.DEPARTMENT_ID FROM departments d WHERE d.MANAGER_ID = e.MANAGER_ID) \nWHERE e.EMPLOYEE_ID = ?;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\"\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["Identify the tables needed: 'departments' for department names and 'employees' for employee counts.", "Use a LEFT JOIN to connect 'departments' and 'employees' on the DEPARTMENT_ID column, ensuring all departments are included even if they have no employees.", "Select the department name from the 'departments' table and count the number of employees from the 'employees' table using COUNT function.", "Group the results by department name to get the count of employees per department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["Identify the tables involved: 'departments' for department names and 'employees' for employee counts.", "Use a LEFT JOIN to combine 'departments' and 'employees' on the DEPARTMENT_ID to ensure all departments are included, even those with no employees.", "Select the department name from the 'departments' table and count the number of employees from the 'employees' table using COUNT function.", "Group the results by department name to get the count of employees per department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS EMPLOYEE_COUNT\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "We need to join these tables to access the city information and employee details.", "Join employees with departments on DEPARTMENT_ID to get department information.", "Join departments with locations on LOCATION_ID to access city information.", "Join locations with countries on COUNTRY_ID to ensure we have the correct country context, although it's not strictly necessary for this query.", "Filter the results to only include employees who work in the city of London.", "Select the full name of the employees (concatenating FIRST_NAME and LAST_NAME) and their salaries."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a comprehensive view of employees' job history along with their current salary details. It combines data from the 'job_history' and 'employees' tables, allowing users to filter for employees whose salary meets or exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum salary value to filter the results.\"\n}\n"}
{"sample_id": "train.3641", "db_id": "baseball_1", "question": "In 2014, what are the id and rank of the team that has the largest average number of attendance?", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games, including attendance and team rankings.", "Filter for the year 2014: We need to focus on the records from the year 2014.", "Order by attendance: To find the team with the largest average attendance, we will order the results by the 'attendance' column in descending order.", "Select the team_id and rank: We need to retrieve the 'team_id' and 'rank' of the team with the highest attendance.", "Limit the results to 1: Since we only want the team with the largest average attendance, we will limit the results to 1."], "gold_sql": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  2014 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, rank FROM home_game WHERE year = 2014 ORDER BY attendance DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n    \"1\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\",\n    \"2\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\"\n}\n"}
{"sample_id": "train.3647", "db_id": "baseball_1", "question": "Which 3 players won the most player awards? List their full name and id.", "rationale": ["Identify the relevant tables: We need to find players and their awards, so we will use the 'player' and 'player_award' tables.", "Join the 'player' table with the 'player_award' table on 'player_id' to associate players with their awards.", "Count the number of awards each player has received using COUNT() function and group the results by 'player_id'.", "Order the results in descending order based on the count of awards to get the players with the most awards at the top.", "Limit the results to the top 3 players to meet the requirement of the query."], "gold_sql": "SELECT T1.name_first ,  T1.name_last ,  T1.player_id FROM player AS T1 JOIN player_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT 3;", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.player_id, p.name_first, p.name_last, COUNT(pa.award_id) AS total_awards\nFROM player p\nJOIN player_award pa ON p.player_id = pa.player_id\nGROUP BY p.player_id\nORDER BY total_awards DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\",\n    \"1\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\"\n}\n"}
{"sample_id": "train.3649", "db_id": "baseball_1", "question": "List three countries which are the origins of the least players.", "rationale": ["We need to find the countries with the least number of players.", "The relevant table for player information is the 'player' table, which contains the 'birth_country' and 'player_id' columns.", "We will group the results by 'birth_country' to count the number of players from each country.", "Using COUNT(player_id) will give us the total number of players from each country.", "We will order the results in ascending order based on the count of players to get the countries with the least players first.", "Finally, we will limit the results to 3 to get only the top three countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\",\n    \"1\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n    \"2\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\"\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["We need to find the countries with the least number of players.", "To do this, we will query the 'player' table which contains the 'birth_country' and 'player_id'.", "We will group the results by 'birth_country' to count the number of players from each country.", "Using COUNT(player_id) will give us the number of players from each country.", "We will order the results in ascending order based on the count of players to get the countries with the least players first.", "Finally, we will limit the results to 3 to get the top three countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\"\n}\n"}
{"sample_id": "train.3651", "db_id": "baseball_1", "question": "Find all the players' first name and last name who have empty death record.", "rationale": ["Identify the relevant table: The 'player' table contains the first and last names of players as well as their death records.", "Determine the condition for empty death records: A player has an empty death record if the 'death_year', 'death_month', and 'death_day' fields are all NULL.", "Construct the SQL query: Use a SELECT statement to retrieve 'name_first' and 'name_last' from the 'player' table where the death record fields are NULL."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE death_year = '';", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE death_year IS NULL AND death_month IS NULL AND death_day IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\"\n}\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["Identify the relevant tables: 'team' for team names and IDs, and 'salary' for salary information.", "Join the 'team' table with the 'salary' table on the 'team_id' to associate each team with its players' salaries.", "Use the MAX() function to find the highest salary for each team.", "Group the results by 'team_id' and 'name' to ensure each team is represented only once with its maximum salary."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT t.name, t.team_id, MAX(s.salary) AS max_salary\nFROM team AS t\nJOIN salary AS s ON t.team_id = s.team_id\nGROUP BY t.team_id, t.name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and identifiers of teams along with their highest recorded salary from the 'salary' table. The data is grouped by team identifiers to ensure that each team is represented only once with its maximum salary.\",\n    \"1\": \"This virtual table provides a list of team names and their corresponding team IDs from the 'team' table, along with the average salary of players from each team. The results are ordered by the average salary in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n    \"2\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\"\n}\n"}
{"sample_id": "train.3662", "db_id": "baseball_1", "question": "Which players won awards in both 1960 and 1961? Return their first names and last names.", "rationale": ["We need to find players who won awards in both 1960 and 1961.", "To do this, we will use the player_award table, which contains information about players and the awards they received, including the year.", "We will perform a self-join on the player_award table to find players who have entries for both years (1960 and 1961).", "We will also join the player table to get the first and last names of the players.", "Finally, we will select the first and last names of the players who meet the criteria."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.name_first, p.name_last\nFROM player_award pa1\nJOIN player_award pa2 ON pa1.player_id = pa2.player_id\nJOIN player p ON pa1.player_id = p.player_id\nWHERE pa1.year = 1960 AND pa2.year = 1961;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\",\n    \"1\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n    \"2\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\"\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) of the Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include the Boston Red Stockings and ensure that the wins are greater than zero.", "Select the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings' AND p.wins > 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n    \"1\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n    \"2\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\"\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) for the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include the Boston Red Stockings.", "Use the MAX function to get the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings'", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n    \"1\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n    \"2\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\"\n}\n"}
{"sample_id": "train.3669", "db_id": "baseball_1", "question": "What are the name and id of the team with the most victories in 2008 postseason?", "rationale": ["Identify the relevant tables: postseason for postseason results and team for team names and IDs.", "Join the postseason table with the team table on the winning team ID.", "Filter the results for the year 2008.", "Group the results by team ID to count the number of wins for each team.", "Order the results by the count of wins in descending order to find the team with the most victories.", "Limit the results to 1 to get only the top team."], "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"], "pred_sql": "SELECT team.name, team.team_id \nFROM postseason \nJOIN team ON postseason.team_id_winner = team.team_id \nWHERE postseason.year = 2008 \nGROUP BY team.team_id \nORDER BY COUNT(postseason.wins) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n    \"1\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n    \"2\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\"\n}\n"}
{"sample_id": "train.3673", "db_id": "baseball_1", "question": "What is the total number of postseason games that team Boston Red Stockings participated in?", "rationale": ["Identify the team of interest: Boston Red Stockings.", "Determine the relevant tables: postseason and team.", "Use the postseason table to sum the total games played by the team in postseason.", "Filter the postseason records by checking both winning and losing team IDs against the team ID of Boston Red Stockings from the team table."], "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"], "pred_sql": "SELECT SUM(games) AS total_postseason_games\nFROM postseason\nWHERE team_id_winner = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')\n   OR team_id_loser = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n    \"1\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n    \"2\": \"This virtual table counts the total number of postseason appearances for a specific team, including both wins and losses. It combines data from the 'postseason' table and the 'team' table, filtering by the team's name provided as a placeholder.\"\n}\n"}
{"sample_id": "train.3678", "db_id": "baseball_1", "question": "What is the total salary expenses of team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant table for salary data, which is the 'salary' table.", "Determine the specific team by querying the 'team' table for 'Boston Red Stockings' in the year 2010 to get the corresponding team_id.", "Use the team_id obtained to filter the salary records for that team in the year 2010.", "Sum the salary amounts for the filtered records to get the total salary expenses."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT SUM(salary) AS total_salary_expenses \nFROM salary \nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings' AND year = 2010) \nAND year = 2010;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n    \"1\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n    \"2\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\"\n}\n"}
{"sample_id": "train.3679", "db_id": "baseball_1", "question": "How many players were in the team Boston Red Stockings in 2000?", "rationale": ["Identify the relevant table: The 'appearances' table contains player information related to teams.", "Determine the criteria: We need to find players who were part of the 'Boston Red Stockings' in the year 2000.", "Use a subquery to find the team_id for 'Boston Red Stockings' in 2000 from the 'team' table.", "Count the distinct player_id from the 'appearances' table where the team_id matches the result from the subquery."], "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"], "pred_sql": "SELECT COUNT(DISTINCT player_id) AS player_count \nFROM appearances \nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings' AND year = 2000)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n    \"1\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n    \"2\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\"\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant table for salary information, which is the 'salary' table.", "Filter the records to only include those from the year 2001.", "Order the results by the salary in descending order to get the highest salaries.", "Limit the results to the top 3 entries to get the three highest salaries."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and identifiers of teams along with their highest recorded salary from the 'salary' table. The data is grouped by team identifiers to ensure that each team is represented only once with its maximum salary.\",\n    \"1\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n    \"2\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\"\n}\n"}
{"sample_id": "train.3684", "db_id": "baseball_1", "question": "List all the salary values players received in 2010 and 2001.", "rationale": ["Identify the relevant table for salary data, which is the 'salary' table.", "Determine the columns needed: 'player_id' and 'salary'.", "Specify the years of interest: 2010 and 2001.", "Use the IN clause to filter the results for the specified years."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year IN (2010, 2001);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\",\n    \"1\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n    \"2\": \"This virtual table provides a list of team names and their corresponding team IDs from the 'team' table, along with the average salary of players from each team. The results are ordered by the average salary in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "To do this, we will query the 'hall_of_fame' table, which contains the 'yearid' for each induction and the 'player_id' for each player inducted.", "We will group the results by 'yearid' to count the number of inductees for each year using COUNT(player_id).", "Next, we will order the results in ascending order based on the count of inductees to find the year with the least number of inductees.", "Finally, we will limit the results to 1 to get only the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(player_id) AS num_inductees\nFROM hall_of_fame\nGROUP BY yearid\nORDER BY num_inductees ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\",\n    \"1\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n    \"2\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\"\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "The 'hall_of_fame' table contains the relevant data, specifically the 'yearid' and 'inducted' columns.", "We will count the number of players inducted (where 'inducted' is 'Y') for each year using COUNT(*) and group the results by 'yearid'.", "To find the year with the least inductees, we will order the results in ascending order based on the count and limit the results to 1 to get the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) AS num_inducted\nFROM hall_of_fame\nWHERE inducted = 'Y'\nGROUP BY yearid\nORDER BY num_inducted ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\",\n    \"1\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n    \"2\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\"\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: 'home_game' for games played and 'park' for park names.", "Filter the 'home_game' table for the year 1907.", "Join the 'home_game' table with the 'park' table to find the team_id associated with 'Columbia Park'.", "Sum the total number of games played in 'Columbia Park' for the year 1907."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nWHERE year = 1907 AND team_id IN (\n    SELECT team_id\n    FROM park\n    WHERE park_name = 'Columbia Park'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by the total attendance of those games. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n    \"1\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n    \"2\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\"\n}\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: 'home_game' for home games and 'park' for park details.", "Join the 'home_game' table with the 'park' table on the park_id to access park names.", "Filter the results to only include games played in 'Columbia Park' in the year 1907.", "Count the total number of games that match these criteria."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT COUNT(*) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.park_name = 'Columbia Park' AND home_game.year = 1907;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by the total attendance of those games. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n    \"1\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\",\n    \"2\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\"\n}\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant tables: home_game (for games played) and park (for city information).", "Join the home_game table with the park table on the park_id to access city information.", "Filter the results to only include games played in Atlanta in the year 2000.", "Use the SUM function to calculate the total number of games played in that city and year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.city = 'Atlanta' AND home_game.year = 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n    \"1\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by the total attendance of those games. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n    \"2\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\"\n}\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: 'home_game' for the games played and 'park' for the location details.", "Join the 'home_game' table with the 'park' table on the park_id to access the city information.", "Filter the results to only include games played in Atlanta in the year 2000.", "Use the SUM function to calculate the total number of games played in that city and year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.city = 'Atlanta' AND home_game.year = 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n    \"1\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by the total attendance of those games. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n    \"2\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\"\n}\n"}
{"sample_id": "train.3697", "db_id": "baseball_1", "question": "List players' first name and last name who received salary from team Washington Nationals in both 2005 and 2007.", "rationale": ["Identify the relevant tables: player, salary, and team.", "Join the player table with the salary table on player_id to get salary information for each player.", "Join the salary table with the team table on team_id to filter by team name.", "Filter the results to include only those players who received a salary from the 'Washington Nationals' in the years 2005 and 2007.", "Use GROUP BY to group the results by player_id to ensure we get unique players.", "Use HAVING COUNT(DISTINCT s.year) = 2 to ensure that only players who received salaries in both years are included."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT p.name_first, p.name_last \nFROM player p \nJOIN salary s ON p.player_id = s.player_id \nJOIN team t ON s.team_id = t.team_id \nWHERE t.name = 'Washington Nationals' \nAND s.year IN (2005, 2007) \nGROUP BY p.player_id \nHAVING COUNT(DISTINCT s.year) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies players who received awards in two specific years. The placeholders represent the years for which the awards are being queried.\",\n    \"1\": \"This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.\",\n    \"2\": \"This virtual table provides a list of team names and their corresponding team IDs from the 'team' table, along with the average salary of players from each team. The results are ordered by the average salary in ascending order, and the number of results returned is limited by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.3699", "db_id": "baseball_1", "question": "How many home games did the team Boston Red Stockings play from 1990 to 2000 in total?", "rationale": ["Identify the relevant table for home games, which is 'home_game'.", "Determine the columns needed: 'games' for total home games and 'year' for filtering the years 1990 to 2000.", "Use a subquery to find the 'team_id' for 'Boston Red Stockings' from the 'team' table.", "Filter the results in the 'home_game' table by the 'team_id' and the specified year range.", "Sum the 'games' column to get the total number of home games played by the team in the specified years."], "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT SUM(games) AS total_home_games\nFROM home_game\nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')\nAND year BETWEEN 1990 AND 2000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n    \"1\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n    \"2\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\"\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant table: home_game, which contains information about home games played by teams.", "Focus on the year 1980 to filter the results.", "Select the team_id and the number of games played (games) for that year.", "Order the results by the number of games in ascending order to find the team with the least number of home games.", "Limit the results to 1 to get only the team with the least number of home games."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, games FROM home_game WHERE year = 1980 ORDER BY games ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n    \"1\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n    \"2\": \"This virtual table counts the total number of postseason losses for a specific team in a given year. The placeholders represent the team's name and the year of interest.\"\n}\n"}
{"sample_id": "train.3710", "db_id": "baseball_1", "question": "Which park did the most people attend in 2008?", "rationale": ["Identify the relevant tables: home_game for attendance data and park for park names.", "Join the home_game table with the park table on the park_id to get park names along with attendance.", "Filter the results to only include records from the year 2008 using a WHERE clause.", "Order the results by attendance in descending order to find the park with the highest attendance.", "Limit the results to 1 to get only the park with the most attendance."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT park.park_name, home_game.attendance \nFROM home_game \nJOIN park ON home_game.park_id = park.park_id \nWHERE home_game.year = 2008 \nORDER BY home_game.attendance DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by the total attendance of those games. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n    \"1\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n    \"2\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\"\n}\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["We need to find the department with the largest number of employees.", "The relevant tables are 'Department' and 'Physician'.", "We will join the 'Department' table with the 'Physician' table on the condition that the head of the department is a physician.", "We will count the number of employees (physicians) in each department using COUNT(p.EmployeeID).", "We will group the results by department ID to get the count for each department.", "To find the department with the largest number of employees, we will order the results in descending order based on the count of employees.", "Finally, we will limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT d.Name, COUNT(p.EmployeeID) AS EmployeeCount\nFROM Department d\nLEFT JOIN Physician p ON d.Head = p.EmployeeID\nGROUP BY d.DepartmentID\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results based on the count of departments, with a limit on the number of results returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["Identify the relevant tables: Department and Affiliated_With.", "We need to count the number of physicians affiliated with each department, so we will join the Department table with the Affiliated_With table on the DepartmentID.", "Use COUNT() to count the number of physicians in each department.", "Group the results by department name to get the count per department.", "Order the results in descending order based on the count of employees (physicians) to find the department with the most employees.", "Limit the results to 1 to get only the department with the highest count."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Affiliated_With.Physician) AS EmployeeCount\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to find the head of the department with the least number of employees, so we will join the Department table with the Physician table on the Head column.", "We will group the results by DepartmentID to count the number of employees in each department.", "We will order the results by the count of employees in ascending order to get the department with the least number of employees.", "Finally, we will limit the results to 1 to get only the head of the department with the least number of employees."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Department \nJOIN Physician ON Department.Head = Physician.EmployeeID \nGROUP BY Department.DepartmentID \nORDER BY COUNT(Physician.EmployeeID) ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results based on the count of departments, with a limit on the number of results returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["Identify the relevant tables: Appointment and Patient.", "We need to retrieve the names of patients who made appointments, so we will select the 'Name' column from the Patient table.", "To link the Appointment table with the Patient table, we will use the foreign key relationship where Appointment.Patient corresponds to Patient.SSN.", "Construct the SQL query using a JOIN to combine the Appointment and Patient tables based on the matching identifiers."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT Patient.Name\nFROM Appointment\nJOIN Patient ON Appointment.Patient = Patient.SSN;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n    \"1\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n    \"2\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\"\n}\n"}
{"sample_id": "train.3905", "db_id": "hospital_1", "question": "List the names of patients who have made appointments.", "rationale": ["We need to list the names of patients who have made appointments.", "The relevant table for appointments is the 'Appointment' table, which contains a reference to the patient through the 'Patient' column.", "The 'Patient' table contains the names of the patients, and we can join it with the 'Appointment' table using the 'Patient' identifier (SSN).", "To avoid duplicate names, we will use the DISTINCT keyword in our SELECT statement."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT Patient.Name\nFROM Appointment\nJOIN Patient ON Appointment.Patient = Patient.SSN;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n    \"1\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n    \"2\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\"\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["Identify the tables involved: Physician, Department, and Affiliated_With.", "We need to join these tables to get the names of physicians and their affiliated departments.", "The Physician table contains the names of the physicians, and the Department table contains the names of the departments.", "The Affiliated_With table links physicians to their departments and indicates whether the affiliation is primary.", "We will perform an INNER JOIN between Physician and Affiliated_With on EmployeeID and Physician, respectively.", "Next, we will join the Department table on the DepartmentID from the Affiliated_With table.", "Finally, we will filter the results to include only those records where the affiliation is marked as primary."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name, Department.Name \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nJOIN Department ON Affiliated_With.Department = Department.DepartmentID \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n    \"1\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n    \"2\": \"This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results based on the count of departments, with a limit on the number of results returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.3915", "db_id": "hospital_1", "question": "What are the name and primarily affiliated department name of each physician?", "rationale": ["Identify the relevant tables: Physician, Department, and Affiliated_With.", "We need to retrieve the names of physicians and their primarily affiliated departments.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns to link physicians with their affiliations.", "Join the resulting table with the Department table on the Department column to get the department names.", "Filter the results to include only those affiliations that are marked as primary by using a WHERE clause."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name, Department.Name \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nJOIN Department ON Affiliated_With.Department = Department.DepartmentID \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n    \"1\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n    \"2\": \"This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results based on the count of departments, with a limit on the number of results returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.3929", "db_id": "hospital_1", "question": "Return the name of each physician and the number of patients he or she treats.", "rationale": ["We need to return the names of physicians and the number of patients they treat.", "The relevant tables are 'Physician' and 'Patient'.", "The 'Patient' table has a column 'PCP' which indicates the primary care physician for each patient.", "We will perform a LEFT JOIN between 'Physician' and 'Patient' on the condition that 'Physician.EmployeeID' matches 'Patient.PCP'.", "We will use COUNT to count the number of patients for each physician.", "Finally, we will group the results by 'Physician.EmployeeID' to aggregate the patient counts."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name, COUNT(Patient.SSN) AS NumberOfPatients\nFROM Physician\nLEFT JOIN Patient ON Physician.EmployeeID = Patient.PCP\nGROUP BY Physician.EmployeeID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n    \"1\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n    \"2\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\"\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["We need to find physicians who are in charge of more than one patient, which means we need to count the number of patients for each physician.", "The 'Patient' table has a column 'PCP' that indicates the primary care physician for each patient, which we can use to join with the 'Physician' table.", "We will join the 'Physician' table with the 'Patient' table on the condition that the physician's EmployeeID matches the patient's PCP.", "After joining, we will group the results by the physician's EmployeeID to count the number of patients associated with each physician.", "Finally, we will use the HAVING clause to filter the results to only include physicians who have more than one patient (i.e., COUNT(Patient.SSN) > 1).", "We will select the names of these physicians in the final output."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Patient ON Physician.EmployeeID = Patient.PCP\nGROUP BY Physician.EmployeeID\nHAVING COUNT(Patient.SSN) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n    \"1\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n    \"2\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\"\n}\n"}
{"sample_id": "train.3931", "db_id": "hospital_1", "question": "Which physicians are in charge of more than one patient? Give me their names.", "rationale": ["We need to find physicians who are in charge of more than one patient, which means we need to count the number of patients for each physician.", "The 'Patient' table has a column 'PCP' that indicates the primary care physician for each patient, which we can use to join with the 'Physician' table.", "We will join the 'Physician' table with the 'Patient' table on the condition that the physician's EmployeeID matches the patient's PCP.", "After joining, we will group the results by the physician's EmployeeID to count the number of patients associated with each physician.", "Finally, we will use the HAVING clause to filter the results to only include physicians who have more than one patient (i.e., COUNT(Patient.SSN) > 1).", "We will select the names of these physicians from the 'Physician' table."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Patient ON Physician.EmployeeID = Patient.PCP\nGROUP BY Physician.EmployeeID\nHAVING COUNT(Patient.SSN) > 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n    \"1\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n    \"2\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\"\n}\n"}
{"sample_id": "train.3934", "db_id": "hospital_1", "question": "Find the number of rooms for different block code?", "rationale": ["Identify the relevant table: The Room table contains information about rooms and their block codes.", "Determine the required information: We need to count the number of rooms for each block code.", "Use the COUNT() function to count the rooms and GROUP BY BlockCode to get the count for each block code.", "Construct the SQL query to select the BlockCode and the count of RoomNumber, grouping by BlockCode."], "gold_sql": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode", "source_tables": ["block", "room"], "pred_sql": "SELECT BlockCode, COUNT(RoomNumber) AS NumberOfRooms\nFROM Room\nGROUP BY BlockCode;", "hint": "\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["We need to find the number of medications prescribed for each brand.", "To do this, we will join the 'Medication' table with the 'Prescribes' table on the medication code.", "We will select the brand from the 'Medication' table and count the number of prescriptions from the 'Prescribes' table.", "Finally, we will group the results by the brand to get the count for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT m.Brand, COUNT(p.Medication) AS MedicationCount\nFROM Medication m\nJOIN Prescribes p ON m.Code = p.Medication\nGROUP BY m.Brand;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n    \"1\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n    \"2\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\"\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: 'Prescribes' for prescriptions and 'Physician' for physician names.", "Join the 'Prescribes' table with the 'Physician' table on the physician's identifier (EmployeeID).", "Select the physician's name from the 'Physician' table.", "Order the results by the dosage (Dose) in descending order to get the highest dose first.", "Limit the results to 1 to get only the physician who prescribed the highest dose."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT p.Name\nFROM Prescribes pr\nJOIN Physician p ON pr.Physician = p.EmployeeID\nORDER BY pr.Dose DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n    \"1\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n    \"2\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\"\n}\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["We need to list the employee IDs of physicians along with their primary affiliation department IDs.", "To achieve this, we will join the 'Physician' table with the 'Affiliated_With' table on the common column 'EmployeeID' from 'Physician' and 'Physician' from 'Affiliated_With'.", "We will filter the results to include only those affiliations that are marked as primary by checking the 'PrimaryAffiliation' column in the 'Affiliated_With' table.", "Finally, we will select the 'EmployeeID' from the 'Physician' table and the 'Department' from the 'Affiliated_With' table."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n    \"1\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n    \"2\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\"\n}\n"}
{"sample_id": "train.3961", "db_id": "hospital_1", "question": "What are each physician's employee id and department id primarily affiliated.", "rationale": ["Identify the relevant tables: Physician and Affiliated_With.", "We need to select the EmployeeID from the Physician table and the Department from the Affiliated_With table.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician identifier respectively.", "Filter the results to include only those records where the PrimaryAffiliation is 'Yes' to get the primary affiliations."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department \nFROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n    \"1\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n    \"2\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\"\n}\n"}
{"sample_id": "train.3970", "db_id": "hospital_1", "question": "Find the three most expensive procedures.", "rationale": ["Identify the table that contains the procedure information, which is the 'Procedures' table.", "Select the 'Name' and 'Cost' columns from the 'Procedures' table.", "Order the results by 'Cost' in descending order to get the most expensive procedures first.", "Limit the results to 3 to find the three most expensive procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\"\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["Identify the table that contains the procedure information, which is the 'Procedures' table.", "We need to retrieve the names and costs of the procedures, so we will select the 'Name' and 'Cost' columns from the 'Procedures' table.", "To find the most costly procedures, we will order the results by the 'Cost' column in descending order.", "Finally, we limit the results to the top three entries using 'LIMIT 3'."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n    \"1\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n    \"2\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\"\n}\n"}
{"sample_id": "train.3973", "db_id": "hospital_1", "question": "Which physicians are trained in procedures that are more expensive than 5000?", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "Join the Physician table with the Trained_In table on the Physician's EmployeeID to find which physicians are trained in which procedures.", "Join the resulting table with the Procedures table on the Treatment code to access the cost of each procedure.", "Filter the results to include only those procedures where the cost is greater than 5000.", "Select the distinct names of the physicians who meet the criteria."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT DISTINCT Physician.Name \nFROM Physician \nJOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician \nJOIN Procedures ON Trained_In.Treatment = Procedures.Code \nWHERE Procedures.Cost > 5000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n    \"1\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n    \"2\": \"This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results based on the count of departments, with a limit on the number of results returned as specified by the placeholder.\"\n}\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "Join the Physician table with the Trained_In table to find which physicians are trained in which procedures.", "Join the resulting table with the Procedures table to access the cost of each procedure.", "Order the results by the cost of the procedures in descending order to find the most expensive one.", "Limit the results to 1 to get the physician trained in the most expensive procedure."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT p.Name\nFROM Physician p\nJOIN Trained_In t ON p.EmployeeID = t.Physician\nJOIN Procedures pr ON t.Treatment = pr.Code\nORDER BY pr.Cost DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n    \"1\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n    \"2\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\"\n}\n"}
{"sample_id": "train.3985", "db_id": "hospital_1", "question": "What procedures cost less than 5000 and have John Wen as a trained physician?", "rationale": ["Identify the relevant tables: Procedures, Trained_In, and Physician.", "We need to find procedures that cost less than 5000, so we will focus on the Procedures table and filter by the Cost column.", "We also need to check if John Wen is a trained physician for these procedures, which requires joining the Trained_In table with the Physician table.", "The join condition will be based on the Treatment code in Trained_In matching the Code in Procedures and the EmployeeID in Physician matching the Physician in Trained_In.", "Finally, we will apply the WHERE clause to filter for procedures with a cost less than 5000 and where the physician's name is 'John Wen'."], "gold_sql": "SELECT name FROM procedures WHERE cost  <  5000 INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT Procedures.Name \nFROM Procedures \nJOIN Trained_In ON Procedures.Code = Trained_In.Treatment \nJOIN Physician ON Trained_In.Physician = Physician.EmployeeID \nWHERE Procedures.Cost < 5000 AND Physician.Name = 'John Wen';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.\",\n    \"1\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\",\n    \"2\": \"This virtual table describes the names of physicians who are conducting appointments. The query joins the 'Appointment' table with the 'Physician' table based on the physician's unique identifier, allowing for the retrieval of physician names associated with each appointment.\"\n}\n"}
{"sample_id": "train.4321", "db_id": "tracking_grants_for_research", "question": "What are the different grant amounts for documents sent before '1986-08-26 20:49:27' and after the grant ended on '1989-03-16 18:27:16'?", "rationale": ["Identify the relevant tables: Grants and Documents are needed to access grant amounts and document sent dates.", "Join the Grants table with the Documents table on the grant_id to link documents to their respective grants.", "Filter the results to include only those documents sent before '1986-08-26 20:49:27'.", "Also, filter to ensure that the grants have ended before '1989-03-16 18:27:16'.", "Select distinct grant amounts to avoid duplicates in the results."], "gold_sql": "SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  '1986-08-26 20:49:27' INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  '1989-03-16 18:27:16'", "source_tables": ["grants", "documents"], "pred_sql": "SELECT DISTINCT Grants.grant_amount \nFROM Grants \nJOIN Documents ON Grants.grant_id = Documents.grant_id \nWHERE Documents.sent_date < '1986-08-26 20:49:27' \nAND Grants.grant_end_date < '1989-03-16 18:27:16';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation IDs and their corresponding details from the 'Organisations' table, which are associated with grants from the 'Grants' table. The results are grouped by organisation ID, and only those organisations that have a total grant amount exceeding a specified threshold are included, as indicated by the placeholder in the HAVING clause.\"\n}\n"}
{"sample_id": "train.4322", "db_id": "tracking_grants_for_research", "question": "List the project details of the project both producing patent and paper as outcomes.", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes are needed to get project details and their outcomes.", "Join the Projects table with Project_Outcomes on project_id to link projects with their outcomes.", "Join the Project_Outcomes table with Research_Outcomes on outcome_code to get the descriptions of the outcomes.", "Filter the results to include only those projects that have outcomes described as 'patent' and 'paper'.", "Use GROUP BY to group the results by project_id to ensure we are counting outcomes per project.", "Use HAVING to ensure that only projects with both outcomes (patent and paper) are included in the final result."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT p.project_details \nFROM Projects p \nJOIN Project_Outcomes po ON p.project_id = po.project_id \nJOIN Research_Outcomes ro ON po.outcome_code = ro.outcome_code \nWHERE ro.outcome_description IN ('patent', 'paper') \nGROUP BY p.project_id \nHAVING COUNT(DISTINCT ro.outcome_code) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the outcome descriptions of research outcomes associated with specific project outcomes. The join between the 'Research_Outcomes' and 'Project_Outcomes' tables is based on the matching outcome codes, allowing users to retrieve detailed descriptions of research outcomes linked to projects.\",\n    \"1\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n    \"2\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: Grants and Organisations are needed to find the total grant amount for organisations described as research.", "Determine the relationship between the tables: Grants has a foreign key to Organisations through organisation_id.", "Filter the organisations based on their type: We need to find organisations that are described as 'research'.", "Use a subquery to get the organisation_type corresponding to the description 'research' from the Organisation_Types table.", "Sum the grant amounts from the Grants table for the filtered organisations."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT SUM(Grants.grant_amount) AS total_grant_amount\nFROM Grants\nJOIN Organisations ON Grants.organisation_id = Organisations.organisation_id\nWHERE Organisations.organisation_type = (SELECT organisation_type FROM Organisation_Types WHERE organisation_type_description = 'research');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation IDs and their corresponding details from the 'Organisations' table, which are associated with grants from the 'Grants' table. The results are grouped by organisation ID, and only those organisations that have a total grant amount exceeding a specified threshold are included, as indicated by the placeholder in the HAVING clause.\",\n    \"1\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n    \"2\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.\"\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the role of staff members by joining the Project_Staff table with the Staff_Roles table to filter for those in a leader role.", "Determine which project has the most staff by grouping the Project_Staff table by project_id and counting the number of staff members for each project.", "Use a subquery to find the maximum count of staff members across all projects.", "Select the project_id that corresponds to the maximum staff count.", "Finally, retrieve the date_from and date_to for the staff members working on the project with the most staff who are in a leader role."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT ps.date_from, ps.date_to \nFROM Project_Staff ps \nJOIN Staff_Roles sr ON ps.role_code = sr.role_code \nWHERE sr.role_description = 'Leader' \nAND ps.project_id = (SELECT project_id \n                     FROM Project_Staff \n                     GROUP BY project_id \n                     HAVING COUNT(staff_id) = (SELECT MAX(staff_count) \n                                               FROM (SELECT COUNT(staff_id) AS staff_count \n                                                     FROM Project_Staff \n                                                     GROUP BY project_id))) \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Organisations, Research_Staff, and Organisation_Types.", "Join the Organisations table with the Research_Staff table to link organisations with their research staff.", "Join the result with the Organisation_Types table to get the type of each organisation.", "Group the results by organisation ID and organisation type to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most research staff.", "Limit the results to 1 to get only the organisation with the highest count."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_id, Organisation_Types.organisation_type \nFROM Organisations \nJOIN Research_Staff ON Organisations.organisation_id = Research_Staff.employer_organisation_id \nJOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type \nGROUP BY Organisations.organisation_id, Organisation_Types.organisation_type \nORDER BY COUNT(Research_Staff.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\",\n    \"2\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.\"\n}\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the relevant tables: Documents, Grants, and Organisations are needed to find the send dates of documents related to grants with a specific amount.", "Determine the relationship between the tables: Documents are linked to Grants through grant_id, and Grants are linked to Organisations through organisation_id.", "Filter the results based on the grant amount: We need to include only those grants where the grant amount is greater than 5000.", "Select the required field: We are interested in the send dates of the documents, which is found in the Documents table.", "Construct the SQL query using JOINs to connect the tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT Documents.sent_date \nFROM Documents \nJOIN Grants ON Documents.grant_id = Grants.grant_id \nJOIN Organisations ON Grants.organisation_id = Organisations.organisation_id \nWHERE Grants.grant_amount > 5000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation IDs and their corresponding details from the 'Organisations' table, which are associated with grants from the 'Grants' table. The results are grouped by organisation ID, and only those organisations that have a total grant amount exceeding a specified threshold are included, as indicated by the placeholder in the HAVING clause.\",\n    \"1\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n    \"2\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.\"\n}\n"}
{"sample_id": "train.4338", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects which did not hire any staff for a researcher role.", "rationale": ["We need to list project details of projects that did not hire any staff for a researcher role.", "To achieve this, we will select from the Projects table, specifically the project_id and project_details columns.", "We will perform a LEFT JOIN with the Project_Staff table on the project_id to find any associated staff members.", "We will filter the join condition to only include staff members with a role_code that corresponds to the researcher role, which we can find by querying the Staff_Roles table.", "Finally, we will add a WHERE clause to filter out projects that have no associated staff members for the researcher role, which is indicated by ps.staff_id being NULL."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT p.project_id, p.project_details \nFROM Projects p \nLEFT JOIN Project_Staff ps ON p.project_id = ps.project_id AND ps.role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Researcher') \nWHERE ps.staff_id IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\",\n    \"2\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.\"\n}\n"}
{"sample_id": "train.4339", "db_id": "tracking_grants_for_research", "question": "What are the details for all projects that did not hire any staff in a research role?", "rationale": ["Identify the relevant tables: Projects and Project_Staff are needed to get project details and staff information.", "Use a LEFT JOIN to include all projects and check for associated staff members in research roles.", "Filter the Project_Staff table to only include staff with a role code that corresponds to research roles by using a subquery on the Staff_Roles table.", "The WHERE clause checks for NULL in the staff_id of the Project_Staff table, indicating that no staff were hired for that project."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT p.project_id, p.project_details \nFROM Projects p \nLEFT JOIN Project_Staff ps ON p.project_id = ps.project_id AND ps.role_code IN (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%research%') \nWHERE ps.staff_id IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\",\n    \"2\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.\"\n}\n"}
{"sample_id": "train.4342", "db_id": "tracking_grants_for_research", "question": "When do all the researcher role staff start to work, and when do they stop working?", "rationale": ["Identify the relevant table: Project_Staff contains information about staff members, including their roles and the dates they started and stopped working.", "Determine the criteria for filtering: We need to find staff members whose roles are related to research. This can be done by checking the role_code against the Staff_Roles table where the role_description contains 'research'.", "Select the relevant columns: We need to retrieve the start date (date_from) and end date (date_to) for the filtered research staff members.", "Construct the SQL query: Use a SELECT statement to get date_from and date_to from Project_Staff, applying a WHERE clause to filter by role_code based on the subquery that selects role_codes from Staff_Roles."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to FROM Project_Staff WHERE role_code IN (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%research%')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.\",\n    \"2\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.\"\n}\n"}
{"sample_id": "train.4350", "db_id": "tracking_grants_for_research", "question": "How many staff does each project has? List the project id and the number in an ascending order.", "rationale": ["Identify the relevant tables: Projects and Project_Staff are needed to get project details and associated staff.", "Use a LEFT JOIN to connect Projects with Project_Staff on project_id to ensure all projects are included, even those without staff.", "Count the number of staff members for each project using COUNT(ps.staff_id).", "Group the results by project_id to get the count of staff per project.", "Order the results in ascending order based on the staff count."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT p.project_id, COUNT(ps.staff_id) AS staff_count\nFROM Projects p\nLEFT JOIN Project_Staff ps ON p.project_id = ps.project_id\nGROUP BY p.project_id\nORDER BY staff_count ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\",\n    \"2\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\"\n}\n"}
{"sample_id": "train.4351", "db_id": "tracking_grants_for_research", "question": "For each project id, how many staff does it have? List them in increasing order.", "rationale": ["Identify the relevant tables: We need to count the number of staff associated with each project, so we will use the Project_Staff table.", "Select the project_id and count the staff_id: We will select the project_id and use the COUNT function to count the number of staff members (staff_id) for each project.", "Group the results by project_id: To get the count of staff for each project, we will group the results by project_id.", "Order the results in increasing order: Finally, we will order the results by the count of staff in ascending order."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT project_id, COUNT(staff_id) AS staff_count \nFROM Project_Staff \nGROUP BY project_id \nORDER BY staff_count ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\",\n    \"2\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes are needed to get project details and their outcomes.", "Join the Projects table with the Project_Outcomes table on the project_id to associate projects with their outcomes.", "Group the results by project_id and project_details to aggregate the outcomes for each project.", "Count the number of outcomes for each project using COUNT(po.outcome_code).", "Order the results in descending order based on the count of outcomes to find the project with the most outcomes.", "Limit the results to 1 to get only the project with the highest number of outcomes."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT p.project_id, p.project_details\nFROM Projects p\nJOIN Project_Outcomes po ON p.project_id = po.project_id\nGROUP BY p.project_id, p.project_details\nORDER BY COUNT(po.outcome_code) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n    \"2\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\"\n}\n"}
{"sample_id": "train.4359", "db_id": "tracking_grants_for_research", "question": "What are the details of the project with no outcomes?", "rationale": ["Identify the main table of interest, which is 'Projects', as we want details of projects.", "Determine the condition for projects with no outcomes, which means we need to find projects that do not have any entries in the 'Project_Outcomes' table.", "Use a subquery to select all project_ids from the 'Project_Outcomes' table.", "Use the NOT IN clause to filter out those project_ids from the main 'Projects' table query."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT * FROM Projects WHERE project_id NOT IN (SELECT project_id FROM Project_Outcomes);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n    \"1\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table describes the outcome descriptions of research outcomes associated with specific project outcomes. The join between the 'Research_Outcomes' and 'Project_Outcomes' tables is based on the matching outcome codes, allowing users to retrieve detailed descriptions of research outcomes linked to projects.\"\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields to link organisations with their research staff.", "Group the results by organisation_id, organisation_type, and organisation_details to aggregate the number of research staff per organisation.", "Count the number of research staff for each organisation using COUNT(rs.staff_id).", "Order the results in descending order to get the organisation with the most research staff at the top.", "Limit the results to 1 to retrieve only the organisation that hired the most research staff."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id, o.organisation_type, o.organisation_details\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\",\n    \"2\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type and ordered by the number of research staff in each type. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisation types to retrieve.\"\n}\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff and Staff_Roles are needed to get staff IDs and their role descriptions.", "Join Project_Staff with Staff_Roles on role_code to get the role descriptions for each staff member.", "Use a subquery to count the number of projects each staff member is involved in, grouping by staff_id.", "Find the maximum number of projects any staff member is involved in using another subquery.", "Filter the results to only include staff members who are involved in the maximum number of projects.", "Group the results by staff_id to get the count of projects for each staff member and order by this count in descending order.", "Limit the results to get only the staff member with the most projects."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT ps.staff_id, sr.role_description\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nWHERE ps.project_id IN (\n    SELECT project_id\n    FROM Project_Staff\n    GROUP BY project_id\n    HAVING COUNT(DISTINCT staff_id) = (\n        SELECT MAX(project_count)\n        FROM (\n            SELECT COUNT(DISTINCT project_id) AS project_count\n            FROM Project_Staff\n            GROUP BY staff_id\n        )\n    )\n)\nGROUP BY ps.staff_id\nORDER BY COUNT(DISTINCT ps.project_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.4364", "db_id": "tracking_grants_for_research", "question": "Which document type is described with the prefix 'Initial'?", "rationale": ["Identify the table that contains document types, which is 'Document_Types'.", "Determine the relevant columns needed: 'document_type_code' and 'document_description'.", "The question asks for document types with descriptions that start with the prefix 'Initial'.", "Use the SQL 'LIKE' operator to filter results where 'document_description' starts with 'Initial'.", "Construct the SQL query to select the required columns from the 'Document_Types' table with the appropriate condition."], "gold_sql": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'", "source_tables": ["document_types"], "pred_sql": "SELECT document_type_code, document_description FROM Document_Types WHERE document_description LIKE 'Initial%';", "hint": "\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["Identify the relevant tables: Grants and Documents.", "We need to count the number of documents associated with each grant, so we will join the Grants table with the Documents table on the grant_id.", "Use COUNT() to count the number of documents for each grant.", "Group the results by grant_id to get the count for each grant.", "To find the document with the most associated documents, we will use a subquery to get the maximum document count for each grant and compare it in the HAVING clause."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT g.grant_id, COUNT(d.document_id) AS document_count, d.document_id \nFROM Grants g \nLEFT JOIN Documents d ON g.grant_id = d.grant_id \nGROUP BY g.grant_id \nHAVING document_count = (SELECT MAX(doc_count) \n                         FROM (SELECT COUNT(document_id) AS doc_count \n                               FROM Documents \n                               WHERE grant_id = g.grant_id \n                               GROUP BY grant_id));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisation IDs and their corresponding details from the 'Organisations' table, which are associated with grants from the 'Grants' table. The results are grouped by organisation ID, and only those organisations that have a total grant amount exceeding a specified threshold are included, as indicated by the placeholder in the HAVING clause.\",\n    \"1\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\"\n}\n"}
{"sample_id": "train.4374", "db_id": "tracking_grants_for_research", "question": "How many Patent outcomes are generated from all the projects?", "rationale": ["Identify the relevant tables: Project_Outcomes and Research_Outcomes are needed to find the patent outcomes associated with projects.", "Join the Project_Outcomes table with the Research_Outcomes table on the outcome_code to link project outcomes with their descriptions.", "Filter the results to only include outcomes that are related to patents by using a WHERE clause with a LIKE condition on the outcome_description.", "Count the number of rows that meet the criteria to get the total number of patent outcomes."], "gold_sql": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  'Patent'", "source_tables": ["project_outcomes"], "pred_sql": "SELECT COUNT(*) AS patent_outcome_count\nFROM Project_Outcomes po\nJOIN Research_Outcomes ro ON po.outcome_code = ro.outcome_code\nWHERE ro.outcome_description LIKE '%Patent%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n    \"1\": \"This virtual table describes the outcome descriptions of research outcomes associated with specific project outcomes. The join between the 'Research_Outcomes' and 'Project_Outcomes' tables is based on the matching outcome codes, allowing users to retrieve detailed descriptions of research outcomes linked to projects.\",\n    \"2\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\"\n}\n"}
{"sample_id": "train.4376", "db_id": "tracking_grants_for_research", "question": "How many project staff worked as leaders or started working before '1989-04-24 23:51:54'?", "rationale": ["Identify the relevant table: Project_Staff contains information about staff members associated with projects.", "Determine the criteria for counting staff: We need to count those who worked as leaders or started before a specific date.", "To find leaders, we will look for a specific role_code in the Staff_Roles table that corresponds to a leader's role.", "We will filter the Project_Staff table based on the role_code for leaders and the date_from column to check if they started before '1989-04-24 23:51:54'.", "Finally, we will use COUNT(*) to get the total number of staff members that meet these criteria."], "gold_sql": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'", "source_tables": ["project_staff"], "pred_sql": "SELECT COUNT(*) \nFROM Project_Staff \nWHERE role_code = (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%leader%') \nAND date_from < '1989-04-24 23:51:54';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\",\n    \"1\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\"\n}\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes are needed to get the project details and their associated outcomes.", "Join the Projects table with Project_Outcomes on project_id to link projects with their outcomes.", "Join the resulting table with Research_Outcomes on outcome_code to get the descriptions of the outcomes.", "Filter the results where the project details match the specified value 'sint'.", "Select the outcome_description from the final joined table."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT ro.outcome_description \nFROM Projects p \nJOIN Project_Outcomes po ON p.project_id = po.project_id \nJOIN Research_Outcomes ro ON po.outcome_code = ro.outcome_code \nWHERE p.project_details = 'sint';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n    \"1\": \"This virtual table describes the outcome descriptions of research outcomes associated with specific project outcomes. The join between the 'Research_Outcomes' and 'Project_Outcomes' tables is based on the matching outcome codes, allowing users to retrieve detailed descriptions of research outcomes linked to projects.\",\n    \"2\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\"\n}\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes are needed to get the project details and their associated outcomes.", "Join the Projects table with Project_Outcomes on project_id to link projects with their outcomes.", "Join the Project_Outcomes table with Research_Outcomes on outcome_code to get the descriptions of the outcomes.", "Filter the results by the project detail 'sint' to get the specific outcomes related to that project."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT ro.outcome_description \nFROM Projects p \nJOIN Project_Outcomes po ON p.project_id = po.project_id \nJOIN Research_Outcomes ro ON po.outcome_code = ro.outcome_code \nWHERE p.project_details = 'sint';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n    \"1\": \"This virtual table describes the outcome descriptions of research outcomes associated with specific project outcomes. The join between the 'Research_Outcomes' and 'Project_Outcomes' tables is based on the matching outcome codes, allowing users to retrieve detailed descriptions of research outcomes linked to projects.\",\n    \"2\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\"\n}\n"}
{"sample_id": "train.4385", "db_id": "tracking_grants_for_research", "question": "What are the details for the projects which were launched by the organization with the most projects?", "rationale": ["Identify the organization with the most projects by counting the number of projects associated with each organization.", "Use a subquery to group the Projects table by organisation_id and count the project_id for each organization.", "Order the results of the subquery by the project count in descending order and limit the results to 1 to get the organization with the most projects.", "Join the original Projects table with the result of the subquery on organisation_id to get the details of the projects launched by that organization."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT p.* \nFROM Projects p \nJOIN (\n    SELECT organisation_id, COUNT(project_id) AS project_count \n    FROM Projects \n    GROUP BY organisation_id \n    ORDER BY project_count DESC \n    LIMIT 1\n) AS org_max ON p.organisation_id = org_max.organisation_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\",\n    \"1\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\"\n}\n"}
{"sample_id": "train.4391", "db_id": "tracking_grants_for_research", "question": "For each project id, how many tasks are there?", "rationale": ["Identify the relevant tables: We need to count tasks associated with each project, so we will use the 'Tasks' table which contains 'task_id' and 'project_id'.", "Determine the aggregation needed: We need to count the number of tasks for each project, which requires a GROUP BY clause on 'project_id'.", "Construct the SQL query: The query will select 'project_id' and the count of 'task_id' as 'task_count', grouping the results by 'project_id'."], "gold_sql": "SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id", "source_tables": ["tasks", "projects"], "pred_sql": "SELECT project_id, COUNT(task_id) AS task_count\nFROM Tasks\nGROUP BY project_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of projects grouped by organisation, showing how many project outcomes are associated with each organisation. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to display based on the count of their associated project outcomes.\",\n    \"1\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n    \"2\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\"\n}\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["Identify the relevant tables: Research_Staff and Staff_Roles are needed to get the staff roles.", "Join the Research_Staff table with the Staff_Roles table on the appropriate key, which is staff_id and role_code respectively.", "Select the role_description from the Staff_Roles table to get the staff roles.", "Use a WHERE clause to filter the results based on the employer_organisation_id from the Research_Staff table, ensuring it matches organisation_id from the Organisations table.", "Order the results by role_description for better readability."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT sr.role_description \nFROM Research_Staff rs \nJOIN Staff_Roles sr ON rs.staff_id = sr.role_code \nWHERE rs.employer_organisation_id IN (SELECT organisation_id FROM Organisations) \nORDER BY sr.role_description;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["Identify the relevant table for staff roles, which is 'Project_Staff'.", "Determine the need to count occurrences of each role, which requires grouping by 'role_code'.", "Use the COUNT function to count the number of staff members for each role.", "Order the results in descending order to find the most common role.", "Limit the results to 1 to get only the most common role."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count \nFROM Project_Staff \nGROUP BY role_code \nORDER BY role_count DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned based on a specified numeric value.\",\n    \"1\": \"This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limited to a specified number of results.\"\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to count the number of products, so we will use the COUNT() function.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to filter by category.", "Add a WHERE clause to filter for products in the 'Spices' category.", "Add another condition to filter for products with a typical selling price greater than 1000."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT COUNT(*) AS product_count \nFROM Products p \nJOIN Ref_Product_Categories c ON p.product_category_code = c.product_category_code \nWHERE c.product_category_description = 'Spices' \nAND p.typical_selling_price > 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the frequency of products associated with each color. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.\"\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the relevant tables: We need to get product category descriptions, which are in the 'Ref_Product_Categories' table, and we need to filter products based on their descriptions, which are in the 'Products' table.", "Determine the relationship between the tables: The 'Products' table has a foreign key 'product_category_code' that links to the 'Ref_Product_Categories' table. We will need to join these two tables on this key.", "Formulate the SQL query: We will select the distinct 'product_category_description' from 'Ref_Product_Categories' where the corresponding products have descriptions containing the letter 't'.", "Use the LIKE operator to filter product descriptions: The condition for filtering will be 'p.product_description LIKE '%t%'' to find any product descriptions that contain the letter 't'."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description\nFROM Ref_Product_Categories rpc\nJOIN Products p ON rpc.product_category_code = p.product_category_code\nWHERE p.product_description LIKE '%t%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\",\n    \"1\": \"This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the frequency of products associated with each color. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.\",\n    \"2\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color in ascending order. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\"\n}\n"}
{"sample_id": "train.5576", "db_id": "products_gen_characteristics", "question": "Count the products that have the color description \"white\" or have the characteristic name \"hot\".", "rationale": ["Identify the tables involved: Products, Ref_Colors, Product_Characteristics, and Characteristics.", "We need to count products based on two conditions: color description being 'white' and characteristic name being 'hot'.", "Join the Products table with Ref_Colors to filter by color description.", "Join the Products table with Product_Characteristics to access the characteristics of each product.", "Join Product_Characteristics with Characteristics to filter by characteristic name.", "Use a WHERE clause to specify the conditions for color description and characteristic name.", "Use COUNT(*) to count the total number of products that meet either condition."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(*) \nFROM Products \nLEFT JOIN Ref_Colors ON Products.color_code = Ref_Colors.color_code \nLEFT JOIN Product_Characteristics ON Products.product_id = Product_Characteristics.product_id \nLEFT JOIN Characteristics ON Product_Characteristics.characteristic_id = Characteristics.characteristic_id \nWHERE Ref_Colors.color_description = 'white' OR Characteristics.characteristic_name = 'hot';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the frequency of products associated with each color. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.\",\n    \"1\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color in ascending order. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\"\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the columns needed: unit_of_measure from Ref_Product_Categories and product_name from Products.", "Establish the relationship between the tables using the foreign key: Products.product_category_code links to Ref_Product_Categories.product_category_code.", "Filter the results to only include products that have 'Herb' in their name using a LIKE clause."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT Ref_Product_Categories.unit_of_measure \nFROM Products \nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code \nWHERE Products.product_name LIKE '%Herb%';", "hint": "\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the columns needed: product_category_code and unit_of_measure from Ref_Product_Categories.", "Establish the relationship between Products and Ref_Product_Categories using the product_category_code foreign key.", "Filter the results based on the product name 'chervil' in the Products table.", "Construct the SQL query using JOIN to combine the necessary tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT rpc.product_category_code, rpc.unit_of_measure \nFROM Products p \nJOIN Ref_Product_Categories rpc ON p.product_category_code = rpc.product_category_code \nWHERE p.product_name = 'chervil';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\",\n    \"1\": \"This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the frequency of products associated with each color. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.\"\n}\n"}
{"sample_id": "train.5589", "db_id": "products_gen_characteristics", "question": "What are the names of products that are not 'white' in color and are not measured by the unit 'Handful'?", "rationale": ["Identify the relevant tables: Products, Ref_Colors, and Ref_Product_Categories are needed to get product names, color descriptions, and unit of measure respectively.", "Join the Products table with Ref_Colors on the color_code to filter out products that are white.", "Join the Products table with Ref_Product_Categories on the product_category_code to filter out products measured by 'Handful'.", "Use a WHERE clause to specify the conditions that the color description should not be 'white' and the unit of measure should not be 'Handful'.", "Select the product_name from the resulting joined tables that meet the criteria."], "gold_sql": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  'white' AND t2.unit_of_measure != 'Handful'", "source_tables": ["products", "ref_colors", "ref_product_categories"], "pred_sql": "SELECT product_name \nFROM Products \nJOIN Ref_Colors ON Products.color_code = Ref_Colors.color_code \nJOIN Ref_Product_Categories ON Products.product_category_code = Ref_Product_Categories.product_category_code \nWHERE Ref_Colors.color_description != 'white' \nAND Ref_Product_Categories.unit_of_measure != 'Handful';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the frequency of products associated with each color. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.\",\n    \"1\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color in ascending order. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\"\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["We need to find the description of the color used by the least number of products.", "To do this, we will join the 'Ref_Colors' table with the 'Products' table on the 'color_code'.", "Next, we will group the results by 'color_code' to count how many products are associated with each color.", "We will then order the results in ascending order based on the count of products, so that the color with the least products comes first.", "Finally, we will limit the results to 1 to get only the color description used by the least number of products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT color_description FROM Ref_Colors\nJOIN Products ON Ref_Colors.color_code = Products.color_code\nGROUP BY Ref_Colors.color_code\nORDER BY COUNT(Products.product_id) ASC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the frequency of products associated with each color. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.\",\n    \"1\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color in ascending order. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\",\n    \"2\": \"This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.\"\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find characteristics that are associated with two or more products.", "To do this, we will join the 'Characteristics' table with the 'Product_Characteristics' table on the 'characteristic_id'.", "Next, we will group the results by 'characteristic_id' to aggregate the products associated with each characteristic.", "We will use the HAVING clause to filter the groups, keeping only those with a count of distinct 'product_id' that is 2 or more.", "Finally, we will select the 'characteristic_name' from the 'Characteristics' table to get the names of the characteristics that meet the criteria."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT c.characteristic_name\nFROM Characteristics c\nJOIN Product_Characteristics pc ON c.characteristic_id = pc.characteristic_id\nGROUP BY c.characteristic_id\nHAVING COUNT(DISTINCT pc.product_id) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the frequency of products associated with each color. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.\"\n}\n"}
{"sample_id": "train.5669", "db_id": "dorm_1", "question": "What are the names of the all-female dorms?", "rationale": ["Identify the table that contains information about dormitories, which is the 'Dorm' table.", "Determine the relevant column that specifies the gender designation for the dormitory, which is the 'gender' column.", "Formulate a SQL query to select the 'dorm_name' from the 'Dorm' table where the 'gender' is 'female'."], "gold_sql": "SELECT dorm_name FROM dorm WHERE gender  =  'F'", "source_tables": ["dorm"], "pred_sql": "SELECT dorm_name FROM Dorm WHERE gender = 'female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n    \"1\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\"\n}\n"}
{"sample_id": "train.5688", "db_id": "dorm_1", "question": "Find the average and total capacity of dorms for the students with gender X.", "rationale": ["Identify the tables needed: Dorm, Lives_in, and Student are required to get the dorm capacity and filter by student gender.", "We need to calculate the average and total capacity of dorms, so we will use the AVG() and SUM() functions on the student_capacity column from the Dorm table.", "To link the students to their respective dorms, we will join the Lives_in table with the Dorm table on dormid, and then join the Student table on stuid.", "We will filter the results based on the gender of the students by adding a WHERE clause that checks if the Sex column in the Student table equals 'X'.", "Finally, we will select the average and total capacity from the resulting joined tables."], "gold_sql": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  'X'", "source_tables": ["dorm"], "pred_sql": "SELECT AVG(D.student_capacity) AS average_capacity, SUM(D.student_capacity) AS total_capacity\nFROM Dorm D\nJOIN Lives_in L ON D.dormid = L.dormid\nJOIN Student S ON L.stuid = S.StuID\nWHERE S.Sex = 'X';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n    \"1\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\"\n}\n"}
{"sample_id": "train.5699", "db_id": "dorm_1", "question": "What are the names and types of the dorms that have a capacity greater than 300 or less than 100?", "rationale": ["Identify the relevant table: The Dorm table contains information about dormitories, including their names and capacities.", "Determine the columns needed: We need the dorm_name and student_capacity columns from the Dorm table.", "Set the conditions for filtering: We want dorms with a capacity greater than 300 or less than 100.", "Construct the SQL query: Use a SELECT statement to retrieve the required columns from the Dorm table with the specified conditions in the WHERE clause."], "gold_sql": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100", "source_tables": ["dorm"], "pred_sql": "SELECT dorm_name, student_capacity FROM Dorm WHERE student_capacity > 300 OR student_capacity < 100;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n    \"1\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\"\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables involved: We need to count students living in male dorms, so we will use the Lives_in and Dorm tables.", "Determine the relationship: The Lives_in table links students to their dorms, and the Dorm table contains information about the dorms, including their gender designation.", "Filter for male dorms: We will add a WHERE clause to filter the dorms to only those designated for males.", "Count the distinct students: We will use COUNT(DISTINCT Lives_in.stuid) to ensure we count each student only once, even if they are in the same dorm."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(DISTINCT Lives_in.stuid) AS total_students\nFROM Lives_in\nJOIN Dorm ON Lives_in.dormid = Dorm.dormid\nWHERE Dorm.gender = 'male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n    \"1\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\"\n}\n"}
{"sample_id": "train.5755", "db_id": "dorm_1", "question": "What is the most common amenity in the dorms?", "rationale": ["Identify the tables involved: Dorm_amenity, Has_amenity, and Dorm.", "Join the Dorm_amenity table with Has_amenity to link amenities to dorms.", "Join the resulting table with the Dorm table to filter by student capacity.", "Use a WHERE clause to filter dorms that have a student capacity greater than 0.", "Group the results by amenity name to count occurrences of each amenity.", "Order the results by the count of amenities in descending order to find the most common one.", "Limit the results to 1 to get only the most common amenity."], "gold_sql": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_amenity", "dorm_amenity"], "pred_sql": "SELECT amenity_name, COUNT(amenity_name) AS amenity_count\nFROM Dorm_amenity\nJOIN Has_amenity ON Dorm_amenity.amenid = Has_amenity.amenid\nJOIN Dorm ON Has_amenity.dormid = Dorm.dormid\nWHERE Dorm.student_capacity > 0\nGROUP BY amenity_name\nORDER BY amenity_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n    \"1\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\"\n}\n"}
{"sample_id": "train.5757", "db_id": "dorm_1", "question": "What are the first names of all students who live in the dorm with the most amenities?", "rationale": ["Identify the tables involved: We need to get student first names from the Student table and find out which dorm has the most amenities from the Dorm and Has_amenity tables.", "Join the Lives_in table with the Student table to link students to their respective dorms.", "Create a subquery to count the number of amenities for each dormitory by joining the Dorm and Has_amenity tables, grouping by dormid.", "Use another subquery to find the maximum count of amenities from the previous subquery.", "Filter the main query to only include students who live in the dormitory that has the maximum number of amenities."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT S.Fname \nFROM Student S \nJOIN Lives_in L ON S.StuID = L.stuid \nJOIN (\n    SELECT D.dormid, COUNT(HA.amenid) AS amenity_count \n    FROM Dorm D \n    JOIN Has_amenity HA ON D.dormid = HA.dormid \n    GROUP BY D.dormid \n) AS DormAmenities ON L.dormid = DormAmenities.dormid \nWHERE DormAmenities.amenity_count = (\n    SELECT MAX(amenity_count) \n    FROM (\n        SELECT D.dormid, COUNT(HA.amenid) AS amenity_count \n        FROM Dorm D \n        JOIN Has_amenity HA ON D.dormid = HA.dormid \n        GROUP BY D.dormid \n    ) AS AmenitiesCount\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n    \"1\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\"\n}\n"}
{"sample_id": "train.5776", "db_id": "customer_complaints", "question": "Find the emails of customers who has filed a complaints of the product with the most complaints.", "rationale": ["Identify the main goal: to find the emails of customers who filed complaints about the product with the most complaints.", "To achieve this, we need to join the Customers table with the Complaints table on the customer_id field, as we want to retrieve customer emails related to complaints.", "Next, we need to determine which product has the most complaints. This can be done by grouping the Complaints table by product_id and counting the number of complaints for each product.", "We will order the results of this grouping in descending order based on the count of complaints and limit the results to 1 to get the product with the most complaints.", "Finally, we will use the product_id obtained from the subquery to filter the main query, ensuring we only select emails of customers who complained about that specific product."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT Customers.email_address\nFROM Customers\nJOIN Complaints ON Customers.customer_id = Complaints.customer_id\nWHERE Complaints.product_id = (\n    SELECT product_id\n    FROM Complaints\n    GROUP BY product_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n    \"1\": \"This virtual table provides the first names of staff members from the 'Staff' table who are associated with complaints in the 'Complaints' table. The results are grouped by staff member, and the number of complaints handled by each staff member is counted. The placeholder in the LIMIT clause allows for specifying the maximum number of staff members to return based on the count of complaints they have handled.\"\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the relevant tables: Customers and Complaints.", "We need to find the emails of customers who filed complaints, so we will join the Customers table with the Complaints table on customer_id.", "To find the product with the greatest number of complaints, we will use a subquery that counts complaints grouped by product_id and orders them in descending order, limiting the result to the top product.", "The outer query will select distinct email addresses from the Customers table where the product_id matches the one returned by the subquery."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT DISTINCT c.email_address\nFROM Customers c\nJOIN Complaints co ON c.customer_id = co.customer_id\nWHERE co.product_id = (\n    SELECT product_id\n    FROM Complaints\n    GROUP BY product_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n    \"1\": \"This virtual table provides the first names of staff members from the 'Staff' table who are associated with complaints in the 'Complaints' table. The results are grouped by staff member, and the number of complaints handled by each staff member is counted. The placeholder in the LIMIT clause allows for specifying the maximum number of staff members to return based on the count of complaints they have handled.\"\n}\n"}
{"sample_id": "train.5779", "db_id": "customer_complaints", "question": "Return the names of products that have had complaints filed by the customer who has filed the fewest complaints.", "rationale": ["We need to find the names of products that have had complaints filed by a specific customer.", "First, we need to identify the customer who has filed the fewest complaints. This can be done by grouping the complaints by customer_id and counting the number of complaints for each customer.", "We will order the results by the count of complaints in ascending order and limit the results to 1 to get the customer with the fewest complaints.", "Next, we will join this result with the Complaints table to find the complaints associated with this customer.", "Finally, we will join the Products table to get the product names associated with these complaints, ensuring we select distinct product names to avoid duplicates."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT DISTINCT Products.product_name \nFROM Products \nJOIN Complaints ON Products.product_id = Complaints.product_id \nJOIN ( \n    SELECT customer_id \n    FROM Complaints \n    GROUP BY customer_id \n    ORDER BY COUNT(complaint_id) ASC \n    LIMIT 1 \n) AS FewestComplaints ON Complaints.customer_id = FewestComplaints.customer_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n    \"1\": \"This virtual table provides the first names of staff members from the 'Staff' table who are associated with complaints in the 'Complaints' table. The results are grouped by staff member, and the number of complaints handled by each staff member is counted. The placeholder in the LIMIT clause allows for specifying the maximum number of staff members to return based on the count of complaints they have handled.\"\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the tables involved: Staff, Complaints, and Products.", "We need to find the last name of the staff member handling a complaint related to the product with the lowest price.", "Join the Staff table with the Complaints table on staff_id to get the staff member handling each complaint.", "Join the Complaints table with the Products table on product_id to access product details related to each complaint.", "Use a subquery to find the minimum product price from the Products table.", "Filter the results to only include complaints related to the product with the lowest price.", "Select the last name of the staff member from the resulting joined table."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT s.last_name \nFROM Staff s \nJOIN Complaints c ON s.staff_id = c.staff_id \nJOIN Products p ON c.product_id = p.product_id \nWHERE p.product_price = (SELECT MIN(product_price) FROM Products) \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n    \"1\": \"This virtual table provides the first names of staff members from the 'Staff' table who are associated with complaints in the 'Complaints' table. The results are grouped by staff member, and the number of complaints handled by each staff member is counted. The placeholder in the LIMIT clause allows for specifying the maximum number of staff members to return based on the count of complaints they have handled.\"\n}\n"}
{"sample_id": "train.5800", "db_id": "customer_complaints", "question": "How many customers are there in the customer type with the most customers?", "rationale": ["Identify the relevant table: Customers, as we need to count customers based on their type.", "We need to group the customers by their customer type code to count how many customers belong to each type.", "Use the COUNT() function to count the number of customers for each customer type.", "Order the results in descending order based on the count of customers to find the type with the most customers.", "Limit the results to 1 to get only the customer type with the highest count."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT customer_type_code, COUNT(customer_id) AS customer_count\nFROM Customers\nGROUP BY customer_type_code\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["We need to find the first names of the top 5 staff members who have handled the greatest number of complaints.", "To do this, we will join the 'Staff' table with the 'Complaints' table on the 'staff_id' column.", "Next, we will group the results by 'staff_id' to count the number of complaints each staff member has handled.", "We will order the results in descending order based on the count of complaints to get the staff who handled the most complaints at the top.", "Finally, we will limit the results to the top 5 staff members."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT s.first_name\nFROM Staff s\nJOIN Complaints c ON s.staff_id = c.staff_id\nGROUP BY s.staff_id\nORDER BY COUNT(c.complaint_id) DESC\nLIMIT 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the last names of staff members who are handling complaints, ordered by the date the complaints were raised. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n    \"1\": \"This virtual table provides the first names of staff members from the 'Staff' table who are associated with complaints in the 'Complaints' table. The results are grouped by staff member, and the number of complaints handled by each staff member is counted. The placeholder in the LIMIT clause allows for specifying the maximum number of staff members to return based on the count of complaints they have handled.\"\n}\n"}
{"sample_id": "train.5812", "db_id": "customer_complaints", "question": "Which state has the most customers?", "rationale": ["Identify the relevant table: Customers.", "Determine the column that represents the state: 'state'.", "Count the number of customers in each state using COUNT(customer_id).", "Group the results by state to aggregate the counts: GROUP BY state.", "Order the results in descending order to find the state with the most customers: ORDER BY customer_count DESC.", "Limit the results to only the top entry to get the state with the most customers: LIMIT 1."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT state, COUNT(customer_id) AS customer_count\nFROM Customers\nGROUP BY state\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5813", "db_id": "customer_complaints", "question": "Give the state that has the most customers.", "rationale": ["Identify the table that contains customer information, which is the 'Customers' table.", "We need to count the number of customers in each state, so we will use the COUNT() function on 'customer_id'.", "To group the results by state, we will use the GROUP BY clause on the 'state' column.", "To find the state with the most customers, we will order the results in descending order based on the customer count using ORDER BY.", "Finally, we will limit the results to only the top entry using LIMIT 1."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT state, COUNT(customer_id) AS customer_count\nFROM Customers\nGROUP BY state\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5865", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions whose share count is bigger than 100 and whose type code is \"PUR\"?", "rationale": ["Identify the relevant tables: Lots and Transactions are needed to get lot details associated with transactions.", "Determine the relationship: Lots are linked to Transactions through the investor_id.", "Filter criteria: We need to filter transactions where share_count is greater than 100 and the transaction type code is 'PUR'.", "Construct the SQL query: Use SELECT to get lot_details from Lots, JOIN with Transactions on investor_id, and apply the WHERE clause for filtering."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  100 AND T3.transaction_type_code  =  'PUR'", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT Lots.lot_details \nFROM Lots \nJOIN Transactions ON Lots.investor_id = Transactions.investor_id \nWHERE Transactions.share_count > 100 \nAND Transactions.transaction_type_code = 'PUR';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides detailed information about investors from the 'Investors' table who have conducted transactions involving a number of shares greater than a specified amount. The placeholder in the WHERE clause represents the minimum share count for filtering the results.\",\n    \"1\": \"This virtual table combines the details of sales and purchase transactions from the 'Sales' and 'Purchases' tables. The placeholder in the SELECT statements represents the specific details of each transaction type.\"\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["Identify the tables involved: Transactions and Ref_Transaction_Types.", "We need to calculate the average transaction amount, so we will use the AVG() function on the amount_of_transaction column from the Transactions table.", "To categorize the average amounts by transaction type, we will join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code.", "We will select the transaction_type_description from the Ref_Transaction_Types table and the average transaction amount.", "Finally, we will group the results by transaction_type_description to get the average for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table combines the details of sales and purchase transactions from the 'Sales' and 'Purchases' tables. The placeholder in the SELECT statements represents the specific details of each transaction type.\"\n}\n"}
{"sample_id": "train.5873", "db_id": "tracking_share_transactions", "question": "Show the number of transactions with transaction type code \"SALE\" for different investors if it is larger than 0.", "rationale": ["Identify the relevant tables: Investors and Transactions are needed to get investor details and transaction counts.", "Join the Investors table with the Transactions table on the investor_id to link investors with their transactions.", "Filter the transactions to only include those with the transaction type code 'SALE'.", "Group the results by investor_id to count the number of transactions for each investor.", "Use the HAVING clause to filter out investors with a transaction count of 0, ensuring only those with more than 0 transactions are included."], "gold_sql": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  'SALE' GROUP BY investor_id", "source_tables": ["transactions"], "pred_sql": "SELECT Investors.investor_id, COUNT(Transactions.transaction_id) AS transaction_count\nFROM Investors\nJOIN Transactions ON Investors.investor_id = Transactions.investor_id\nWHERE Transactions.transaction_type_code = 'SALE'\nGROUP BY Investors.investor_id\nHAVING transaction_count > 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides detailed information about investors from the 'Investors' table who have conducted transactions involving a number of shares greater than a specified amount. The placeholder in the WHERE clause represents the minimum share count for filtering the results.\",\n    \"1\": \"This virtual table combines the details of sales and purchase transactions from the 'Sales' and 'Purchases' tables. The placeholder in the SELECT statements represents the specific details of each transaction type.\"\n}\n"}
{"sample_id": "train.5876", "db_id": "tracking_share_transactions", "question": "Show the transaction type code that occurs the most frequently.", "rationale": ["We need to find the transaction type code that occurs the most frequently.", "To do this, we will query the Transactions table, which contains the transaction_type_code.", "We will group the results by transaction_type_code to count the occurrences of each type.", "Next, we will order the results in descending order based on the count of occurrences.", "Finally, we will limit the results to 1 to get the most frequent transaction type code."], "gold_sql": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["transactions"], "pred_sql": "SELECT transaction_type_code\nFROM Transactions\nGROUP BY transaction_type_code\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table combines the details of sales and purchase transactions from the 'Sales' and 'Purchases' tables. The placeholder in the SELECT statements represents the specific details of each transaction type.\"\n}\n"}
{"sample_id": "train.5884", "db_id": "tracking_share_transactions", "question": "What are the details of the lots which are not used in any transactions?", "rationale": ["Identify the Lots table to retrieve details of lots.", "Determine that we need to find lots that are not used in any transactions.", "To find lots not used in transactions, we can use a subquery to select all lot_ids from the Transactions_Lots table.", "The main query will select all columns from the Lots table where the lot_id is not in the list of lot_ids returned by the subquery."], "gold_sql": "SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id", "source_tables": ["lots", "transactions_lots"], "pred_sql": "SELECT * FROM Lots WHERE lot_id NOT IN (SELECT lot_id FROM Transactions_Lots);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table combines the details of sales and purchase transactions from the 'Sales' and 'Purchases' tables. The placeholder in the SELECT statements represents the specific details of each transaction type.\",\n    \"1\": \"This virtual table provides detailed information about investors from the 'Investors' table who have conducted transactions involving a number of shares greater than a specified amount. The placeholder in the WHERE clause represents the minimum share count for filtering the results.\"\n}\n"}
{"sample_id": "train.5893", "db_id": "cre_Theme_park", "question": "Show details of all visitors.", "rationale": ["The user wants to see details of all visitors, which means we need to select all columns from the Visitors table.", "The SQL query to retrieve all records from a table is done using 'SELECT * FROM table_name'.", "In this case, the table name is 'Visitors', so the full SQL query becomes 'SELECT * FROM Visitors;'."], "gold_sql": "SELECT Tourist_Details FROM VISITORS", "source_tables": ["visitors"], "pred_sql": "SELECT * FROM Visitors;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n    \"1\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\",\n    \"2\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table, ensuring that only attractions with visit counts below or equal to the specified threshold are included.\"\n}\n"}
{"sample_id": "train.5901", "db_id": "cre_Theme_park", "question": "What is the detail of the location UK Gallery?", "rationale": ["Identify the table that contains location details, which is the 'Locations' table.", "Determine the columns needed: 'Location_Name', 'Address', and 'Other_Details'.", "Use a WHERE clause to filter the results for the specific location 'UK Gallery'.", "Construct the SQL query to select the required columns from the 'Locations' table where the location name matches 'UK Gallery'."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "pred_sql": "SELECT Location_Name, Address, Other_Details FROM Locations WHERE Location_Name = 'UK Gallery';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n    \"1\": \"This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.\",\n    \"2\": \"This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The data is retrieved by joining the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for the royal family that corresponds to the tourist attraction.\"\n}\n"}
{"sample_id": "train.5902", "db_id": "cre_Theme_park", "question": "Return the detail of the location named \"UK Gallery\".", "rationale": ["Identify the table that contains location details, which is the 'Locations' table.", "Determine the column that holds the name of the location, which is 'Location_Name'.", "Formulate a SQL query to select all columns from the 'Locations' table where the 'Location_Name' matches 'UK Gallery'."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "pred_sql": "SELECT * FROM Locations WHERE Location_Name = 'UK Gallery';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n    \"1\": \"This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.\",\n    \"2\": \"This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The data is retrieved by joining the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for the royal family that corresponds to the tourist attraction.\"\n}\n"}
{"sample_id": "train.5914", "db_id": "cre_Theme_park", "question": "Give me the star rating descriptions of the hotels that cost more than 10000.", "rationale": ["Identify the relevant tables: We need to get star rating descriptions from the Ref_Hotel_Star_Ratings table and filter hotels based on their price from the Hotels table.", "Determine the relationship between tables: The Hotels table has a foreign key that links to the Ref_Hotel_Star_Ratings table through the star_rating_code.", "Construct the SQL query: We will select the star_rating_description from Ref_Hotel_Star_Ratings, joining it with Hotels on star_rating_code, and apply a WHERE clause to filter hotels that cost more than 10000."], "gold_sql": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  10000", "source_tables": ["ref_hotel_star_ratings", "hotels"], "pred_sql": "SELECT Ref_Hotel_Star_Ratings.star_rating_description \nFROM Hotels \nJOIN Ref_Hotel_Star_Ratings ON Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code \nWHERE Hotels.price_range = 'More than 10000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n    \"1\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table, ensuring that only attractions with visit counts below or equal to the specified threshold are included.\",\n    \"2\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\"\n}\n"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["Identify the relevant tables: Museums and Tourist_Attractions.", "Determine the required fields: Museum details from the Museums table and opening hours from the Tourist_Attractions table.", "Establish the relationship between the tables: Museums are linked to Tourist_Attractions through the Museum_ID and Tourist_Attraction_ID.", "Construct the SQL query to select the desired fields from the joined tables."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT Museums.Museum_Details, Tourist_Attractions.Opening_Hours \nFROM Museums \nJOIN Tourist_Attractions ON Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.\",\n    \"1\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n    \"2\": \"This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The data is retrieved by joining the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for the royal family that corresponds to the tourist attraction.\"\n}\n"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables: Royal_Family and Tourist_Attractions.", "Determine the relationship between the tables: Royal_Family is linked to Tourist_Attractions via Royal_Family_ID and Tourist_Attraction_ID.", "Select the desired columns: Name, Description, and How_to_Get_There from the Tourist_Attractions table.", "Construct the SQL query using a JOIN to combine the two tables based on the identified relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name, Tourist_Attractions.Description, Tourist_Attractions.How_to_Get_There \nFROM Royal_Family \nJOIN Tourist_Attractions ON Royal_Family.Royal_Family_ID = Tourist_Attractions.Tourist_Attraction_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The data is retrieved by joining the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for the royal family that corresponds to the tourist attraction.\",\n    \"1\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5924", "db_id": "cre_Theme_park", "question": "Find the details of the shops that can be reached by walk.", "rationale": ["Identify the relevant tables: Shops and Tourist_Attractions.", "Determine the relationship between the tables: Shops are associated with Tourist_Attractions through the Shop_ID and Tourist_Attraction_ID.", "Select the necessary columns: Shop_ID and Shop_Details from the Shops table.", "Filter the results based on the instruction on how to get to the attractions, specifically looking for those that mention 'walk'.", "Construct the SQL query using JOIN to combine the Shops and Tourist_Attractions tables, applying the WHERE clause for filtering."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "pred_sql": "SELECT Shops.Shop_ID, Shops.Shop_Details \nFROM Shops \nJOIN Tourist_Attractions ON Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Tourist_Attractions.How_to_Get_There LIKE '%walk%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n    \"1\": \"This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5927", "db_id": "cre_Theme_park", "question": "What are the details of the markets that can be accessed by walk or bus?", "rationale": ["Identify the relevant table for street markets, which is 'Street_Markets'.", "Determine the columns needed from the 'Street_Markets' table, which are 'Market_ID' and 'Market_Details'.", "Recognize that we need to filter the street markets based on how to get to the associated tourist attractions.", "The 'Tourist_Attractions' table contains the 'How_to_Get_There' column, which indicates the access methods for attractions.", "Construct a subquery to select 'Tourist_Attraction_ID' from 'Tourist_Attractions' where 'How_to_Get_There' is either 'walk' or 'bus'.", "Use the results of the subquery to filter the 'Street_Markets' table by matching 'Market_ID' with 'Tourist_Attraction_ID' from the subquery."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "pred_sql": "SELECT Market_ID, Market_Details \nFROM Street_Markets \nWHERE Market_ID IN (\n    SELECT Tourist_Attraction_ID \n    FROM Tourist_Attractions \n    WHERE How_to_Get_There IN ('walk', 'bus')\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n    \"1\": \"This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.\",\n    \"2\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\"\n}\n"}
{"sample_id": "train.5928", "db_id": "cre_Theme_park", "question": "Find the details of all the markets that are accessible by walk or bus.", "rationale": ["Identify the relevant table: Street_Markets contains the details of the markets we want to retrieve.", "Determine the condition for accessibility: We need to filter markets based on how to get to the associated tourist attractions.", "Join the Street_Markets table with the Tourist_Attractions table using the Tourist_Attraction_ID to find those that are accessible by walking or by bus.", "Use a subquery to select the Tourist_Attraction_IDs from the Tourist_Attractions table where the How_to_Get_There column contains 'walk' or 'bus'.", "Construct the final SQL query to select all columns from Street_Markets where the Market_ID matches the IDs retrieved from the subquery."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "pred_sql": "SELECT * FROM Street_Markets WHERE Market_ID IN (SELECT Tourist_Attraction_ID FROM Tourist_Attractions WHERE How_to_Get_There LIKE '%walk%' OR How_to_Get_There LIKE '%bus%');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n    \"1\": \"This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.\",\n    \"2\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\"\n}\n"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "Determine the relevant columns needed, which are all columns in this case since we want the details of the hotels.", "To find the most expensive hotels, we need to sort the hotels by their price range in descending order.", "Use the ORDER BY clause to sort the results by 'price_range' in descending order.", "Limit the results to the top three entries using the LIMIT clause."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n    \"1\": \"This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The data is retrieved by joining the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for the royal family that corresponds to the tourist attraction.\",\n    \"2\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\"\n}\n"}
{"sample_id": "train.5943", "db_id": "cre_Theme_park", "question": "Show the details and star ratings of the 3 least expensive hotels.", "rationale": ["Identify the relevant tables: Hotels and Ref_Hotel_Star_Ratings.", "We need to select hotel details and their star ratings, so we will select columns from both tables: hotel_id and price_range from Hotels, and star_rating_description from Ref_Hotel_Star_Ratings.", "Join the Hotels table with Ref_Hotel_Star_Ratings on the star_rating_code to get the star rating descriptions for each hotel.", "Order the results by price_range in ascending order to find the least expensive hotels.", "Limit the results to 3 to get only the three least expensive hotels."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT Hotels.hotel_id, Hotels.price_range, Ref_Hotel_Star_Ratings.star_rating_description \nFROM Hotels \nJOIN Ref_Hotel_Star_Ratings ON Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code \nORDER BY Hotels.price_range ASC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n    \"1\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table, ensuring that only attractions with visit counts below or equal to the specified threshold are included.\",\n    \"2\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\"\n}\n"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["Identify the relevant tables: 'Tourist_Attractions' for attraction details and 'Visits' for visit records.", "Join the 'Tourist_Attractions' table with the 'Visits' table on the common column 'Tourist_Attraction_ID' to link visits to their respective attractions.", "Select the 'How_to_Get_There' column to find out the transportation methods used to reach the attractions.", "Count the number of visits for each transportation method using COUNT(*) and group the results by 'How_to_Get_There'.", "Order the results by the count of visits in descending order to find the most popular transportation method.", "Limit the results to 1 to get only the top transportation method chosen by visitors."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Visit_Count\nFROM Tourist_Attractions\nJOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID\nGROUP BY How_to_Get_There\nORDER BY Visit_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n    \"1\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n    \"2\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\"\n}\n"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant tables: 'Tourist_Attractions' for transportation methods and 'Visits' for counting visits.", "Join the 'Tourist_Attractions' table with the 'Visits' table on the common key 'Tourist_Attraction_ID'.", "Select the 'How_to_Get_There' column to get the transportation methods and count the number of visits using COUNT(Visit_ID).", "Group the results by 'How_to_Get_There' to aggregate the visit counts for each transportation method.", "Order the results in descending order of visit counts to find the most used transportation method.", "Limit the results to 1 to get the top transportation method."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(Visit_ID) AS Visit_Count\nFROM Tourist_Attractions\nJOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID\nGROUP BY How_to_Get_There\nORDER BY Visit_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n    \"1\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n    \"2\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\"\n}\n"}
{"sample_id": "train.5951", "db_id": "cre_Theme_park", "question": "Show different tourist attractions' names, ids, and the corresponding number of visits.", "rationale": ["Identify the tables needed: 'Tourist_Attractions' for attraction names and IDs, and 'Visits' for counting the number of visits.", "Use a LEFT JOIN to combine 'Tourist_Attractions' with 'Visits' on the common column 'Tourist_Attraction_ID'. This allows us to include all attractions even if they have no visits.", "Select the columns: 'Name' and 'Tourist_Attraction_ID' from 'Tourist_Attractions', and use COUNT() on 'Visit_ID' from 'Visits' to get the number of visits.", "Group the results by 'Tourist_Attraction_ID' to ensure we get a count of visits for each unique attraction."], "gold_sql": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name, Tourist_Attractions.Tourist_Attraction_ID, COUNT(Visits.Visit_ID) AS Number_of_Visits\nFROM Tourist_Attractions\nLEFT JOIN Visits ON Tourist_Attractions.Tourist_Attraction_ID = Visits.Tourist_Attraction_ID\nGROUP BY Tourist_Attractions.Tourist_Attraction_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n    \"1\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\",\n    \"2\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table, ensuring that only attractions with visit counts below or equal to the specified threshold are included.\"\n}\n"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find tourist attractions that have specific features, namely 'parking' or 'shopping'.", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions with their features.", "Then, join the Features table to get the details of those features.", "Use a WHERE clause to filter the results to only include features that are either 'parking' or 'shopping'.", "Select the Name of the tourist attractions that meet these criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT Tourist_Attractions.Name\nFROM Tourist_Attractions\nJOIN Tourist_Attraction_Features ON Tourist_Attractions.Tourist_Attraction_ID = Tourist_Attraction_Features.Tourist_Attraction_ID\nJOIN Features ON Tourist_Attraction_Features.Feature_ID = Features.Feature_ID\nWHERE Features.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n    \"1\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\",\n    \"2\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table, ensuring that only attractions with visit counts below or equal to the specified threshold are included.\"\n}\n"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find the names of tourist attractions that have specific features (parking or shopping).", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions with their features.", "Then, join the Features table to get the details of those features.", "Use a WHERE clause to filter the results to only include features that are either 'parking' or 'shopping'.", "Select the Name of the tourist attractions from the final result."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT Tourist_Attractions.Name \nFROM Tourist_Attractions \nJOIN Tourist_Attraction_Features ON Tourist_Attractions.Tourist_Attraction_ID = Tourist_Attraction_Features.Tourist_Attraction_ID \nJOIN Features ON Tourist_Attraction_Features.Feature_ID = Features.Feature_ID \nWHERE Features.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\",\n    \"1\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\",\n    \"2\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table, ensuring that only attractions with visit counts below or equal to the specified threshold are included.\"\n}\n"}
{"sample_id": "train.5964", "db_id": "cre_Theme_park", "question": "Which tourist attractions do the tourists Vincent and Marcelle visit? Tell me the names of the attractions.", "rationale": ["Identify the relevant tables: Tourist_Attractions for attraction names, Visits for visit records, and Visitors for tourist details.", "Join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID to link attractions with their visit records.", "Join the resulting table with the Visitors table on the Tourist_ID to filter visits by specific tourists.", "Use a WHERE clause to specify the names of the tourists (Vincent and Marcelle) to filter the results accordingly.", "Select the Name column from the Tourist_Attractions table to get the names of the attractions visited by the specified tourists."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT ta.Name \nFROM Tourist_Attractions ta \nJOIN Visits v ON ta.Tourist_Attraction_ID = v.Tourist_Attraction_ID \nJOIN Visitors vi ON v.Tourist_ID = vi.Tourist_ID \nWHERE vi.Tourist_Details IN ('Vincent', 'Marcelle');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and unique identifiers of tourist attractions that have been visited a limited number of times, as specified by a placeholder for numeric values. The data is sourced from the 'Tourist_Attractions' table, and it is filtered based on the number of visits recorded in the 'Visits' table.\",\n    \"1\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n    \"2\": \"This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.\"\n}\n"}
{"sample_id": "train.6059", "db_id": "customers_and_addresses", "question": "What is the average amount of items ordered in each order?", "rationale": ["To find the average amount of items ordered in each order, we need to focus on the 'Order_Items' table, which contains the 'order_quantity' for each product ordered in an order.", "We will use the AVG() function to calculate the average of the 'order_quantity' column.", "The SQL query will select the average of 'order_quantity' from the 'Order_Items' table."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "pred_sql": "SELECT AVG(order_quantity) AS average_items_ordered\nFROM Order_Items;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of product details and their identifiers from the 'Products' table, based on the quantities ordered from the 'Order_Items' table. The results are grouped by product ID and ordered by the total quantity ordered, with a limit specified by a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n    \"2\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\"\n}\n"}
{"sample_id": "train.6066", "db_id": "customers_and_addresses", "question": "Find the payment method that is used most frequently.", "rationale": ["Identify the relevant table: The question asks about payment methods, which are found in the Customers table.", "Count the occurrences of each payment method: We need to count how many times each payment method appears in the Customers table.", "Group the results by payment method: This allows us to aggregate the counts for each unique payment method.", "Order the results by frequency: We want to sort the payment methods by how often they are used, in descending order.", "Limit the results to the top one: Since we only want the most frequently used payment method, we limit the results to 1."], "gold_sql": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT payment_method, COUNT(payment_method) AS frequency\nFROM Customers\nGROUP BY payment_method\nORDER BY frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: We need to find the city with the most customers, so we will use the Customer_Addresses and Addresses tables.", "Join the tables: We will join Customer_Addresses with Addresses on the address_id to get the city associated with each customer.", "Count distinct customers: We will count the distinct customer_id for each city to avoid counting the same customer multiple times.", "Group by city: We will group the results by city to aggregate the customer counts for each city.", "Order the results: We will order the results in descending order based on the customer count to find the city with the most customers.", "Limit the results: We will limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(DISTINCT customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6098", "db_id": "customers_and_addresses", "question": "Find the contact channel code that was used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "We need to find the contact channel code associated with a specific customer name, which is 'Tillman Ernser'.", "Join the Customers table with the Customer_Contact_Channels table on the customer_id to link customer names with their contact channels.", "Filter the results using a WHERE clause to specify the customer name 'Tillman Ernser'.", "Select the channel_code from the resulting joined table."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT ccc.channel_code \nFROM Customers c \nJOIN Customer_Contact_Channels ccc ON c.customer_id = ccc.customer_id \nWHERE c.customer_name = 'Tillman Ernser';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\",\n    \"1\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the specific contact channel code being queried.\"\n}\n"}
{"sample_id": "train.6099", "db_id": "customers_and_addresses", "question": "What is the \"active to date\" of the latest contact channel used by \"Tillman Ernser\"?", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "We need to find the 'active to date' for the contact channels associated with the customer named 'Tillman Ernser'.", "Join the Customers table with the Customer_Contact_Channels table on the customer_id to link customers with their contact channels.", "Filter the results to only include the customer with the name 'Tillman Ernser'.", "Order the results by 'active_from_date' in descending order to get the latest contact channel first.", "Limit the results to 1 to get only the latest contact channel's 'active to date'."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT ccc.active_to_date \nFROM Customers c \nJOIN Customer_Contact_Channels ccc ON c.customer_id = ccc.customer_id \nWHERE c.customer_name = 'Tillman Ernser' \nORDER BY ccc.active_from_date DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n    \"1\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\"\n}\n"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "We need to find the 'active_to_date' for the contact channels associated with the customer named 'Tillman Ernser'.", "Join the Customers table with the Customer_Contact_Channels table on the customer_id to link customers with their contact channels.", "Filter the results to only include the customer named 'Tillman Ernser'.", "Use the MAX function to get the latest 'active_to_date' from the filtered results."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT MAX(CCC.active_to_date) AS latest_active_to_date\nFROM Customers C\nJOIN Customer_Contact_Channels CCC ON C.customer_id = CCC.customer_id\nWHERE C.customer_name = 'Tillman Ernser';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n    \"1\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\"\n}\n"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["To find the average time span of contact channels, we need to calculate the duration for each contact channel by subtracting the 'active_from_date' from the 'active_to_date'.", "We will use the 'julianday' function to convert the date strings into Julian day numbers, which allows us to perform arithmetic operations on the dates.", "We will select the average of these durations using the AVG() function.", "We need to ensure that we only consider contact channels that have an 'active_to_date' (i.e., they have been deactivated) to get a meaningful average."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_time_span\nFROM Customer_Contact_Channels\nWHERE active_to_date IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n    \"1\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\"\n}\n"}
{"sample_id": "train.6102", "db_id": "customers_and_addresses", "question": "Compute the average active time span of contact channels.", "rationale": ["We need to compute the average active time span of contact channels, which involves calculating the difference between the activation and deactivation dates of each contact channel.", "The relevant table for this information is 'Customer_Contact_Channels', which contains the columns 'active_from_date' and 'active_to_date'.", "To calculate the time span, we can use the 'julianday' function to convert these dates into Julian day numbers, allowing us to subtract them to find the duration.", "We will use the AVG function to compute the average of these time spans.", "We also need to ensure that we only consider channels that have an active end date, so we will add a WHERE clause to filter out any channels that are still active (i.e., where 'active_to_date' is NULL)."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_active_time_span\nFROM Customer_Contact_Channels\nWHERE active_to_date IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n    \"1\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\"\n}\n"}
{"sample_id": "train.6104", "db_id": "customers_and_addresses", "question": "Return the channel code and contact number of the customer contact channel whose active duration was the longest.", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the channel code and contact number.", "Determine the longest active duration: This can be calculated by subtracting active_from_date from active_to_date.", "Use the ORDER BY clause to sort the results based on the duration in descending order.", "Limit the results to 1 to get the channel with the longest active duration."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT channel_code, contact_number\nFROM Customer_Contact_Channels\nORDER BY (julianday(active_to_date) - julianday(active_from_date)) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n    \"1\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\"\n}\n"}
{"sample_id": "train.6105", "db_id": "customers_and_addresses", "question": "Find the name and active date of the customer that use email as the contact channel.", "rationale": ["Identify the tables needed: Customers and Customer_Contact_Channels.", "We need to retrieve the customer name and the active date of the contact channel.", "Join the Customers table with the Customer_Contact_Channels table on the customer_id.", "Filter the results to include only those records where the channel_code is 'email'.", "Select the customer_name and active_from_date from the joined tables."], "gold_sql": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT c.customer_name, cc.active_from_date \nFROM Customers c \nJOIN Customer_Contact_Channels cc ON c.customer_id = cc.customer_id \nWHERE cc.channel_code = 'email';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n    \"1\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\"\n}\n"}
{"sample_id": "train.6127", "db_id": "customers_and_addresses", "question": "Who made the latest order?", "rationale": ["Identify the table that contains order information, which is 'Customer_Orders'.", "To find the latest order, we need to sort the orders by 'order_date' in descending order.", "We will select the 'customer_id' from the 'Customer_Orders' table to identify who made the latest order.", "Using 'LIMIT 1' will ensure we only get the most recent order."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT 1", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT customer_id FROM Customer_Orders ORDER BY order_date DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total quantity of products ordered from the 'Customer_Orders' table, filtered by a specific order status. The placeholder in the WHERE clause represents the order status to filter the results accordingly.\"\n}\n"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["Identify the relevant tables: Products and Order_Items.", "Join the Products table with the Order_Items table on product_id to link products with their ordered quantities.", "Group the results by product_id to aggregate the total order quantity for each product.", "Use SUM(oi.order_quantity) to calculate the total quantity ordered for each product.", "Order the results in descending order based on the total quantity ordered to find the product with the largest order quantity.", "Limit the results to 1 to get only the product with the largest total order quantity."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT p.product_id, p.product_details\nFROM Products p\nJOIN Order_Items oi ON p.product_id = oi.product_id\nGROUP BY p.product_id\nORDER BY SUM(oi.order_quantity) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of product details and their identifiers from the 'Products' table, based on the quantities ordered from the 'Order_Items' table. The results are grouped by product ID and ordered by the total quantity ordered, with a limit specified by a placeholder for numeric values.\",\n    \"1\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n    \"2\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\"\n}\n"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The question asks for addresses, so we will use the 'Addresses' table.", "Determine the filtering criteria: We need to find addresses in two specific cities (East Julianaside and Gleasonmouth) and their corresponding states (Texas and Arizona).", "Construct the WHERE clause: We will use an OR condition to combine the two sets of criteria for the cities and states.", "Formulate the SQL query: We will select all columns from the 'Addresses' table where the conditions are met."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "\n"}
{"sample_id": "train.6134", "db_id": "customers_and_addresses", "question": "What are all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The question asks for addresses, so we will use the 'Addresses' table.", "Determine the conditions: We need to find addresses in two specific cities (East Julianaside and Gleasonmouth) and their corresponding states (Texas and Arizona).", "Construct the WHERE clause: We will use an OR condition to combine the two sets of criteria for the cities and states.", "Select all columns: Since the question asks for all addresses, we will use SELECT * to retrieve all columns from the Addresses table."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "\n"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["Identify the table that contains the competition information, which is the 'match' table.", "Determine the column that holds the competition name, which is 'Competition'.", "Use a SELECT statement to find the Match_ID where the Competition matches '1994 FIFA World Cup qualification'."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "pred_sql": "SELECT Match_ID FROM match WHERE Competition = (SELECT Competition FROM match WHERE Competition = '1994 FIFA World Cup qualification');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\"\n}\n"}
{"sample_id": "train.6275", "db_id": "city_record", "question": "Find the city that hosted the most events.", "rationale": ["Identify the relevant tables: 'hosting_city' for match hosting information and 'city' for city names.", "Join the 'hosting_city' table with the 'city' table on the Host_City and City_ID to get city names for hosted matches.", "Count the number of matches hosted by each city using COUNT(hc.Match_ID).", "Group the results by city name to aggregate the match counts.", "Order the results in descending order based on the match count to find the city with the most events.", "Limit the results to 1 to get only the top city that hosted the most events."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "pred_sql": "SELECT c.City, COUNT(hc.Match_ID) AS Match_Count\nFROM hosting_city hc\nJOIN city c ON hc.Host_City = c.City_ID\nGROUP BY c.City\nORDER BY Match_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\",\n    \"1\": \"This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\"\n}\n"}
{"sample_id": "train.6282", "db_id": "city_record", "question": "Which three cities have the largest regional population?", "rationale": ["Identify the table that contains the relevant data, which is the 'city' table.", "We need to select the 'City' and 'Regional_Population' columns from the 'city' table.", "To find the cities with the largest regional population, we will order the results by 'Regional_Population' in descending order.", "Finally, we will limit the results to the top 3 cities using the LIMIT clause."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "pred_sql": "SELECT City, Regional_Population FROM city ORDER BY Regional_Population DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\"\n}\n"}
{"sample_id": "train.6283", "db_id": "city_record", "question": "What are the three largest cities in terms of regional population?", "rationale": ["Identify the relevant table: The 'city' table contains the information about cities and their populations.", "Select the columns needed: We need the 'City' name and 'Regional_Population'.", "Order the results: To find the largest cities, we will order the results by 'Regional_Population' in descending order.", "Limit the results: We only want the top three cities, so we will use the LIMIT clause with a value of 3."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "pred_sql": "SELECT City, Regional_Population FROM city ORDER BY Regional_Population DESC LIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\",\n    \"1\": \"This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n    \"2\": \"This virtual table lists the names of cities from the 'city' table that have a March average temperature lower than July or higher than October. The query joins the 'city' table with the 'temperature' table based on the city identifier, allowing for the comparison of temperature data across different months.\"\n}\n"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["We need to find the city with the highest temperature in February.", "To do this, we will join the 'city' table with the 'temperature' table using the 'City_ID' as the common key.", "We will select the 'City' name and the average temperature in February ('Feb') from the joined tables.", "To find the highest temperature, we will order the results by the 'Feb' column in descending order.", "Finally, we will limit the results to just one city using 'LIMIT 1' to get the city with the highest temperature."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT City, Feb FROM city JOIN temperature ON city.City_ID = temperature.City_ID ORDER BY Feb DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n    \"1\": \"This virtual table lists the names of cities from the 'city' table that have a March average temperature lower than July or higher than October. The query joins the 'city' table with the 'temperature' table based on the city identifier, allowing for the comparison of temperature data across different months.\",\n    \"2\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\"\n}\n"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the tables involved: 'city' for city names and 'temperature' for temperature data.", "Determine the columns needed: 'City' from 'city' and temperature data for March, July, and October from 'temperature'.", "Establish the relationship between the tables using the 'City_ID' foreign key.", "Formulate the WHERE clause to filter cities based on the condition: March temperature lower than July or higher than October.", "Combine the SELECT statement with the JOIN and WHERE clause to create the final SQL query."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Jul OR t.Mar > t.Oct;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that have a March average temperature lower than July or higher than October. The query joins the 'city' table with the 'temperature' table based on the city identifier, allowing for the comparison of temperature data across different months.\",\n    \"1\": \"This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n    \"2\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\"\n}\n"}
{"sample_id": "train.6290", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in July and which have also served as host cities?", "rationale": ["Identify the relevant tables: 'city', 'temperature', and 'hosting_city'.", "We need to find cities where the average temperature in March (Mar) is lower than in July (Jul). This requires joining the 'city' table with the 'temperature' table on 'City_ID'.", "Additionally, we need to ensure that these cities have hosted matches, which requires joining the 'hosting_city' table on 'Host_City'.", "The final query will select the city names from the 'city' table where the temperature condition is met and the city has hosted matches."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nJOIN hosting_city h ON c.City_ID = h.Host_City \nWHERE t.Mar < t.Jul;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that have a March average temperature lower than July or higher than October. The query joins the 'city' table with the 'temperature' table based on the city identifier, allowing for the comparison of temperature data across different months.\",\n    \"1\": \"This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n    \"2\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\"\n}\n"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the relevant tables: 'city', 'temperature', and 'hosting_city'.", "We need to compare the average temperatures in March and December, so we will join the 'city' table with the 'temperature' table on 'City_ID'.", "The condition for lower temperature in March than in December is specified in the WHERE clause: t.Mar < t.Dec.", "To find cities that have never served as host cities, we will use a subquery that selects all Host_City from the 'hosting_city' table and ensure that the City_ID is not in that list using NOT IN.", "Finally, we select the City names from the resulting dataset."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table that have a March average temperature lower than July or higher than October. The query joins the 'city' table with the 'temperature' table based on the city identifier, allowing for the comparison of temperature data across different months.\",\n    \"1\": \"This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n    \"2\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\"\n}\n"}
{"sample_id": "train.6295", "db_id": "city_record", "question": "Which cities have higher temperature in Feb than in Jun or have once served as host cities?", "rationale": ["Identify the relevant tables: 'city', 'temperature', and 'hosting_city'.", "We need to find cities where the average temperature in February is higher than in June. This requires joining the 'city' table with the 'temperature' table on 'City_ID'.", "Additionally, we need to check if the city has ever hosted a match, which involves joining the 'city' table with the 'hosting_city' table on 'Host_City'.", "Use a LEFT JOIN for the 'hosting_city' table to include cities that may not have hosted any matches, allowing us to check for NULL values to determine if they have hosted matches.", "The final query should select distinct city names that meet either of the two conditions: higher temperature in February than in June or having hosted a match."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT DISTINCT c.City \nFROM city c \nJOIN temperature t ON c.City_ID = t.City_ID \nLEFT JOIN hosting_city h ON c.City_ID = h.Host_City \nWHERE (t.Feb > t.Jun) OR (h.Host_City IS NOT NULL);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.\",\n    \"1\": \"This virtual table lists the names of cities from the 'city' table that have a March average temperature lower than July or higher than October. The query joins the 'city' table with the 'temperature' table based on the city identifier, allowing for the comparison of temperature data across different months.\",\n    \"2\": \"This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.\"\n}\n"}
{"sample_id": "train.6324", "db_id": "e_government", "question": "Find the last name of the first ever contact person of the organization with the highest UK Vat number.", "rationale": ["Identify the organization with the highest UK VAT number by using a subquery to select the maximum value from the Organizations table.", "Join the Organization_Contact_Individuals table with the Individuals table to get the contact person's last name.", "Join the Organization_Contact_Individuals table with the Organizations table to filter by the organization with the highest UK VAT number.", "Order the results by the date of contact to find the first contact person.", "Limit the results to 1 to get only the first contact person's last name."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.uk_vat_number  =  (SELECT max(uk_vat_number) FROM organizations) ORDER BY t2.date_contact_to ASC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "pred_sql": "SELECT i.individual_last_name\nFROM Organization_Contact_Individuals oci\nJOIN Individuals i ON oci.individual_id = i.individual_id\nJOIN Organizations org ON oci.organization_id = org.organization_id\nWHERE org.uk_vat_number = (\n    SELECT MAX(uk_vat_number)\n    FROM Organizations\n)\nORDER BY oci.date_contact_from ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6328", "db_id": "e_government", "question": "Find name of the services that has never been used.", "rationale": ["Identify the services from the 'Services' table.", "Determine which services have been booked by checking the 'Party_Services' table.", "Use an EXCEPT clause to filter out the booked services from the list of all services.", "The final query selects the service names that are not present in the 'Party_Services' table."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "pred_sql": "SELECT service_name FROM Services EXCEPT SELECT service_name FROM Services INNER JOIN Party_Services ON Services.service_id = Party_Services.service_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of services from the 'Services' table that have not been booked by any party. The query uses an EXCEPT clause to exclude service names that are present in the 'Party_Services' table, indicating that those services have been booked. The placeholder in the query represents the service names that are being filtered out based on their booking status.\"\n}\n"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table: The question asks for cities and states, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' for cities and 'state_province_county' for states.", "Use DISTINCT to avoid duplicate entries: Since we want the names of all cities and states, using DISTINCT ensures that we only get unique combinations.", "Construct the SQL query: Combine the selected columns and table into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6331", "db_id": "e_government", "question": "What are the names of all cities and states?", "rationale": ["Identify the relevant table: The question asks for city and state names, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' and 'state_province_county' from the Addresses table.", "Use DISTINCT to avoid duplicate entries: Since cities and states may repeat, we use DISTINCT to get unique combinations.", "Construct the SQL query: Combine the selected columns and table into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the relevant tables: We need to find individuals who are contact individuals for organizations, so we will use the Organization_Contact_Individuals and Individuals tables.", "Determine the relationship: The Organization_Contact_Individuals table has a foreign key 'individual_id' that links to the Individuals table.", "Select the required field: We need the last names of the individuals, which is in the Individuals table under 'individual_last_name'.", "Construct the SQL query: We will use a JOIN to combine the Organization_Contact_Individuals and Individuals tables on the 'individual_id' field and select the 'individual_last_name' from the Individuals table."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "pred_sql": "SELECT Individuals.individual_last_name \nFROM Organization_Contact_Individuals \nJOIN Individuals ON Organization_Contact_Individuals.individual_id = Individuals.individual_id;", "hint": "\n"}
{"sample_id": "train.6723", "db_id": "activity_1", "question": "Show the first name, last name, and phone number for all female faculty members.", "rationale": ["Identify the relevant table: The 'Faculty' table contains the information about faculty members, including their first name, last name, and phone number.", "Determine the columns to select: We need to select the 'Fname', 'Lname', and 'Phone' columns from the 'Faculty' table.", "Apply the filter condition: We need to filter the results to include only female faculty members, which is indicated by the 'Sex' column in the 'Faculty' table.", "Construct the SQL query: Combine the SELECT statement with the FROM clause and the WHERE condition to form the complete SQL query."], "gold_sql": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'", "source_tables": ["faculty"], "pred_sql": "SELECT F.Fname, F.Lname, F.Phone \nFROM Faculty F \nWHERE F.Sex = 'Female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\"\n}\n"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the table that contains faculty information, which is the 'Faculty' table.", "Determine the column that stores the gender of faculty members, which is 'Sex'.", "Formulate a query to select the unique identifiers (FacID) of faculty members where the 'Sex' column is equal to 'Male'."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "pred_sql": "SELECT FacID FROM Faculty WHERE Sex = 'Male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique identifiers of students who are advised by faculty members of a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n    \"2\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\"\n}\n"}
{"sample_id": "train.6738", "db_id": "activity_1", "question": "Find the building that has the largest number of faculty members.", "rationale": ["To find the building with the largest number of faculty members, we need to count the number of faculty members in each building.", "We will use the 'Faculty' table, which contains the 'Building' and 'FacID' columns.", "We will group the results by 'Building' to get the count of faculty members in each building.", "We will use the COUNT function to count the number of 'FacID' entries for each building.", "To get the building with the largest number of faculty members, we will order the results in descending order based on the count.", "Finally, we will limit the results to 1 to get only the building with the highest count."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(FacID) AS FacultyCount\nFROM Faculty\nGROUP BY Building\nORDER BY FacultyCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n    \"1\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n    \"2\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier, and the count reflects the number of students associated with each advisor.\"\n}\n"}
{"sample_id": "train.6740", "db_id": "activity_1", "question": "In which buildings are there at least ten professors?", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their building locations.", "Determine the required information: We need to find buildings with at least ten professors.", "Group the results: Use GROUP BY to group the results by the Building column.", "Count the number of faculty members in each building: Use COUNT(FacID) to count the number of professors in each building.", "Filter the results: Use HAVING to filter groups that have a count of faculty members greater than or equal to 10."], "gold_sql": "SELECT building FROM Faculty WHERE rank  =  'Professor' GROUP BY building HAVING count(*)  >=  10", "source_tables": ["faculty"], "pred_sql": "SELECT Building\nFROM Faculty\nGROUP BY Building\nHAVING COUNT(FacID) >= 10;", "hint": "\n"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their rank and gender.", "Filter for assistant professors: We need to focus on faculty members with the rank of 'Assistant Professor'.", "Group by gender: We want to count the number of male and female assistant professors, so we will group the results by the 'Sex' column.", "Count the number of professors: Use the COUNT function to get the number of assistant professors for each gender."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) AS NumberOfProfessors \nFROM Faculty \nWHERE Rank = 'Assistant Professor' \nGROUP BY Sex;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty advisors. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students for each rank.\",\n    \"1\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n    \"2\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier, and the count reflects the number of students associated with each advisor.\"\n}\n"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the tables involved: We need information from the Faculty and Student tables.", "Determine the relationship: Faculty members are linked to students through the Advisor field in the Student table.", "Specify the selection criteria: We are looking for the advisor of a specific student, Linda Smith, so we will filter based on her first and last name.", "Construct the SQL query: We will select the first and last name of the faculty member from the Faculty table, joining it with the Student table on the Advisor field, and applying the necessary WHERE clause to filter for Linda Smith."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Faculty.Fname, Faculty.Lname \nFROM Faculty \nJOIN Student ON Faculty.FacID = Student.Advisor \nWHERE Student.Fname = 'Linda' AND Student.Lname = 'Smith';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier, and the count reflects the number of students associated with each advisor.\",\n    \"1\": \"This virtual table identifies faculty members who serve as advisors to students. It retrieves the unique identifiers of faculty members from the 'Faculty' table, joining it with the 'Student' table based on the advisor relationship. The results are grouped by faculty ID, and only those faculty members who have advised a specified number of students are included, as indicated by the placeholder in the HAVING clause.\",\n    \"2\": \"This virtual table identifies the unique identifiers of students who are advised by faculty members of a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\"\n}\n"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table to get student IDs and the 'Faculty' table to get faculty IDs.", "Determine the relationship: The 'Advisor' column in the 'Student' table indicates which faculty member is advising the student, and it corresponds to the 'FacID' in the 'Faculty' table.", "Construct the subquery: We will create a subquery that selects all 'FacID' from the 'Faculty' table, which represents all faculty members.", "Use the subquery in the main query: We will select 'StuID' from the 'Student' table where the 'Advisor' is in the list of faculty IDs obtained from the subquery."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT StuID FROM Student WHERE Advisor IN (SELECT FacID FROM Faculty)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier, and the count reflects the number of students associated with each advisor.\",\n    \"1\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n    \"2\": \"This virtual table identifies faculty members who serve as advisors to students. It retrieves the unique identifiers of faculty members from the 'Faculty' table, joining it with the 'Student' table based on the advisor relationship. The results are grouped by faculty ID, and only those faculty members who have advised a specified number of students are included, as indicated by the placeholder in the HAVING clause.\"\n}\n"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the tables needed: We need the 'Student' table to get student names and the 'Faculty' table to find the advisor's name.", "Join the 'Student' table with the 'Faculty' table on the advisor's ID (Advisor) to link students with their advisors.", "Filter the results to only include students whose advisor's first name is 'Michael' and last name is 'Goodrich'.", "Select the first name and last name of the students from the joined tables."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT S.Fname, S.LName \nFROM Student S \nJOIN Faculty F ON S.Advisor = F.FacID \nWHERE F.Fname = 'Michael' AND F.Lname = 'Goodrich';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique identifiers of students who are advised by faculty members of a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n    \"2\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\"\n}\n"}
{"sample_id": "train.6759", "db_id": "activity_1", "question": "What are the first and last name of the faculty who has the most students?", "rationale": ["Identify the tables involved: Faculty, Faculty_Participates_in, Participates_in, and Student.", "Join the Faculty table with Faculty_Participates_in to link faculty members with their activities.", "Join the resulting table with Participates_in to link activities with students.", "Join with the Student table to access student information.", "Group the results by faculty ID to count the number of students associated with each faculty member.", "Order the results by the count of students in descending order to find the faculty member with the most students.", "Limit the results to 1 to get only the faculty member with the highest count."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty", "student"], "pred_sql": "SELECT F.Fname, F.Lname\nFROM Faculty F\nJOIN Faculty_Participates_in FPI ON F.FacID = FPI.FacID\nJOIN Participates_in PI ON FPI.actid = PI.actid\nJOIN Student S ON PI.stuid = S.StuID\nGROUP BY F.FacID\nORDER BY COUNT(S.StuID) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n    \"1\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n    \"2\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\"\n}\n"}
{"sample_id": "train.6765", "db_id": "activity_1", "question": "What activities do we have?", "rationale": ["The question asks for a list of activities, which corresponds to the 'activity_name' column in the 'Activity' table.", "To retrieve the names of all activities, we need to select the 'activity_name' from the 'Activity' table.", "No filtering or joining with other tables is necessary since we only need the names of the activities."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "pred_sql": "SELECT activity_name FROM Activity;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities being compared.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n    \"2\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\"\n}\n"}
{"sample_id": "train.6766", "db_id": "activity_1", "question": "List all the activities we have.", "rationale": ["The task is to list all the activities available in the database.", "To achieve this, we need to select all records from the 'Activity' table.", "The 'Activity' table contains the relevant information about activities, including their unique identifiers and names.", "The SQL query to retrieve all records from the 'Activity' table is 'SELECT * FROM Activity;'."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "pred_sql": "SELECT * FROM Activity;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n    \"1\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities being compared.\",\n    \"2\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\"\n}\n"}
{"sample_id": "train.6780", "db_id": "activity_1", "question": "What is the first and last name of the faculty members who participated in at least one activity? For each of them, also show the number of activities they participated in.", "rationale": ["Identify the required information: first name, last name, and count of activities for faculty members who participated in at least one activity.", "Use the 'Faculty' table to get the first and last names of faculty members.", "Join the 'Faculty' table with the 'Faculty_Participates_in' table on the 'FacID' to link faculty members with their activities.", "Use COUNT() to count the number of activities each faculty member participated in.", "Group the results by 'FacID' to ensure each faculty member is represented once with their activity count.", "Use HAVING clause to filter out faculty members who have a count of activities greater than zero."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname, Faculty.Lname, COUNT(Faculty_Participates_in.actid) AS activity_count\nFROM Faculty\nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID\nGROUP BY Faculty.FacID\nHAVING COUNT(Faculty_Participates_in.actid) > 0;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n    \"1\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n    \"2\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities being compared.\"\n}\n"}
{"sample_id": "train.6781", "db_id": "activity_1", "question": "Show all the activity names and the number of faculty involved in each activity.", "rationale": ["We need to retrieve the names of activities and the count of faculty involved in each activity.", "To do this, we will select the 'activity_name' from the 'Activity' table.", "We will join the 'Activity' table with the 'Faculty_Participates_in' table on the 'actid' to link activities with faculty participation.", "Next, we will join the 'Faculty_Participates_in' table with the 'Faculty' table to get the faculty details, although we only need the count of faculty members.", "We will use COUNT() to count the number of faculty members for each activity.", "Finally, we will group the results by 'Activity.activity_name' to get the count of faculty for each activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "pred_sql": "SELECT Activity.activity_name, COUNT(Faculty_FacID) AS faculty_count\nFROM Activity\nLEFT JOIN Faculty_Participates_in ON Activity.actid = Faculty_Participates_in.actid\nLEFT JOIN Faculty ON Faculty_Participates_in.FacID = Faculty.FacID\nGROUP BY Activity.activity_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n    \"1\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n    \"2\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\"\n}\n"}
{"sample_id": "train.6782", "db_id": "activity_1", "question": "How many faculty members participate in each activity? Return the activity names and the number of faculty members.", "rationale": ["Identify the tables needed: We need the 'Activity' table for activity names and the 'Faculty_Participates_in' table to count faculty participation.", "Join the 'Faculty_Participates_in' table with the 'Activity' table on the 'actid' column to link faculty members with their respective activities.", "Use the COUNT function to count the number of faculty members participating in each activity.", "Group the results by 'Activity.activity_name' to get the count of faculty members for each activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "pred_sql": "SELECT Activity.activity_name, COUNT(Faculty_FacID) AS faculty_count\nFROM Faculty_Participates_in\nJOIN Activity ON Faculty_Participates_in.actid = Activity.actid\nGROUP BY Activity.activity_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n    \"1\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n    \"2\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier, and the count reflects the number of students associated with each advisor.\"\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: We need to look at the 'Participates_in' table to find students participating in activities and the 'Student' table to filter students based on age.", "We need to select the 'stuid' from the 'Participates_in' table where the student ID exists in the 'Student' table and the age is less than 20.", "Construct the inner query to select 'StuID' from the 'Student' table where 'Age' is less than 20.", "Use the result of the inner query to filter the 'Participates_in' table for students who are under 20 and participating in activities."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT stuid FROM Participates_in WHERE stuid IN (SELECT StuID FROM Student WHERE Age < 20);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities being compared.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n    \"2\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\"\n}\n"}
{"sample_id": "train.6795", "db_id": "activity_1", "question": "Find the first names of the faculty members who are playing Canoeing or Kayaking.", "rationale": ["Identify the tables needed: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members, so we will select from the Faculty table.", "To find out which activities the faculty members are participating in, we will join the Faculty table with the Faculty_Participates_in table on the FacID.", "Next, we need to join the Activity table to get the names of the activities associated with the activities in which the faculty members participate.", "We will filter the results to only include activities that are either 'Canoeing' or 'Kayaking' using the WHERE clause with the IN operator."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname \nFROM Faculty \nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID \nJOIN Activity ON Faculty_Participates_in.actid = Activity.actid \nWHERE Activity.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n    \"1\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\"\n}\n"}
{"sample_id": "train.6796", "db_id": "activity_1", "question": "Which faculty members are playing either Canoeing or Kayaking? Tell me their first names.", "rationale": ["Identify the relevant tables: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members who participate in specific activities, namely Canoeing and Kayaking.", "Join the Faculty table with the Faculty_Participates_in table on the FacID to link faculty members with their activities.", "Join the resulting table with the Activity table on actid to access the activity names.", "Filter the results to include only those activities that are either Canoeing or Kayaking using the WHERE clause.", "Select the first names of the faculty members from the Faculty table."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname \nFROM Faculty \nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID \nJOIN Activity ON Faculty_Participates_in.actid = Activity.actid \nWHERE Activity.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n    \"1\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\",\n    \"2\": \"This virtual table identifies the unique identifiers of students who are advised by faculty members of a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\"\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the relevant tables: Faculty and Faculty_Participates_in for faculty information and their activities.", "Join the Faculty table with the Faculty_Participates_in table to link faculty members with their activities.", "Join the resulting table with the Activity table to access the activity names.", "Filter the results to exclude faculty members who participate in 'Canoeing' or 'Kayaking'.", "Use a LEFT JOIN to ensure faculty members who do not participate in any activities are also included.", "Select only the first names of the faculty members who meet the criteria.", "Group the results by faculty ID to avoid duplicates."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty F \nLEFT JOIN Faculty_Participates_in FPI ON F.FacID = FPI.FacID \nLEFT JOIN Activity A ON FPI.actid = A.actid \nWHERE A.activity_name NOT IN ('Canoeing', 'Kayaking') OR A.activity_name IS NULL \nGROUP BY F.FacID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n    \"1\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\"\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables involved: We need to find students participating in specific activities, so we will use the 'Participates_in' and 'Activity' tables.", "Determine the relationship: The 'Participates_in' table links students to activities through the 'actid' column, which is also present in the 'Activity' table.", "Filter the activities: We need to filter the activities to only include 'Canoeing' and 'Kayaking'.", "Select distinct student IDs: We want to retrieve unique student IDs, so we will use SELECT DISTINCT on the 'stuid' column from the 'Participates_in' table.", "Join the tables: We will join the 'Participates_in' table with the 'Activity' table on the 'actid' column to access the activity names."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT DISTINCT p.stuid \nFROM Participates_in p \nJOIN Activity a ON p.actid = a.actid \nWHERE a.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clause represent the names of the activities being compared.\",\n    \"1\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is joined with the 'Faculty_Participates_in' table to link faculty members with their respective activities. The results are grouped by the unique identifier of each faculty member, allowing for a count of their participation in activities.\",\n    \"2\": \"This virtual table provides the count of faculty members who participate in activities, filtered by the first and last names of the faculty members. The placeholders in the WHERE clause represent the first and last names of the faculty member being queried.\"\n}\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant tables: 'car_names' for car models and 'cars_data' for horsepower.", "Join 'car_names' and 'cars_data' on the MakeId to access horsepower for each car model.", "Order the results by horsepower in ascending order to find the minimum.", "Limit the results to 1 to get only the model with the minimum horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model FROM car_names JOIN cars_data ON car_names.MakeId = cars_data.Id ORDER BY cars_data.Horsepower ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\",\n    \"1\": \"This virtual table provides a list of car makes and their identifiers from the 'car_names' table, specifically for cars that have a horsepower greater than the minimum horsepower recorded in the 'cars_data' table and have a cylinder count less than a specified number. The placeholder in the WHERE clause represents the maximum number of cylinders allowed.\",\n    \"2\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\"\n}\n"}
{"sample_id": "dev.97", "db_id": "car_1", "question": "Find the model of the car whose weight is below the average weight.", "rationale": ["Identify the requirement: We need to find car models whose weight is below the average weight.", "To find the average weight, we will use the AVG() function on the Weight column from the cars_data table.", "We will then create a subquery to select the Ids of the cars that have a weight less than this average weight.", "Finally, we will select the Model from the car_names table where the MakeId corresponds to the Ids from the previous subquery."], "gold_sql": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model FROM car_names WHERE MakeId IN (SELECT Id FROM cars_data WHERE Weight < (SELECT AVG(Weight) FROM cars_data));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n    \"1\": \"The virtual table describes the car models from the 'car_names' table, ordered by their fuel efficiency (MPG) in descending order. The placeholder in the LIMIT clause represents the maximum number of car models to return.\",\n    \"2\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\"\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car make and model.", "We need to find the 'Accelerate' value for the specific car model 'hornet sportabout (sw)'.", "Join the 'cars_data' table with the 'car_names' table on the appropriate foreign key (cars_data.Id = car_names.MakeId).", "Filter the results to only include the row where the model matches 'hornet sportabout (sw)'.", "Select the 'Accelerate' column from the resulting joined table."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT Accelerate FROM cars_data INNER JOIN car_names ON cars_data.Id = car_names.MakeId WHERE car_names.Model = 'hornet sportabout (sw)'", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for car models from the 'cars_data' table, specifically for a given model name. The query joins the 'cars_data' table with the 'car_names' table to filter results based on the specified model. The results are ordered by the acceleration time in ascending order, and a limit is applied to restrict the number of returned records.\",\n    \"1\": \"This virtual table provides the number of cylinders for car models from the 'cars_data' table, specifically for a given model name. The query joins the 'cars_data' table with the 'car_names' table to filter results based on the specified model. The results are ordered by the acceleration time in ascending order, and a limit is applied to restrict the number of returned records.\",\n    \"2\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\"\n}\n"}
{"sample_id": "dev.112", "db_id": "car_1", "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: 'cars_data' for acceleration data and 'car_names' for car model names.", "Join the 'cars_data' table with the 'car_names' table on the 'MakeId' to link car models with their acceleration data.", "Filter the results to find the specific car model 'hornet sportabout' made by 'amc'.", "Select the 'Accelerate' column from the resulting joined table to get the acceleration time for the specified car model."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT cars_data.Accelerate \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE car_names.Model = 'hornet sportabout' \nAND car_names.Make = 'amc';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n    \"1\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\",\n    \"2\": \"This virtual table provides the number of cylinders for car models from the 'cars_data' table, specifically for a given model name. The query joins the 'cars_data' table with the 'car_names' table to filter results based on the specified model. The results are ordered by the acceleration time in ascending order, and a limit is applied to restrict the number of returned records.\"\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the relevant tables: 'car_makers' for car makers and 'countries' for country information.", "Determine the relationship between the tables: 'car_makers' is linked to 'countries' through the 'Country' identifier.", "Use a COUNT function to count the number of car makers based in France.", "Filter the results using a WHERE clause to specify the country as France."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(*) AS NumberOfCarMakers\nFROM car_makers\nJOIN countries ON car_makers.Country = countries.CountryId\nWHERE countries.CountryName = 'France';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of car makers based in a specific country. It joins the 'car_makers' table with the 'countries' table using the country identifier, and filters the results based on the specified country name.\",\n    \"1\": \"This virtual table provides a count of car makers grouped by their respective countries from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents a numeric threshold for the minimum number of car makers that must be associated with a country.\",\n    \"2\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\"\n}\n"}
{"sample_id": "dev.121", "db_id": "car_1", "question": "What are all the makers and models?", "rationale": ["The user wants to retrieve all car makers and their corresponding models.", "To get this information, we need to join the 'car_names' table with the 'model_list' table to connect car models with their makers.", "Next, we join the 'model_list' table with the 'car_makers' table to get the maker names associated with each model.", "The final SQL query selects the 'Maker' and 'Model' columns from the joined tables."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "pred_sql": "SELECT Maker, Model FROM car_names INNER JOIN model_list ON car_names.Model = model_list.Model INNER JOIN car_makers ON model_list.Maker = car_makers.Id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n    \"1\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n    \"2\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\"\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the relevant tables: countries and car_makers.", "We need to filter countries that are in Europe, so we will join the countries table with the car_makers table using the country identifier.", "We will use a subquery to get the ContId for Europe from the continents table.", "Group the results by country name to count the number of car manufacturers in each country.", "Use the HAVING clause to filter countries that have at least 3 car manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName\nFROM countries c\nJOIN car_makers cm ON c.CountryId = cm.Country\nWHERE c.Continent = (SELECT ContId FROM continents WHERE Continent = 'Europe')\nGROUP BY c.CountryName\nHAVING COUNT(cm.Id) >= 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of car makers grouped by their respective countries from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents a numeric threshold for the minimum number of car makers that must be associated with a country.\",\n    \"1\": \"This virtual table provides the count of car makers based in a specific country. It joins the 'car_makers' table with the 'countries' table using the country identifier, and filters the results based on the specified country name.\",\n    \"2\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\"\n}\n"}
{"sample_id": "dev.130", "db_id": "car_1", "question": "What are the names of all European countries with at least 3 manufacturers?", "rationale": ["Identify the relevant tables: countries and car_makers.", "We need to filter countries that are in Europe, so we will join the countries table with the continents table to get the ContId for Europe.", "Join the car_makers table with the countries table using the country identifier to count the number of manufacturers per country.", "Group the results by country name to aggregate the count of manufacturers.", "Use the HAVING clause to filter countries that have at least 3 manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName \nFROM countries c \nJOIN car_makers cm ON c.CountryId = cm.Country \nWHERE c.Continent = (SELECT ContId FROM continents WHERE Continent = 'Europe') \nGROUP BY c.CountryName \nHAVING COUNT(cm.Id) >= 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the count of car makers based in a specific country. It joins the 'car_makers' table with the 'countries' table using the country identifier, and filters the results based on the specified country name.\",\n    \"1\": \"This virtual table provides a count of car makers grouped by their respective countries from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents a numeric threshold for the minimum number of car makers that must be associated with a country.\"\n}\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the relevant tables: 'cars_data' for horsepower and cylinder information, and 'car_names' for the make of the car.", "We need to find the maximum horsepower, so we will use the MAX() function on the 'Horsepower' column from the 'cars_data' table.", "We need to filter the results to only include car models with 3 cylinders, which will be done using a WHERE clause.", "We will join the 'cars_data' table with the 'car_names' table on the 'Id' and 'MakeId' columns to get the make of the car corresponding to the horsepower.", "Finally, we will select the maximum horsepower and the make of the car models that meet the criteria."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(cars_data.Horsepower) AS MaxHorsepower, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Cylinders = 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of car makes and their identifiers from the 'car_names' table, specifically for cars that have a horsepower greater than the minimum horsepower recorded in the 'cars_data' table and have a cylinder count less than a specified number. The placeholder in the WHERE clause represents the maximum number of cylinders allowed.\",\n    \"1\": \"This virtual table provides a list of car models from the 'car_names' table that have a specific number of cylinders. The results are filtered based on the cylinder count in the 'cars_data' table, and the output is ordered by horsepower in descending order. The placeholders in the query represent the number of cylinders and the limit for the number of results to return.\",\n    \"2\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\"\n}\n"}
{"sample_id": "dev.141", "db_id": "car_1", "question": "Which model has the most version(make) of cars?", "rationale": ["Identify the relevant tables: We need to find car models and their makes, which are in the 'car_names' table.", "Count the number of makes for each model: We will use the COUNT function to count how many makes correspond to each model.", "Group the results by model: We will use GROUP BY to aggregate the counts for each model.", "Order the results to find the model with the most makes: We will use ORDER BY to sort the counts in descending order.", "Limit the results to the top model: We will use LIMIT 1 to get only the model with the highest count."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "pred_sql": "SELECT Model, COUNT(Make) AS VersionCount\nFROM car_names\nGROUP BY Model\nORDER BY VersionCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n    \"1\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n    \"2\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\"\n}\n"}
{"sample_id": "dev.142", "db_id": "car_1", "question": "What model has the most different versions?", "rationale": ["Identify the relevant tables: 'car_names' for car models and 'cars_data' for different versions of those models.", "Join 'car_names' and 'cars_data' on the MakeId to associate each model with its versions.", "Group the results by Model to count the number of different versions for each model.", "Order the results by the count of versions in descending order to find the model with the most versions.", "Limit the results to 1 to get only the top model with the most different versions."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "pred_sql": "SELECT Model, COUNT(*) as VersionCount\nFROM car_names\nJOIN cars_data ON car_names.MakeId = cars_data.Id\nGROUP BY Model\nORDER BY VersionCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n    \"1\": \"The virtual table describes the car models from the 'car_names' table, ordered by their fuel efficiency (MPG) in descending order. The placeholder in the LIMIT clause represents the maximum number of car models to return.\",\n    \"2\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\"\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["Identify the relevant tables: We need to find car makers and their models, so we will use the 'car_makers' and 'model_list' tables.", "Join the tables: We will join 'car_makers' with 'model_list' on the car maker's ID to associate each maker with their models.", "Group the results: We will group the results by the car maker's ID and name to count the number of models each maker has.", "Filter the results: We will use the HAVING clause to filter out car makers that have more than 3 models."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker \nFROM car_makers cm \nJOIN model_list ml ON cm.Id = ml.Maker \nGROUP BY cm.Id, cm.Maker \nHAVING COUNT(ml.ModelId) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\",\n    \"1\": \"This virtual table provides a list of car makes and their identifiers from the 'car_names' table, specifically for cars that have a horsepower greater than the minimum horsepower recorded in the 'cars_data' table and have a cylinder count less than a specified number. The placeholder in the WHERE clause represents the maximum number of cylinders allowed.\",\n    \"2\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\"\n}\n"}
{"sample_id": "dev.161", "db_id": "car_1", "question": "How many countries has more than 2 car makers ?", "rationale": ["We need to count the number of countries that have more than 2 car makers.", "To do this, we will first join the 'countries' table with the 'car_makers' table using the country identifier.", "Next, we will group the results by country and count the number of car makers for each country.", "We will use the HAVING clause to filter the groups to only include those with more than 2 car makers.", "Finally, we will count the number of countries that meet this criterion."], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(*) AS CountryCount\nFROM (\n    SELECT countries.CountryId, COUNT(car_makers.Id) AS MakerCount\n    FROM countries\n    JOIN car_makers ON countries.CountryId = car_makers.Country\n    GROUP BY countries.CountryId\n    HAVING MakerCount > 2\n) AS CountryMakers;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of car makers grouped by their respective countries from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents a numeric threshold for the minimum number of car makers that must be associated with a country.\",\n    \"1\": \"This virtual table provides the count of car makers based in a specific country. It joins the 'car_makers' table with the 'countries' table using the country identifier, and filters the results based on the specified country name.\",\n    \"2\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\"\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car models.", "We need to filter the cars based on the number of cylinders, specifically looking for cars with 4 cylinders.", "Join the 'cars_data' table with the 'car_names' table on the appropriate foreign key (cars_data.Id = car_names.MakeId).", "Select the model name from 'car_names' and the horsepower from 'cars_data'.", "Order the results by horsepower in descending order to find the model with the largest horsepower.", "Limit the results to 1 to get only the top result."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT car_names.Model, cars_data.Horsepower \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Cylinders = 4 \nORDER BY cars_data.Horsepower DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of car models from the 'car_names' table that have a specific number of cylinders. The results are filtered based on the cylinder count in the 'cars_data' table, and the output is ordered by horsepower in descending order. The placeholders in the query represent the number of cylinders and the limit for the number of results to return.\",\n    \"1\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\",\n    \"2\": \"This virtual table provides a list of car makes and their identifiers from the 'car_names' table, specifically for cars that have a horsepower greater than the minimum horsepower recorded in the 'cars_data' table and have a cylinder count less than a specified number. The placeholder in the WHERE clause represents the maximum number of cylinders allowed.\"\n}\n"}
{"sample_id": "dev.171", "db_id": "car_1", "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?", "rationale": ["Identify the relevant tables: car_names, model_list, car_makers, and cars_data are needed to get the car models and their weights.", "Join the tables: car_names should be joined with model_list to get the maker information, then with car_makers to filter out 'Ford Motor Company', and finally with cars_data to access the weight of the cars.", "Set the conditions: We need to filter for cars that weigh less than 3500 and are not made by 'Ford Motor Company'.", "Select the model names: The final output should be the names of the models that meet the criteria."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';", "source_tables": ["car_makers", "model_list", "car_names", "cars_data"], "pred_sql": "SELECT car_names.Model \nFROM car_names \nJOIN model_list ON car_names.Model = model_list.Model \nJOIN car_makers ON model_list.Maker = car_makers.Id \nJOIN cars_data ON car_names.MakeId = cars_data.Id \nWHERE cars_data.Weight < 3500 \nAND car_makers.FullName != 'Ford Motor Company';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n    \"1\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\",\n    \"2\": \"The virtual table describes the car models from the 'car_names' table, ordered by their fuel efficiency (MPG) in descending order. The placeholder in the LIMIT clause represents the maximum number of car models to return.\"\n}\n"}
{"sample_id": "dev.175", "db_id": "car_1", "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .", "rationale": ["Identify the relevant tables: car_makers and model_list.", "We need to find car makers that produce at least 2 models, so we will join car_makers with model_list on the Maker ID.", "Group the results by car maker ID and name to count the number of models each maker produces.", "Use the HAVING clause to filter for car makers that have 2 or more models.", "Additionally, we need to ensure that there are more than 3 distinct car makers in total, which can be checked using a subquery."], "gold_sql": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(ml.ModelId) >= 2\nAND (SELECT COUNT(DISTINCT cm2.Id) FROM car_makers cm2) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.\",\n    \"1\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n    \"2\": \"This virtual table provides a list of car makes and their identifiers from the 'car_names' table, specifically for cars that have a horsepower greater than the minimum horsepower recorded in the 'cars_data' table and have a cylinder count less than a specified number. The placeholder in the WHERE clause represents the maximum number of cylinders allowed.\"\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["We need to find car makers that produce at least 2 models and make more than 3 cars.", "Start by selecting the Id and Maker from the car_makers table.", "Join the model_list table to link car makers to their models using the Maker identifier.", "Join the car_names table to connect the models to their respective makes using the Model identifier.", "Join the cars_data table to count the number of cars associated with each make.", "Group the results by car maker Id and Maker name to aggregate the counts.", "Use the HAVING clause to filter for car makers that have at least 2 distinct models and more than 3 cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nJOIN car_names cn ON ml.Model = cn.Model\nJOIN cars_data cd ON cn.MakeId = cd.Id\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(DISTINCT ml.Model) >= 2 AND COUNT(cd.Id) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists car models from the 'car_names' table, ordered by their miles per gallon (MPG) fuel efficiency from the 'cars_data' table. The placeholder in the LIMIT clause represents the maximum number of car models to display.\",\n    \"1\": \"This virtual table provides a list of car makes and their identifiers from the 'car_names' table, specifically for cars that have a horsepower greater than the minimum horsepower recorded in the 'cars_data' table and have a cylinder count less than a specified number. The placeholder in the WHERE clause represents the maximum number of cylinders allowed.\",\n    \"2\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\"\n}\n"}
{"sample_id": "dev.526", "db_id": "student_transcripts_tracking", "question": "What are the names and ids of every course with less than 2 sections?", "rationale": ["Identify the relevant tables: Courses and Sections.", "We need to find courses that have less than 2 sections, so we will join the Courses table with the Sections table on the course_id.", "Use a LEFT JOIN to ensure we include courses that may not have any sections at all.", "Group the results by course_id to aggregate the sections for each course.", "Use the HAVING clause to filter the grouped results to only include courses with a count of sections less than 2."], "gold_sql": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2", "source_tables": ["courses", "sections"], "pred_sql": "SELECT Courses.course_id, Courses.course_name\nFROM Courses\nLEFT JOIN Sections ON Courses.course_id = Sections.course_id\nGROUP BY Courses.course_id\nHAVING COUNT(Sections.section_id) < 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n    \"1\": \"This virtual table provides the first name, middle name, last name, and student ID of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\"\n}\n"}
{"sample_id": "dev.534", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs.", "Join the Students table with the Student_Enrolment table to link students with their enrolments.", "Join the Student_Enrolment table with the Degree_Programs table to access degree program information.", "Group the results by student_id to aggregate enrolment data for each student.", "Use the HAVING clause to filter students who are enrolled in exactly 2 distinct degree programs."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nGROUP BY s.student_id\nHAVING COUNT(DISTINCT se.degree_program_id) = 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. It uses an intersection of two queries to ensure that the semesters returned are common to two instances of the same degree program, represented by a placeholder for the degree program's name.\",\n    \"1\": \"This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. It uses an intersection of two queries to ensure that the semesters returned are common to two instances of the same degree program, represented by a placeholder for the degree program's name.\",\n    \"2\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\"\n}\n"}
{"sample_id": "dev.535", "db_id": "student_transcripts_tracking", "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs.", "We need to join these tables to get the students enrolled in a Bachelor degree program.", "The join condition will be based on the foreign keys: Student_Enrolment.student_id = Students.student_id and Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id.", "We will filter the results to include only those degree programs that have 'Bachelor' in their name using a WHERE clause.", "Finally, we will select the first name, middle name, and last name of the students."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nWHERE dp.degree_summary_name LIKE '%Bachelor%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n    \"1\": \"This virtual table provides the first name, middle name, last name, and student ID of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\",\n    \"2\": \"This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. It uses an intersection of two queries to ensure that the semesters returned are common to two instances of the same degree program, represented by a placeholder for the degree program's name.\"\n}\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["Identify the relevant tables: Degree_Programs and Student_Enrolment are needed to find the degree programs and their enrolments.", "Join the Degree_Programs table with the Student_Enrolment table on the degree_program_id to associate students with their respective programs.", "Group the results by degree_program_id and degree_summary_name to aggregate the enrolment counts for each program.", "Count the number of student enrolments for each degree program using COUNT(se.student_enrolment_id).", "Order the results in descending order to find the program with the most enrolments.", "Limit the results to 1 to get only the program with the highest number of students enrolled."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_program_id, dp.degree_summary_name\nFROM Degree_Programs dp\nJOIN Student_Enrolment se ON dp.degree_program_id = se.degree_program_id\nGROUP BY dp.degree_program_id, dp.degree_summary_name\nORDER BY COUNT(se.student_enrolment_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n    \"1\": \"This virtual table provides a list of degree program names from the 'Degree_Programs' table, which are associated with student enrolments. The results are grouped by the degree program name and ordered by the number of enrolments in descending order, allowing users to see the most popular degree programs. The placeholder in the LIMIT clause represents the maximum number of degree programs to return.\",\n    \"2\": \"This virtual table provides the first name, middle name, last name, and student ID of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\"\n}\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment are needed to get student details and their enrolment counts.", "Join the Students table with the Student_Enrolment table on the student_id to link students with their enrolments.", "Use COUNT() to count the number of enrolments for each student.", "Group the results by student_id to aggregate the enrolment counts for each student.", "Order the results by the count of enrolments in descending order to find the student with the most enrolments.", "Limit the results to 1 to get only the student with the highest enrolment count."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name, COUNT(se.student_enrolment_id) AS number_of_enrolments \nFROM Students s \nJOIN Student_Enrolment se ON s.student_id = se.student_id \nGROUP BY s.student_id \nORDER BY number_of_enrolments DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n    \"1\": \"This virtual table provides the first name, middle name, last name, and student ID of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\",\n    \"2\": \"This virtual table provides a list of degree program names from the 'Degree_Programs' table, which are associated with student enrolments. The results are grouped by the degree program name and ordered by the number of enrolments in descending order, allowing users to see the most popular degree programs. The placeholder in the LIMIT clause represents the maximum number of degree programs to return.\"\n}\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["To find the course with the most enrollments, we need to count the number of students enrolled in each course.", "We will join the Courses table with the Student_Enrolment_Courses table to link courses with their enrollments.", "Next, we will join the Student_Enrolment table to get the actual enrollments for each course.", "We will group the results by course ID to count the number of enrollments for each course.", "Finally, we will order the results by the count of enrollments in descending order and limit the result to 1 to get the course with the most enrollments."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT Courses.course_name\nFROM Courses\nJOIN Student_Enrolment_Courses ON Courses.course_id = Student_Enrolment_Courses.course_id\nJOIN Student_Enrolment ON Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id\nGROUP BY Courses.course_id\nORDER BY COUNT(Student_Enrolment.student_enrolment_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n    \"1\": \"This virtual table provides the first name, middle name, last name, and student ID of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\",\n    \"2\": \"This virtual table provides a list of degree program names from the 'Degree_Programs' table, which are associated with student enrolments. The results are grouped by the degree program name and ordered by the number of enrolments in descending order, allowing users to see the most popular degree programs. The placeholder in the LIMIT clause represents the maximum number of degree programs to return.\"\n}\n"}
{"sample_id": "dev.548", "db_id": "student_transcripts_tracking", "question": "What is the name of the course with the most students enrolled?", "rationale": ["Identify the relevant tables: Courses, Student_Enrolment_Courses, and Student_Enrolment are needed to find the course with the most students enrolled.", "Join the Courses table with the Student_Enrolment_Courses table on course_id to link courses with their enrolments.", "Join the resulting table with the Student_Enrolment table to access student enrolment records.", "Group the results by course_id to count the number of students enrolled in each course.", "Order the results by the count of students in descending order to get the course with the most students at the top.", "Limit the results to 1 to get only the course with the highest enrolment."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT Courses.course_name\nFROM Courses\nJOIN Student_Enrolment_Courses ON Courses.course_id = Student_Enrolment_Courses.course_id\nJOIN Student_Enrolment ON Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id\nGROUP BY Courses.course_id\nORDER BY COUNT(Student_Enrolment.student_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n    \"1\": \"This virtual table provides the first name, middle name, last name, and student ID of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\",\n    \"2\": \"This virtual table provides a list of degree program names from the 'Degree_Programs' table, which are associated with student enrolments. The results are grouped by the degree program name and ordered by the number of enrolments in descending order, allowing users to see the most popular degree programs. The placeholder in the LIMIT clause represents the maximum number of degree programs to return.\"\n}\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant table: We need to retrieve last names of students, so we will focus on the 'Students' table.", "Filter students based on their address: We need to find students who live in North Carolina. This requires a subquery to the 'Addresses' table to get the 'address_id' for North Carolina.", "Exclude students who are enrolled in any degree programs: We need to ensure that these students have not registered in any degree programs, which requires another subquery to the 'Student_Enrolment' table to filter out those students.", "Combine the conditions: Use the results from the subqueries to filter the main query on the 'Students' table, ensuring we only select last names of students who meet both criteria."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "SELECT last_name \nFROM Students \nWHERE current_address_id IN (\n    SELECT address_id \n    FROM Addresses \n    WHERE state_province_county = 'North Carolina'\n) \nAND student_id NOT IN (\n    SELECT student_id \n    FROM Student_Enrolment\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\",\n    \"1\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile number.\",\n    \"2\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\"\n}\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table: The 'Students' table contains the information about students, including their names and mobile phone numbers.", "Determine the columns needed: We need the 'cell_mobile_number' column to get the mobile phone number of the student.", "Formulate the WHERE clause: We need to filter the results to find the student named 'Timmothy Ward'. This requires checking both the 'first_name' and 'last_name' columns.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to retrieve the desired mobile phone number."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\",\n    \"1\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile number.\",\n    \"2\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\"\n}\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["Identify the relevant tables: We need to find the address with the most students, so we will use the 'Addresses' and 'Students' tables.", "Join the 'Addresses' table with the 'Students' table on the current address ID to associate students with their addresses.", "Group the results by address ID to count the number of students associated with each address.", "Order the results by the count of students in descending order to find the address with the most students.", "Limit the results to 1 to get only the address with the highest count."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT a.address_id, a.line_1, a.line_2, a.line_3\nFROM Addresses a\nJOIN Students s ON a.address_id = s.current_address_id\nGROUP BY a.address_id\nORDER BY COUNT(s.student_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile number.\",\n    \"1\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\",\n    \"2\": \"This virtual table provides a list of students along with their first, middle, and last names, along with the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\"\n}\n"}
{"sample_id": "dev.578", "db_id": "student_transcripts_tracking", "question": "What are the different addresses that have students living there?", "rationale": ["We need to find different addresses where students live, which includes both current and permanent addresses.", "To achieve this, we will join the 'Addresses' table with the 'Students' table on the address IDs.", "We will use the 'current_address_id' and 'permanent_address_id' from the 'Students' table to match with 'address_id' in the 'Addresses' table.", "Using DISTINCT will ensure that we only get unique addresses, avoiding duplicates if a student has both current and permanent addresses in the same location."], "gold_sql": "SELECT count(DISTINCT current_address_id) FROM Students", "source_tables": ["students"], "pred_sql": "SELECT DISTINCT Addresses.* FROM Addresses JOIN Students ON Addresses.address_id = Students.current_address_id OR Addresses.address_id = Students.permanent_address_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\",\n    \"1\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile number.\"\n}\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve information about a section, we need to select all columns from the Sections table.", "We will use a WHERE clause to filter the results to only include the section where the section_name is 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT * FROM Sections WHERE section_name = 'h';", "hint": "\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms.", "Determine the condition: We need to count countries where the government form is 'Republic'.", "Construct the SQL query: Use the COUNT function to count the number of rows in the 'country' table that meet the specified condition."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(*) FROM country WHERE GovernmentForm = 'Republic';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"1\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"2\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\"\n}\n"}
{"sample_id": "dev.723", "db_id": "world_1", "question": "How many people live in Asia, and what is the largest GNP among them?", "rationale": ["Identify the continent of interest, which is Asia.", "To find the total population of Asia, we need to sum the population of all countries in Asia. This can be done using the SUM function on the Population column of the country table.", "To find the largest GNP among the countries in Asia, we can use the MAX function on the GNP column of the country table.", "We will filter the countries by the continent 'Asia' using a WHERE clause."], "gold_sql": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  'Asia'", "source_tables": ["country"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation, MAX(c.GNP) AS LargestGNP\nFROM country c\nWHERE c.Continent = 'Asia';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n    \"1\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n    \"2\": \"This virtual table provides a list of continents along with the count of countries that speak languages from those continents. The placeholder in the LIMIT clause allows the user to specify the maximum number of continents to retrieve based on the number of countries associated with each continent.\"\n}\n"}
{"sample_id": "dev.724", "db_id": "world_1", "question": "What is the average life expectancy in African countries that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains the life expectancy and government form information.", "Determine the conditions: We need to filter for countries in Africa and those that are republics.", "Use the AVG function: To calculate the average life expectancy, we will use the AVG() function on the LifeExpectancy column.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter the results accordingly."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT AVG(LifeExpectancy) AS AverageLifeExpectancy \nFROM country \nWHERE Continent = 'Africa' \nAND GovernmentForm LIKE '%Republic%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n    \"1\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"2\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\"\n}\n"}
{"sample_id": "dev.725", "db_id": "world_1", "question": "Give the average life expectancy for countries in Africa which are republics?", "rationale": ["Identify the relevant table: The 'country' table contains the information about countries, including life expectancy and government form.", "Determine the conditions: We need to filter countries that are in Africa and have a government form that includes 'Republic'.", "Use the AVG() function: To calculate the average life expectancy, we will use the AVG() function on the 'LifeExpectancy' column.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter the results accordingly."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT AVG(LifeExpectancy) AS AverageLifeExpectancy \nFROM country \nWHERE Continent = 'Africa' \nAND GovernmentForm LIKE '%Republic%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\"\n}\n"}
{"sample_id": "dev.731", "db_id": "world_1", "question": "Give the mean GNP and total population of nations which are considered US territory.", "rationale": ["Identify the countries that are considered US territories. These include Puerto Rico, Guam, American Samoa, and the U.S. Virgin Islands.", "To find the mean GNP and total population, we need to select from the 'country' table.", "We will use a subquery to filter the countries based on the cities that are US territories.", "The subquery will select the 'CountryCode' from the 'city' table where the city names match the US territories.", "Finally, we will calculate the average GNP and the sum of the population for the filtered countries."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT AVG(GNP) AS Mean_GNP, SUM(Population) AS Total_Population \nFROM country \nWHERE Code IN (SELECT CountryCode FROM city WHERE Name = 'Puerto Rico' OR Name = 'Guam' OR Name = 'American Samoa' OR Name = 'U.S. Virgin Islands');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n    \"1\": \"This virtual table calculates the total population of countries that do not have a specific language as an official language. The placeholder in the subquery represents the language name that is being checked against the countries.\",\n    \"2\": \"This virtual table provides a list of continents along with the count of countries that speak languages from those continents. The placeholder in the LIMIT clause allows the user to specify the maximum number of continents to retrieve based on the number of countries associated with each continent.\"\n}\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the table that contains information about countries and their government forms, which is the 'country' table.", "We need to count the distinct forms of government, so we will use the COUNT(DISTINCT ...) function.", "We need to filter the results to only include countries in Africa, which can be done using a WHERE clause that checks the 'Continent' column for 'Africa'.", "Combine these elements to form the SQL query that counts the different forms of government in Africa."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(DISTINCT GovernmentForm) AS DifferentGovernmentForms\nFROM country\nWHERE Continent = 'Africa';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"1\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"2\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\"\n}\n"}
{"sample_id": "dev.754", "db_id": "world_1", "question": "What are the countries where either English or Dutch is the official language ?", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find the countries with specific official languages.", "Determine the criteria: We are interested in countries where either English or Dutch is an official language.", "Use a JOIN: We will join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' fields to link countries with their languages.", "Filter the results: We will use a WHERE clause to filter for languages that are either 'English' or 'Dutch' and ensure that the language is marked as official (IsOfficial = 'T').", "Select distinct country names: We want to ensure that we get unique country names, so we will use DISTINCT in our SELECT statement."], "gold_sql": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'english' and isofficial  =  't' union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'dutch' and isofficial  =  't'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT country.Name \nFROM country \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE countrylanguage.Language IN ('English', 'Dutch') AND countrylanguage.IsOfficial = 'T';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\",\n    \"1\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n    \"2\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\"\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["We need to find countries that have either English or Dutch as an official language.", "To do this, we will join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' columns respectively.", "We will filter the results using a WHERE clause to check if the 'Language' is either 'English' or 'Dutch'.", "Additionally, we will ensure that the language is marked as official by checking that 'IsOfficial' is 'T'.", "Finally, we will select distinct country names to avoid duplicates in the results."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT country.Name \nFROM country \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE countrylanguage.Language IN ('English', 'Dutch') AND countrylanguage.IsOfficial = 'T';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n    \"1\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\",\n    \"2\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\"\n}\n"}
{"sample_id": "dev.758", "db_id": "world_1", "question": "Which languages are spoken by only one country in republic governments?", "rationale": ["Identify the relevant tables: countrylanguage for languages and country for government forms.", "Join the countrylanguage table with the country table on the CountryCode to access government forms.", "Filter the results to include only official languages (IsOfficial = 'T') and countries with a republican form of government.", "Group the results by language to count how many countries speak each language.", "Use the HAVING clause to filter for languages that are spoken in exactly one country (COUNT(DISTINCT c.Code) = 1)."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl.Language \nFROM countrylanguage cl \nJOIN country c ON cl.CountryCode = c.Code \nWHERE cl.IsOfficial = 'T' \nAND c.GovernmentForm = 'Republic' \nGROUP BY cl.Language \nHAVING COUNT(DISTINCT c.Code) = 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\",\n    \"1\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n    \"2\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\"\n}\n"}
{"sample_id": "dev.759", "db_id": "world_1", "question": "What languages are only used by a single country with a republic government?", "rationale": ["Identify the relevant tables: We need to look at the 'countrylanguage' table for languages and the 'country' table for government forms.", "Join the 'countrylanguage' table with the 'country' table on the CountryCode to access both languages and their corresponding countries.", "Filter the results to include only official languages (IsOfficial = 'T') and countries with a republic government (GovernmentForm = 'Republic').", "Group the results by language to count how many distinct countries speak each language.", "Use the HAVING clause to filter the grouped results to only include languages that are spoken in exactly one country (COUNT(DISTINCT c.Code) = 1)."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl.Language\nFROM countrylanguage cl\nJOIN country c ON cl.CountryCode = c.Code\nWHERE cl.IsOfficial = 'T' AND c.GovernmentForm = 'Republic'\nGROUP BY cl.Language\nHAVING COUNT(DISTINCT c.Code) = 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"1\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"2\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\"\n}\n"}
{"sample_id": "dev.760", "db_id": "world_1", "question": "Find the city with the largest population that uses English.", "rationale": ["Identify the relevant tables: city, country, and countrylanguage.", "We need to find cities that have English as a spoken language, so we will join the city table with the countrylanguage table on the country code.", "We also need to join the country table to get the country code for the cities.", "Filter the results to only include rows where the language is 'English'.", "To find the city with the largest population, we will order the results by the Population column in descending order.", "Finally, we will limit the results to only return the top result, which will be the city with the largest population that speaks English."], "gold_sql": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  'English' ORDER BY T1.Population DESC LIMIT 1", "source_tables": ["city", "countrylanguage"], "pred_sql": "SELECT city.Name, city.Population \nFROM city \nJOIN country ON city.CountryCode = country.Code \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE countrylanguage.Language = 'English' \nORDER BY city.Population DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n    \"1\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n    \"2\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\"\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the requirement: We need to find the total population of countries that do not use English as an official language.", "To achieve this, we will first identify the countries that have English as an official language using the countrylanguage table.", "We will use a subquery to select the CountryCode of countries where Language is 'English' and IsOfficial is 'T'.", "Next, we will sum the Population from the country table for those countries whose Code is not in the list obtained from the subquery.", "The final SQL query will sum the populations of all countries excluding those that have English as an official language."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(Population) \nFROM country \nWHERE Code NOT IN (\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language = 'English' AND IsOfficial = 'T'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total population of countries that do not have a specific language as an official language. The placeholder in the subquery represents the language name that is being checked against the countries.\",\n    \"1\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n    \"2\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\"\n}\n"}
{"sample_id": "dev.774", "db_id": "world_1", "question": "What are the African countries that have a  population less than any country in Asia?", "rationale": ["Identify the countries in Africa by filtering the 'country' table where the 'Continent' is 'Africa'.", "Determine the maximum population of countries in Asia by using a subquery that selects the maximum 'Population' from the 'country' table where the 'Continent' is 'Asia'.", "Combine these two conditions to find African countries whose population is less than the maximum population of any Asian country."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Africa'  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  'Asia')", "source_tables": ["country"], "pred_sql": "SELECT Name FROM country WHERE Continent = 'Africa' AND Population < (SELECT MAX(Population) FROM country WHERE Continent = 'Asia');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total population of countries that do not have a specific language as an official language. The placeholder in the subquery represents the language name that is being checked against the countries.\",\n    \"1\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n    \"2\": \"This virtual table provides a list of continents along with the count of countries that speak languages from those continents. The placeholder in the LIMIT clause allows the user to specify the maximum number of continents to retrieve based on the number of countries associated with each continent.\"\n}\n"}
{"sample_id": "dev.777", "db_id": "world_1", "question": "What are the Asian countries which have a population larger than that of any country in Africa?", "rationale": ["Identify the countries in Asia by filtering the 'country' table for 'Continent' = 'Asia'.", "Determine the population of these Asian countries by selecting the 'Population' column.", "To find countries in Asia with a population larger than any country in Africa, we need to compare their populations to the maximum population of countries in Africa.", "Use a subquery to select the maximum population from the 'country' table where 'Continent' = 'Africa'.", "Combine these conditions in a SQL SELECT statement to retrieve the names of the Asian countries that meet the criteria."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Asia'  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  'Africa')", "source_tables": ["country"], "pred_sql": "SELECT Name FROM country WHERE Continent = 'Asia' AND Population > (SELECT MAX(Population) FROM country WHERE Continent = 'Africa');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n    \"1\": \"This virtual table provides a list of continents along with the count of countries that speak languages from those continents. The placeholder in the LIMIT clause allows the user to specify the maximum number of continents to retrieve based on the number of countries associated with each continent.\",\n    \"2\": \"This virtual table provides a list of continents along with the count of countries that speak languages from those continents. The placeholder in the LIMIT clause allows the user to specify the maximum number of continents to retrieve based on the number of countries speaking languages from each continent.\"\n}\n"}
{"sample_id": "dev.778", "db_id": "world_1", "question": "What are the country codes for countries that do not speak English?", "rationale": ["Identify the main requirement: to find country codes for countries that do not speak English.", "Understand that we need to look at the 'country' table for country codes.", "We need to exclude countries that have English as an official language, which is found in the 'countrylanguage' table.", "Construct a subquery to select CountryCode from 'countrylanguage' where Language is 'English'.", "Use the NOT IN clause to filter out these country codes from the main query on the 'country' table."], "gold_sql": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["countrylanguage"], "pred_sql": "SELECT DISTINCT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"1\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"2\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\"\n}\n"}
{"sample_id": "dev.786", "db_id": "world_1", "question": "Which unique cities are in Asian countries where Chinese is the official language ?", "rationale": ["Identify the tables needed: city, country, and countrylanguage.", "We need to find unique cities, so we will use SELECT DISTINCT on city.Name.", "We need to join the city table with the country table on CountryCode to get the continent information.", "We also need to join the country table with the countrylanguage table to filter by the language spoken.", "The WHERE clause will filter for countries in Asia and where Chinese is an official language."], "gold_sql": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  't' and t2.language  =  'chinese' and t1.continent  =  'asia'", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT DISTINCT city.Name \nFROM city \nJOIN country ON city.CountryCode = country.Code \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE country.Continent = 'Asia' \nAND countrylanguage.Language = 'Chinese' \nAND countrylanguage.IsOfficial = 'T';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\",\n    \"1\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n    \"2\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\"\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the required fields: Name, year of independence (IndepYear), and surface area (SurfaceArea) from the country table.", "Determine the condition to find the country with the lowest population, which involves using a subquery to get the minimum population from the country table.", "Construct the SQL query to select the specified fields from the country table where the population matches the minimum population found in the subquery."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n    \"1\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"2\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\"\n}\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["We need to find countries that speak more than 2 languages.", "To do this, we will join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' columns respectively.", "We will select the country name from the 'country' table and count the number of languages from the 'countrylanguage' table.", "We will group the results by country name to aggregate the language counts.", "Finally, we will use the HAVING clause to filter the results to only include countries that have more than 2 languages spoken."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Name, COUNT(cl.Language) AS LanguageCount\nFROM country c\nJOIN countrylanguage cl ON c.Code = cl.CountryCode\nGROUP BY c.Name\nHAVING COUNT(cl.Language) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n    \"1\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\",\n    \"2\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\"\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the relevant table: The 'country' table contains the columns for GovernmentForm, Population, and LifeExpectancy.", "Filter the countries based on the condition: We need countries with an average LifeExpectancy greater than 72.", "Group the results by GovernmentForm to get the total population for each form of government.", "Use the SUM function to calculate the total population for each government form."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation\nFROM country\nWHERE LifeExpectancy > 72\nGROUP BY GovernmentForm;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"1\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n    \"2\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\"\n}\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the table to query: The 'city' table contains the population data.", "Determine the condition: We need to find cities with a population between 160000 and 900000.", "Construct the SQL query: Use the SELECT statement to retrieve all columns from the 'city' table where the population falls within the specified range using the BETWEEN clause."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT * FROM city WHERE Population BETWEEN '160000' AND '900000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\"\n}\n"}
{"sample_id": "dev.820", "db_id": "world_1", "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?", "rationale": ["Identify the relevant table: countrylanguage, which contains information about languages spoken in countries.", "Filter the records to only include those where the Language is 'Spanish'.", "Order the results by the Percentage column in descending order to get the countries where Spanish is spoken by the largest percentage of people.", "Select the CountryCode from the filtered and ordered results."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "pred_sql": "SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' ORDER BY Percentage DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n    \"1\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n    \"2\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\"\n}\n"}
{"sample_id": "dev.821", "db_id": "world_1", "question": "Return the codes of countries for which Spanish is the predominantly spoken language.", "rationale": ["Identify the table that contains language information: countrylanguage.", "We need to find countries where Spanish is predominantly spoken, which implies that it should be an official language and spoken by a significant percentage of the population.", "The query should select the CountryCode from the countrylanguage table where the Language is 'Spanish' and the Percentage is greater than 50, indicating that it is predominantly spoken."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "pred_sql": "SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' AND Percentage > 50;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table counts the number of countries that have two specific languages spoken within them. The placeholders in the query represent the names of the languages being compared.\",\n    \"1\": \"This virtual table identifies countries where two specific languages are spoken. The placeholders in the WHERE clause represent the names of the languages being queried.\",\n    \"2\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\"\n}\n"}
{"sample_id": "dev.920", "db_id": "dog_kennels", "question": "What is the average age of the dogs who have gone through any treatments?", "rationale": ["Identify the main goal: Calculate the average age of dogs that have received treatments.", "Determine the relevant tables: 'Dogs' for dog information and 'Treatments' for treatment records.", "Use a subquery to find all dog_ids from the 'Treatments' table, which indicates which dogs have received treatments.", "Filter the 'Dogs' table using the list of dog_ids obtained from the subquery to calculate the average age of those dogs."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT AVG(age) AS average_age\nFROM Dogs\nWHERE dog_id IN (\n    SELECT dog_id\n    FROM Treatments\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers if needed.\",\n    \"1\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\",\n    \"2\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum allowable total treatment cost.\"\n}\n"}
{"sample_id": "dev.936", "db_id": "dog_kennels", "question": "Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.", "rationale": ["Identify the relevant tables: Owners, Dogs, and Treatments.", "Join the Owners table with the Dogs table using the owner_id to link owners to their dogs.", "Join the resulting table with the Treatments table using the dog_id to link treatments to the respective dogs.", "Group the results by owner_id and last_name to aggregate treatment costs for each owner.", "Use SUM to calculate the total cost of treatments for each owner.", "Order the results in descending order based on the total treatment cost to find the owner who has paid the most.", "Limit the results to 1 to get only the top owner."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT Owners.owner_id, Owners.last_name\nFROM Owners\nJOIN Dogs ON Owners.owner_id = Dogs.owner_id\nJOIN Treatments ON Dogs.dog_id = Treatments.dog_id\nGROUP BY Owners.owner_id, Owners.last_name\nORDER BY SUM(Treatments.cost_of_treatment) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n    \"1\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum allowable total treatment cost.\",\n    \"2\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\"\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["Identify the relevant tables: Treatments and Professionals.", "We need to join the Treatments table with the Professionals table to get the professional's details along with their treatment records.", "We will group the results by professional_id to count the number of distinct treatment types each professional has administered.", "The HAVING clause will filter the groups to include only those professionals who have administered at least two different types of treatments."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT professional_id, cell_number\nFROM Treatments\nJOIN Professionals ON Treatments.professional_id = Professionals.professional_id\nGROUP BY professional_id\nHAVING COUNT(DISTINCT treatment_type_code) >= 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of professionals along with their cell numbers from the 'Professionals' table who have administered a specified number of treatments. The placeholder in the HAVING clause represents the minimum count of treatments that a professional must have administered.\",\n    \"1\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\",\n    \"2\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\"\n}\n"}
{"sample_id": "dev.944", "db_id": "dog_kennels", "question": "What are the first name and last name of the professionals who have done treatment with cost below average?", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "Determine the required fields: first_name and last_name from the Professionals table.", "Calculate the average treatment cost using the AVG function on the cost_of_treatment field in the Treatments table.", "Filter the professionals who have administered treatments with costs below this average.", "Use a subquery to find professional_ids from the Treatments table where the cost_of_treatment is less than the average.", "Join the results of the subquery with the Professionals table to get the first and last names of the relevant professionals."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT first_name, last_name \nFROM Professionals \nWHERE professional_id IN (\n    SELECT professional_id \n    FROM Treatments \n    WHERE cost_of_treatment < (\n        SELECT AVG(cost_of_treatment) \n        FROM Treatments\n    )\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\",\n    \"1\": \"This virtual table provides a list of professionals along with their cell numbers from the 'Professionals' table who have administered a specified number of treatments. The placeholder in the HAVING clause represents the minimum count of treatments that a professional must have administered.\",\n    \"2\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum allowable total treatment cost.\"\n}\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["Identify the tables needed: Owners, Dogs, and Sizes.", "Select the required columns: first_name and last_name from Owners, and size_description from Sizes.", "Join the Owners table with the Dogs table on owner_id to link each dog to its owner.", "Join the Dogs table with the Sizes table on size_code to get the size description of each dog.", "Construct the SQL SELECT statement to retrieve the desired information."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n    \"1\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\",\n    \"2\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers if needed.\"\n}\n"}
{"sample_id": "dev.951", "db_id": "dog_kennels", "question": "What are each owner's first name, last name, and the size of their dog?", "rationale": ["Identify the required information: owner's first name, last name, and dog's size.", "Determine the relevant tables: Owners, Dogs, and Sizes.", "Establish the relationships between the tables: Owners are linked to Dogs via owner_id, and Dogs are linked to Sizes via size_code.", "Construct the SQL SELECT statement to retrieve the desired columns from the Owners and Sizes tables, while joining the Dogs table to connect them."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n    \"1\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\",\n    \"2\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers if needed.\"\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "Determine the columns needed: arriving date (date_arrived) and departing date (date_departed) from Dogs.", "Establish the relationship between Dogs and Treatments using the dog_id foreign key.", "Construct the SQL query to select the required columns from Dogs while joining with Treatments to filter only those dogs that have undergone treatment."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.date_arrived, d.date_departed \nFROM Dogs d \nJOIN Treatments t ON d.dog_id = t.dog_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\",\n    \"1\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum allowable total treatment cost.\",\n    \"2\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers if needed.\"\n}\n"}
{"sample_id": "dev.961", "db_id": "dog_kennels", "question": "Who owns the youngest dog? Give me his or her last name.", "rationale": ["Identify the tables involved: Owners and Dogs.", "We need to find the last name of the owner of the youngest dog, so we will join the Owners table with the Dogs table on the owner_id.", "To find the youngest dog, we need to filter the Dogs table by the minimum age. This can be done using a subquery that selects the minimum age from the Dogs table.", "Finally, we select the last name of the owner from the Owners table where the dog's age matches the minimum age found in the subquery."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.last_name\nFROM Owners\nJOIN Dogs ON Owners.owner_id = Dogs.owner_id\nWHERE Dogs.age = (\n    SELECT MIN(age)\n    FROM Dogs\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n    \"1\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers if needed.\",\n    \"2\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\"\n}\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["Identify the tables needed: Dogs, Breeds, and Sizes.", "We need to get distinct combinations of breed types and size types, so we will select breed names from the Breeds table and size descriptions from the Sizes table.", "Join the Dogs table with the Breeds table on the breed_code to get the breed names.", "Join the Dogs table with the Sizes table on the size_code to get the size descriptions.", "Use SELECT DISTINCT to ensure that we only get unique combinations of breed names and size descriptions."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT B.breed_name, S.size_description\nFROM Dogs D\nJOIN Breeds B ON D.breed_code = B.breed_code\nJOIN Sizes S ON D.size_code = S.size_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\",\n    \"1\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers if needed.\",\n    \"2\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\"\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["Identify the tables needed: We need information from the 'Professionals' table for the first names and from the 'Treatment_Types' table for the treatment descriptions.", "Determine the relationship between the tables: The 'Treatments' table links 'Professionals' and 'Treatment_Types' through their respective IDs.", "Construct the SQL query: We will select the first name from 'Professionals' and the treatment description from 'Treatment_Types', joining these tables on their respective keys."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT Professionals.first_name, Treatment_Types.treatment_type_description\nFROM Treatments\nJOIN Professionals ON Treatments.professional_id = Professionals.professional_id\nJOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\",\n    \"1\": \"This virtual table provides a list of professionals along with their cell numbers from the 'Professionals' table who have administered a specified number of treatments. The placeholder in the HAVING clause represents the minimum count of treatments that a professional must have administered.\",\n    \"2\": \"This virtual table provides the names of dogs along with the dates of their treatments from the 'Dogs' and 'Treatments' tables. It filters the results to include only those dogs that belong to the least common breed, as determined by counting the occurrences of each breed and limiting the results to a specified number.\"\n}\n"}
