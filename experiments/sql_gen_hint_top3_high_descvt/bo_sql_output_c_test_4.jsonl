{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["Identify the relevant table: The question asks for information about staff assignments, so we will use the Staff_Department_Assignments table.", "Select the required columns: We need the staff_id and staff_name, but staff_name is in the Staff table, so we will need to join it with the Staff table.", "Determine the ordering: We want to find the staff member who has been assigned for the least amount of time, which means we should order by the date_assigned_from column in ascending order.", "Limit the results: Since we only want the staff member with the least assignment time, we will limit the results to 1."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name \nFROM Staff_Department_Assignments \nORDER BY date_assigned_from ASC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4753", "db_id": "department_store", "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.", "rationale": ["Identify the relevant tables: Customers and Customer_Orders.", "We need to find distinct customer IDs, so we will select from the Customers table.", "Join the Customers table with the Customer_Orders table on customer_id to link customers with their orders.", "We need to filter customers who made orders after some orders that were cancelled. This means we need to find orders that have a status of 'Cancelled'.", "Use a subquery to select order_ids from Customer_Orders where the order_status_code is 'Cancelled'.", "The main query will select distinct customer_ids from Customers where their order_ids are in the list of cancelled order_ids."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "pred_sql": "SELECT DISTINCT C.customer_id \nFROM Customers C \nJOIN Customer_Orders CO ON C.customer_id = CO.customer_id \nWHERE CO.order_id IN (\n    SELECT CO2.order_id \n    FROM Customer_Orders CO2 \n    WHERE CO2.order_status_code = 'Cancelled'\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\",\n        \"virtual_table\": \"SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4755", "db_id": "department_store", "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?", "rationale": ["Identify the relevant table: Staff_Department_Assignments contains the staff assignments and their dates.", "Determine the condition: We need to find staff who were assigned to a department earlier than any Clerical Staff.", "Use a subquery to find the earliest assignment date of Clerical Staff: SELECT MIN(date_assigned_from) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical'.", "Construct the main query to select staff_id from Staff_Department_Assignments where their assignment date is earlier than the result of the subquery."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "pred_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_from < (SELECT MIN(date_assigned_from) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical')", "hint": "\n"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["Identify the relevant table: The 'Customers' table contains the customer information including their addresses.", "Determine the required fields: We need to retrieve 'customer_id' and 'customer_name'.", "Formulate the WHERE clause: We need to filter customers based on their address containing 'TN'.", "Use the LIKE operator to search for 'TN' in the 'customer_address' field, ensuring to use wildcards (%) to match any characters before or after 'TN'.", "Combine these elements into a complete SQL SELECT statement."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name FROM Customers WHERE customer_address LIKE '%TN%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\",\n        \"virtual_table\": \"SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4760", "db_id": "department_store", "question": "What are the names and genders of staff who were assigned in 2016?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "We need to retrieve the names and genders of staff members, which are in the Staff table.", "To find out which staff were assigned in 2016, we need to join the Staff table with the Staff_Department_Assignments table on staff_id.", "Filter the results based on the date range for the year 2016, using the date_assigned_from and date_assigned_to columns."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name, staff_gender \nFROM Staff \nJOIN Staff_Department_Assignments ON Staff.staff_id = Staff_Department_Assignments.staff_id \nWHERE date_assigned_from >= '2016-01-01' AND date_assigned_to <= '2016-12-31';", "hint": "\n"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "We need to find staff members who have been assigned multiple jobs, which implies looking for staff members with multiple distinct job titles.", "Join the Staff table with the Staff_Department_Assignments table on staff_id to get the job assignments for each staff member.", "Group the results by staff_id to aggregate the job assignments for each staff member.", "Use the HAVING clause to filter groups where the count of distinct job titles (job_title_code) is greater than 1."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name\nFROM Staff\nJOIN Staff_Department_Assignments ON Staff.staff_id = Staff_Department_Assignments.staff_id\nGROUP BY Staff.staff_id\nHAVING COUNT(DISTINCT job_title_code) > 1;", "hint": "\n"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["Identify the relevant table: Customers, which contains customer_id, customer_name, and payment_method_code.", "Filter customers based on their address: Use the LIKE operator to find addresses containing 'WY'.", "Exclude customers using a credit card: Use the NOT EQUAL operator to filter out those with payment_method_code as 'CREDIT_CARD'.", "Combine these conditions in the WHERE clause of the SQL query."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name FROM Customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'CREDIT_CARD'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\",\n        \"virtual_table\": \"SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4793", "db_id": "department_store", "question": "Find the average price of all product clothes.", "rationale": ["Identify the table that contains product information, which is the 'Products' table.", "Determine the relevant column for price, which is 'product_price'.", "To find the average price, use the AVG() function.", "Filter the products to only include those that are classified as clothes by using a WHERE clause on 'product_type_code'.", "Assume 'clothes' is represented by a specific code in 'product_type_code', which I will use as 'clothes' for this query."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "pred_sql": "SELECT AVG(product_price) AS average_price\nFROM Products\nWHERE product_type_code = 'clothes';", "hint": "\n"}
{"sample_id": "train.4795", "db_id": "department_store", "question": "Find the name of the most expensive hardware product.", "rationale": ["Identify the relevant table: Products, which contains product information including name and price.", "Filter the products to only include those that are classified as 'hardware'.", "Sort the filtered products by price in descending order to get the most expensive one at the top.", "Limit the results to 1 to retrieve only the most expensive hardware product."], "gold_sql": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1", "source_tables": ["products"], "pred_sql": "SELECT product_name FROM Products WHERE product_type_code = 'hardware' ORDER BY product_price DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["We need to find the maximum page sizes that have more than 3 products listed.", "To do this, we will group the results by 'max_page_size' from the 'product' table.", "We will use the HAVING clause to filter groups that have a count of products greater than 3."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING COUNT(product_id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4903", "db_id": "store_product", "question": "What is the maximum page size for everything that has more than 3 products listed?", "rationale": ["Identify the requirement: We need to find the maximum page size for products that have more than 3 listings in stores.", "To achieve this, we will first identify products that are listed in more than 3 stores. This can be done using the 'store_product' table, grouping by 'Product_ID' and using the HAVING clause to filter those with a count of Store_ID greater than 3.", "Next, we will select the 'max_page_size' from the 'product' table for those identified products. We will use a subquery to get the list of product IDs that meet the criteria from the 'store_product' table.", "The final SQL query combines these steps to retrieve the maximum page size for the relevant products."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size FROM product WHERE product_id IN (SELECT Product_ID FROM store_product GROUP BY Product_ID HAVING COUNT(Store_ID) > 3)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4913", "db_id": "store_product", "question": "What is the total number of residents for the districts with the 3 largest areas?", "rationale": ["Identify the requirement: We need to find the total number of residents in the districts with the 3 largest areas.", "To achieve this, we will first need to identify the districts with the largest areas. This can be done by ordering the districts based on the 'City_Area' column in descending order and limiting the results to the top 3.", "Once we have the top 3 districts, we can then sum their populations. This requires a subquery that selects the 'District_ID' of these top districts.", "Finally, we will use the SUM function to calculate the total population from the 'City_Population' column for these districts."], "gold_sql": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3", "source_tables": ["district"], "pred_sql": "SELECT SUM(City_Population) AS Total_Residents\nFROM district\nWHERE District_ID IN (\n    SELECT District_ID\n    FROM district\n    ORDER BY City_Area DESC\n    LIMIT 3\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\",\n        \"virtual_table\": \"SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["Identify the relevant tables: store, store_district, and district are needed to find store names based on district.", "Join the store table with the store_district table on Store_ID to link stores with their respective districts.", "Join the resulting table with the district table on District_ID to access district names.", "Filter the results where the district name is 'Khanewal' to get only the stores located in that district."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT s.Store_Name \nFROM store AS s \nJOIN store_district AS sd ON s.Store_ID = sd.Store_ID \nJOIN district AS d ON sd.District_ID = d.District_ID \nWHERE d.District_name = 'Khanewal';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\",\n        \"virtual_table\": \"SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of districts that have stores of a specific type, ensuring that only districts with stores of the same type are returned. The placeholders in the WHERE clause represent the type of store being queried.\",\n        \"virtual_table\": \"SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["To find the city with the most number of stores, we need to join the relevant tables: district, store_district, and store.", "We will join the store_district table with the district table to get the district names associated with each store.", "Next, we will join the store table to count the number of stores in each district.", "We will group the results by district name to aggregate the count of stores per district.", "Finally, we will order the results in descending order based on the count of stores and limit the result to 1 to get the district with the most stores."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT d.District_name\nFROM district AS d\nJOIN store_district AS sd ON d.District_ID = sd.District_ID\nJOIN store AS s ON sd.Store_ID = s.Store_ID\nGROUP BY d.District_name\nORDER BY COUNT(s.Store_ID) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\",\n        \"virtual_table\": \"SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of districts that have stores of a specific type, ensuring that only districts with stores of the same type are returned. The placeholders in the WHERE clause represent the type of store being queried.\",\n        \"virtual_table\": \"SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4930", "db_id": "store_product", "question": "Find products with max page size as \"A4\" and pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to filter products based on two conditions: max_page_size should be 'A4' and pages_per_minute_color should be less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table where the specified conditions are met."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' AND pages_per_minute_color < '5';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4932", "db_id": "store_product", "question": "Find products with max page size as \"A4\" or pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to find products where the max page size is 'A4' or the pages per minute for color is less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table that meet either of the specified conditions."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4935", "db_id": "store_product", "question": "What are all of the products whose name includes the substring \"Scanner\"?", "rationale": ["Identify the table that contains product names: the 'product' table.", "Determine the condition to filter products based on their names: we need to find products whose names include the substring 'Scanner'.", "Use the SQL LIKE operator with wildcards (%) to match any characters before and after 'Scanner'.", "Construct the SQL query using the SELECT statement to retrieve the product names that meet the condition."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\",\n        \"virtual_table\": \"SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4937", "db_id": "store_product", "question": "What is the most common maximum page size?", "rationale": ["Identify the column of interest: 'max_page_size' from the 'product' table.", "To find the most common maximum page size, we need to group the results by 'max_page_size'.", "Use the COUNT function to count occurrences of each 'max_page_size'.", "Order the results in descending order based on the count to get the most common size at the top.", "Limit the results to 1 to get only the most common maximum page size."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1", "source_tables": ["product"], "pred_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4938", "db_id": "store_product", "question": "Find the name of the products that are not using the most frequently-used max page size.", "rationale": ["Identify the most frequently-used max page size by grouping the products by 'max_page_size' and counting occurrences.", "Order the results by count in descending order to find the most common max page size.", "Limit the results to 1 to get only the most frequently-used max page size.", "Select products from the 'product' table where their 'max_page_size' is not equal to the most common one identified in the subquery."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE max_page_size != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["The question asks for the average number of students enrolled in each college.", "To find the average enrollment, we can use the AVG() function on the 'enr' column from the 'College' table.", "We need to select the average enrollment without grouping by college since we want the overall average across all colleges.", "The final SQL query will be: SELECT AVG(enr) AS average_enrollment FROM College."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "pred_sql": "SELECT AVG(enr) AS average_enrollment FROM College", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of colleges located in a specific state that have an enrollment number either less than or greater than a specified value. The placeholders in the WHERE clauses represent the enrollment numbers and the state name.\",\n        \"virtual_table\": \"SELECT cName FROM College WHERE enr  <  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING] UNION SELECT cName FROM College WHERE enr  >  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["The question asks for the average training hours of players.", "To calculate the average, we need to use the AVG() function in SQL.", "We assume there is a column 'training_hours' in the Player table that stores the training hours for each player.", "The SQL query will select the average of the 'training_hours' column from the Player table."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_training_hours FROM Player", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4956", "db_id": "soccer_2", "question": "Find the name and training hours of players whose hours are below 1500.", "rationale": ["Identify the relevant tables: Player table contains player information including names and hours.", "Determine the columns needed: We need the player's name (pName) and their training hours.", "Apply the condition: We need to filter players whose training hours are below 1500.", "Construct the SQL query using SELECT to retrieve the required columns from the Player table with the specified condition."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "pred_sql": "SELECT pName, hours FROM Player WHERE hours < 1500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4961", "db_id": "soccer_2", "question": "What are the different types of player positions?", "rationale": ["The question asks for the different types of player positions.", "To find the unique player positions, we can use the DISTINCT keyword.", "We will select the 'pPos' column from the 'Tryout' table, which contains the player positions."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT pPos FROM Tryout", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["The question asks for the number of students accepted after the tryout.", "To find this, we need to count the entries in the Tryout table where the decision is 'accepted'.", "The SQL query uses the COUNT() function to count the number of rows that meet this condition."], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) FROM Tryout WHERE decision = 'accepted';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["The task is to find the maximum, average, and minimum training hours of all players.", "Since the schema does not explicitly mention a 'training_hours' column, we assume it is a derived or calculated field based on player data.", "To calculate these statistics, we will use aggregate functions: MAX(), AVG(), and MIN().", "We will select these aggregate values from the Player table, as it contains the relevant player data."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT MAX(training_hours) AS max_hours, AVG(training_hours) AS avg_hours, MIN(training_hours) AS min_hours FROM Player", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4967", "db_id": "soccer_2", "question": "What is the average, maximum, and minimum for the number of hours spent training?", "rationale": ["The question asks for the average, maximum, and minimum hours spent training.", "To calculate these statistics, we need to use aggregate functions: AVG() for average, MAX() for maximum, and MIN() for minimum.", "We assume there is a table named 'training_data' that contains a column 'training_hours' which records the hours spent training by players.", "The SQL query will select the average, maximum, and minimum of the 'training_hours' column from the 'training_data' table."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_hours, MAX(training_hours) AS max_hours, MIN(training_hours) AS min_hours FROM training_data;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    }\n}\n"}
{"sample_id": "train.4970", "db_id": "soccer_2", "question": "What are the names of players whose training hours is between 500 and 1500?", "rationale": ["Identify the relevant table: The question asks for player names, so we will focus on the Player table.", "Determine the condition: The question specifies a range for training hours (between 500 and 1500).", "Assume there is a column for training hours in the Player table, which is not explicitly mentioned in the schema provided. We will use 'training_hours' as a placeholder.", "Construct the SQL query using the SELECT statement to retrieve player names that meet the training hours condition."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE training_hours BETWEEN 500 AND 1500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4971", "db_id": "soccer_2", "question": "What are the names of players who train between 500 and 1500 hours?", "rationale": ["Identify the relevant table for player information, which is the Player table.", "Determine the criteria for filtering players based on training hours, which is between 500 and 1500 hours.", "Since the training hours are not directly available in the schema, assume that there is a way to filter players based on their tryout decisions (e.g., accepted players).", "Construct a subquery to select player IDs from the Tryout table where the decision is 'Accepted'.", "Combine the results of the subquery with the Player table to get the names of players who meet the criteria."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE decision = 'Accepted') AND hours BETWEEN 500 AND 1500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4975", "db_id": "soccer_2", "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?", "rationale": ["Identify the relevant table: The 'College' table contains the necessary information about college names and enrollment numbers.", "Determine the conditions: We need colleges with an enrollment number greater than 10000 and located in Louisiana.", "Construct the SQL query: Use a SELECT statement to retrieve 'cName' and 'enr' from the 'College' table, applying the specified conditions in the WHERE clause."], "gold_sql": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = 'LA'", "source_tables": ["college"], "pred_sql": "SELECT cName, enr FROM College WHERE enr > 10000 AND state = 'Louisiana'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of colleges located in a specific state that have an enrollment number either less than or greater than a specified value. The placeholders in the WHERE clauses represent the enrollment numbers and the state name.\",\n        \"virtual_table\": \"SELECT cName FROM College WHERE enr  <  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING] UNION SELECT cName FROM College WHERE enr  >  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of colleges from the 'College' table that have an enrollment number greater than the minimum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\",\n        \"virtual_table\": \"SELECT DISTINCT cName FROM college WHERE enr  >  (SELECT min(enr) FROM college WHERE state  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    }\n}\n"}
{"sample_id": "train.4981", "db_id": "soccer_2", "question": "What are the name of the players who received a card in descending order of the hours of training?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to select the names of players, which is in the Player table under the column 'pName'.", "The players' eligibility or card year is not directly needed for this query, but we will join the Player table with the Tryout table to access the decision made regarding their tryout.", "The join condition is based on the player ID (pID) which is common in both tables.", "To get the names of players in descending order, we will use the ORDER BY clause on the decision column from the Tryout table."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player JOIN Tryout ON Player.pID = Tryout.pID ORDER BY Tryout.decision DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["To find the most popular position among players in the tryout, we need to count how many players are trying out for each position.", "We will use the COUNT function to count the number of players for each position in the Tryout table.", "We will group the results by the position (pPos) to get the count for each position.", "Finally, we will order the results in descending order based on the count and limit the results to 1 to get the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count FROM Tryout GROUP BY pPos ORDER BY position_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["To find the most popular position at tryouts, we need to count how many players tried out for each position.", "We will use the COUNT function to count the number of occurrences of each position in the Tryout table.", "We will group the results by the position (pPos) to get the count for each position.", "To determine which position is the most popular, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one entry to get the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["The question asks for the minimum hours of students playing in different positions.", "To find the minimum hours, we need to count the number of tryouts (which can be considered as hours played) for each player in each position.", "We can achieve this by grouping the tryout records by player ID and position, and counting the number of records for each group.", "Next, we need to find the minimum count of hours for each position.", "This can be done by wrapping the previous query in another SELECT statement that groups by position and uses the MIN function."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(hours) AS min_hours FROM (SELECT pPos, COUNT(*) AS hours FROM tryout GROUP BY pID, pPos) GROUP BY pPos;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["Identify the relevant tables: We need to find the minimum time students spent practicing for each position, which suggests we need a table that records practice times and player positions.", "Assume there is a table named 'practice_sessions' that records practice times along with player positions. This table would likely have columns like 'pID', 'pPos', and 'practice_time'.", "To find the minimum practice time for each position, we can use the MIN() function in SQL.", "We will group the results by 'pPos' to get the minimum practice time for each position.", "The final SQL query will select the position and the minimum practice time from the 'practice_sessions' table, grouped by position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(practice_time) AS min_practice_time FROM practice_sessions GROUP BY pPos", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    }\n}\n"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["Identify the tables involved: Player and Tryout.", "We need the names of students, which are in the Player table under the column pName.", "We also need to check the decision made during tryouts, which is in the Tryout table under the column decision.", "To get the names of students who received a 'yes' at tryouts, we will join the Player and Tryout tables on the pID column.", "The final query will select the pName from the Player table and filter results where the decision in the Tryout table is 'yes'."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT Player.pName, Tryout.decision FROM Player JOIN Tryout ON Player.pID = Tryout.pID WHERE Tryout.decision = 'yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find the names of students (players) who successfully tried out for a specific position, which is 'striker'.", "Join the Player table with the Tryout table on the player ID (pID) to access player names and their tryout details.", "Filter the results where the position (pPos) is 'striker' and the decision indicates a successful tryout.", "Select the player names (pName) from the filtered results."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pName \nFROM Player AS P \nJOIN Tryout AS T ON P.pID = T.pID \nWHERE T.pPos = 'striker' AND T.decision = 'successful';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["Identify the requirement: We need to find the average number of hours spent practicing by students who got rejected.", "Determine the relevant tables: The 'practice' table (not explicitly mentioned in the schema but assumed to exist for this context) will hold the hours spent practicing, and the 'tryout' table will provide the decision status of players.", "Use a subquery to filter players who were rejected: We will select pIDs from the 'tryout' table where the decision is 'rejected'.", "Calculate the average hours: We will use the AVG function on the hours column from the 'practice' table, filtering it by the pIDs obtained from the subquery."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT AVG(hours) FROM practice WHERE pID IN (SELECT pID FROM tryout WHERE decision = 'rejected')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    }\n}\n"}
{"sample_id": "train.5018", "db_id": "soccer_2", "question": "Which college has any student who is a goalie and succeeded in the tryout.", "rationale": ["Identify the relevant tables: We need to look at the 'Tryout' table since it contains information about players, their positions, and the decisions made during tryouts.", "Filter for the specific position: We are interested in players who are goalies, so we will filter the results where pPos = 'goalie'.", "Filter for successful tryouts: We also need to ensure that we only consider players who succeeded in their tryouts, so we will add a condition for decision = 'succeeded'.", "Select distinct colleges: We want to know which colleges have at least one player who meets the above criteria, so we will select distinct college names (cName) from the Tryout table."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT cName \nFROM Tryout \nWHERE pPos = 'goalie' AND decision = 'succeeded';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find the state and enrollment of colleges where students got accepted in the tryout decision.", "This requires a JOIN between the College and Tryout tables on the college name (cName).", "We filter the results to include only those records from Tryout where the decision is 'accepted'.", "Select the state and enrollment number from the College table."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT C.state, C.enr FROM College AS C JOIN Tryout AS T ON C.cName = T.cName WHERE T.decision = 'accepted'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["Identify the requirement: We need to find the total number of students enrolled in colleges that have accepted students during tryouts, along with the states of those colleges.", "We will use the College table to get the enrollment numbers and states.", "We need to filter the colleges based on whether they have accepted students during tryouts. This can be done by checking the Tryout table for decisions that are 'accepted'.", "To achieve this, we will create a subquery that selects distinct college names from the Tryout table where the decision is 'accepted'.", "The main query will then sum the enrollment numbers from the College table for those colleges returned by the subquery, grouping the results by state."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT SUM(enr) AS total_enrollment, state FROM College WHERE cName IN (SELECT DISTINCT cName FROM Tryout WHERE decision = 'accepted') GROUP BY state;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5026", "db_id": "soccer_2", "question": "Find the names of schools that have some students playing in goalie and mid positions.", "rationale": ["Identify the positions of interest: goalie and mid.", "Use the INTERSECT operator to find colleges that have players trying out for both positions.", "Construct the SQL query to select the college names (cName) from the Tryout table where the position (pPos) is 'goalie' and intersect it with another selection from the same table where the position is 'mid'."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "pred_sql": "SELECT cName FROM tryout WHERE pPos = 'goalie' INTERSECT SELECT cName FROM tryout WHERE pPos = 'mid'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.5028", "db_id": "soccer_2", "question": "Find the names of states that have some college students playing in goalie and mid positions.", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find states where colleges have students trying out for specific positions: goalie and mid.", "Use a JOIN operation to connect the College and Tryout tables based on the college name (cName).", "Filter the results by the positions using the IN clause to include both 'goalie' and 'mid'.", "Select distinct states to avoid duplicates in the results."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT T1.state FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos IN ('goalie', 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    }\n}\n"}
{"sample_id": "train.5029", "db_id": "soccer_2", "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?", "rationale": ["Identify the positions of interest: goalie and mid-field.", "Use the provided virtual table structure to find colleges hosting tryouts for the position of goalie.", "Use the provided virtual table structure to find colleges hosting tryouts for the position of mid-field.", "Combine the results of both queries using INTERSECT to find states that have colleges with players trying out for both positions.", "Join the College and Tryout tables on the college name to get the corresponding states for the colleges that hosted tryouts for both positions."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos = 'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos = 'mid-field'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    }\n}\n"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["Identify the positions of interest: goalie and mid.", "Use the 'tryout' table to find colleges where players are trying out for these positions.", "Filter the results to include only those colleges that have players in either goalie or mid positions.", "Count the distinct colleges that meet the criteria."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(DISTINCT cName) FROM tryout WHERE pPos IN ('goalie', 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.5037", "db_id": "soccer_2", "question": "What is the count of states with college students playing in the mid position but not as goalies?", "rationale": ["Identify the states where colleges have students trying out for the 'mid' position.", "Use a JOIN between the College and Tryout tables to filter by the 'mid' position.", "Use the EXCEPT clause to exclude states where colleges have students trying out for the 'goalie' position.", "Count the distinct states that remain after the exclusion."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')", "source_tables": ["tryout", "college"], "pred_sql": "SELECT COUNT(DISTINCT T1.state) FROM college AS T1 JOIN tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos = 'mid' EXCEPT SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos = 'goalie';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    }\n}\n"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["Identify the requirement: We need to find states with colleges that have enrollments less than some other college.", "Use the second virtual table provided in the hint, which summarizes the minimum enrollment numbers of colleges grouped by their respective states.", "To find states with colleges having enrollments less than the minimum enrollment, we can use a subquery to get the minimum enrollment from the College table.", "The final SQL query selects distinct states from the College table where the enrollment number is less than the minimum enrollment number found in the subquery."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE enr < (SELECT MIN(enr) FROM College)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of colleges located in a specific state that have an enrollment number either less than or greater than a specified value. The placeholders in the WHERE clauses represent the enrollment numbers and the state name.\",\n        \"virtual_table\": \"SELECT cName FROM College WHERE enr  <  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING] UNION SELECT cName FROM College WHERE enr  >  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    }\n}\n"}
{"sample_id": "train.5102", "db_id": "cre_Drama_Workshop_Groups", "question": "Show the minimum, average, maximum order quantity of all invoices.", "rationale": ["Identify the relevant table: The task requires information about invoices, specifically the order quantities, which are found in the Invoice_Items table.", "Determine the required calculations: We need to calculate the minimum, average, and maximum order quantity of all invoices.", "Construct the SQL query: Use the SELECT statement to retrieve the minimum, average, and maximum values of the Order_Quantity column from the Invoice_Items table."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "pred_sql": "SELECT MIN(Order_Quantity) AS Min_Quantity, AVG(Order_Quantity) AS Avg_Quantity, MAX(Order_Quantity) AS Max_Quantity\nFROM Invoice_Items;", "hint": "\n"}
{"sample_id": "train.5118", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the payment method code used by the most orders?", "rationale": ["Identify the relevant table: Invoices contains the payment_method_code and Order_ID.", "Group the results by payment_method_code to count how many orders are associated with each payment method.", "Order the results in descending order based on the count of Order_ID to find the most used payment method.", "Limit the results to 1 to get only the top payment method code."], "gold_sql": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices"], "pred_sql": "SELECT payment_method_code\nFROM Invoices\nGROUP BY payment_method_code\nORDER BY COUNT(Order_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5127", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the descriptions of the service types that cost more than 100.", "rationale": ["Identify the relevant tables: Ref_Service_Types and Services are needed to get service type descriptions and their associated prices.", "Join the two tables on the Service_Type_Code to link service descriptions with their prices.", "Filter the results to only include services where the Product_Price is greater than 100."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT T1.Service_Type_Description \nFROM Ref_Service_Types AS T1 \nJOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code \nWHERE T2.Product_Price > 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the descriptions of service types associated with a specific product name from the 'Services' table, ensuring that the same product name is used in both parts of the query. The placeholders represent the product name that the user can specify to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["Identify the relevant tables: Drama_Workshop_Groups and Services.", "Determine the relationship between the tables: Drama_Workshop_Groups is linked to Services through Workshop_Group_ID.", "Filter the Services table for entries where Product_Name is 'film'.", "Select the Store_Name from Drama_Workshop_Groups that corresponds to the filtered services."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "pred_sql": "SELECT T1.Store_Name FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID = T2.Workshop_Group_ID WHERE T2.Product_Name = 'film'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular product. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the descriptions of service types associated with a specific product name from the 'Services' table, ensuring that the same product name is used in both parts of the query. The placeholders represent the product name that the user can specify to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5142", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the order details of the products with price higher than 2000?", "rationale": ["Identify the relevant tables: We need to look at the 'Order_Items' table for order details and the 'Products' table for product prices.", "Determine the columns needed: We want order item ID, order ID, product ID, order quantity from 'Order_Items', and product name and price from 'Products'.", "Establish the relationship between tables: 'Order_Items' has a foreign key 'Product_ID' that links to 'Products'.", "Filter the results: We need to include only those products where the price is greater than 2000.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses to retrieve the desired information."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_Items.Order_Item_ID, Order_Items.Order_ID, Order_Items.Product_ID, Order_Items.Order_Quantity, Products.Product_Name, Products.Product_Price \nFROM Order_Items \nJOIN Products ON Order_Items.Product_ID = Products.Product_ID \nWHERE Products.Product_Price > 2000;", "hint": "\n"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["Identify the relevant tables: We need to look at the 'Order_Items' table for order details and the 'Products' table for product prices.", "Determine the columns needed: We want to retrieve order item ID, order ID, product ID, order quantity, product name, and product price.", "Join the tables: We need to join 'Order_Items' with 'Products' on the 'Product_ID' to access product details related to each order item.", "Apply the filter: We need to filter the results to include only those products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_Items.Order_Item_ID, Order_Items.Order_ID, Order_Items.Product_ID, Order_Items.Order_Quantity, Products.Product_Name, Products.Product_Price \nFROM Order_Items \nJOIN Products ON Order_Items.Product_ID = Products.Product_ID \nWHERE Products.Product_Price > 2000;", "hint": "\n"}
{"sample_id": "train.5160", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the most frequent status of bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most frequent status of bookings, which means we need to count occurrences of each status code.", "Use the COUNT function: We will count how many times each 'Status_Code' appears in the 'Bookings' table.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each status.", "Order the results: To find the most frequent status, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most frequent status, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Frequency\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most common status code, which implies counting occurrences of each status code.", "Use the COUNT function: We will count how many times each status code appears in the 'Bookings' table.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each unique status code.", "Order the results: To find the most common status code, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most common status code, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Count\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["Identify the relevant tables: We need to find workshop groups and their bookings, so we will use the Drama_Workshop_Groups and Bookings tables.", "Determine the relationship: The Drama_Workshop_Groups table is linked to the Bookings table through the Workshop_Group_ID.", "Specify the condition: We are interested in bookings with a status code of 'stop'.", "Select the desired output: We want the names of the workshop groups, which can be found in the Store_Name column of the Drama_Workshop_Groups table."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "pred_sql": "SELECT DW.Store_Name \nFROM Drama_Workshop_Groups AS DW \nJOIN Bookings AS B ON DW.Workshop_Group_ID = B.Workshop_Group_ID \nWHERE B.Status_Code = 'stop';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular product. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5171", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the description of the service type that offers not only the photo product but also the film product.", "rationale": ["Identify the tables involved: Ref_Service_Types and Services.", "Determine the relationship between the tables: Ref_Service_Types is linked to Services via Service_Type_Code.", "Use the provided hint to create a virtual table that retrieves service type descriptions based on product names.", "The query needs to find service types that offer both 'photo' and 'film' products, which can be achieved using the INTERSECT operator to ensure both conditions are met.", "Construct the SQL query using the structure from the hint, replacing the placeholders with 'photo' and 'film' respectively."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code WHERE T2.Product_Name = 'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code WHERE T2.Product_Name = 'film'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the descriptions of service types associated with a specific product name from the 'Services' table, ensuring that the same product name is used in both parts of the query. The placeholders represent the product name that the user can specify to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular product. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5459", "db_id": "voter_2", "question": "Find the average age of female students.", "rationale": ["Identify the table that contains the age of students, which is the 'Student' table.", "Determine the condition needed to filter for female students, which is 'Sex = 'Female' '.", "Use the AVG() function to calculate the average age of the filtered results.", "Construct the SQL query to select the average age from the 'Student' table where the sex is female."], "gold_sql": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  'F'", "source_tables": ["student"], "pred_sql": "SELECT AVG(Age) AS Average_Age FROM Student WHERE Sex = 'Female';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5466", "db_id": "voter_2", "question": "What are the distinct president votes on 08/30/2015?", "rationale": ["Identify the relevant tables: We need to look at the Student and Voting_record tables to find the president votes.", "Determine the columns needed: We need the distinct president votes, which are in the Voting_record table under the column President_Vote.", "Join the tables: We will join the Student table with the Voting_record table on the StuID column, which is common to both tables.", "Filter by date: We need to filter the results to only include records where the Registration_Date is '2015-08-30'.", "Use DISTINCT: Since we want distinct president votes, we will use the DISTINCT keyword in our SELECT statement."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT T1.President_Vote FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.StuID WHERE T2.Registration_Date = '2015-08-30'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["Identify the tables involved: We need to retrieve data from the Student and Voting_record tables.", "Determine the relevant columns: We want distinct president votes, which means we will focus on the President_Vote column in the Voting_record table and the StuID from the Student table.", "Join the tables: We will join the Student table with the Voting_record table on the StuID, which is common in both tables.", "Filter by date: We need to filter the results to only include records where the Registration_Date is '08/30/2015'.", "Select distinct values: Since we want distinct president votes, we will use the DISTINCT keyword in our SELECT statement."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT T1.StuID FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.President_Vote WHERE T2.Registration_Date = '08/30/2015'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5476", "db_id": "voter_2", "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.", "rationale": ["Identify the relevant tables: We need to use the 'Student' table to get student ages and the 'Voting_record' table to check for secretary votes.", "Join the two tables on the StuID column since it is the common identifier for students in both tables.", "Filter the results to only include records from the fall election cycle by checking the 'Election_Cycle' column in the Voting_record table.", "Additionally, we need to ensure that we only consider students who have cast a vote for secretary, which can be checked by ensuring 'Secretary_Vote' is not null.", "Select distinct ages from the filtered results to avoid duplicates."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Age \nFROM Student AS S \nJOIN Voting_record AS V ON S.StuID = V.StuID \nWHERE V.Election_Cycle = 'fall' AND V.Secretary_Vote IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["Identify the relevant tables: We need to look at the Student table for advisors and the Voting_record table for voting information.", "Determine the condition: We want to find students who have treasurer votes in the spring election cycle.", "Use a subquery: We will create a subquery to select the StuID of students who voted for treasurer in the specified election cycle.", "Join the results: We will then use this list of StuIDs to filter the Student table to get the advisors for these students."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Advisor FROM Student WHERE StuID IN (SELECT StuID FROM Voting_record WHERE Treasurer_Vote IS NOT NULL AND Election_Cycle = 'spring')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5486", "db_id": "voter_2", "question": "How many male (sex is M) students have class senator votes in the fall election cycle?", "rationale": ["Identify the tables involved: We need to use the 'Student' table to filter by gender and the 'Voting_record' table to check for class senator votes.", "Determine the condition for male students: We will filter the 'Sex' column in the 'Student' table for 'M'.", "Identify the voting record for class senator: We will join the 'Student' table with the 'Voting_record' table on the 'StuID' and 'Class_Senator_Vote' columns.", "Specify the election cycle: We need to filter the records for the fall election cycle in the 'Voting_record' table.", "Count the number of male students who meet these criteria: We will use COUNT(*) to get the total number of records that match our conditions."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT COUNT(*) FROM Student AS S JOIN Voting_record AS V ON S.StuID = V.Class_Senator_Vote WHERE S.Sex = 'M' AND V.Election_Cycle = 'fall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first and last names of students from the 'Student' table who have voted for a presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["Identify the tables involved: We need data from the 'Student' table for student details and the 'Voting_record' table for voting details.", "Determine the conditions: We are looking for students with a city code of 'NYC', who have voted in the spring election cycle, and specifically have a record for secretary votes.", "Calculate the average age: We need to compute the average age of the filtered students, which requires casting the 'Age' column to an integer for accurate calculation.", "Join the tables: We will join the 'Student' table with the 'Voting_record' table on the StuID to correlate students with their voting records.", "Construct the SQL query: Using the identified conditions and calculations, we will construct the SQL query to retrieve the average age."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(CAST(Age AS INTEGER)) AS Average_Age \nFROM Student AS S \nJOIN Voting_record AS V ON S.StuID = V.StuID \nWHERE S.city_code = 'NYC' \nAND V.Election_Cycle = 'spring' \nAND V.Secretary_Vote IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5492", "db_id": "voter_2", "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.", "rationale": ["Identify the tables involved: We need data from the Student table and the Voting_record table.", "Determine the columns needed: We need the Age from the Student table and we want to calculate the average age of female students who have voted for secretary.", "Filter conditions: We need to filter for female students (Sex = 'F') and those who have participated in the spring election cycle and have a non-null Secretary_Vote.", "Join the tables: We will join the Student table with the Voting_record table on StuID to correlate students with their voting records.", "Calculate the average age: Use the AVG function on the Age column, ensuring to cast it to an integer for accurate calculation."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(CAST(Age AS INTEGER)) AS Average_Age \nFROM Student AS S \nJOIN Voting_record AS V ON S.StuID = V.StuID \nWHERE S.Sex = 'F' \nAND V.Election_Cycle = 'spring' \nAND V.Secretary_Vote IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["Identify the tables involved: We need to retrieve data from the Student and Voting_record tables.", "Determine the columns needed: We need distinct first names (Fname) from the Student table.", "Establish the join condition: We will join the Student table with the Voting_record table on the StuID and Vice_President_Vote columns.", "Add the filtering condition: We need to filter out students whose city_code is 'PIT'.", "Construct the SQL query using SELECT DISTINCT to ensure unique first names are returned."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT T1.Fname FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Vice_President_Vote WHERE T1.city_code != 'PIT'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5495", "db_id": "voter_2", "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?", "rationale": ["Identify the relevant tables: We need to retrieve data from the Student and Voting_record tables.", "Determine the columns needed: We want distinct first names of students, so we will select T1.Fname.", "Establish the join condition: We need to join the Student table (T1) with the Voting_record table (T2) on the condition that the StuID in Student matches the Vice_President_Vote in Voting_record.", "Add the filtering condition: We need to filter out students whose city_code is 'PIT'.", "Construct the SQL query using the SELECT statement with DISTINCT to ensure unique first names are returned."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT T1.Fname \nFROM Student AS T1 \nJOIN Voting_record AS T2 ON T1.StuID = T2.Vice_President_Vote \nWHERE T1.city_code != 'PIT';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5496", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is not 2192.", "rationale": ["Identify the relevant tables: Student and Voting_record.", "We need to find distinct last names of students, so we will use SELECT DISTINCT on the LName column from the Student table.", "We need to join the Student table with the Voting_record table to access the voting information, specifically the President_Vote column.", "The join condition will be on the StuID from the Student table and the President_Vote from the Voting_record table.", "We need to filter out students whose advisor is '2192', so we will add a WHERE clause to exclude these records."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT T1.LName FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.President_Vote WHERE T1.Advisor != '2192'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5499", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes and have 8741 as the advisor?", "rationale": ["Identify the relevant tables: Student and Voting_record.", "We need to find distinct last names of students who voted for a presidential candidate, which involves joining the Student table with the Voting_record table on the StuID and President_Vote columns.", "We need to filter the results to only include students whose advisor is '8741'.", "The final SQL query selects distinct last names from the joined tables with the specified conditions."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT T1.LName FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.President_Vote WHERE T1.Advisor = '8741'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and gender.", "Filter for female students: We need to include a condition to filter the results where the 'Sex' column is 'F'.", "Count occurrences of each major: We will use the COUNT function to count how many female students are in each major.", "Group by major: To get the count of female students per major, we will use the GROUP BY clause on the 'Major' column.", "Order by count in descending order: To find the most common major, we will order the results by the count of students in descending order.", "Limit the results to one: Since we only want the most common major, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as MajorCount \nFROM Student \nWHERE Sex = 'F' \nGROUP BY Major \nORDER BY MajorCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first and last names of students from the 'Student' table who have voted for a presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and gender.", "Filter for female students: We need to count only female students, so we will add a WHERE clause to filter by Sex = 'Female'.", "Group by major: To find out how many female students are studying each major, we will use GROUP BY on the Major column.", "Count the number of female students per major: We will use COUNT(*) to count the number of female students in each major.", "Order the results: To find the major with the most female students, we will order the results in descending order based on the count.", "Limit the results: Since we only want the major with the most female students, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as FemaleCount \nFROM Student \nWHERE Sex = 'Female' \nGROUP BY Major \nORDER BY FemaleCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first and last names of students from the 'Student' table who have voted for a presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the condition for product category: We need to find the product category code for 'Spices'.", "Use a subquery to get the product_category_code from Ref_Product_Categories where the description is 'Spices'.", "Set the condition for typical selling price to be greater than 1000.", "Combine these conditions in a SELECT statement to count the number of products that meet both criteria."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT count(*) FROM Products WHERE product_category_code = (SELECT product_category_code FROM Ref_Product_Categories WHERE product_category_description = 'Spices') AND typical_selling_price > 1000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the relevant tables: We need to get product category descriptions, which are in the Ref_Product_Categories table, and we need to filter products based on their descriptions, which are in the Products table.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to access the category descriptions for each product.", "Use a WHERE clause to filter products whose descriptions contain the letter 't'. This can be done using the LIKE operator with a wildcard.", "Select distinct product category descriptions to avoid duplicates in the results."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description \nFROM Products p \nJOIN Ref_Product_Categories rpc ON p.product_category_code = rpc.product_category_code \nWHERE p.product_description LIKE '%t%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n        \"virtual_table\": \"SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["Identify the relevant tables: Products, Product_Characteristics, and Characteristics are needed to find the distinct characteristic names for the product 'cumin'.", "Join the Products table with Product_Characteristics on product_id to link products with their characteristics.", "Join the resulting table with Characteristics on characteristic_id to access the characteristic names.", "Filter the results to only include the product where the product_name is 'cumin'.", "Use COUNT(DISTINCT c.characteristic_name) to count the number of unique characteristic names associated with the product 'cumin'."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT c.characteristic_name) AS distinct_characteristic_names\nFROM Products p\nJOIN Product_Characteristics pc ON p.product_id = pc.product_id\nJOIN Characteristics c ON pc.characteristic_id = c.characteristic_id\nWHERE p.product_name = 'cumin';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n        \"virtual_table\": \"SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["Identify the tables involved: Products, Ref_Colors, Product_Characteristics, and Characteristics.", "We need to count products that either have a color described as 'white' or have a characteristic with the name 'hot'.", "Join the Products table with the Ref_Colors table to filter by color description.", "Join the Products table with the Product_Characteristics table to access characteristics of each product.", "Join the Product_Characteristics table with the Characteristics table to filter by characteristic name.", "Use a WHERE clause to specify the conditions for color description and characteristic name.", "Use COUNT(*) to get the total number of products that meet either condition."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(*) FROM Products p JOIN Ref_Colors c ON p.color_code = c.color_code JOIN Product_Characteristics pc ON p.product_id = pc.product_id JOIN Characteristics ch ON pc.characteristic_id = ch.characteristic_id WHERE c.color_description = 'white' OR ch.characteristic_name = 'hot';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n        \"virtual_table\": \"SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: We need to find the unit of measure for 'Herb' products, which involves the Products table and the Ref_Product_Categories table.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to access the unit_of_measure.", "Filter the results to only include products that have 'Herb' in their product name using a LIKE clause.", "Select the unit_of_measure from the Ref_Product_Categories table."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT t2.unit_of_measure FROM Ref_Product_Categories AS t2 JOIN Products AS t1 ON t1.product_category_code = t2.product_category_code WHERE t1.product_name LIKE '%Herb%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n        \"virtual_table\": \"SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the columns needed: product_category_code and unit_of_measure from Ref_Product_Categories.", "Establish the relationship between Products and Ref_Product_Categories using the product_category_code.", "Filter the results based on the product name 'chervil'.", "Construct the SQL query to select the required columns with the appropriate JOIN and WHERE clause."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT rpc.product_category_code, rpc.unit_of_measure \nFROM Products AS p \nJOIN Ref_Product_Categories AS rpc ON p.product_category_code = rpc.product_category_code \nWHERE p.product_name = 'chervil';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n        \"virtual_table\": \"SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["We need to find the description of the color for most products.", "To do this, we will join the Products table with the Ref_Colors table on the color_code.", "We will group the results by color_description to count how many products are associated with each color.", "We will use COUNT(*) to count the number of products for each color.", "Finally, we will order the results in descending order based on the product count and limit the result to 1 to get the color with the most products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT color_description, COUNT(*) as product_count FROM Products AS p JOIN Ref_Colors AS c ON p.color_code = c.color_code GROUP BY c.color_description ORDER BY product_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n        \"virtual_table\": \"SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["Identify the relevant tables: We need to look at the 'Ref_Colors' table for color descriptions and the 'Products' table to find out how many products are associated with each color.", "Join the 'Ref_Colors' table with the 'Products' table on the 'color_code' to link colors with their respective products.", "Group the results by 'color_code' to count how many products are associated with each color.", "Order the results by the count of products in ascending order to find the color used by the least products.", "Limit the results to 1 to get only the color with the least number of associated products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT rc.color_description\nFROM Ref_Colors rc\nJOIN Products p ON rc.color_code = p.color_code\nGROUP BY rc.color_code\nORDER BY COUNT(p.product_id) ASC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n        \"virtual_table\": \"SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To do this, we will join the 'Characteristics' table with the 'Product_Characteristics' table on the 'characteristic_id'.", "Next, we will group the results by 'characteristic_name' to aggregate the data for each characteristic.", "We will use the HAVING clause to filter the groups, ensuring that we only include those characteristics that are linked to two or more distinct products (using COUNT(DISTINCT pc.product_id))."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT c.characteristic_name \nFROM Characteristics AS c \nJOIN Product_Characteristics AS pc ON c.characteristic_id = pc.characteristic_id \nGROUP BY c.characteristic_name \nHAVING COUNT(DISTINCT pc.product_id) >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n        \"virtual_table\": \"SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to query.", "Select the 'Builder' column: We want to list the builders, so we will select this column.", "Use DISTINCT to avoid duplicate entries: Since multiple railways can have the same builder, we will use DISTINCT to ensure each builder is listed only once.", "Order the results: We need the results in ascending alphabetical order, so we will use ORDER BY Builder ASC.", "Construct the SQL query: Combine all these elements into a complete SQL query."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "pred_sql": "SELECT DISTINCT Builder FROM railway ORDER BY Builder ASC;", "hint": "\n"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["Identify the relevant tables: 'railway' and 'train'.", "We need to find the railway associated with the most trains, so we will join the 'railway' table with the 'train' table on 'Railway_ID'.", "We will group the results by 'Railway_ID' and 'Builder' to count the number of trains associated with each railway.", "Use COUNT(train.Train_ID) to count the number of trains for each railway.", "Order the results in descending order based on the count of trains to get the railway with the most trains at the top.", "Limit the results to 1 to get only the railway associated with the most trains."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "pred_sql": "SELECT railway.Railway_ID, railway.Builder\nFROM railway\nJOIN train ON railway.Railway_ID = train.Railway_ID\nGROUP BY railway.Railway_ID, railway.Builder\nORDER BY COUNT(train.Train_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["We need to find the most common builder of railways, which means we will be counting how many railways each builder has constructed.", "To do this, we will select the 'Builder' column from the 'railway' table and count the occurrences of each builder using COUNT(*).", "We will group the results by 'Builder' to aggregate the counts for each unique builder.", "Next, we will order the results in descending order based on the count of railways built by each builder, so that the most common builder appears first.", "Finally, we will limit the results to just one entry to get the most common builder."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "pred_sql": "SELECT Builder, COUNT(*) as BuilderCount \nFROM railway \nGROUP BY Builder \nORDER BY BuilderCount DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["Identify the criteria for selecting students: female students, students living in a city with code 'BAL', and male students under the age of 20.", "Use the first part of the virtual table to select last names of female students or students living in city 'BAL'.", "Use the second part of the virtual table to select last names of male students under 20.", "Combine both selections using UNION to ensure all qualifying last names are included."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "pred_sql": "SELECT LName FROM Student WHERE Sex = 'Female' OR city_code = 'BAL' UNION SELECT LName FROM Student WHERE Sex = 'Male' AND Age < '20'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of students from the 'Student' table based on specific criteria. It includes students of a certain gender residing in a specific city, as well as students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age criteria.\",\n        \"virtual_table\": \"SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND city_code  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND age  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city_code\"\n    }\n}\n"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["Identify the tables involved: Dorm and Has_amenity.", "We need to count the number of amenities for each dormitory.", "Join the Dorm table with the Has_amenity table on the dormid to link dormitories with their amenities.", "Filter the dormitories to include only those with a student capacity greater than 100.", "Group the results by dormid to get the count of amenities for each dormitory."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "pred_sql": "SELECT count(*), T1.dormid FROM Dorm AS T1 JOIN Has_amenity AS T2 ON T1.dormid = T2.dormid WHERE T1.student_capacity > 100 GROUP BY T1.dormid", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] OR student_capacity  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables involved: We need to count students living in male dorms, so we will use the 'Lives_in' and 'Dorm' tables.", "Join the 'Lives_in' table with the 'Dorm' table on the dormid to link students to their respective dorms.", "Filter the results to include only those dorms where the gender is 'male'.", "Count the total number of students that meet the criteria using COUNT(*) function."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(*) FROM Lives_in AS L JOIN Dorm AS D ON L.dormid = D.dormid WHERE D.gender = 'male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] OR student_capacity  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city_code\"\n    }\n}\n"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["Identify the requirement: We need to find the first names of students living in the dorm with the most amenities.", "Use the provided hint to create a virtual table that counts the number of amenities per dormitory. This is done by joining the Dorm and Has_amenity tables and grouping by dormid.", "Sort the results of the count in descending order and limit to 1 to get the dorm with the most amenities.", "Next, we need to find the students living in that dorm. We will use a subquery to get the dormid from the previous step.", "Finally, we select the first names of students from the Student table where their StuID matches those living in the identified dorm."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT Fname FROM Student WHERE StuID IN (SELECT stuid FROM Lives_in WHERE dormid = (SELECT dormid FROM (SELECT count(*) AS amenity_count, T1.dormid FROM Dorm AS T1 JOIN Has_amenity AS T2 ON T1.dormid = T2.dormid GROUP BY T1.dormid ORDER BY amenity_count DESC LIMIT 1)))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] OR student_capacity  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["Identify the information needed: first name and age of students living in a dorm with a TV Lounge.", "Determine the relationship between students and dorms: Students live in dorms as indicated by the Lives_in table.", "Identify which dorms have a TV Lounge: Use the Has_amenity table to find dorms that have the amenity identified by the Dorm_amenity table.", "Join these tables to filter students based on their dorms: Use a subquery to find student IDs (stuid) from the Lives_in table where the dormid matches those that have a TV Lounge."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "pred_sql": "SELECT Fname, Age FROM Student WHERE StuID IN (SELECT stuid FROM Lives_in WHERE dormid IN (SELECT dormid FROM Has_amenity WHERE amenid = (SELECT amenid FROM Dorm_amenity WHERE amenity_name = 'TV Lounge')));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] OR student_capacity  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city_code\"\n    }\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the goal: We need to find the emails of customers who have filed complaints on the product with the greatest number of complaints.", "To achieve this, we will first need to determine which product has the greatest number of complaints. This can be done by grouping the Complaints table by product_id and counting the number of complaints for each product.", "We will order the results by the count of complaints in descending order and limit the results to 1 to get the product with the highest number of complaints.", "Next, we will join the Customers table with the Complaints table to get the email addresses of customers who filed complaints about that specific product.", "Finally, we will construct the SQL query to select the email addresses from the Customers table where the product_id matches the one identified in the previous step."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address \nFROM Customers c \nJOIN Complaints comp ON c.customer_id = comp.customer_id \nWHERE comp.product_id = (\n    SELECT product_id \n    FROM Complaints \n    GROUP BY product_id \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\",\n        \"virtual_table\": \"SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["Identify the products that have been complained about by customers.", "Join the Products table with the Complaints table to link products to complaints.", "Join the resulting table with the Customers table to access customer information.", "Use a subquery to find the customer who has filed the least amount of complaints by grouping complaints by customer_id and ordering by the count of complaints in ascending order, limiting the result to 1.", "Filter the main query to only include products associated with the identified customer."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT DISTINCT p.product_name \nFROM Products AS p \nJOIN Complaints AS c ON p.product_id = c.product_id \nJOIN Customers AS cu ON c.customer_id = cu.customer_id \nWHERE cu.customer_id IN (\n    SELECT customer_id \n    FROM Complaints \n    GROUP BY customer_id \n    ORDER BY COUNT(*) ASC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\",\n        \"virtual_table\": \"SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the tables involved: Staff, Complaints, and Products.", "We need to find the last name of the staff member handling a complaint related to the product with the lowest price.", "Join the Staff table with the Complaints table on staff_id to link staff members to complaints.", "Join the Complaints table with the Products table on product_id to link complaints to products.", "Use a subquery to find the minimum product price from the Products table.", "Filter the results to only include complaints related to the product with this minimum price.", "Select the last name of the staff member from the resulting joined tables."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT s.last_name \nFROM Staff s \nJOIN Complaints c ON s.staff_id = c.staff_id \nJOIN Products p ON c.product_id = p.product_id \nWHERE p.product_price = (SELECT MIN(product_price) FROM Products)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\",\n        \"virtual_table\": \"SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["Identify the relevant table: The question pertains to the 'Complaints' table, specifically focusing on the 'complaint_status_code'.", "We need to count the number of records for each complaint status. This requires a GROUP BY clause on 'complaint_status_code'.", "To filter the results to only those statuses with more than 3 records, we will use the HAVING clause with COUNT(*) > 3.", "The final SQL query will select the 'complaint_status_code' and the count of complaints for each status, applying the necessary grouping and filtering."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "pred_sql": "SELECT complaint_status_code, COUNT(*) as complaint_count \nFROM Complaints \nGROUP BY complaint_status_code \nHAVING COUNT(*) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\",\n        \"virtual_table\": \"SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["Identify the need to count customers based on the most common customer type.", "Use a subquery to find the most common customer type by grouping the 'customer_type_code' in the 'Customers' table and ordering by the count of each type in descending order.", "Limit the subquery to return only the top result, which represents the most common customer type.", "Use the result of the subquery to filter the main query that counts the total number of customers with that specific customer type."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) FROM Customers WHERE customer_type_code = (SELECT customer_type_code FROM Customers GROUP BY customer_type_code ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique town or city names from the 'Customers' table, filtered by a specific customer type code. The results are grouped by town or city and ordered by the count of occurrences, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the customer type code and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT town_city FROM customers WHERE customer_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY town_city ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to find the first names of staff members, so we will select the 'first_name' column from the Staff table.", "To determine how many complaints each staff member has handled, we will join the Staff table with the Complaints table on the 'staff_id' column.", "We will group the results by 'staff_id' to aggregate the number of complaints handled by each staff member.", "We will use the COUNT function to count the number of complaints for each staff member.", "To get the top 5 staff members who handled the greatest number of complaints, we will order the results in descending order based on the count of complaints and limit the results to 5."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name \nFROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nGROUP BY Staff.staff_id \nORDER BY COUNT(Complaints.complaint_id) DESC \nLIMIT 5;", "hint": "\n"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to join these tables on the staff_id to link staff members with the complaints they handled.", "We want to count the number of complaints each staff member has handled, so we will use COUNT(Complaints.complaint_id).", "Group the results by staff_id to aggregate the complaint counts for each staff member.", "Order the results in descending order based on the count of complaints to get the staff members who handled the most complaints at the top.", "Limit the results to the top 5 staff members."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name FROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nGROUP BY Staff.staff_id \nORDER BY COUNT(Complaints.complaint_id) DESC \nLIMIT 5;", "hint": "\n"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The user wants to see all investor details, which means we need to select all columns from the Investors table.", "The SQL query to retrieve all columns from a table is done using 'SELECT * FROM table_name'.", "In this case, the table name is 'Investors', so the query becomes 'SELECT * FROM Investors'."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "pred_sql": "SELECT * FROM Investors;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY investor_id\"\n    }\n}\n"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["The query needs to show details of all investors who have made transactions with a share count greater than 100.", "To achieve this, we need to select the relevant columns from the Investors table, specifically 'investor_id' and 'Investor_details'.", "We will join the Investors table with the Transactions table on the 'investor_id' column to link investors with their transactions.", "The condition for filtering is that the 'share_count' in the Transactions table must be greater than 100."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "pred_sql": "SELECT Investors.investor_id, Investors.Investor_details \nFROM Investors \nJOIN Transactions ON Investors.investor_id = Transactions.investor_id \nWHERE Transactions.share_count > 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY investor_id\"\n    }\n}\n"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["Identify the relevant tables: We need to get lot details, which are in the 'Lots' table, and we need to filter based on transactions, which are in the 'Transactions' table.", "Determine the relationship between tables: The 'Lots' table is linked to the 'Transactions' table through the 'Transactions_Lots' table. We will need to join these tables to access the required data.", "Construct the SQL query: Start with selecting 'lot_details' from the 'Lots' table. Then, join 'Transactions_Lots' on 'lot_id' and 'Transactions' on 'transaction_id'.", "Add the filter condition: We need to filter transactions where the 'share_count' is less than 50. This will be added in the WHERE clause of the SQL query."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT Lots.lot_details \nFROM Lots \nJOIN Transactions_Lots ON Lots.lot_id = Transactions_Lots.lot_id \nJOIN Transactions ON Transactions_Lots.transaction_id = Transactions.transaction_id \nWHERE Transactions.share_count < 50;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY investor_id\"\n    }\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["We need to calculate the average transaction amount for different transaction types.", "To do this, we will select the transaction type description from the Ref_Transaction_Types table and the amount of transaction from the Transactions table.", "We will join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to get the corresponding descriptions for each transaction type.", "Next, we will use the AVG() function to calculate the average of the amount_of_transaction for each transaction type.", "Finally, we will group the results by transaction_type_description to get the average amounts for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY investor_id\"\n    }\n}\n"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["We need to find the maximum and minimum share count for different transaction types.", "To do this, we will select the maximum and minimum of the 'share_count' column from the 'Transactions' table.", "We also need to include the transaction type description, which is found in the 'Ref_Transaction_Types' table.", "We will join the 'Transactions' table with the 'Ref_Transaction_Types' table on the 'transaction_type_code' to get the descriptions.", "Finally, we will group the results by the transaction type description to get the max and min share counts for each type."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT MAX(share_count) AS max_share_count, MIN(share_count) AS min_share_count, rt.transaction_type_description \nFROM Transactions t \nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code \nGROUP BY rt.transaction_type_description;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY investor_id\"\n    }\n}\n"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["The user wants details of all sales and purchases, which means we need to retrieve data from both the Sales and Purchases tables.", "We will select the relevant columns from both tables: sales_transaction_id and sales_details from the Sales table, and purchase_transaction_id and purchase_details from the Purchases table.", "Since we want to combine the results from both tables, we can use a FULL OUTER JOIN to ensure we get all records from both tables, even if there are no matching records in one of them."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "pred_sql": "SELECT Sales.sales_transaction_id, Sales.sales_details, Purchases.purchase_transaction_id, Purchases.purchase_details \nFROM Sales \nFULL OUTER JOIN Purchases ON Sales.sales_transaction_id = Purchases.purchase_transaction_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY investor_id\"\n    }\n}\n"}
