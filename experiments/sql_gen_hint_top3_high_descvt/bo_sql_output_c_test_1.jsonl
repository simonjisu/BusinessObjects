{"sample_id": "train.1109", "db_id": "match_season", "question": "Return the colleges that have players who play the Midfielder position, as well as players who play the Defender position.", "rationale": ["Identify the positions of interest: Midfielder and Defender.", "Use the provided hint to create a SQL query that retrieves colleges attended by players in these positions.", "Utilize the INTERSECT operator to find common colleges attended by players in both positions.", "Construct the final SQL query using the SELECT statement for colleges with the specified conditions."], "gold_sql": "SELECT College FROM match_season WHERE POSITION  =  'Midfielder' INTERSECT SELECT College FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "pred_sql": "SELECT College FROM match_season WHERE Position = 'Midfielder' INTERSECT SELECT College FROM match_season WHERE Position = 'Defender'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\",\n        \"virtual_table\": \"SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of countries represented by players who occupy a specific position in matches. It uses an intersection to find countries where players in that position are participating in matches, ensuring that only countries with players in that position are returned. The placeholders in the query represent the position of the players being filtered.\",\n        \"virtual_table\": \"SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides information about the draft pick number and draft class of players from the 'match_season' table who play in a specific position. The placeholder in the WHERE clause represents the position of the player.\",\n        \"virtual_table\": \"SELECT Draft_Pick_Number ,  Draft_Class FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1222", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with type code \"Duplex\"?", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for apartment type.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to link bookings to their respective apartments.", "Filter the results to only include apartments with the type code 'Duplex'.", "Select the booking start and end dates from the joined tables."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  'Duplex'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartment_Bookings ab \nJOIN Apartments a ON ab.apt_id = a.apt_id \nWHERE a.apt_type_code = 'Duplex';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1224", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with more than 2 bedrooms?", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "We need to filter apartments based on the number of bedrooms, specifically those with more than 2 bedrooms.", "Use a subquery to select apt_id from the Apartments table where bedroom_count is greater than 2.", "Join this subquery with the Apartment_Bookings table to get the booking start and end dates for those apartments."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT booking_start_date, booking_end_date FROM Apartment_Bookings WHERE apt_id IN (SELECT apt_id FROM Apartments WHERE bedroom_count > 2)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1225", "db_id": "apartment_rentals", "question": "Find the booking start date and end date for the apartments that have more than two bedrooms.", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to access both booking dates and bedroom counts.", "Filter the results to include only those apartments that have more than two bedrooms using a WHERE clause."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT booking_start_date, booking_end_date \nFROM Apartment_Bookings \nJOIN Apartments ON Apartment_Bookings.apt_id = Apartments.apt_id \nWHERE bedroom_count > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1229", "db_id": "apartment_rentals", "question": "Which apartments have bookings with status code \"Confirmed\"? Return their apartment numbers.", "rationale": ["Identify the relevant tables: Apartments and Apartment_Bookings are needed to find apartment numbers with confirmed bookings.", "Join the Apartments table with the Apartment_Bookings table on the apt_id to link apartments with their bookings.", "Filter the results to include only those bookings where the booking_status_code is 'Confirmed'.", "Select the apt_number from the filtered results to get the desired output."], "gold_sql": "SELECT DISTINCT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  'Confirmed'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT a.apt_number \nFROM Apartments a \nJOIN Apartment_Bookings ab ON a.apt_id = ab.apt_id \nWHERE ab.booking_status_code = 'Confirmed';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1232", "db_id": "apartment_rentals", "question": "Show the guest first names, start dates, and end dates of all the apartment bookings.", "rationale": ["Identify the tables needed: We need data from the 'Apartment_Bookings' table for booking details and the 'Guests' table for guest names.", "Determine the columns to select: We need 'guest_first_name' from the 'Guests' table, and 'booking_start_date' and 'booking_end_date' from the 'Apartment_Bookings' table.", "Establish the relationship between tables: The 'Apartment_Bookings' table has a foreign key 'guest_id' that links to the 'Guests' table's primary key 'guest_id'.", "Construct the SQL query: Use a JOIN to combine the two tables on the guest_id, and select the required columns."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT Guests.guest_first_name, Apartment_Bookings.booking_start_date, Apartment_Bookings.booking_end_date \nFROM Apartment_Bookings \nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1234", "db_id": "apartment_rentals", "question": "Show the start dates and end dates of all the apartment bookings made by guests with gender code \"Female\".", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking details and Guests for guest information.", "Determine the columns needed: booking_start_date and booking_end_date from Apartment_Bookings.", "Establish the relationship between tables: Join Apartment_Bookings with Guests on guest_id.", "Filter the results to include only those bookings made by guests with gender code 'Female'."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  'Female'", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT booking_start_date, booking_end_date \nFROM Apartment_Bookings \nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id \nWHERE Guests.gender_code = 'Female';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1238", "db_id": "apartment_rentals", "question": "Show the facility codes of apartments with more than 4 bedrooms.", "rationale": ["Identify the relevant tables: We need to access the 'Apartments' table for bedroom counts and the 'Apartment_Facilities' table for facility codes.", "Join the 'Apartments' table with the 'Apartment_Facilities' table on the 'apt_id' to link apartments with their facilities.", "Filter the results to include only those apartments that have more than 4 bedrooms using a WHERE clause.", "Select the distinct facility codes from the joined tables to avoid duplicates."], "gold_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "source_tables": ["apartments", "apartment_facilities"], "pred_sql": "SELECT DISTINCT af.facility_code \nFROM Apartments a \nJOIN Apartment_Facilities af ON a.apt_id = af.apt_id \nWHERE a.bedroom_count > 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1256", "db_id": "apartment_rentals", "question": "Show the top 3 apartment type codes sorted by the average number of rooms in descending order.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of rooms.", "Determine the required aggregation: We need to calculate the average number of rooms for each apartment type code.", "Group the results: Use GROUP BY to group the results by apt_type_code.", "Sort the results: Use ORDER BY to sort the average number of rooms in descending order.", "Limit the results: Use LIMIT to restrict the output to the top 3 apartment type codes."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY AVG(room_count) DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1258", "db_id": "apartment_rentals", "question": "Show the apartment type code that has the largest number of total rooms, together with the number of bathrooms and number of bedrooms.", "rationale": ["Identify the relevant table: The Apartments table contains the necessary columns for apartment type code, number of bathrooms, number of bedrooms, and total number of rooms.", "Group the results by apartment type code: This allows us to aggregate data for each type of apartment.", "Order the results by the total number of rooms: We want to find the apartment type with the largest number of total rooms, so we will order by the sum of room_count in descending order.", "Limit the results to one: Since we only want the apartment type with the largest number of total rooms, we will limit our results to 1."], "gold_sql": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, bathroom_count, bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1261", "db_id": "apartment_rentals", "question": "Which apartment type code appears the most often?", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes.", "Determine the goal: We want to find out which apartment type code appears the most often.", "Use the COUNT function: This will count the number of occurrences of each apartment type code.", "Group the results: Use GROUP BY to group the results by apartment type code.", "Order the results: Use ORDER BY to sort the counts in descending order so that the most common type appears first.", "Limit the results: Use LIMIT 1 to return only the top result, which is the most common apartment type code."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, COUNT(*) as type_count FROM Apartments GROUP BY apt_type_code ORDER BY type_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1262", "db_id": "apartment_rentals", "question": "Show the most common apartment type code among apartments with more than 1 bathroom.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of bathrooms.", "Filter apartments: We need to filter apartments that have more than 1 bathroom, which is done using the WHERE clause.", "Group by apartment type: To find the most common apartment type code, we group the results by apt_type_code.", "Count occurrences: We order the grouped results by the count of apartments in each type in descending order to find the most common type.", "Limit results: We limit the results to 1 to get only the most common apartment type code."], "gold_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count > 1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1272", "db_id": "apartment_rentals", "question": "Show the apartment numbers of apartments with unit status availability of both 0 and 1.", "rationale": ["Identify the relevant tables: Apartments and View_Unit_Status.", "We need to find apartment numbers, so we will select 'apt_number' from the Apartments table.", "To filter apartments based on their availability status, we will use the View_Unit_Status table.", "The availability status is indicated by the 'available_yn' column in the View_Unit_Status table, where we want to check for both 'Yes' (1) and 'No' (0).", "We will use a subquery to select 'apt_id' from View_Unit_Status where 'available_yn' is either 'Yes' or 'No'.", "Finally, we will use this subquery to filter the main query to get the apartment numbers."], "gold_sql": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1", "source_tables": ["view_unit_status", "apartments"], "pred_sql": "SELECT apt_number FROM Apartments WHERE apt_id IN (SELECT apt_id FROM View_Unit_Status WHERE available_yn IN ('Yes', 'No'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1294", "db_id": "soccer_1", "question": "How many leagues are there in England?", "rationale": ["Identify the relevant table: The question asks about leagues, so we will use the 'League' table.", "Determine the condition: We need to filter the leagues to only those in England.", "Construct the SQL query: We will use the COUNT function to count the number of leagues that match the condition."], "gold_sql": "SELECT count(*) FROM Country AS T1 JOIN League AS T2 ON T1.id  =  T2.country_id WHERE T1.name  =  'England'", "source_tables": ["country", "league"], "pred_sql": "SELECT COUNT(*) AS league_count FROM League WHERE name = 'England';", "hint": "\n"}
{"sample_id": "train.1303", "db_id": "soccer_1", "question": "List all of the player ids with a height of at least 180cm and an overall rating higher than 85.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to select player ids, so we will select 'player_api_id' from the Player table.", "We need to join Player with Player_Attributes on 'player_api_id' to access the height and overall rating.", "Apply the condition for height (at least 180cm) from the Player table.", "Apply the condition for overall rating (higher than 85) from the Player_Attributes table.", "Use DISTINCT to ensure unique player ids are returned."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE overall_rating  >  85", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT DISTINCT P.player_api_id FROM Player AS P JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.height >= 180 AND PA.overall_rating > 85;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of players from the 'Player' table who have a specific preferred foot and whose overall skill rating falls within a defined range. The placeholders in the WHERE clause represent the preferred foot and the minimum and maximum overall ratings.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING] AND T2.overall_rating  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.overall_rating  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of players from the 'Player' table who have a crossing ability greater than a specified value and have a preferred foot that matches a given specification. The placeholders in the WHERE clause represent the crossing ability threshold and the preferred foot of the players.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  [PLACEHOLDER-TYPE:NUMBER] AND T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1304", "db_id": "soccer_1", "question": "List all of the ids for left-footed players with a height between 180cm and 190cm.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to filter players based on their height, which is in the Player table.", "We also need to filter players based on their preferred foot, which is in the Player_Attributes table.", "The preferred foot condition is that it should be 'left'.", "The height condition is that it should be between 180cm and 190cm.", "To get the ids of left-footed players, we will use a subquery to find player_api_ids from Player_Attributes where preferred_foot is 'left'.", "Finally, we will select distinct player_api_ids from the Player table where height is between 180 and 190 and matches the ids from the subquery."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 AND height  <=  190 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE preferred_foot  =  'left'", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT DISTINCT P.player_api_id FROM Player AS P WHERE P.height BETWEEN 180 AND 190 AND P.player_api_id IN (SELECT PA.player_api_id FROM Player_Attributes AS PA WHERE PA.preferred_foot = 'left')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of players from the 'Player' table who have a specific preferred foot and whose overall skill rating falls within a defined range. The placeholders in the WHERE clause represent the preferred foot and the minimum and maximum overall ratings.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING] AND T2.overall_rating  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.overall_rating  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of players from the 'Player' table who have a crossing ability greater than a specified value and have a preferred foot that matches a given specification. The placeholders in the WHERE clause represent the crossing ability threshold and the preferred foot of the players.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  [PLACEHOLDER-TYPE:NUMBER] AND T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1306", "db_id": "soccer_1", "question": "List the names and birthdays of the top five players in terms of potential.", "rationale": ["Identify the relevant tables: We need to retrieve player names and birthdays, which are in the 'Player' table, and we need to rank players based on their potential, which is in the 'Player_Attributes' table.", "Determine the criteria for selection: We want the top five players based on their potential rating.", "Construct a subquery to get the top five players by potential: This involves selecting player_api_id from 'Player_Attributes', ordering by potential in descending order, and limiting the results to 5.", "Join the results of the subquery with the 'Player' table to get the names and birthdays of these players: We will use the player_api_id from the subquery to filter the 'Player' table."], "gold_sql": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT 5", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT player_name, birthday FROM Player WHERE player_api_id IN (SELECT player_api_id FROM Player_Attributes ORDER BY potential DESC LIMIT 5)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of players from the 'Player' table who have a specific preferred foot and whose overall skill rating falls within a defined range. The placeholders in the WHERE clause represent the preferred foot and the minimum and maximum overall ratings.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING] AND T2.overall_rating  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.overall_rating  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of players from the 'Player' table who have a crossing ability greater than a specified value and have a preferred foot that matches a given specification. The placeholders in the WHERE clause represent the crossing ability threshold and the preferred foot of the players.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  [PLACEHOLDER-TYPE:NUMBER] AND T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1511", "db_id": "insurance_and_eClaims", "question": "Which type of policy is most frequently used? Give me the policy type code.", "rationale": ["Identify the relevant table: The question asks about policy types, so we will focus on the Policies table.", "Determine the required columns: We need the Policy_Type_Code and a count of how many times each type is used.", "Use the COUNT function: To find out how frequently each policy type is used, we will use COUNT(*) to count the occurrences of each Policy_Type_Code.", "Group the results: We will group the results by Policy_Type_Code to aggregate the counts for each type.", "Order the results: To find the most frequently used policy type, we will order the results in descending order based on the frequency count.", "Limit the results: Since we only want the most frequently used policy type, we will limit the results to 1."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(*) as Frequency\nFROM Policies\nGROUP BY Policy_Type_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1513", "db_id": "insurance_and_eClaims", "question": "Find all the policy types that are used by more than 2 customers.", "rationale": ["Identify the relevant table: The 'Policies' table contains the 'Policy_Type_Code' and 'Customer_ID' which are needed for this query.", "We need to find policy types used by more than 2 customers, so we will group by 'Customer_ID' and count the distinct customers.", "Use a subquery to first find 'Customer_ID's that are associated with more than 2 policies.", "In the main query, select 'Policy_Type_Code' from the 'Policies' table where the 'Customer_ID' is in the result of the subquery.", "Finally, group the results by 'Policy_Type_Code' to get the distinct policy types used by more than 2 customers."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code\nFROM Policies\nWHERE Customer_ID IN (\n    SELECT Customer_ID\n    FROM Policies\n    GROUP BY Customer_ID\n    HAVING COUNT(DISTINCT Customer_ID) > 2\n)\nGROUP BY Policy_Type_Code;", "hint": "\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["Identify the relevant table: The 'Claim_Headers' table contains the 'Amount_Paid' column which is needed for the calculations.", "Determine the required calculations: We need to calculate both the total and average of the 'Amount_Paid' column.", "Construct the SQL query: Use the SUM() function to get the total amount paid and the AVG() function to get the average amount paid from the 'Claim_Headers' table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\",\n        \"virtual_table\": \"SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.1518", "db_id": "insurance_and_eClaims", "question": "How much amount in total were claimed in the most recently created document?", "rationale": ["Identify the relevant tables: Claim_Headers for the amount claimed and Claims_Documents for the document creation date.", "We need to sum the 'Amount_Claimed' from the Claim_Headers table.", "Join Claim_Headers with Claims_Documents on the Claim_ID to link claims with their documents.", "To find the most recently created document, we will order the Claims_Documents by 'Created_Date' in descending order and limit the result to 1.", "Use this date in the WHERE clause to filter the claims that have documents created on that specific date."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT sum(t1.Amount_Claimed) FROM Claim_Headers AS t1 JOIN Claims_Documents AS t2 ON t1.Claim_Header_ID = t2.Claim_ID WHERE t2.Created_Date = (SELECT Created_Date FROM Claims_Documents ORDER BY Created_Date DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\",\n        \"virtual_table\": \"SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers are needed to find the customer details and their claims.", "Join the Customers table with the Policies table on Customer_ID to link customers to their policies.", "Join the resulting table with Claim_Headers on Policy_ID to access the claims made by each customer.", "Use a subquery to find the maximum amount claimed from the Claim_Headers table.", "Filter the results to only include the customer(s) who made a claim equal to this maximum amount."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details\nFROM Customers AS c\nJOIN Policies AS p ON c.Customer_ID = p.Customer_ID\nJOIN Claim_Headers AS ch ON p.Policy_ID = ch.Policy_ID\nWHERE ch.Amount_Claimed = (\n    SELECT MAX(Amount_Claimed)\n    FROM Claim_Headers\n);\n", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\",\n        \"virtual_table\": \"SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.1521", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the minimum amount of payment in one claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers.", "We need to find the customer who has made the minimum payment in one claim, which involves joining these tables based on their relationships.", "Join Customers with Policies on Customer_ID to link customers to their policies.", "Join Policies with Claim_Headers on Policy_ID to link policies to their claims.", "Use a subquery to find the minimum Amount_Paid from Claim_Headers.", "Select the Customer_Details from Customers where the Amount_Paid matches the minimum found in the subquery."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details\nFROM Customers c\nJOIN Policies p ON c.Customer_ID = p.Customer_ID\nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID\nWHERE ch.Amount_Paid = (\n    SELECT MIN(Amount_Paid)\n    FROM Claim_Headers\n);\n", "hint": "\n"}
{"sample_id": "train.1531", "db_id": "insurance_and_eClaims", "question": "Find the names of the customers who have an deputy policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Filter the Policies table for those with a Policy_Type_Code that indicates a deputy policy.", "Select the distinct Customer_Details from the Customers table for those who have a deputy policy."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT DISTINCT Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Policy_Type_Code = 'deputy';", "hint": "\n"}
{"sample_id": "train.1533", "db_id": "insurance_and_eClaims", "question": "Find the names of customers who either have an deputy policy or uniformed policy.", "rationale": ["Identify the tables involved: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Select the relevant columns: We need Customer_Details from the Customers table.", "Filter the results based on the Policy_Type_Code: We want policies that are either 'deputy' or 'uniformed'.", "Use a JOIN to combine data from both tables based on the Customer_ID.", "Use DISTINCT to ensure we only get unique customer names."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy' OR t1.policy_type_code  =  'Uniform'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT DISTINCT Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Policy_Type_Code IN ('deputy', 'uniformed');", "hint": "\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find the customer who started a policy most recently, so we will join the Customers table with the Policies table on Customer_ID.", "We will order the results by the Start_Date of the policies in descending order to get the most recent policy first.", "Finally, we will limit the results to 1 to get only the most recent customer."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nORDER BY Policies.Start_Date DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "We need to join the Accounts table with the Customers table to access customer details.", "Select the required fields: account_id, account_name, and other_account_details from the Accounts table.", "Filter the results to include only those accounts associated with customers whose first name is 'Meaghan'.", "Construct the SQL query using the SELECT statement with JOIN and WHERE clause."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT A.account_id, A.account_name, A.other_account_details \nFROM Accounts AS A \nJOIN Customers AS C ON A.customer_id = C.customer_id \nWHERE C.customer_first_name = 'Meaghan';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    }\n}\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Accounts and Customers are needed to get account details for a specific customer.", "Join the Accounts table with the Customers table on the customer_id to link accounts to customers.", "Filter the results to only include the customer named Meaghan Keeling by using a WHERE clause that checks both first and last names.", "Select the desired columns from the Accounts table, which include account_id, account_name, date_account_opened, and other_account_details."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT A.account_id, A.account_name, A.date_account_opened, A.other_account_details \nFROM Accounts AS A \nJOIN Customers AS C ON A.customer_id = C.customer_id \nWHERE C.customer_first_name = 'Meaghan' AND C.customer_last_name = 'Keeling';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    }\n}\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["The query needs to find the full names of customers with a specific account name, which is '900'.", "To achieve this, we will join the Accounts table (T1) with the Customers table (T2) using the customer_id as the foreign key.", "We will select the first name and last name from the Customers table and concatenate them to form the full name.", "We will filter the results using a WHERE clause to only include accounts with the name '900'."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT T2.customer_first_name || ' ' || T2.customer_last_name AS full_name \nFROM Accounts AS T1 \nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id \nWHERE T1.account_name = '900'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    }\n}\n"}
{"sample_id": "train.1568", "db_id": "customers_and_invoices", "question": "Return the id and full name of the customer with the most accounts.", "rationale": ["The task is to find the customer with the most accounts, which requires counting the number of accounts associated with each customer.", "To achieve this, we can use a subquery that joins the Accounts table with the Customers table to get the customer details along with the count of accounts.", "The subquery will group the results by customer_id and count the number of accounts for each customer.", "After obtaining the counts, we will order the results in descending order based on the account count to get the customer with the most accounts at the top.", "Finally, we will limit the results to just one record to get the customer with the highest account count, and select their customer_id and full name (concatenating first and last names)."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_id, customer_first_name || ' ' || customer_last_name AS full_name \nFROM (\n    SELECT T1.customer_id, T2.customer_first_name, T2.customer_last_name, COUNT(*) AS account_count \n    FROM Accounts AS T1 \n    JOIN Customers AS T2 ON T1.customer_id = T2.customer_id \n    GROUP BY T1.customer_id\n) \nORDER BY account_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    }\n}\n"}
{"sample_id": "train.1579", "db_id": "customers_and_invoices", "question": "How many transaction does each account have? Show the number and account id.", "rationale": ["The question asks for the number of transactions associated with each account, along with the account ID.", "To get this information, we need to join the 'Financial_Transactions' table with the 'Accounts' table using the account_id as the common key.", "We will use a COUNT function to count the number of transactions for each account.", "The results should be grouped by account_id to ensure we get a count for each individual account.", "The hint provided a virtual table that summarizes this exact information, which we can use as a template for our SQL query."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT T2.account_name, T1.account_id, count(*) FROM Financial_Transactions AS T1 JOIN Accounts AS T2 ON T1.account_id = T2.account_id GROUP BY T1.account_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    }\n}\n"}
{"sample_id": "train.1589", "db_id": "customers_and_invoices", "question": "Show the account name, id and the number of transactions for each account.", "rationale": ["Identify the tables needed: Accounts and Financial_Transactions.", "We need to select the account name and account ID from the Accounts table.", "We also need to count the number of transactions associated with each account from the Financial_Transactions table.", "Join the Financial_Transactions table with the Accounts table on the account_id field.", "Group the results by account_id to get the count of transactions for each account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "pred_sql": "SELECT T2.account_name, T1.account_id, COUNT(*) AS number_of_transactions \nFROM Financial_Transactions AS T1 \nJOIN Accounts AS T2 ON T1.account_id = T2.account_id \nGROUP BY T1.account_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    }\n}\n"}
{"sample_id": "train.1599", "db_id": "customers_and_invoices", "question": "Show the invoice number and the number of transactions for each invoice.", "rationale": ["We need to show the invoice number and the number of transactions for each invoice.", "The relevant tables are Invoices and Financial_Transactions.", "We will join these two tables on the invoice_number field, as it is the common field between them.", "We will select the invoice_number from the Invoices table and count the transaction_id from the Financial_Transactions table to get the number of transactions for each invoice.", "Finally, we will group the results by invoice_number to ensure we get a count for each unique invoice."], "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"], "pred_sql": "SELECT I.invoice_number, COUNT(FT.transaction_id) AS number_of_transactions \nFROM Invoices AS I \nJOIN Financial_Transactions AS FT ON I.invoice_number = FT.invoice_number \nGROUP BY I.invoice_number;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    }\n}\n"}
{"sample_id": "train.1602", "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?", "rationale": ["Identify the need to find the invoice number and date for the invoice with the greatest number of transactions.", "Utilize the Financial_Transactions table to count the number of transactions associated with each invoice.", "Group the results by invoice number and order them in descending order based on the count of transactions.", "Limit the results to get the invoice with the highest transaction count.", "Use a subquery to find the order_id corresponding to that invoice.", "Finally, select the invoice_number and invoice_date from the Invoices table where the order_id matches the one found in the subquery."], "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"], "pred_sql": "SELECT invoice_number, invoice_date FROM Invoices WHERE order_id = (SELECT order_id FROM Financial_Transactions GROUP BY invoice_number ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of order IDs and their corresponding details from the 'Orders' table, specifically for those orders that are associated with invoices. The results are grouped by order ID, and only those orders that have more than a specified number of associated invoices are included. The placeholder in the HAVING clause represents the minimum count of invoices required for an order to be displayed.\",\n        \"virtual_table\": \"SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["The task is to show the order ids and the number of items in each order.", "To achieve this, we need to count the number of items associated with each order.", "The relevant table for this information is 'Order_Items', which contains 'order_id' and 'order_item_id'.", "We will use the COUNT function to count the 'order_item_id' for each 'order_id'.", "We will group the results by 'order_id' to get the count of items for each specific order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT order_id, COUNT(order_item_id) AS number_of_items FROM Order_Items GROUP BY order_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of distinct products associated with each order from the 'Order_Items' table. The placeholder in the SELECT clause represents the order identifier, while the count function calculates the unique product count for each order.\",\n        \"virtual_table\": \"SELECT order_id ,  count(DISTINCT product_id) FROM Order_items GROUP BY order_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of order IDs and their corresponding details from the 'Orders' table, specifically for those orders that are associated with invoices. The results are grouped by order ID, and only those orders that have more than a specified number of associated invoices are included. The placeholder in the HAVING clause represents the minimum count of invoices required for an order to be displayed.\",\n        \"virtual_table\": \"SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    }\n}\n"}
{"sample_id": "train.2049", "db_id": "party_people", "question": "Show all ministers who do not belong to Progress Party.", "rationale": ["Identify the relevant table: The 'party' table contains information about political parties and their associated ministers.", "Determine the required information: We need to select ministers who do not belong to the 'Progress Party'.", "Use a SELECT statement to retrieve the 'Minister' column from the 'party' table.", "Apply a WHERE clause to filter out the 'Progress Party' by checking that the 'Party_name' is not equal to 'Progress Party'.", "Use DISTINCT to ensure that each minister is listed only once in the result."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT DISTINCT p.Minister FROM party AS p WHERE p.Party_name != 'Progress Party';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement represents the party's name, and the count function aggregates the total number of members for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT clause represents the party name, while the count function aggregates the total number of events for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    }\n}\n"}
{"sample_id": "train.2058", "db_id": "party_people", "question": "How many members are in each party?", "rationale": ["Identify the tables involved: We need to count members from the 'member' table and associate them with their respective parties from the 'party' table.", "Determine the relationship: The 'member' table has a foreign key 'Party_ID' that links to the 'party' table's 'Party_ID'.", "Use a JOIN operation: We will join the 'member' table (aliased as T1) with the 'party' table (aliased as T2) on the 'Party_ID'.", "Count the members: We will use the COUNT function to count the number of members for each party.", "Group by party: To get the count per party, we will group the results by 'Party_ID' from the 'party' table.", "Select the party name and count: The final output will include the party name and the count of members, which we will alias as 'Member_Count'."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT T2.Party_name, COUNT(*) AS Member_Count FROM member AS T1 JOIN party AS T2 ON T1.Party_ID = T2.Party_ID GROUP BY T2.Party_ID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement represents the party's name, and the count function aggregates the total number of members for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT clause represents the party name, while the count function aggregates the total number of events for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    }\n}\n"}
{"sample_id": "train.2071", "db_id": "party_people", "question": "Show party names and the number of events for each party.", "rationale": ["The task is to show party names and the number of events for each party.", "We need to retrieve data from the 'party_events' table to count the number of events.", "To get the party names, we will join the 'party' table with the 'party_events' table using the Party_ID.", "The SQL query will use the COUNT function to aggregate the total number of events for each party.", "We will group the results by Party_ID to ensure we get a count for each individual party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT T2.party_name, count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id = T2.party_id GROUP BY T1.party_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT clause represents the party name, while the count function aggregates the total number of events for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement represents the party's name, and the count function aggregates the total number of members for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    }\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the relevant tables: party_events, party, and region.", "We need to count the number of events, so we will use the COUNT() function.", "Join the party_events table with the party table to get the party names associated with the events.", "Join the resulting table with the region table to filter by the United Kingdom region.", "Add a WHERE clause to filter for events specifically named 'Annual Meeting'.", "Finally, use COUNT(*) to get the total number of Annual Meeting events in the United Kingdom."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT COUNT(*) FROM party_events AS T1 JOIN party AS T2 ON T1.Party_ID = T2.Party_ID JOIN region AS T3 ON T2.Region_ID = T3.Region_ID WHERE T1.Event_Name = 'Annual Meeting' AND T3.Region_name = 'United Kingdom'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT clause represents the party name, while the count function aggregates the total number of events for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    }\n}\n"}
{"sample_id": "train.2176", "db_id": "formula_1", "question": "What are the names and years of all races that had a driver with the last name Lewis?", "rationale": ["Identify the tables needed: races, results, and drivers.", "We need to select the names and years of races, so we will select 'races.name' and 'races.year'.", "To find the relevant races, we need to join the 'races' table with the 'results' table on 'raceId'.", "Next, we join the 'results' table with the 'drivers' table on 'driverId' to access driver information.", "We filter the results to include only those where the driver's surname is 'Lewis'."], "gold_sql": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = 'Lewis'", "source_tables": ["results", "drivers", "races"], "pred_sql": "SELECT races.name, races.year FROM races JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE drivers.surname = 'Lewis';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the races of interest: Australian Grand Prix and Chinese Grand Prix.", "Use a SQL query to select the first and last names of drivers who participated in the Australian Grand Prix.", "Utilize the EXCEPT clause to exclude those drivers who also participated in the Chinese Grand Prix.", "Join the races, results, and drivers tables to get the required information about the drivers.", "Construct the final SQL query using the provided virtual table structure."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT T3.forename, T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename, T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T1.name = 'Chinese Grand Prix'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2183", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who was in position 1 as standing and won?", "rationale": ["We need to find distinct drivers who were in position 1 as standing and won.", "To do this, we will join the 'results' table with the 'drivers' table to get the forenames of the drivers.", "We also need to join the 'driverStandings' table to filter for those who were in position 1 and had wins.", "The condition for position is 'T4.position = 1' and for wins is 'T4.wins > 0'.", "Finally, we select distinct forenames from the results."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT T3.forename FROM results AS T2 JOIN drivers AS T3 ON T2.driverId = T3.driverId JOIN driverStandings AS T4 ON T2.raceId = T4.raceId WHERE T4.position = 1 AND T4.wins > 0;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2185", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["We need to find distinct drivers who won in position 1 and had more than 20 points.", "The relevant table for driver standings is 'driverStandings', which contains the position and points for each driver in a race.", "We will join the 'driverStandings' table with the 'drivers' table to get the forenames of the drivers.", "We filter the results where the position is 1 and points are greater than 20.", "Finally, we select distinct forenames to avoid duplicates."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM driverStandings ds \nJOIN drivers d ON ds.driverId = d.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2186", "db_id": "formula_1", "question": "What are the first names of the different drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["We need to find the first names of drivers who won in position 1 as per driver standings and had more than 20 points.", "To achieve this, we will join the 'results' table with the 'driverStandings' table on the driverId to get the standings of each driver.", "Next, we will join the 'drivers' table to get the first names of these drivers.", "We will filter the results where the position in driver standings is 1 and the points are greater than 20.", "Finally, we will select distinct first names to avoid duplicates."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM results AS r \nJOIN driverStandings AS ds ON r.driverId = ds.driverId \nJOIN drivers AS d ON r.driverId = d.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2189", "db_id": "formula_1", "question": "What are the numbers of races for each constructor id?", "rationale": ["The question asks for the number of races for each constructor id.", "To get this information, we need to count the number of races associated with each constructor.", "The relevant table for this information is 'constructorResults', which links constructors to races.", "We will use the COUNT function to count the occurrences of raceId for each constructorId.", "We will group the results by constructorId to get the count for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(raceId) AS number_of_races FROM constructorResults GROUP BY constructorId;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the distinct number of drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.\",\n        \"virtual_table\": \"SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the relevant tables: constructors and constructorResults.", "We need to find constructors that are Japanese, so we will filter by nationality in the constructors table.", "We also need to check the points earned by these constructors, which is found in the constructorResults table.", "Join the constructors table with the constructorResults table on the constructorId to access both sets of information.", "Apply the filters for nationality and points in the WHERE clause."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT c.name \nFROM constructors AS c \nJOIN constructorResults AS cr ON c.constructorId = cr.constructorId \nWHERE c.nationality = 'Japanese' \nAND cr.points > 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: 'races' for race details and 'results' for fastest lap speeds.", "We need to find the average fastest lap speed for a specific race, which is the Monaco Grand Prix in 2008.", "Join the 'races' table with the 'results' table on the raceId to access both race and result data.", "Filter the results to only include those from the Monaco Grand Prix in 2008 using a WHERE clause.", "Use the AVG() function to calculate the average of the fastest lap speeds from the results."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(T2.fastestLapSpeed) AS average_fastest_lap_speed \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nWHERE T1.name = 'Monaco Grand Prix' AND T1.year = 2008;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2221", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["Identify the relevant tables: 'races' for race details and 'results' for fastest lap speeds.", "We need to find the maximum fastest lap speed for a specific race, so we will join the 'races' table with the 'results' table on 'raceId'.", "Filter the results to only include the race named 'Monaco Grand Prix' in the year 2008 using a WHERE clause.", "Select the maximum value of 'fastestLapSpeed' from the results of the joined tables."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT max(T2.fastestLapSpeed) FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.name = 'Monaco Grand Prix' AND T1.year = 2008", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: 'races' for race details and 'results' for fastest lap speeds.", "We need to find the maximum fastest lap speed for a specific race, which is the Monaco Grand Prix in 2008.", "Join the 'races' table with the 'results' table on the raceId to access both race and result data.", "Filter the results to only include the Monaco Grand Prix in 2008 using the WHERE clause.", "Select the maximum value of the fastest lap speed from the results table."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT max(T2.fastestLapSpeed) AS max_fastest_lap_speed \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nWHERE T1.name = 'Monaco Grand Prix' AND T1.year = 2008;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["Identify the tables needed: 'races' for race names and years, and 'results' for fastest lap speeds.", "Join the 'races' table with the 'results' table on the raceId to access both race names and their corresponding fastest lap speeds.", "Filter the results to include only races that occurred after the year 2004 using a WHERE clause.", "Use the MAX function to find the maximum fastest lap speed for each race.", "Group the results by race name to ensure we get the maximum speed for each race individually.", "Order the final results by year to present them in chronological order."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT max(T2.fastestLapSpeed), T1.name, T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.year > 2004 GROUP BY T1.name ORDER BY T1.year", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2225", "db_id": "formula_1", "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the tables needed: We need data from the 'races' table for race names and years, and from the 'results' table for fastest lap speeds.", "Join the 'races' table with the 'results' table on the raceId to combine race information with results.", "Filter the results to include only races held after 2004 using a WHERE clause.", "Calculate the average fastest lap speed using AVG() function and group the results by race name and year.", "Order the final results by year to get a chronological list."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(T2.fastestLapSpeed) AS average_fastest_lap_speed, T1.name, T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.year > 2004 GROUP BY T1.name ORDER BY T1.year", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2226", "db_id": "formula_1", "question": "What is the average fastest lap speed for races held after 2004, for each race, ordered by year?", "rationale": ["Identify the tables needed: We need data from the 'races' table for the year and the 'results' table for the fastest lap speed.", "Join the 'races' table with the 'results' table on 'raceId' to combine race information with results.", "Filter the races to include only those held after 2004 using a WHERE clause.", "Calculate the average fastest lap speed using AVG() function and group the results by year to get the average for each year.", "Order the results by year to present them in chronological order."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(T2.fastestLapSpeed) AS average_fastest_lap_speed, T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.year > 2004 GROUP BY T1.year ORDER BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the distinct number of drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.\",\n        \"virtual_table\": \"SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2243", "db_id": "machine_repair", "question": "What is the starting year of the oldest technicians?", "rationale": ["Identify the relevant table: The 'technician' table contains the 'Starting_Year' column which is needed to find the oldest technician.", "Use the MIN() function to find the earliest starting year from the 'Starting_Year' column.", "Construct the SQL query to select the minimum starting year from the 'technician' table."], "gold_sql": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT MIN(Starting_Year) AS Oldest_Starting_Year FROM technician;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the starting years of technicians from the 'technician' table who belong to two specific teams. The placeholders in the WHERE clause represent the identifiers for the teams being compared.\",\n        \"virtual_table\": \"SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the number of repair assignments handled by each technician. It joins the 'repair_assignment' table with the 'technician' table to associate each assignment with the technician's name. The result is grouped by the technician's name, allowing for a count of assignments per technician.\",\n        \"virtual_table\": \"SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name\"\n    }\n}\n"}
{"sample_id": "train.2248", "db_id": "machine_repair", "question": "What are the teams with the most technicians?", "rationale": ["We need to find the teams with the most technicians.", "To do this, we will count the number of technicians in each team.", "We will use the COUNT() function to count the technicians grouped by their team.", "The GROUP BY clause will be used to group the results by the 'Team' column in the technician table.", "Finally, we will order the results in descending order to show the teams with the most technicians at the top."], "gold_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT Team, COUNT(*) AS technician_count FROM technician GROUP BY Team ORDER BY technician_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the starting years of technicians from the 'technician' table who belong to two specific teams. The placeholders in the WHERE clause represent the identifiers for the teams being compared.\",\n        \"virtual_table\": \"SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the number of repair assignments handled by each technician. It joins the 'repair_assignment' table with the 'technician' table to associate each assignment with the technician's name. The result is grouped by the technician's name, allowing for a count of assignments per technician.\",\n        \"virtual_table\": \"SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name\"\n    }\n}\n"}
{"sample_id": "train.2258", "db_id": "machine_repair", "question": "What are the names of the technicians  and how many machines are they assigned to repair?", "rationale": ["Identify the tables involved: We need to get technician names and the count of machines they are assigned to repair, which involves the 'technician' and 'repair_assignment' tables.", "Join the tables: We will join the 'repair_assignment' table with the 'technician' table on the technician ID to associate each repair assignment with the technician's name.", "Count the assignments: We will use COUNT(*) to count the number of repair assignments for each technician.", "Group by technician name: To get the count per technician, we will group the results by the technician's name."], "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name", "source_tables": ["repair_assignment", "technician"], "pred_sql": "SELECT T2.Name, COUNT(*) AS Machine_Count FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_id = T2.technician_id GROUP BY T2.Name", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the number of repair assignments handled by each technician. It joins the 'repair_assignment' table with the 'technician' table to associate each assignment with the technician's name. The result is grouped by the technician's name, allowing for a count of assignments per technician.\",\n        \"virtual_table\": \"SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the starting years of technicians from the 'technician' table who belong to two specific teams. The placeholders in the WHERE clause represent the identifiers for the teams being compared.\",\n        \"virtual_table\": \"SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2328", "db_id": "csu_1", "question": "Find all the campuses opened in 1958.", "rationale": ["Identify the relevant table: The question asks about campuses, which are listed in the 'Campuses' table.", "Determine the filtering criteria: The question specifies campuses opened in the year 1958, so we need to filter by the 'Year' column.", "Construct the SQL query: We will select all relevant columns from the 'Campuses' table where the 'Year' is equal to '1958'."], "gold_sql": "SELECT campus FROM campuses WHERE YEAR  =  1958", "source_tables": ["campuses"], "pred_sql": "SELECT Id, Campus, Location, County, Year FROM Campuses WHERE Year = '1958'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2334", "db_id": "csu_1", "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.", "rationale": ["Identify the relevant tables: The question pertains to the 'Campuses' table, which contains information about campus names and their locations.", "Determine the conditions: The campuses need to be in either 'Northridge, Los Angeles' or 'San Francisco, San Francisco'.", "Use the UNION operator to combine results from two SELECT statements: One for each location and county combination.", "Construct the first SELECT statement to find campuses in Northridge, Los Angeles: SELECT Campus FROM Campuses WHERE Location = 'Northridge' AND County = 'Los Angeles'.", "Construct the second SELECT statement to find campuses in San Francisco, San Francisco: SELECT Campus FROM Campuses WHERE Location = 'San Francisco' AND County = 'San Francisco'.", "Combine both SELECT statements using UNION to get the final result."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE Location = 'Northridge' AND County = 'Los Angeles' UNION SELECT Campus FROM Campuses WHERE Location = 'San Francisco' AND County = 'San Francisco'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the names of campuses from the 'Campuses' table that are located in a specific geographical location and county. The query uses placeholders for the location and county to allow for flexible input.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2350", "db_id": "csu_1", "question": "Which campus has the most faculties in year 2003?", "rationale": ["Identify the relevant tables: Campuses and faculty.", "Join the Campuses table with the faculty table on the campus identifier.", "Filter the results for the year 2003 using the WHERE clause.", "Order the results by the number of faculty members in descending order to get the campus with the most faculty.", "Limit the results to 1 to get only the campus with the highest number of faculty."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T1.Campus, T2.Faculty FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus WHERE T2.Year = 2003 ORDER BY T2.Faculty DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2356", "db_id": "csu_1", "question": "report the total number of degrees granted between 1998 and 2002.", "rationale": ["Identify the relevant tables: 'Campuses' and 'degrees'.", "We need to sum the total number of degrees awarded, so we will use the SUM function on the 'Degrees' column from the 'degrees' table.", "We need to filter the results based on the year range from 1998 to 2002, which will be done using a WHERE clause.", "Join the 'Campuses' table with the 'degrees' table on the campus identifier to ensure we are counting degrees awarded at each campus.", "Construct the SQL query to select the sum of degrees for the specified year range."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(T2.Degrees) FROM Campuses AS T1 JOIN degrees AS T2 ON T1.Id = T2.Campus WHERE T2.Year >= '1998' AND T2.Year <= '2002'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to join these tables on the campus identifier (Id in Campuses and Campus in degrees).", "Filter the results to include only campuses in Orange county.", "Filter the degrees awarded to include only those granted after the year 2000.", "Group the results by campus to get the total number of degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT T1.Campus, SUM(T2.Degrees) FROM Campuses AS T1 JOIN degrees AS T2 ON T1.Id = T2.Campus WHERE T1.County = 'Orange' AND T2.Year >= '2000' GROUP BY T1.Campus", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant table for total enrollments, which is the 'enrollments' table.", "Filter the records for the year 1956 by using a WHERE clause on the 'Year' column.", "Add conditions to filter campuses with total enrollment greater than 400 and full-time equivalent (FTE) enrollment greater than 200 using additional WHERE clauses."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT e.Campus \nFROM enrollments AS e \nWHERE e.Year = '1956' \nAND e.TotalEnrollment_AY > 400 \nAND e.FTE_AY > 200;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2363", "db_id": "csu_1", "question": "What campus started in year 1956, has more than 200 full time students, and more than 400 students enrolled?", "rationale": ["Identify the relevant tables: Campuses and enrollments.", "We need to filter campuses based on the year they started, which is in the Campuses table.", "We also need to check for the number of full-time students (FTE_AY) and total enrollments (TotalEnrollment_AY) from the enrollments table.", "Join the Campuses table with the enrollments table on the campus identifier.", "Apply the filters: year = 1956, FTE_AY > 200, and TotalEnrollment_AY > 400."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT c.Campus \nFROM Campuses c \nJOIN enrollments e ON c.Id = e.Campus \nWHERE c.Year = '1956' \nAND e.TotalEnrollment_AY > '400' \nAND e.FTE_AY > '200';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2366", "db_id": "csu_1", "question": "List the campuses in Los Angeles county.", "rationale": ["Identify the relevant table: The 'Campuses' table contains information about campuses, including their location and county.", "Determine the filtering criteria: We need to filter campuses based on the county, specifically 'Los Angeles'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' column from the 'Campuses' table where the 'County' matches 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the names of campuses from the 'Campuses' table that are located in a specific geographical location and county. The query uses placeholders for the location and county to allow for flexible input.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: 'Campuses' for campus information and 'degrees' for degree information.", "Join the 'Campuses' table with the 'degrees' table on the campus identifier.", "Filter the results to include only records for 'San Jose State University'.", "Further filter the results to include only degrees conferred in the year 2000.", "Use the SUM function to calculate the total number of degrees conferred."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(T2.Degrees) FROM Campuses AS T1 JOIN degrees AS T2 ON T1.Id = T2.Campus WHERE T1.Campus = 'San Jose State University' AND T2.Year = '2000'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2374", "db_id": "csu_1", "question": "What is the number of faculty lines in campus \"Long Beach State University\" in 2002?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to filter by campus name.", "Filter the results to only include records for 'Long Beach State University' and the year 2002.", "Count the number of faculty lines for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2002 AND T2.campus  =  'Long Beach State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) FROM faculty AS t2 JOIN Campuses AS t1 ON t1.Id = t2.Campus WHERE t1.Campus = 'Long Beach State University' AND t2.Year = 2002;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2376", "db_id": "csu_1", "question": "How many faculty lines are there in \"San Francisco State University\" in year 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to filter by campus name.", "Filter the results to only include records for 'San Francisco State University'.", "Further filter the results to only include records for the year 2004.", "Count the number of faculty lines that meet these criteria."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) FROM faculty AS t2 JOIN Campuses AS t1 ON t1.Id = t2.Campus WHERE t1.Campus = 'San Francisco State University' AND t2.Year = 2004;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus identification.", "We need to filter the faculty data for a specific campus ('San Francisco State University') and a specific year (2004).", "Use a subquery to find the Id of 'San Francisco State University' from the 'Campuses' table.", "Count the number of faculty lines for that specific campus and year using COUNT(*) in the main query."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) FROM faculty WHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Francisco State University') AND Year = 2004;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2381", "db_id": "csu_1", "question": "How many faculty members did the university that conferred the most degrees in 2002 have?", "rationale": ["Identify the year of interest, which is 2002, for the degrees awarded.", "Determine which campus conferred the most degrees in 2002 by summing the degrees awarded and grouping by campus.", "Use a subquery to find the campus with the maximum number of degrees awarded in 2002.", "Join the faculty table to get the number of faculty members for that specific campus.", "Select the faculty count for the campus that conferred the most degrees in 2002."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty AS f \nJOIN degrees AS d ON f.Campus = d.Campus \nWHERE d.Year = '2002' \nAND d.Campus = (SELECT d.Campus \n                FROM degrees AS d \n                WHERE d.Year = '2002' \n                GROUP BY d.Campus \n                ORDER BY SUM(d.Degrees) DESC \n                LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2382", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the least number of degrees in year 2001?", "rationale": ["Identify the year of interest, which is 2001.", "Use the degrees table to find the campus that conferred the least number of degrees in 2001.", "Group the results by campus and order them by the sum of degrees in ascending order to find the campus with the least degrees.", "Limit the result to 1 to get only the campus with the least degrees.", "Use the faculty table to count the number of faculty lines for that specific campus."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(*) FROM faculty WHERE campus = (SELECT T1.campus FROM campuses AS T1 JOIN degrees AS T2 ON T1.id = T2.campus WHERE T2.year = 2001 GROUP BY T1.campus ORDER BY SUM(T2.degrees) ASC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the year of interest, which is 2001.", "Use the degrees table to find the total number of degrees awarded by each campus in 2001.", "Group the results by campus and sum the degrees awarded to get the total degrees per campus.", "Order the campuses by the total degrees in ascending order to find the campus with the least degrees awarded.", "Limit the results to 1 to get only the campus with the least degrees.", "Join this result with the faculty table to find the number of faculty members at that campus.", "Count the number of faculty members for the campus that awarded the least degrees."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(faculty.Faculty) FROM faculty AS faculty JOIN (SELECT T1.Campus, SUM(T2.Degrees) AS TotalDegrees FROM campuses AS T1 JOIN degrees AS T2 ON T1.Id = T2.Campus WHERE T2.Year = '2001' GROUP BY T1.Campus ORDER BY TotalDegrees ASC LIMIT 1) AS LeastDegrees ON faculty.Campus = LeastDegrees.Campus;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "Determine the specific campus of interest, which is 'San Jose State'.", "Use a subquery to find the 'Id' of 'San Jose State' from the 'Campuses' table.", "Filter the 'discipline_enrollments' table by the campus 'Id' obtained from the subquery.", "Sum the 'Undergraduate' column to get the total number of undergraduates at 'San Jose State'."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT SUM(Undergraduate) AS Total_Undergraduates FROM discipline_enrollments WHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Jose State')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2397", "db_id": "candidate_poll", "question": "Return the poll resource associated with the most candidates.", "rationale": ["We need to find the poll resource associated with the most candidates.", "To do this, we will select the 'Poll_Source' from the 'candidate' table.", "We will count the number of candidates associated with each 'Poll_Source' using COUNT(*).", "We will group the results by 'Poll_Source' to aggregate the counts for each source.", "Finally, we will order the results in descending order based on the count of candidates and limit the result to 1 to get the source with the most candidates."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source, COUNT(*) as Candidate_Count FROM candidate GROUP BY Poll_Source ORDER BY Candidate_Count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n        \"virtual_table\": \"SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n        \"virtual_table\": \"SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate\"\n    }\n}\n"}
{"sample_id": "train.2405", "db_id": "candidate_poll", "question": "Return the poll source corresponding to the candidate who has the oppose rate.", "rationale": ["Identify the relevant table: The 'candidate' table contains the 'Poll_Source' and 'Oppose_rate' columns.", "Determine the condition: We need to find the poll source for candidates who have an oppose rate, which implies we are looking for records where 'Oppose_rate' is not null.", "Construct the SQL query: We will select 'Poll_Source' from the 'candidate' table where 'Oppose_rate' is not null."], "gold_sql": "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source FROM candidate WHERE Oppose_rate IS NOT NULL", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n        \"virtual_table\": \"SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n        \"virtual_table\": \"SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate\"\n    }\n}\n"}
{"sample_id": "train.2417", "db_id": "candidate_poll", "question": "For each sex, what is the name and sex of the candidate with the oppose rate for their sex?", "rationale": ["Identify the relevant tables: 'candidate' for candidate data and 'people' for personal details.", "We need to join the 'candidate' table with the 'people' table using the foreign key 'People_ID'.", "We want to select the name and sex of candidates along with their oppose rate.", "The query should filter candidates based on their sex, so we will use a subquery to get distinct sexes from the 'people' table.", "Finally, we will order the results by sex to group them accordingly."], "gold_sql": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex", "source_tables": ["candidate", "people"], "pred_sql": "SELECT p.Name, p.Sex, c.Oppose_rate \nFROM candidate c \nJOIN people p ON c.People_ID = p.People_ID \nWHERE p.Sex IN (SELECT DISTINCT Sex FROM people) \nORDER BY p.Sex;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n        \"virtual_table\": \"SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n        \"virtual_table\": \"SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate\"\n    }\n}\n"}
{"sample_id": "train.2434", "db_id": "movie_1", "question": "Find the titles of all movies directed by steven spielberg.", "rationale": ["Identify the relevant table: The 'Movie' table contains the information about movie titles and directors.", "Determine the required columns: We need the 'title' of the movies directed by 'steven spielberg'.", "Formulate the SQL query: Use a SELECT statement to retrieve the 'title' from the 'Movie' table where the 'director' matches 'steven spielberg'."], "gold_sql": "SELECT title FROM Movie WHERE director = 'Steven Spielberg'", "source_tables": ["movie"], "pred_sql": "SELECT title FROM Movie WHERE director = 'steven spielberg'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles and directors of movies from the 'Movie' table that have the same director but different titles. The query uses a self-join on the 'Movie' table to compare movies directed by the same person, ensuring that the titles are not the same. The results are ordered by the director's name and the movie title.\",\n        \"virtual_table\": \"SELECT T1.title ,  T1.director FROM Movie AS T1 JOIN Movie AS T2 ON T1.director  =  T2.director WHERE T1.title != T2.title ORDER BY T1.director ,  T1.title\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2461", "db_id": "movie_1", "question": "What are the different names of all reviewers whose ratings do not have a date field?", "rationale": ["Identify the tables involved: We need to get reviewer names from the Reviewer table and check their ratings in the Rating table.", "We need to find reviewers whose ratings do not have a date field, which means we are looking for records in the Rating table where the ratingDate is NULL.", "To get the names of the reviewers, we will join the Reviewer table with the Rating table on the rID field.", "We will use a SELECT DISTINCT statement to ensure that we only get unique reviewer names."], "gold_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  'null'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT R.name \nFROM Reviewer AS R \nJOIN Rating AS T1 ON R.rID = T1.rID \nWHERE T1.ratingDate IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average star ratings of movies from the 'Rating' table, excluding those rated by a specific reviewer. The placeholder in the subquery represents the reviewer's name whose ratings are to be excluded.\",\n        \"virtual_table\": \"SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]) GROUP BY mID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average star ratings of movies from the 'Rating' table, excluding those rated by a specific reviewer. The placeholder in the subquery represents the reviewer's name whose ratings are to be excluded.\",\n        \"virtual_table\": \"SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]) GROUP BY mID\"\n    }\n}\n"}
{"sample_id": "train.2476", "db_id": "movie_1", "question": "Find the names of all reviewers who rated Gone with the Wind.", "rationale": ["Identify the tables involved: We need to get reviewer names, so we will use the Reviewer table. We also need to link ratings to movies, so we will use the Rating and Movie tables.", "Determine the relationships: The Reviewer table is linked to the Rating table through rID, and the Rating table is linked to the Movie table through mID.", "Formulate the query: We need to select the names of reviewers from the Reviewer table where their ratings correspond to the movie titled 'Gone with the Wind'.", "Use JOINs to connect the tables: We will join the Reviewer table with the Rating table on rID, and then join the Rating table with the Movie table on mID.", "Add a WHERE clause: We will filter the results to only include ratings for the movie 'Gone with the Wind'."], "gold_sql": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  'Gone with the Wind'", "source_tables": ["rating", "movie", "reviewer"], "pred_sql": "SELECT Reviewer.name FROM Reviewer JOIN Rating ON Reviewer.rID = Rating.rID JOIN Movie ON Rating.mID = Movie.mID WHERE Movie.title = 'Gone with the Wind';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2483", "db_id": "movie_1", "question": "What are the names of all the reviewers and movie names?", "rationale": ["The question asks for the names of all reviewers and the names of movies they reviewed.", "To get this information, we need to join the Reviewer table with the Rating table on the reviewer ID (rID).", "Next, we need to join the resulting table with the Movie table on the movie ID (mID) to get the movie titles.", "The final SQL query will select the reviewer's name from the Reviewer table and the movie title from the Movie table."], "gold_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "source_tables": ["movie", "reviewer"], "pred_sql": "SELECT Reviewer.name, Movie.title FROM Reviewer JOIN Rating ON Reviewer.rID = Rating.rID JOIN Movie ON Rating.mID = Movie.mID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    }\n}\n"}
{"sample_id": "train.2495", "db_id": "movie_1", "question": "For each director, how many reviews have they received?", "rationale": ["Identify the tables involved: Movie and Rating.", "We need to count the number of reviews for each director, which means we need to aggregate data by the director's name.", "Join the Movie table with the Rating table on the movie ID (mID) to link each review to its corresponding movie.", "Use COUNT() function to count the number of ratings (reviews) for each director.", "Group the results by the director's name to get the count for each director."], "gold_sql": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT M.director, COUNT(R.rID) AS review_count \nFROM Movie AS M \nJOIN Rating AS R ON M.mID = R.mID \nGROUP BY M.director", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2500", "db_id": "movie_1", "question": "What are the names and years of the movies that has the top 3 highest rating star?", "rationale": ["Identify the main goal: to find the names and years of movies with the top 3 highest ratings.", "The relevant tables are Movie and Rating, as we need movie details and their ratings.", "To get the top 3 highest ratings, we can use a subquery on the Rating table to select mID ordered by stars in descending order and limit the results to 3.", "Once we have the top 3 mIDs, we can join this result with the Movie table to get the title and year of these movies.", "The final SQL query selects the title and year from the Movie table where the mID is in the list of top 3 mIDs from the subquery."], "gold_sql": "SELECT T2.title ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID ORDER BY T1.stars DESC LIMIT 3", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title, year FROM Movie WHERE mID IN (SELECT mID FROM Rating ORDER BY stars DESC LIMIT 3)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    }\n}\n"}
{"sample_id": "train.2502", "db_id": "movie_1", "question": "For each director, return the director's name together with the title of the movie they directed that received the highest rating among all of their movies, and the value of that rating. Ignore movies whose director is NULL.", "rationale": ["We need to find the highest-rated movie for each director.", "First, we join the Movie table with the Rating table on the movie ID (mID) to access both movie titles and their ratings.", "We filter out any movies where the director is NULL using the WHERE clause.", "Next, we group the results by director and movie title to aggregate the ratings for each movie directed by the same director.", "To find the highest rating for each director, we use the MAX function on the stars column.", "Finally, we use a HAVING clause to ensure that we only return the movie with the maximum rating for each director. We achieve this by comparing the maximum stars of each movie to the maximum stars of all movies directed by that director."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT M.director, M.title, MAX(R.stars) AS highest_rating\nFROM Movie AS M\nJOIN Rating AS R ON M.mID = R.mID\nWHERE M.director IS NOT NULL\nGROUP BY M.director, M.title\nHAVING MAX(R.stars) = (SELECT MAX(stars) FROM Rating WHERE mID IN (SELECT mID FROM Movie WHERE director = M.director))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the titles and directors of movies from the 'Movie' table that have the same director but different titles. The query uses a self-join on the 'Movie' table to compare movies directed by the same person, ensuring that the titles are not the same. The results are ordered by the director's name and the movie title.\",\n        \"virtual_table\": \"SELECT T1.title ,  T1.director FROM Movie AS T1 JOIN Movie AS T2 ON T1.director  =  T2.director WHERE T1.title != T2.title ORDER BY T1.director ,  T1.title\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the unique movie identifiers along with the average star ratings from the 'Rating' table. It groups the results by movie ID and filters to include only those movies that have received a minimum number of ratings, as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2503", "db_id": "movie_1", "question": "For each director, what are the titles and ratings for all the movies they reviewed?", "rationale": ["The question asks for the titles and ratings of movies reviewed by each director.", "To get this information, we need to join the Rating table with the Movie table using the movie ID (mID).", "The Rating table contains the ratings (stars) given by reviewers, and the Movie table contains the titles and directors of the movies.", "We will select the title of the movie, the stars given in the rating, and the director's name from the joined tables.", "The SQL query will be structured as a SELECT statement that retrieves these columns from the joined tables."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.title, T1.stars, T2.director FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2505", "db_id": "movie_1", "question": "For each reviewer id, what is the title and rating for the movie with the smallest rating?", "rationale": ["We need to find the title and rating for the movie with the smallest rating for each reviewer.", "To achieve this, we will join the Rating table with the Movie table to get the movie titles along with their ratings.", "We will use a subquery to find the minimum stars given by each reviewer. This subquery will select the minimum stars from the Rating table where the reviewer ID matches the current row's reviewer ID.", "The main query will select the title of the movie, the reviewer ID, and the stars from the Rating table where the stars are equal to the minimum stars found in the subquery."], "gold_sql": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.title, T1.rID, T1.stars FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID WHERE T1.stars = (SELECT MIN(stars) FROM Rating WHERE rID = T1.rID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2507", "db_id": "movie_1", "question": "For each director, what is the title and score of their most poorly rated movie?", "rationale": ["We need to find the title and score of the most poorly rated movie for each director.", "To do this, we will join the Rating table with the Movie table on the movie ID (mID).", "We will group the results by director and title to aggregate the ratings for each movie directed by the same individual.", "We will use the MIN function to find the lowest star rating for each movie.", "To ensure we only get the most poorly rated movie for each director, we will use a HAVING clause that compares the minimum stars of each movie to the overall minimum stars for that director."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.director, T2.title, MIN(T1.stars) AS min_stars \nFROM Rating AS T1 \nJOIN Movie AS T2 ON T1.mID = T2.mID \nGROUP BY T2.director, T2.title \nHAVING MIN(T1.stars) = (SELECT MIN(stars) \n                         FROM Rating AS T3 \n                         JOIN Movie AS T4 ON T3.mID = T4.mID \n                         WHERE T4.director = T2.director)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2508", "db_id": "movie_1", "question": "What is the name of the movie that is rated by most of times?", "rationale": ["Identify the goal: We need to find the name of the movie that has been rated the most times.", "To achieve this, we will count the number of ratings for each movie using the Rating table.", "We will group the results by movie ID (mID) to get the count of ratings for each movie.", "Next, we will order these counts in descending order to find the movie with the highest count.", "Finally, we will limit the results to just one movie to get the top-rated movie.", "We will then join this result with the Movie table to get the title of that movie."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title FROM Movie WHERE mID IN (SELECT mID FROM Rating GROUP BY mID ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    }\n}\n"}
{"sample_id": "train.2509", "db_id": "movie_1", "question": "What is the name of the movie that has been reviewed the most?", "rationale": ["Identify the goal: We need to find the name of the movie that has been reviewed the most.", "To determine which movie has been reviewed the most, we need to count the number of reviews for each movie.", "We can achieve this by grouping the ratings by movie ID (mID) and counting the number of reviewer IDs (rID) for each movie.", "Next, we will order these counts in descending order to get the movie with the highest number of reviews at the top.", "Finally, we will limit our results to just one movie to get the top-reviewed movie.", "We will then select the title of this movie from the Movie table using its mID."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title FROM Movie WHERE mID IN (SELECT mID FROM Rating GROUP BY mID ORDER BY COUNT(rID) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    }\n}\n"}
{"sample_id": "train.2517", "db_id": "movie_1", "question": "What are the ids of all moviest hat have not been reviewed by Britanny Harris?", "rationale": ["Identify the movies that have not been reviewed by Britanny Harris.", "To find this, we need to select all movie IDs from the Movie table.", "We will use a subquery to find all movie IDs that have been reviewed by Britanny Harris.", "The subquery will join the Rating table with the Reviewer table to filter ratings by Britanny Harris.", "The main query will select movie IDs from the Movie table that are not in the list of IDs returned by the subquery."], "gold_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT mID FROM Movie WHERE mID NOT IN (SELECT mID FROM Rating JOIN Reviewer ON Rating.rID = Reviewer.rID WHERE Reviewer.name = 'Britanny Harris');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the unique movie identifiers along with the average star ratings from the 'Rating' table. It groups the results by movie ID and filters to include only those movies that have received a minimum number of ratings, as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2518", "db_id": "movie_1", "question": "Find the average rating star for each movie that received at least 2 ratings.", "rationale": ["The task is to find the average rating star for each movie that received at least 2 ratings.", "We need to calculate the average stars for each movie, which can be done using the AVG() function on the 'stars' column from the 'Rating' table.", "To ensure we only include movies with at least 2 ratings, we will use the HAVING clause with COUNT(*) to filter the results after grouping by movie ID (mID).", "The provided virtual table in the hint already outlines the necessary structure for this query, indicating that we should select mID and the average of stars, grouping by mID and applying a count filter."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2", "source_tables": ["rating"], "pred_sql": "SELECT mID, avg(stars) FROM Rating GROUP BY mID HAVING count(*) >= 2", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the unique movie identifiers along with the average star ratings from the 'Rating' table. It groups the results by movie ID and filters to include only those movies that have received a minimum number of ratings, as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    }\n}\n"}
{"sample_id": "train.2528", "db_id": "movie_1", "question": "What are the names of reviewers who had rated 3 star and 4 star?", "rationale": ["The question asks for the names of reviewers who rated movies with 3 stars and 4 stars.", "To find reviewers who rated both, we can use the INTERSECT operation, which will return only those reviewers who appear in both sets of results.", "We need to join the Rating table with the Reviewer table to get the names of the reviewers based on their ratings.", "The first part of the query selects reviewer names who rated movies with 3 stars.", "The second part of the query selects reviewer names who rated movies with 4 stars.", "By using INTERSECT, we ensure that only reviewers who rated both 3 stars and 4 stars are returned."], "gold_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID = T2.rID WHERE T1.stars = '3' INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID = T2.rID WHERE T1.stars = '4'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of reviewers who have given a specific number of stars to movies. The query uses an INTERSECT operation to find reviewers who rated two different movies with the same star rating. The placeholders in the WHERE clause represent the number of stars given in the ratings.\",\n        \"virtual_table\": \"SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2530", "db_id": "movie_1", "question": "What are the names of movies that get 3 star and 4 star?", "rationale": ["The user wants to find movie titles that received both 3-star and 4-star ratings.", "To achieve this, we can use the INTERSECT operator, which allows us to find common results from two separate queries.", "The first part of the query selects movie titles from the Movie table where the rating is 3 stars.", "The second part of the query selects movie titles from the Movie table where the rating is 4 stars.", "By using INTERSECT, we ensure that only movie titles that appear in both result sets (i.e., movies rated 3 stars and 4 stars) are returned."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    }\n}\n"}
{"sample_id": "train.2576", "db_id": "inn_1", "question": "Find the most popular room in the hotel. The most popular room is the room that had seen the largest number of reservations.", "rationale": ["To find the most popular room, we need to count the number of reservations for each room.", "We will join the Reservations table (T1) with the Rooms table (T2) on the RoomId.", "We will group the results by the Room identifier to get the count of reservations for each room.", "We will order the results by the count of reservations in descending order to get the most popular room at the top.", "Finally, we will limit the results to 1 to get only the most popular room."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T2.roomName, COUNT(*) AS reservation_count \nFROM Reservations AS T1 \nJOIN Rooms AS T2 ON T1.Room = T2.RoomId \nGROUP BY T1.Room \nORDER BY reservation_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n        \"virtual_table\": \"SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    }\n}\n"}
{"sample_id": "train.2577", "db_id": "inn_1", "question": "Which room has the largest number of reservations?", "rationale": ["Identify the tables involved: Reservations and Rooms.", "We need to count the number of reservations for each room, so we will join the Reservations table with the Rooms table on the Room identifier.", "Use COUNT(*) to count the number of reservations for each room.", "Group the results by the Room identifier to get the count per room.", "Order the results in descending order based on the count of reservations to find the room with the largest number of reservations.", "Limit the results to 1 to get only the room with the highest count."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T2.roomName, COUNT(*) AS reservation_count \nFROM Reservations AS T1 \nJOIN Rooms AS T2 ON T1.Room = T2.RoomId \nGROUP BY T1.Room \nORDER BY reservation_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n        \"virtual_table\": \"SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    }\n}\n"}
{"sample_id": "train.2578", "db_id": "inn_1", "question": "How many kids stay in the rooms reserved by ROY SWEAZY?", "rationale": ["Identify the relevant table for the query, which is the Reservations table since it contains information about guests and their reservations.", "We need to sum the number of kids from the Reservations table for a specific guest, identified by their first and last name.", "The SQL query will use the SUM function to calculate the total number of kids for the specified guest.", "The WHERE clause will filter the results to include only those reservations made by ROY SWEAZY."], "gold_sql": "SELECT kids FROM Reservations WHERE FirstName = 'ROY' AND LastName  =  'SWEAZY';", "source_tables": ["reservations"], "pred_sql": "SELECT SUM(Kids) AS TotalKids \nFROM Reservations \nWHERE LastName = 'SWEAZY' AND FirstName = 'ROY';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n        \"virtual_table\": \"SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    }\n}\n"}
{"sample_id": "train.2582", "db_id": "inn_1", "question": "Which room has the highest rate? List the room's full name, rate, check in and check out date.", "rationale": ["Identify the relevant tables: Rooms and Reservations.", "We need to find the room with the highest rate, which is stored in the Reservations table under the Rate column.", "Join the Rooms table with the Reservations table on the RoomId to get room details along with reservation details.", "Select the room name, rate, check-in date, and check-out date from the joined tables.", "Order the results by the Rate in descending order to get the highest rate at the top.", "Limit the results to 1 to get only the room with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT R.roomName, R.basePrice AS Rate, Res.CheckIn, Res.CheckOut \nFROM Rooms AS R \nJOIN Reservations AS Res ON R.RoomId = Res.Room \nORDER BY Res.Rate DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n        \"virtual_table\": \"SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    }\n}\n"}
{"sample_id": "train.2583", "db_id": "inn_1", "question": "Return the name, rate, check in and check out date for the room with the highest rate.", "rationale": ["Identify the required fields: room name, rate, check-in date, and check-out date.", "Determine the tables involved: Rooms and Reservations.", "Join the Rooms table with the Reservations table on the RoomId to access room details along with reservation details.", "Use a subquery to find the maximum rate from the Reservations table.", "Filter the results to only include the reservation(s) with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T2.roomName, T1.Rate, T1.CheckIn, T1.CheckOut \nFROM Reservations AS T1 \nJOIN Rooms AS T2 ON T1.Room = T2.RoomId \nWHERE T1.Rate = (SELECT MAX(Rate) FROM Reservations)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n        \"virtual_table\": \"SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    }\n}\n"}
{"sample_id": "train.2589", "db_id": "inn_1", "question": "Find the total number of king beds available.", "rationale": ["The user wants to find the total number of king beds available.", "To achieve this, we need to count the number of rooms that have a bed type of 'king'.", "We will use the Rooms table, specifically filtering for rows where the bedType column equals 'king'.", "The SQL query will use the COUNT function to get the total number of such rooms."], "gold_sql": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT count(*) FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n        \"virtual_table\": \"SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room\"\n    }\n}\n"}
{"sample_id": "train.2590", "db_id": "inn_1", "question": "List the names and decor of rooms that have a king bed. Sort the list by their price.", "rationale": ["Identify the required information: room names and decor of rooms with a king bed.", "Refer to the provided hint for the virtual table that matches the requirement.", "The hint specifies a SELECT statement that retrieves roomName and decor from the Rooms table where bedType is 'king'.", "The results should be ordered by basePrice as specified in the user query.", "Construct the SQL query using the identified elements."], "gold_sql": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName, decor FROM Rooms WHERE bedType = 'king' ORDER BY basePrice;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    }\n}\n"}
{"sample_id": "train.2594", "db_id": "inn_1", "question": "What is the decor of room Recluse and defiance?", "rationale": ["Identify the relevant table: The 'Rooms' table contains the decor information.", "Determine the required columns: We need the 'decor' column for the specified rooms.", "Specify the condition: We want to filter the results to include only the rooms named 'Recluse' and 'defiance'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'decor' for the specified room names."], "gold_sql": "SELECT decor FROM Rooms WHERE roomName  =  'Recluse and defiance';", "source_tables": ["rooms"], "pred_sql": "SELECT decor FROM Rooms WHERE roomName IN ('Recluse', 'defiance');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;\"\n    }\n}\n"}
{"sample_id": "train.2604", "db_id": "inn_1", "question": "Find the first and last names of people who payed more than the rooms' base prices.", "rationale": ["Identify the relevant tables: Reservations and Rooms.", "We need to find the first and last names of guests from the Reservations table.", "We need to compare the Rate in Reservations with the basePrice in Rooms.", "To do this, we will use a subquery to select the basePrice from Rooms where the RoomId matches the Room in Reservations.", "The final query will select FirstName and LastName from Reservations where the Rate is greater than the basePrice from the subquery."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT FirstName, LastName FROM Reservations WHERE Rate > (SELECT basePrice FROM Rooms WHERE Rooms.RoomId = Reservations.Room);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;\"\n    }\n}\n"}
{"sample_id": "train.2609", "db_id": "inn_1", "question": "How many rooms have a king bed?", "rationale": ["The user wants to know how many rooms have a king bed.", "To find this, we need to count the number of entries in the 'Rooms' table where the 'bedType' column is equal to 'king'.", "The SQL query will use the COUNT() function to get the total number of rooms that meet this condition."], "gold_sql": "SELECT count(*) FROM Rooms WHERE bedType  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT COUNT(*) FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;\"\n    }\n}\n"}
