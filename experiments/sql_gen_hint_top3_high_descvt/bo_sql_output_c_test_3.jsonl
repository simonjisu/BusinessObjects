{"sample_id": "train.3672", "db_id": "baseball_1", "question": "For each year, return the year and the number of times the team Boston Red Stockings won in the postseasons.", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team names.", "Join the 'postseason' table with the 'team' table on the winning team ID to get the team names.", "Filter the results to only include wins by the 'Boston Red Stockings'.", "Group the results by year to count the number of wins for each year.", "Select the count of wins and the year from the grouped results."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "pred_sql": "SELECT count(*) AS wins, T1.year \nFROM postseason AS T1 \nJOIN team AS T2 ON T1.team_id_winner = T2.team_id_br \nWHERE T2.name = 'Boston Red Stockings' \nGROUP BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year\"\n    }\n}\n"}
{"sample_id": "train.3677", "db_id": "baseball_1", "question": "What is the total salary paid by team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant tables: salary and team.", "We need to sum the salary for players from the Boston Red Stockings in 2010.", "Join the salary table with the team table on team_id to filter by team name.", "Use a WHERE clause to specify the year (2010) and the team name ('Boston Red Stockings').", "Select the sum of salaries as total_salary."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT SUM(salary) AS total_salary \nFROM salary AS T1 \nJOIN team AS T2 ON T1.team_id = T2.team_id \nWHERE T1.year = 2010 AND T2.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant table for salary records, which is the 'salary' table.", "Filter the records for the year 2001 using the WHERE clause.", "Order the results by salary in descending order to get the highest salaries.", "Limit the results to the top 3 entries to get the three highest salaries."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3682", "db_id": "baseball_1", "question": "How much salary did the top 3 well-paid players get in 2001?", "rationale": ["Identify the relevant table for salary information, which is the 'salary' table.", "We need to filter the records for the year 2001, so we will use a WHERE clause to specify this year.", "To find the top 3 well-paid players, we will order the results by salary in descending order.", "Finally, we will limit the results to the top 3 entries using LIMIT 3."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3683", "db_id": "baseball_1", "question": "What were all the salary values of players in 2010 and 2001?", "rationale": ["Identify the relevant table for salary records, which is the 'salary' table.", "Determine the years of interest, which are 2010 and 2001.", "Construct a SQL query that selects the salary from the 'salary' table for each of the specified years.", "Use the UNION operator to combine the results from both years into a single result set."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT salary FROM salary WHERE year = 2010 UNION SELECT salary FROM salary WHERE year = 2001", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "The 'hall_of_fame' table contains the relevant data, specifically the 'yearid' and 'inducted' columns.", "We will count the number of players inducted (where 'inducted' is 'Y') for each year using COUNT(*) and group the results by 'yearid'.", "To find the year with the least inductees, we will order the results in ascending order based on the count and limit the output to 1, which will give us the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) as num_inducted FROM hall_of_fame WHERE inducted = 'Y' GROUP BY yearid ORDER BY num_inducted ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["To find the year in which the least number of players entered the Hall of Fame, we need to count the number of players inducted each year.", "We will use the 'hall_of_fame' table, which contains the 'yearid' (year of induction) and 'player_id' (identifier for each player).", "We will group the results by 'yearid' to count how many players were inducted in each year.", "Next, we will order the results by the count of 'player_id' in ascending order to get the year with the least inductees at the top.", "Finally, we will limit the results to 1 to get only the year with the least number of inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY COUNT(player_id) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: home_game for games played and park for park details.", "We need to filter the home_game table for the year 1907 and the specific park name 'Columbia Park'.", "To do this, we will first find the park_id for 'Columbia Park' from the park table.", "Then, we will sum the games played in that park for the year 1907 using the SUM function on the games column in the home_game table."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) FROM home_game WHERE year = '1907' AND park_id = (SELECT park_id FROM park WHERE park_name = 'Columbia Park');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: 'home_game' for home games and 'park' for park details.", "We need to count the number of games, so we will use COUNT(*) in the SELECT statement.", "Join the 'home_game' table with the 'park' table on the park_id to filter by park name.", "Add a WHERE clause to filter for the year 1907 and the park name 'Columbia Park'.", "Construct the final SQL query using the identified elements."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT COUNT(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id = T2.park_id WHERE T1.year = '1907' AND T2.park_name = 'Columbia Park';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant tables: We need to find the total number of games played in Atlanta in 2000, which involves the 'home_game' table for game data and the 'team' table for city information.", "Join the tables: We will join 'home_game' (T1) with 'team' (T2) on the team_id to access both game and city information.", "Filter by year and city: We will filter the results to only include games from the year 2000 and where the city is Atlanta.", "Calculate the total games: We will use the SUM function to calculate the total number of games played in Atlanta in 2000."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id WHERE T1.year = 2000 AND T2.city = 'Atlanta';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: home_game for games played and park for city information.", "Join the home_game table with the park table on the park_id to access city information.", "Filter the results for the year 2000 and the city of Atlanta.", "Use SUM to count the total number of games played in Atlanta in 2000."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(T1.games) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id = T2.park_id WHERE T1.year = 2000 AND T2.city = 'Atlanta';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3693", "db_id": "baseball_1", "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?", "rationale": ["Identify the relevant table for home game attendance, which is the 'home_game' table.", "To find the total attendance for the Boston Red Stockings, we need to filter the records in the 'home_game' table by the team ID associated with that name.", "The team ID can be found by querying the 'team' table where the name is 'Boston Red Stockings'.", "We also need to restrict the years to between 2000 and 2010, which can be done using a WHERE clause with a BETWEEN condition.", "Finally, we will use the SUM function to calculate the total attendance for the specified team and years."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT SUM(attendance) AS total_attendance \nFROM home_game \nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings') \nAND year BETWEEN 2000 AND 2010;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3698", "db_id": "baseball_1", "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?", "rationale": ["Identify the relevant tables: We need to retrieve player names based on salary records, so we will use the 'salary' and 'player' tables, along with the 'team' table to filter by team name.", "Use JOINs to connect the tables: We will join the 'salary' table with the 'player' table on 'player_id' and with the 'team' table on 'team_id'.", "Filter by year and team name: We will filter the results for the years 2005 and 2007 specifically for the 'Washington Nationals'.", "Use INTERSECT to find common players: Since we want players who were paid in both years, we will use the INTERSECT operator to find players that appear in both queries for 2005 and 2007."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT T2.name_first, T2.name_last \nFROM salary AS T1 \nJOIN player AS T2 ON T1.player_id = T2.player_id \nJOIN team AS T3 ON T3.team_id_br = T1.team_id \nWHERE T1.year = 2005 AND T3.name = 'Washington Nationals' \nINTERSECT \nSELECT T2.name_first, T2.name_last \nFROM salary AS T1 \nJOIN player AS T2 ON T1.player_id = T2.player_id \nJOIN team AS T3 ON T3.team_id_br = T1.team_id \nWHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant tables: 'home_game' for home games and 'team' for team details.", "Join the 'home_game' table with the 'team' table on 'team_id' to get team information for the year 1980.", "Filter the results to only include records from the year 1980.", "Group the results by 'team_id' to aggregate the number of home games played by each team.", "Order the results by the total number of home games in ascending order to find the team with the least number of home games.", "Limit the results to 1 to get only the team with the least number of home games."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT T2.team_id FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id WHERE T1.year = 1980 GROUP BY T1.team_id ORDER BY SUM(T1.games) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3709", "db_id": "baseball_1", "question": "Which park had most attendances in 2008?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'team' for team information.", "We need to find the park with the most attendance in 2008, so we filter the 'home_game' table for the year 2008.", "Join the 'home_game' table with the 'team' table to get team details associated with each home game.", "Group the results by team ID to aggregate attendance data for each team.", "Order the results by average attendance in descending order to find the team with the highest attendance.", "Limit the results to 1 to get only the top team."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT T2.team_id, T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id WHERE T1.year = 2008 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3857", "db_id": "insurance_policies", "question": "Find the settlement amount of the claim with the largest claim amount. Show both the settlement amount and claim amount.", "rationale": ["Identify the relevant tables: Claims and Settlements are needed to get the claim and settlement amounts.", "We need to find the claim with the largest claim amount, so we will use a subquery to get the maximum Amount_Claimed from the Claims table.", "Join the Claims table with the Settlements table on Claim_ID to access both the claim amount and the settlement amount.", "Select the Amount_Settled from Settlements and Amount_Claimed from Claims where the Amount_Claimed matches the maximum amount found in the subquery."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"], "pred_sql": "SELECT S.Amount_Settled, C.Amount_Claimed\nFROM Claims C\nJOIN Settlements S ON C.Claim_ID = S.Claim_ID\nWHERE C.Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claims);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n        \"virtual_table\": \"SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3862", "db_id": "insurance_policies", "question": "Among all the claims, which settlements have a claimed amount that is no more than the average? List the claim start date.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find settlements where the claimed amount is no more than the average claimed amount across all claims.", "Join the Claims table with the Settlements table on Claim_ID to access both claims and their corresponding settlements.", "Use a subquery to calculate the average claimed amount from the Claims table.", "Filter the results to include only those settlements where the Amount_Claimed is less than or equal to the average amount calculated."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT C.Date_Claim_Made FROM Claims C JOIN Settlements S ON C.Claim_ID = S.Claim_ID WHERE S.Amount_Claimed <= (SELECT avg(Amount_Claimed) FROM Claims)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n        \"virtual_table\": \"SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3863", "db_id": "insurance_policies", "question": "Return the claim start date for the claims whose claimed amount is no more than the average", "rationale": ["Identify the relevant table: The 'Claims' table contains the information about claims, including the claimed amounts and the dates when claims were made.", "Determine the condition: We need to find claims where the claimed amount is no more than the average claimed amount across all claims.", "Calculate the average claimed amount: This can be done using a subquery that selects the average of 'Amount_Claimed' from the 'Claims' table.", "Construct the SQL query: We will select 'Date_Claim_Made' from the 'Claims' table where 'Amount_Claimed' is less than or equal to the average amount calculated in the subquery."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Claimed <= (SELECT avg(Amount_Claimed) FROM Claims)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n        \"virtual_table\": \"SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3868", "db_id": "insurance_policies", "question": "How many settlements were made on the claim with the most recent claim settlement date? List the number and the claim id.", "rationale": ["Identify the most recent claim settlement date by using a subquery to find the maximum 'Date_Claim_Settled' from the 'Claims' table.", "Join the 'Claims' table with the 'Settlements' table on 'Claim_ID' to link claims with their settlements.", "Filter the results to only include claims that have the most recent settlement date using a WHERE clause.", "Count the number of settlements associated with that claim using COUNT(S.Settlement_ID).", "Group the results by 'Claim_ID' to get the count of settlements for each claim."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT COUNT(S.Settlement_ID) AS Number_of_Settlements, C.Claim_ID \nFROM Claims AS C \nJOIN Settlements AS S ON C.Claim_ID = S.Claim_ID \nWHERE C.Date_Claim_Settled = (SELECT MAX(Date_Claim_Settled) FROM Claims) \nGROUP BY C.Claim_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n        \"virtual_table\": \"SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )\"\n    }\n}\n"}
{"sample_id": "train.3869", "db_id": "insurance_policies", "question": "Find the claim id and the number of settlements made for the claim with the most recent settlement date.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find the claim ID and the number of settlements for the claim with the most recent settlement date.", "Join the Claims table with the Settlements table on Claim_ID to link claims with their settlements.", "Use a subquery to find the maximum settlement date from the Settlements table.", "Group the results by Claim_ID to count the number of settlements for each claim.", "Select the Claim_ID and the count of settlements as Number_of_Settlements."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT T1.Claim_ID, COUNT(T2.Settlement_ID) AS Number_of_Settlements \nFROM Claims AS T1 \nJOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID \nWHERE T2.Date_Claim_Settled = (SELECT MAX(Date_Claim_Settled) FROM Settlements) \nGROUP BY T1.Claim_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n        \"virtual_table\": \"SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )\"\n    }\n}\n"}
{"sample_id": "train.3878", "db_id": "insurance_policies", "question": "What is the most popular payment method?", "rationale": ["Identify the relevant table: The Payments table contains information about payment transactions, including the payment method.", "Determine the required information: We need to find the most popular payment method, which implies counting the occurrences of each payment method.", "Use the COUNT function: To find out how many times each payment method was used, we will use the COUNT function on the Payment_Method_Code column.", "Group the results: We will group the results by Payment_Method_Code to aggregate the counts for each method.", "Order the results: To find the most popular method, we will order the results in descending order based on the count of payments.", "Limit the results: Since we only want the most popular payment method, we will limit the results to 1."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Payment_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Payment_Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3879", "db_id": "insurance_policies", "question": "Which payment method is used the most often?", "rationale": ["Identify the relevant table: The question is about payment methods, so we will focus on the Payments table.", "Determine the required information: We need to find out which payment method is used the most often, which implies counting the occurrences of each payment method.", "Use the COUNT function: We will count the number of times each Payment_Method_Code appears in the Payments table.", "Group the results: To get the count for each payment method, we will use GROUP BY on Payment_Method_Code.", "Order the results: To find the most frequently used payment method, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most used payment method, we will limit the results to 1."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Method_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Method_Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3880", "db_id": "insurance_policies", "question": "With which kind of payment method were the least number of payments processed?", "rationale": ["The question asks for the payment method with the least number of payments processed.", "To find this, we need to count the number of payments for each payment method.", "We will use the COUNT() function to count the number of payments grouped by 'Payment_Method_Code'.", "Next, we will order the results in ascending order based on the count of payments to get the least processed payment method at the top.", "Finally, we will limit the results to 1 to get only the payment method with the least number of payments."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Payment_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Payment_Count ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3886", "db_id": "insurance_policies", "question": "Which kind of policy type was chosen by the most customers?", "rationale": ["Identify the relevant table: The question pertains to the types of policies chosen by customers, so we will focus on the 'Customer_Policies' table.", "Count distinct customers: We need to count how many distinct customers chose each policy type. This requires using the COUNT function with DISTINCT on 'Customer_ID'.", "Group by policy type: To get the count of customers for each policy type, we will group the results by 'Policy_Type_Code'.", "Order by customer count: To find out which policy type was chosen by the most customers, we will order the results in descending order based on the count of customers.", "Limit the results: Since we only want the policy type chosen by the most customers, we will limit the results to 1."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(DISTINCT Customer_ID) AS Customer_Count\nFROM Customer_Policies\nGROUP BY Policy_Type_Code\nORDER BY Customer_Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3893", "db_id": "insurance_policies", "question": "Which customers do not have any policies? Find the details of these customers.", "rationale": ["Identify the Customers table as the primary source of customer information.", "To find customers without policies, we need to check which Customer_IDs are present in the Customer_Policies table.", "Use a subquery to select all Customer_IDs from the Customer_Policies table.", "Use the NOT IN clause to filter out those Customer_IDs from the Customers table, thus identifying customers without any policies."], "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"], "pred_sql": "SELECT * FROM Customers WHERE Customer_ID NOT IN (SELECT Customer_ID FROM Customer_Policies);", "hint": "\n"}
{"sample_id": "train.3895", "db_id": "insurance_policies", "question": "Which claims had exactly one settlement? For each, tell me the the date the claim was made, the date it was settled and the amount settled.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to join these two tables on the Claim_ID to get the necessary information about claims and their settlements.", "We want to group the results by Claim_ID to count the number of settlements associated with each claim.", "Using the HAVING clause, we filter the groups to include only those claims that have exactly one settlement (COUNT(T2.Settlement_ID) = 1).", "Select the required fields: Claim_ID, Date_Claim_Made, Date_Claim_Settled from Claims and Amount_Settled from Settlements."], "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT T1.Claim_ID, T1.Date_Claim_Made, T1.Date_Claim_Settled, T2.Amount_Settled \nFROM Claims AS T1 \nJOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID \nGROUP BY T1.Claim_ID \nHAVING COUNT(T2.Settlement_ID) = 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n        \"virtual_table\": \"SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )\"\n    }\n}\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to count the number of employees in each department, which requires joining the Department table with the Physician table.", "Use a LEFT JOIN to include all departments even if they have no physicians.", "Group the results by department name to count the number of employees in each department.", "Order the results by the count of employees in descending order to find the department with the largest number of employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT d.Name, COUNT(p.EmployeeID) AS EmployeeCount\nFROM Department d\nLEFT JOIN Physician p ON d.Head = p.EmployeeID\nGROUP BY d.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["To find the department with the most employees, we need to count the number of physicians affiliated with each department.", "We will join the 'Department' table with the 'Affiliated_With' table on the department ID.", "We will group the results by department name to count the number of physicians in each department.", "We will use the COUNT function to count the number of physicians for each department.", "To get the department with the most employees, we will order the results by the count of employees in descending order.", "Finally, we will limit the results to 1 to get only the department with the highest count."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Affiliated_With.Physician) AS EmployeeCount\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3901", "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["We need to find the head of the department with the least employees.", "To do this, we will join the Department table with the Affiliated_With table to count the number of physicians in each department.", "We will group the results by DepartmentID to get the count of physicians per department.", "Next, we will order the results by the count of physicians in ascending order to find the department with the least employees.", "Finally, we will limit the results to 1 to get only the head of that department."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Head\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.DepartmentID\nORDER BY COUNT(Affiliated_With.Physician) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["Identify the head of the department by joining the Physician and Department tables on the condition that the Physician's EmployeeID matches the Department's Head.", "To find the department with the least number of employees, we need to count the number of physicians affiliated with each department. This can be done using a subquery that groups by the department and counts the number of physicians.", "The subquery will order the departments by the count of affiliated physicians in ascending order and limit the result to 1, which gives us the department with the least number of employees.", "Finally, we use this result in the main query to filter for the head of that specific department, retrieving their name and position."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Physician \nJOIN Department ON Physician.EmployeeID = Department.Head \nWHERE Department.DepartmentID = \n    (SELECT Affiliated_With.Department \n     FROM Affiliated_With \n     GROUP BY Affiliated_With.Department \n     ORDER BY COUNT(Affiliated_With.Physician) ASC \n     LIMIT 1);", "hint": "\n"}
{"sample_id": "train.3903", "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["Identify the head of the department with the least employees.", "To find the department with the least employees, we need to count the number of physicians affiliated with each department.", "We can use a subquery to group by DepartmentID in the Affiliated_With table and count the number of physicians in each department.", "Order the results of this subquery by the count of physicians in ascending order and limit the result to 1 to get the department with the least employees.", "Join the Department table with the Physician table on the Head column to get the name and position of the head of that department."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Department \nJOIN Physician ON Department.Head = Physician.EmployeeID \nWHERE Department.DepartmentID = \n    (SELECT DepartmentID \n     FROM Affiliated_With \n     GROUP BY DepartmentID \n     ORDER BY COUNT(Physician) ASC \n     LIMIT 1);", "hint": "\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["We need to find the names of patients who made an appointment.", "The relevant tables are 'Appointment' and 'Patient'.", "We will join these two tables on the condition that the Patient's SSN in the 'Patient' table matches the Patient identifier in the 'Appointment' table.", "To get unique patient names, we will use DISTINCT to avoid duplicates in case a patient has multiple appointments."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT T2.Name FROM Appointment AS T1 JOIN Patient AS T2 ON T1.Patient = T2.SSN;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["Identify the tables involved: Physician, Department, and Affiliated_With.", "We need to join the Physician table with the Affiliated_With table to link physicians to their departments.", "Next, we join the result with the Department table to get the names of the departments.", "We need to filter the results to only include primary affiliations, which is indicated in the Affiliated_With table.", "The final query selects the names of physicians and their affiliated department names."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT T1.Name, T3.Name \nFROM Physician AS T1 \nJOIN Affiliated_With AS T2 ON T1.EmployeeID = T2.Physician \nJOIN Department AS T3 ON T2.Department = T3.DepartmentID \nWHERE T2.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\",\n        \"virtual_table\": \"SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of physicians along with their associated departments from the 'Affiliated_With' table, filtered by whether the affiliation is marked as primary. The placeholder in the WHERE clause represents the primary affiliation status.\",\n        \"virtual_table\": \"SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    }\n}\n"}
{"sample_id": "train.3928", "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["Identify the tables involved: Physician and Patient.", "Determine the relationship: A physician can be a primary care physician (PCP) for multiple patients.", "Join the Physician table with the Patient table on the condition that the EmployeeID of the Physician matches the PCP of the Patient.", "Count the number of patients for each physician using COUNT(*) and group the results by the physician's EmployeeID to aggregate patient counts.", "Select the physician's name and the count of patients they take care of."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT T1.Name, COUNT(*) AS NumberOfPatients \nFROM Physician AS T1 \nJOIN Patient AS T2 ON T1.EmployeeID = T2.PCP \nGROUP BY T1.EmployeeID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\",\n        \"virtual_table\": \"SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["Identify the relevant tables: Physician and Patient.", "Determine the relationship: A physician can be a primary care physician (PCP) for multiple patients.", "Join the Physician table with the Patient table on the condition that the EmployeeID of the Physician matches the PCP of the Patient.", "Group the results by the EmployeeID of the Physician to count how many patients each physician is responsible for.", "Use the HAVING clause to filter out physicians who are in charge of more than one patient."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Patient AS T2 ON T1.EmployeeID = T2.PCP GROUP BY T1.EmployeeID HAVING COUNT(*) > 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\",\n        \"virtual_table\": \"SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3940", "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication.", "We need to find the names of physicians who have prescribed a specific medication, which is 'Thesisin'.", "Join the Physician table with the Prescribes table on the EmployeeID and Physician columns respectively.", "Then, join the resulting table with the Medication table on the Medication code.", "Filter the results where the medication name is 'Thesisin'.", "Select the Name of the physicians from the final result."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT T1.Name \nFROM Physician AS T1 \nJOIN Prescribes AS T2 ON T1.EmployeeID = T2.Physician \nJOIN Medication AS T3 ON T2.Medication = T3.Code \nWHERE T3.Name = 'Thesisin';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\",\n        \"virtual_table\": \"SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3941", "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["Identify the tables involved: Physician, Prescribes, and Medication.", "We need to find the names of physicians who prescribe a specific medication, which is 'Thesisin'.", "Join the Physician table with the Prescribes table on the EmployeeID and Physician columns respectively.", "Then, join the resulting table with the Medication table on the Medication code.", "Filter the results where the medication name is 'Thesisin'.", "Select the Name of the physicians from the final result."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT T1.Name \nFROM Physician AS T1 \nJOIN Prescribes AS T2 ON T1.EmployeeID = T2.Physician \nJOIN Medication AS T3 ON T2.Medication = T3.Code \nWHERE T3.Name = 'Thesisin';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\",\n        \"virtual_table\": \"SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["The task is to find the number of medications prescribed for each brand.", "We need to count the number of prescriptions for each brand of medication.", "To do this, we will join the 'Medication' table with the 'Prescribes' table on the medication code.", "We will select the count of prescriptions and the brand name from the 'Medication' table.", "Finally, we will group the results by the brand name to get the count for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT count(*), T1.Brand FROM Medication AS T1 JOIN Prescribes AS T2 ON T1.Code = T2.Medication GROUP BY T1.Brand", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    }\n}\n"}
{"sample_id": "train.3948", "db_id": "hospital_1", "question": "Find the patient who has the most recent undergoing treatment?", "rationale": ["To find the patient who has the most recent undergoing treatment, we need to look at the 'Undergoes' table, which contains information about patients undergoing procedures.", "The 'Undergoes' table includes the 'Patient' identifier and the 'DateUndergoes' which indicates when the treatment was performed.", "We will sort the results by 'DateUndergoes' in descending order to get the most recent date at the top.", "Finally, we will limit the results to just one entry to get the patient with the most recent treatment."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT U.Patient, U.DateUndergoes FROM Undergoes AS U ORDER BY U.DateUndergoes DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3949", "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["Identify the relevant tables: Patient and Undergoes are needed to find patients undergoing treatments.", "Join the Patient table with the Undergoes table on the patient identifier (SSN).", "Order the results by the date of the procedures in descending order to get the most recent treatment.", "Limit the results to 1 to get only the most recent patient undergoing treatment."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT P.Name\nFROM Patient AS P\nJOIN Undergoes AS U ON P.SSN = U.Patient\nORDER BY U.DateUndergoes DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: Physician and Prescribes.", "We need to find the physician who prescribed the highest dose, so we will join the Physician table with the Prescribes table on the physician's identifier.", "We will select the physician's name from the Physician table.", "To find the highest dose prescribed, we will order the results by the Dose column in descending order.", "Finally, we will limit the results to 1 to get only the physician with the highest dose."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT P.Name \nFROM Physician P \nJOIN Prescribes R ON P.EmployeeID = R.Physician \nORDER BY R.Dose DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["Identify the relevant tables: Physician and Affiliated_With.", "Determine the columns needed: EmployeeID from Physician and Department from Affiliated_With.", "Establish the relationship between the tables: Join Physician and Affiliated_With on EmployeeID and Physician respectively.", "Filter the results to include only primary affiliations by adding a WHERE clause for PrimaryAffiliation.", "Construct the SQL query using the SELECT statement to retrieve the desired columns."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT T1.EmployeeID, T2.Department FROM Physician AS T1 JOIN Affiliated_With AS T2 ON T1.EmployeeID = T2.Physician WHERE T2.PrimaryAffiliation = 'yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of physicians along with their associated departments from the 'Affiliated_With' table, filtered by whether the affiliation is marked as primary. The placeholder in the WHERE clause represents the primary affiliation status.\",\n        \"virtual_table\": \"SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\",\n        \"virtual_table\": \"SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    }\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["The task is to find the three most costly procedures.", "To achieve this, we need to select the 'Name' from the 'Procedures' table.", "We will order the results by the 'Cost' column in descending order to get the most expensive procedures first.", "Finally, we will limit the results to 3 to get only the top three costly procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3972", "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "Join the Physician table with the Trained_In table on the EmployeeID and Physician columns respectively to get the physicians and their trained procedures.", "Join the resulting table with the Procedures table on the Treatment and Code columns to access the cost of each procedure.", "Filter the results to include only those procedures where the cost is greater than 5000."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician JOIN Procedures AS T3 ON T3.Code = T2.Treatment WHERE T3.Cost > 5000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the tables involved: Physician, Trained_In, and Procedures.", "We need to find the physician who is trained in the most expensive procedure.", "To do this, we will join the Physician table with the Trained_In table on the physician's identifier, and then join with the Procedures table on the treatment code.", "We will filter the results to only include those procedures that have the maximum cost.", "The subquery (SELECT MAX(cost) FROM procedures) will give us the highest cost of any procedure.", "Finally, we select the name of the physician who is trained in that most expensive procedure."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid = T2.physician JOIN procedures AS T3 ON T3.code = T2.treatment WHERE T3.cost = (SELECT MAX(cost) FROM procedures)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3980", "db_id": "hospital_1", "question": "Find all procedures which cost more than 1000 or which physician John Wen was trained in.", "rationale": ["Identify the requirement to find procedures with a cost greater than 1000 or those that a specific physician (John Wen) is trained in.", "Use the first virtual table provided in the hint, which allows for selecting procedure names based on cost and physician training.", "The first part of the query selects procedure names from the 'Procedures' table where the cost is greater than 1000.", "The second part of the query uses a UNION to combine results from a join between the 'Physician', 'Trained_In', and 'Procedures' tables to find procedures that John Wen is trained in.", "Replace the placeholders in the virtual table with the actual values: cost threshold of 1000 and physician name 'John Wen'."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT name FROM procedures WHERE cost > 1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid = T2.physician JOIN procedures AS T3 ON T3.code = T2.treatment WHERE T1.name = 'John Wen'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3993", "db_id": "hospital_1", "question": "How many patients are not using Procrastin-X as medication?", "rationale": ["Identify the patients who have been prescribed medications by checking the 'Prescribes' table.", "Filter out the patients who have been prescribed 'Procrastin-X' by using a subquery to find the medication code for 'Procrastin-X' in the 'Medication' table.", "Count the total number of patients in the 'Patient' table whose SSN is not in the list of patients who have been prescribed 'Procrastin-X'."], "gold_sql": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )", "source_tables": ["patient", "prescribes", "medication"], "pred_sql": "SELECT COUNT(*) FROM Patient WHERE SSN NOT IN (SELECT Patient FROM Prescribes WHERE Medication = (SELECT Code FROM Medication WHERE Name = 'Procrastin-X'));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    }\n}\n"}
{"sample_id": "train.4256", "db_id": "club_1", "question": "What are the first names of all the students?", "rationale": ["Identify the table that contains the first names of students, which is the 'Student' table.", "Determine the specific column needed, which is 'Fname' for first names.", "Construct the SQL query to select the 'Fname' column from the 'Student' table."], "gold_sql": "SELECT DISTINCT fname FROM student", "source_tables": ["student"], "pred_sql": "SELECT Fname FROM Student;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n        \"virtual_table\": \"SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  [PLACEHOLDER-TYPE:STRING] AND t3.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4271", "db_id": "club_1", "question": "Give me the first name and last name for all the female members of the club \"Bootup Baltimore\".", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "Determine the columns needed: first name (Fname) and last name (LName) of female students.", "Use JOINs to connect the tables based on their relationships: Club to Member_of_club on ClubID, and Member_of_club to Student on StuID.", "Filter the results to include only those members of the club 'Bootup Baltimore' and only female students by using a WHERE clause."], "gold_sql": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  'Bootup Baltimore' AND t3.sex  =  'F'", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT t3.Fname, t3.LName FROM Club AS t1 JOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID JOIN Student AS t3 ON t2.StuID = t3.StuID WHERE t1.ClubName = 'Bootup Baltimore' AND t3.Sex = 'Female'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n        \"virtual_table\": \"SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  [PLACEHOLDER-TYPE:STRING] AND t3.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4277", "db_id": "club_1", "question": "Find the club which has the largest number of members majoring in \"600\".", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "We need to find clubs with members majoring in '600'.", "Join the Club table with Member_of_club and Student tables using their respective IDs.", "Filter the results where the Major of the student is '600'.", "Group the results by ClubName to count the number of members in each club.", "Order the results by the count of members in descending order to find the club with the most members.", "Limit the results to 1 to get only the club with the largest number of members."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  '600' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT t1.ClubName FROM Club AS t1 JOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID JOIN Student AS t3 ON t2.StuID = t3.StuID WHERE t3.Major = '600' GROUP BY t1.ClubName ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of clubs that students with a specific major are members of. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of clubs returned. The placeholders in the WHERE clause and LIMIT clause represent the major of the students and the maximum number of clubs to display, respectively.\",\n        \"virtual_table\": \"SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n        \"virtual_table\": \"SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  [PLACEHOLDER-TYPE:STRING] AND t3.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4278", "db_id": "club_1", "question": "Find the name of the club that has the most female students.", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "We need to find clubs with female students, so we will filter by the 'Sex' column in the Student table.", "Join the Club table with Member_of_club and then with Student to get the necessary information about club memberships and student genders.", "Group the results by club name to count the number of female members in each club.", "Order the results by the count of female members in descending order to find the club with the most female students.", "Limit the results to 1 to get only the top club."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid = t2.clubid JOIN student AS t3 ON t2.stuid = t3.stuid WHERE t3.sex = 'Female' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n        \"virtual_table\": \"SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  [PLACEHOLDER-TYPE:STRING] AND t3.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of clubs that students with a specific major are members of. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of clubs returned. The placeholders in the WHERE clause and LIMIT clause represent the major of the students and the maximum number of clubs to display, respectively.\",\n        \"virtual_table\": \"SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4312", "db_id": "club_1", "question": "List the clubs that have at least a member with advisor \"1121\".", "rationale": ["Identify the tables involved: We need to get club names, so we will use the 'Club' table. We also need to check which students are members of these clubs, so we will use the 'Member_of_club' table. Finally, we need to filter students based on their advisor, which requires the 'Student' table.", "Join the tables: We will join the 'Club' table with the 'Member_of_club' table on ClubID, and then join the result with the 'Student' table on StuID to get access to the advisor information.", "Filter by advisor: We will add a WHERE clause to filter students whose advisor is '1121'.", "Select distinct club names: Since multiple students can belong to the same club, we will use DISTINCT to ensure that each club name is listed only once."], "gold_sql": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  1121", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT DISTINCT c.ClubName \nFROM Club AS c \nJOIN Member_of_club AS m ON c.ClubID = m.ClubID \nJOIN Student AS s ON m.StuID = s.StuID \nWHERE s.Advisor = '1121';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of clubs that students with a specific major are members of. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of clubs returned. The placeholders in the WHERE clause and LIMIT clause represent the major of the students and the maximum number of clubs to display, respectively.\",\n        \"virtual_table\": \"SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n        \"virtual_table\": \"SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  [PLACEHOLDER-TYPE:STRING] AND t3.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: Grants and Organisations are needed to get the grant amounts and their associated organisations.", "Join the Grants table with the Organisations table on the organisation_id to link grants to their respective organisations.", "Filter the results to include only those organisations that are described as 'research'. This requires a subquery to find the organisation_type corresponding to 'research' in the Organisation_Types table.", "Use the SUM function to calculate the total grant amount for the filtered organisations."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT SUM(grant_amount) AS total_grant_amount \nFROM Grants AS G \nJOIN Organisations AS O ON G.organisation_id = O.organisation_id \nWHERE O.organisation_type = (SELECT organisation_type FROM Organisation_Types WHERE organisation_type_description = 'research');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n        \"virtual_table\": \"SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the requirement to find the dates of staff involvement in a project with the most staff members and specifically those in a leader role.", "Use a subquery to find the project_id of the project that has the most staff members by grouping Project_Staff by project_id and ordering by the count of staff members, limiting the result to 1.", "Use a UNION to combine results from two queries: one for the project with the most staff and another for staff members with a specific role code (in this case, 'leader').", "Select the date_from and date_to from both sets of results to get the required information."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to FROM Project_Staff WHERE project_id IN (SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1) UNION SELECT date_from, date_to FROM Project_Staff WHERE role_code = 'leader'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4328", "db_id": "tracking_grants_for_research", "question": "Find the organisation ids and details of the organisations which are involved in", "rationale": ["The user wants to find the organisation ids and details of the organisations involved in some context, which is not specified but implies a general query about organisations.", "To retrieve the organisation ids and their details, we need to select the relevant columns from the Organisations table.", "The relevant columns are 'organisation_id' and 'organisation_details'.", "Thus, the SQL query will be a simple SELECT statement that fetches these columns from the Organisations table."], "gold_sql": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  6000", "source_tables": ["grants", "organisations"], "pred_sql": "SELECT organisation_id, organisation_details FROM Organisations;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Research_Staff, Organisations, and Organisation_Types.", "We need to find the organisation with the most research staff, so we will count the number of staff members in the Research_Staff table grouped by organisation.", "Join the Research_Staff table with the Organisations table on the employer_organisation_id to get the organisation details.", "Join the Organisations table with the Organisation_Types table to get the organisation type description.", "Group the results by organisation ID and organisation type to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to get the organisation with the most staff at the top.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_id, Organisation_Types.organisation_type \nFROM Research_Staff \nJOIN Organisations ON Research_Staff.employer_organisation_id = Organisations.organisation_id \nJOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type \nGROUP BY Organisations.organisation_id, Organisation_Types.organisation_type \nORDER BY COUNT(Research_Staff.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4331", "db_id": "tracking_grants_for_research", "question": "What is the type and id of the organization that has the most research staff?", "rationale": ["Identify the relevant tables: We need to find information about organizations and their associated research staff, so we will use the Organisations and Research_Staff tables.", "Join the tables: We will join the Organisations table with the Research_Staff table on the organisation_id to link each research staff member to their respective organization.", "Group by organization: To find out how many research staff each organization has, we will group the results by organisation_id and organisation_type.", "Count the research staff: We will count the number of staff members for each organization using COUNT(Research_Staff.staff_id).", "Order by count: To find the organization with the most research staff, we will order the results in descending order based on the count of research staff.", "Limit to one result: Finally, we will limit the results to just one organization, which will be the one with the most research staff."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_type, Organisations.organisation_id\nFROM Organisations\nJOIN Research_Staff ON Organisations.organisation_id = Research_Staff.employer_organisation_id\nGROUP BY Organisations.organisation_id, Organisations.organisation_type\nORDER BY COUNT(Research_Staff.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4333", "db_id": "tracking_grants_for_research", "question": "What is the type of the organization with the most research staff?", "rationale": ["Identify the table that contains information about organizations and their types, which is the Organisations table.", "Determine the relationship between Research_Staff and Organisations to find out which organization has the most research staff. This is done by grouping Research_Staff by employer_organisation_id and counting the number of staff members for each organization.", "Use a subquery to find the organisation_id with the maximum count of research staff members.", "Once we have the organisation_id, we can find the corresponding organisation_type from the Organisations table.", "Finally, we need to get the description of that organisation type from the Organisation_Types table using the organisation_type found in the previous step."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT organisation_type_description FROM Organisation_Types WHERE organisation_type = (SELECT organisation_type FROM Organisations WHERE organisation_id IN (SELECT employer_organisation_id FROM Research_Staff GROUP BY employer_organisation_id ORDER BY COUNT(*) DESC LIMIT 1))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the relevant tables: Documents, Grants, Organisations, and Organisation_Types.", "We need to find the sent dates of documents, so we will select the 'sent_date' from the Documents table.", "To filter documents based on grant amounts, we will join the Documents table with the Grants table on 'grant_id'.", "We need to ensure that the grants have an amount greater than 5000, so we will add a WHERE clause for this condition.", "To include information about the organisation type, we will join the Grants table with the Organisations table and then with the Organisation_Types table.", "Finally, we will construct the SQL query to select the 'sent_date' from the Documents table where the grant amount is greater than 5000."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT T2.sent_date \nFROM Documents AS T2 \nJOIN Grants AS T1 ON T1.grant_id = T2.grant_id \nJOIN Organisations AS T3 ON T1.organisation_id = T3.organisation_id \nJOIN Organisation_Types AS T4 ON T3.organisation_type = T4.organisation_type \nWHERE T1.grant_amount > 5000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n        \"virtual_table\": \"SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4335", "db_id": "tracking_grants_for_research", "question": "What are the send dates for all documents that have a grant amount of more than 5000 and are involved in research?", "rationale": ["Identify the relevant tables: Documents and Grants.", "We need to retrieve the 'sent_date' from the Documents table.", "We need to filter documents based on the grant amount from the Grants table, specifically those greater than 5000.", "Join the Documents table with the Grants table on the 'grant_id' to access the grant amount for each document.", "Construct the SQL query to select 'sent_date' from Documents where the associated grant amount is greater than 5000."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT T2.sent_date \nFROM Documents AS T2 \nJOIN Grants AS T1 ON T1.grant_id = T2.grant_id \nWHERE T1.grant_amount > 5000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n        \"virtual_table\": \"SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4343", "db_id": "tracking_grants_for_research", "question": "When did researchers start and stop working?", "rationale": ["The question asks for the start and stop dates of researchers working on projects.", "To find this information, we need to look at the Project_Staff table, which contains the dates of staff involvement in projects.", "We can use a subquery to get the top N projects with the most staff members, which will help us filter the relevant projects.", "The hint provides a virtual table structure that combines two sets of data: one for the top projects and another for filtering by role code.", "We will replace the placeholders in the hint with specific values: we will limit to the top 5 projects and filter by the role code for researchers.", "The final SQL query will select the start and end dates from the Project_Staff table based on these criteria."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to FROM Project_Staff WHERE project_id IN ( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 5 ) UNION SELECT date_from, date_to FROM Project_Staff WHERE role_code = 'researcher'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4349", "db_id": "tracking_grants_for_research", "question": "What are the details for the project whose research has been published?", "rationale": ["The question asks for details of projects whose research has been published.", "To find this information, we need to join the Projects table with the Project_Outcomes table based on the project_id.", "We will filter the results based on the outcome_code that indicates the research has been published.", "Assuming 'published' is the outcome code representing published research, we will use it in the WHERE clause to filter the results."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE '%Published%'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id WHERE T2.outcome_code = 'published'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes are needed to get project details and their outcomes.", "Join the Projects table with the Project_Outcomes table on the project_id to associate projects with their outcomes.", "Group the results by project_id and project_details to aggregate the outcomes for each project.", "Count the number of outcomes for each project using COUNT(PO.outcome_code).", "Order the results in descending order to get the project with the most outcomes at the top.", "Limit the results to 1 to get only the project with the highest count of outcomes."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT P.project_id, P.project_details \nFROM Projects AS P \nJOIN Project_Outcomes AS PO ON P.project_id = PO.project_id \nGROUP BY P.project_id, P.project_details \nORDER BY COUNT(PO.outcome_code) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "We need to join these tables on the organisation_id to get the details of the organisations that hired research staff.", "Count the number of research staff for each organisation using COUNT(rs.staff_id).", "Group the results by organisation_id to aggregate the counts for each organisation.", "Order the results in descending order to find the organisation with the most research staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4361", "db_id": "tracking_grants_for_research", "question": "What are the ids, types, and details of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff are needed to get the organization details and the count of research staff.", "Join the Organisations table with the Research_Staff table on the organisation_id to link organizations with their respective research staff.", "Group the results by organisation_id to count the number of research staff per organization.", "Order the results in descending order based on the count of research staff to find the organization with the most staff.", "Limit the results to 1 to get only the organization with the highest count of research staff."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details \nFROM Organisations o \nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id \nGROUP BY o.organisation_id \nORDER BY COUNT(rs.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff for staff involvement in projects and Staff_Roles for role descriptions.", "We need to find the staff ID and the role description of the role involved with the most number of projects.", "To find the role involved with the most projects, we can use a subquery that counts the number of staff members per project and orders them in descending order, limiting the result to the top project.", "Join the Project_Staff table with the Staff_Roles table to get the role descriptions based on the role code.", "Select the staff ID and the corresponding role description from the joined tables."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT ps.staff_id, sr.role_description\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nWHERE ps.project_id IN (\n    SELECT project_id\n    FROM Project_Staff\n    GROUP BY project_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4367", "db_id": "tracking_grants_for_research", "question": "For grants that have descriptions of Regular and Initial Applications, what are their start dates?", "rationale": ["Identify the relevant document types by querying the Document_Types table for descriptions 'Regular Applications' and 'Initial Applications'.", "Use the resulting document_type_code to filter the Documents table to find grants associated with these document types.", "Select the grant_id from the Documents table based on the filtered document_type_code.", "Finally, use the grant_id to retrieve the grant_start_date from the Grants table."], "gold_sql": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Regular' INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Initial Application'", "source_tables": ["grants", "document_types", "documents"], "pred_sql": "SELECT grant_start_date FROM Grants WHERE grant_id IN (SELECT grant_id FROM Documents WHERE document_type_code IN (SELECT document_type_code FROM Document_Types WHERE document_description IN ('Regular Applications', 'Initial Applications')));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n        \"virtual_table\": \"SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["Identify the relevant tables: Grants and Documents.", "We need to count the number of documents associated with each grant, so we will use a LEFT JOIN between Grants and Documents on the grant_id.", "Use COUNT() to count the number of documents for each grant.", "Group the results by grant_id to get the count for each grant.", "To find which grant has the most documents, we will order the results by the document count in descending order.", "Limit the results to 1 to get the grant with the most documents."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT g.grant_id, COUNT(d.document_id) AS document_count, d.document_id AS most_documents\nFROM Grants g\nLEFT JOIN Documents d ON g.grant_id = d.grant_id\nGROUP BY g.grant_id\nORDER BY document_count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n        \"virtual_table\": \"SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4372", "db_id": "tracking_grants_for_research", "question": "What are all the details of the organisations described as 'Sponsor'? Sort the result in an ascending order.", "rationale": ["Identify the relevant table: Organisations.", "Determine the condition to filter organisations: organisation_type should match the type described as 'Sponsor'.", "To find the organisation_type corresponding to 'Sponsor', a subquery is needed to select it from the Organisation_Types table.", "Construct the SQL query to select all columns from Organisations where the organisation_type matches the result of the subquery, and sort the results in ascending order by organisation_id."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "pred_sql": "SELECT * FROM Organisations WHERE organisation_type = (SELECT organisation_type FROM Organisation_Types WHERE organisation_type_description = 'Sponsor') ORDER BY organisation_id ASC;", "hint": "\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant table: The question asks for project details, which are stored in the 'Projects' table.", "Determine the specific condition: The user is looking for projects with a specific detail, which is 'sint'.", "Construct the SQL query: Use a SELECT statement to retrieve 'project_details' from the 'Projects' table where 'project_details' matches 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT project_details FROM Projects WHERE project_details = 'sint';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant table: The question asks for a description related to project details, which is found in the 'Projects' table.", "Determine the specific condition: The user is looking for projects with a specific detail, which is 'sint'.", "Construct the SQL query: Use a SELECT statement to retrieve 'project_details' from the 'Projects' table where 'project_details' matches 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT project_details FROM Projects WHERE project_details = 'sint'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4383", "db_id": "tracking_grants_for_research", "question": "What is the id of the organization with the maximum number of outcomes and how many outcomes are there?", "rationale": ["We need to find the organization with the maximum number of outcomes.", "To do this, we will join the Project_Outcomes table with the Projects table using the project_id.", "Next, we will join the Projects table with the Organisations table using the organisation_id.", "We will count the number of outcomes for each organization using COUNT(outcome_code).", "We will group the results by organisation_id to get the count for each organization.", "To find the organization with the maximum outcomes, we will order the results by outcome_count in descending order.", "Finally, we will limit the results to 1 to get only the organization with the maximum outcomes."], "gold_sql": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT organisation_id, COUNT(outcome_code) AS outcome_count\nFROM Project_Outcomes\nJOIN Projects ON Project_Outcomes.project_id = Projects.project_id\nJOIN Organisations ON Projects.organisation_id = Organisations.organisation_id\nGROUP BY organisation_id\nORDER BY outcome_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4384", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects launched by the organisation", "rationale": ["Identify the relevant table for project details, which is the 'Projects' table.", "Determine the relationship between projects and organisations, which is through the 'organisation_id'.", "Select the 'organisation_id' from the 'Organisations' table to filter projects launched by those organisations.", "Construct the SQL query to select 'project_details' from the 'Projects' table where the 'organisation_id' matches those in the 'Organisations' table."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT project_details FROM Projects WHERE organisation_id IN (SELECT organisation_id FROM Organisations)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["Identify the relevant tables: Project_Staff and Staff_Roles are needed to get the staff roles.", "Project_Staff contains the role_code which links to Staff_Roles for the role descriptions.", "Join Project_Staff with Staff_Roles on role_code to get the descriptions of the roles.", "Select the role_code and role_description to provide a clear output of staff roles."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, role_description FROM Project_Staff JOIN Staff_Roles ON Project_Staff.role_code = Staff_Roles.role_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4394", "db_id": "tracking_grants_for_research", "question": "What are the descriptions of all the project outcomes?", "rationale": ["The user wants to retrieve descriptions of all project outcomes, which suggests querying the Project_Outcomes table.", "The relevant columns for the descriptions are 'outcome_code' and 'outcome_details'.", "The SQL query will select these columns from the Project_Outcomes table without any filtering conditions, as we want all outcomes."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code", "source_tables": ["project_outcomes", "research_outcomes"], "pred_sql": "SELECT outcome_code, outcome_details FROM Project_Outcomes;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["Identify the relevant table: The question pertains to staff roles, so we will focus on the Project_Staff table.", "Determine the information needed: We need to find the most common role, which implies counting occurrences of each role.", "Group by role_code: To count how many times each role appears, we will use GROUP BY on the role_code column.", "Count occurrences: We will use COUNT(*) to count the number of staff members for each role.", "Order by count: To find the most common role, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most common role, we will limit the results to 1."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count \nFROM Project_Staff \nGROUP BY role_code \nORDER BY role_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4410", "db_id": "network_2", "question": "Who is the oldest person whose job is student?", "rationale": ["Identify the table to query: The relevant table is 'Person' as it contains information about individuals including their job and age.", "Filter the results: We need to find individuals whose job is 'student'. This will be done using a WHERE clause.", "Sort the results: To find the oldest person, we will sort the results by age in descending order using ORDER BY age DESC.", "Limit the results: Since we only want the oldest person, we will limit the results to 1 using LIMIT 1."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "pred_sql": "SELECT name, age FROM Person WHERE job = 'student' ORDER BY age DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4439", "db_id": "network_2", "question": "What is the name and age of every male? Order the results by age.", "rationale": ["Identify the relevant table: The 'Person' table contains the information we need about individuals, including their name, age, and gender.", "Filter the results: We need to select only those individuals whose gender is 'male'.", "Select the required columns: We need to retrieve the 'name' and 'age' of these individuals.", "Order the results: The final output should be ordered by the 'age' column in ascending order."], "gold_sql": "SELECT name FROM Person WHERE gender  =  'male' ORDER BY age", "source_tables": ["person"], "pred_sql": "SELECT name, age FROM Person WHERE gender = 'male' ORDER BY age;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4441", "db_id": "network_2", "question": "What are the names and ages of every person who is a friend of both Dan and Alice?", "rationale": ["Identify the requirement: We need names and ages of persons who are friends with both Dan and Alice.", "Use the 'Person' table to get names and ages.", "Join the 'Person' table with the 'PersonFriend' table to access friendship data.", "To find mutual friends, we can use the INTERSECT operator to get names and ages of persons who are friends with Dan and also friends with Alice.", "Construct the first part of the query to find friends of Dan.", "Construct the second part of the query to find friends of Alice.", "Combine both parts using INTERSECT to get the final result."], "gold_sql": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name, T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend = 'Dan' INTERSECT SELECT T1.name, T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend = 'Alice'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4444", "db_id": "network_2", "question": "Find the name of the person who has friends with age above 40 and under age 30?", "rationale": ["Identify the requirement: We need to find names of persons who have friends older than 40 and younger than 30.", "Use the provided virtual table structure to create the SQL query.", "The first part of the query will select names of persons who have friends older than 40.", "The second part of the query will exclude those who have friends younger than 30 using the EXCEPT clause.", "Combine these two parts into a single SQL query."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  > 40) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  < 30)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4445", "db_id": "network_2", "question": "What are the names of every person who has a friend over 40 and under 30?", "rationale": ["Identify the requirement: We need names of persons who have friends over 40 and under 30.", "Use the provided virtual table structure to filter friends based on age criteria.", "The first part of the query selects names of persons whose friends are older than 40.", "The second part of the query excludes names of persons whose friends are younger than 30 using the EXCEPT clause.", "Combine these two parts to form the final SQL query."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age > 40) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age < 30)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4449", "db_id": "network_2", "question": "What are the names of the people who have no friends who are students?", "rationale": ["Identify the requirement: We need the names of people who have no friends who are students.", "Use the 'Person' table to get all names.", "Use the 'PersonFriend' table to find friends of each person.", "Filter out those who have friends with the job title 'student'.", "The SQL query will use the EXCEPT clause to exclude names of people who have friends that are students."], "gold_sql": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  'student'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT name FROM Person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.friend WHERE T1.job = 'student'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who do not have any friends that work in a specific occupation. The placeholder in the query allows for the specification of the job title to filter out those individuals accordingly.\",\n        \"virtual_table\": \"SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4454", "db_id": "network_2", "question": "Find the name of persons who are friends with Bob.", "rationale": ["Identify the tables involved: We need to get names from the 'Person' table and check friendships from the 'PersonFriend' table.", "Determine the relationship: We will join the 'Person' table with the 'PersonFriend' table on the name column.", "Specify the condition: We want to find friends of 'Bob', so we will filter the results where the friend column in 'PersonFriend' is 'Bob'.", "Use DISTINCT to ensure we get unique names of persons who are friends with Bob."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend = 'Bob'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] OR T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4455", "db_id": "network_2", "question": "What are the names of all of Bob's friends?", "rationale": ["Identify the main entity of the query, which is Bob.", "We need to find Bob's friends, which are listed in the PersonFriend table.", "Join the Person table with the PersonFriend table on the name column to access Bob's friends.", "Filter the results where the name in the Person table is 'Bob'.", "Select the friend names from the PersonFriend table where they are friends with Bob."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T1.name = 'Bob'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] OR T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4456", "db_id": "network_2", "question": "Find the names of females who are friends with Zach", "rationale": ["Identify the relevant tables: We need to use the 'Person' table to get the names and gender of individuals, and the 'PersonFriend' table to find friends.", "We are looking for females who are friends with Zach, so we will join the 'Person' table (aliased as T1) with the 'PersonFriend' table (aliased as T2) on the name column.", "In the WHERE clause, we specify that we want to find records where T2.friend is 'Zach' to filter for friends of Zach.", "Additionally, we need to filter for females, so we add another condition in the WHERE clause that T1.gender must be 'female'.", "The final SQL query selects the names of individuals who meet both criteria."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Zach' AND T1.gender  =  'female'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend = 'Zach' AND T1.gender = 'female'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] OR T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4465", "db_id": "network_2", "question": "What are the different names of friends who are younger than the average age for a friend?", "rationale": ["Identify the average age of friends from the 'Person' table.", "Filter friends who are younger than this average age.", "Use a JOIN between 'Person' and 'PersonFriend' to get the names of friends.", "Select distinct names of friends who meet the age criteria."], "gold_sql": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE (SELECT AVG(age) FROM Person WHERE name = T2.friend) > (SELECT age FROM Person WHERE name = T2.friend)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4466", "db_id": "network_2", "question": "Who has friends that are older than the average age? Print their friends and their ages as well", "rationale": ["First, we need to find the average age of all persons in the 'Person' table.", "Next, we will identify individuals who have friends that are older than this average age.", "We will use a subquery to select names from the 'Person' table where the age is greater than the average age.", "We also need to ensure that these individuals do not have friends who are younger than the average age, which can be done using an EXCEPT clause with another subquery.", "Finally, we will join the 'PersonFriend' table to get the names of these friends and their ages from the 'Person' table."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T2.friend, P.age FROM PersonFriend AS T2 JOIN Person AS P ON T2.friend = P.name WHERE T2.name IN (SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age > (SELECT AVG(age) FROM Person)) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age < (SELECT AVG(age) FROM Person)))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4467", "db_id": "network_2", "question": "Whare the names, friends, and ages of all people who are older than the average age of a person?", "rationale": ["Identify the columns needed: names, friends, and ages of people.", "We need to join the 'Person' table with the 'PersonFriend' table to get the friends of each person.", "We need to filter the results to include only those people whose age is greater than the average age of all persons.", "To find the average age, we can use a subquery: (SELECT AVG(age) FROM Person).", "Construct the SQL query using the SELECT statement with the necessary JOIN and WHERE clauses."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, PF.friend, P.age FROM Person AS P JOIN PersonFriend AS PF ON P.name = PF.name WHERE P.age > (SELECT AVG(age) FROM Person)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4473", "db_id": "network_2", "question": "What are the names of all people who are friends with Alice for the shortest amount of time?", "rationale": ["Identify the main subject of the query: we need to find people who are friends with Alice.", "We need to join the 'Person' table with the 'PersonFriend' table to access the names of Alice's friends.", "The condition for friendship is that the 'name' in 'PersonFriend' should be 'Alice'.", "To find the friends with the shortest friendship duration, we need to look for the minimum year in which the friendship was established.", "We will use a subquery to find the minimum year of friendship for Alice and filter the results based on that year."], "gold_sql": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend"], "pred_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.friend WHERE T2.name = 'Alice' AND T2.year = (SELECT MIN(year) FROM PersonFriend WHERE name = 'Alice')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] OR T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4475", "db_id": "network_2", "question": "What are the names, ages, and jobs of all people who are friends with Alice for the longest amount of time?", "rationale": ["Identify the required information: names, ages, and jobs of people who are friends with Alice.", "Use the 'Person' table to get the names, ages, and jobs.", "Join the 'Person' table with the 'PersonFriend' table on the name column to link friends with their details.", "Filter the results to include only those who are friends with Alice by using a WHERE clause.", "To find the friends who have been friends with Alice for the longest time, we need to find the maximum year of friendship established with Alice.", "Use a subquery to get the maximum year from the 'PersonFriend' table where the friend is Alice."], "gold_sql": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name, T1.age, T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend = 'Alice' AND T2.year = (SELECT max(year) FROM PersonFriend WHERE friend = 'Alice')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4478", "db_id": "network_2", "question": "Which person whose friends have the oldest average age?", "rationale": ["Identify the need to find the person whose friends have the oldest average age.", "To achieve this, we need to calculate the average age of friends for each person.", "Join the 'PersonFriend' table with the 'Person' table to get the ages of friends.", "Group the results by the person's name to calculate the average age of their friends.", "Order the results by average age in descending order to find the oldest average age.", "Limit the results to 1 to get only the top person with the oldest average age."], "gold_sql": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT 1", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name FROM Person AS T1 JOIN (SELECT T2.name, AVG(CAST(T3.age AS INTEGER)) AS avg_age FROM PersonFriend AS T2 JOIN Person AS T3 ON T2.friend = T3.name GROUP BY T2.name) AS avg_friends ON T1.name = avg_friends.name ORDER BY avg_friends.avg_age DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4480", "db_id": "network_2", "question": "What is the total number of people who has no friend living in the city of Austin.", "rationale": ["Identify the requirement: We need to count the number of distinct people who have no friends living in Austin.", "Use the PersonFriend table to find names of people and their friends.", "Filter out friends who live in Austin by using a subquery that selects names from the Person table where city is 'Austin'.", "Count the distinct names from the PersonFriend table where the friend is not in the list of friends living in Austin."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT COUNT(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM Person WHERE city = 'Austin')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of distinct persons from the 'PersonFriend' table who have friends that do not reside in a specified city. The placeholder in the WHERE clause represents the name of the city to filter out friends.\",\n        \"virtual_table\": \"SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who do not have any friends that work in a specific occupation. The placeholder in the query allows for the specification of the job title to filter out those individuals accordingly.\",\n        \"virtual_table\": \"SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4503", "db_id": "document_management", "question": "Find the types of documents with more than 4 documents.", "rationale": ["Identify the relevant table: The question pertains to documents, so we will use the 'Documents' table.", "Determine the required information: We need to find the types of documents, which corresponds to the 'document_type_code' column.", "Count the number of documents for each type: We will use the COUNT() function to count the number of documents for each 'document_type_code'.", "Group the results by document type: We will use GROUP BY on 'document_type_code' to aggregate the counts for each type.", "Filter the results: We need to include only those document types that have more than 4 documents, which can be done using the HAVING clause."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code, COUNT(*) AS document_count\nFROM Documents\nGROUP BY document_type_code\nHAVING COUNT(*) > 4;", "hint": "\n"}
{"sample_id": "train.4504", "db_id": "document_management", "question": "What are the codes of types of documents of which there are for or more?", "rationale": ["Identify the table that contains the document types, which is the 'Documents' table.", "We need to select the 'document_type_code' from the 'Documents' table.", "To find the document types that have four or more documents, we will group the results by 'document_type_code'.", "We will use the HAVING clause to filter the groups to only include those with a count of 'document_code' that is greater than or equal to 4."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code\nFROM Documents\nGROUP BY document_type_code\nHAVING COUNT(document_code) >= 4;", "hint": "\n"}
{"sample_id": "train.4505", "db_id": "document_management", "question": "Find the total access count of all documents in the most popular document type.", "rationale": ["We need to find the total access count of all documents in the most popular document type.", "First, we need to identify the most popular document type. This can be done by grouping the documents by their type code and summing their access counts.", "We will order the results by the summed access count in descending order to get the most popular document type at the top.", "To get only the most popular document type, we will limit our results to 1.", "Once we have the most popular document type, we can then sum the access counts of all documents that match this type code."], "gold_sql": "SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT SUM(access_count) AS total_access_count\nFROM Documents\nWHERE document_type_code = (\n    SELECT document_type_code\n    FROM Documents\n    GROUP BY document_type_code\n    ORDER BY SUM(access_count) DESC\n    LIMIT 1\n);", "hint": "\n"}
{"sample_id": "train.4525", "db_id": "document_management", "question": "Find names of the document without any images.", "rationale": ["We need to find documents that do not have any associated images.", "To do this, we will select the document names from the Documents table.", "We will perform a LEFT JOIN with the Document_Sections table to get sections related to each document.", "Next, we will perform another LEFT JOIN with the Document_Sections_Images table to find images associated with those sections.", "Finally, we will filter the results where the image_id in Document_Sections_Images is NULL, indicating that there are no images associated with those documents."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "pred_sql": "SELECT d.document_name \nFROM Documents d \nLEFT JOIN Document_Sections ds ON d.document_code = ds.document_code \nLEFT JOIN Document_Sections_Images dsi ON ds.section_id = dsi.section_id \nWHERE dsi.image_id IS NULL;", "hint": "\n"}
{"sample_id": "train.4532", "db_id": "document_management", "question": "Count the number of users that are logged in.", "rationale": ["The task is to count the number of users that are logged in.", "To achieve this, we need to count the total entries in the 'Users' table, as each entry represents a user.", "The SQL function COUNT(*) will be used to count all rows in the 'Users' table.", "The final SQL query will be 'SELECT COUNT(*) AS number_of_users FROM Users;' which gives us the total number of users."], "gold_sql": "SELECT count(*) FROM users WHERE user_login  =  1", "source_tables": ["users"], "pred_sql": "SELECT COUNT(*) AS number_of_users FROM Users;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of user names and their corresponding passwords from the 'Users' table, grouped by their role codes. The results are ordered by the number of users in each role, showing the top roles based on user count, with a limit specified by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of user names and their corresponding passwords from the 'Users' table, grouped by their role codes. The results are ordered by the number of users in each role, showing the most populated roles first, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4733", "db_id": "department_store", "question": "Return the distinct name of customers whose order status is Pending, in the order of customer id.", "rationale": ["Identify the tables needed: Customers and Customer_Orders.", "We need to retrieve customer names, so we will select from the Customers table.", "We need to filter based on the order status, which is found in the Customer_Orders table.", "Join the Customers table with the Customer_Orders table on the customer_id field to link customers with their orders.", "Filter the results to include only those orders where the order status code is 'Pending'.", "Use DISTINCT to ensure that we only get unique customer names.", "Order the results by customer_id to meet the requirement of ordering by customer id."], "gold_sql": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending' ORDER BY T2.customer_id", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT C.customer_name FROM Customers AS C JOIN Customer_Orders AS O ON C.customer_id = O.customer_id WHERE O.order_status_code = 'Pending' ORDER BY C.customer_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\",\n        \"virtual_table\": \"SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4736", "db_id": "department_store", "question": "What are the names and addressed of customers who have both New and Pending orders?", "rationale": ["Identify the tables involved: Customers and Customer_Orders.", "Determine the required fields: customer_name and customer_address from the Customers table.", "Establish the relationship between Customers and Customer_Orders using customer_id.", "Filter the orders based on their status: 'New' and 'Pending'.", "Use INTERSECT to find customers who have both New and Pending orders."], "gold_sql": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'New' INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending'", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT T1.customer_name, T1.customer_address \nFROM Customers AS T1 \nJOIN Customer_Orders AS T2 ON T1.customer_id = T2.customer_id \nWHERE T2.order_status_code = 'New' \nINTERSECT \nSELECT T1.customer_name, T1.customer_address \nFROM Customers AS T1 \nJOIN Customer_Orders AS T2 ON T1.customer_id = T2.customer_id \nWHERE T2.order_status_code = 'Pending'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\",\n        \"virtual_table\": \"SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4749", "db_id": "department_store", "question": "Find the id and name of the staff who has been assigned for the shortest period.", "rationale": ["Identify the relevant table: Staff_Department_Assignments contains the staff assignments and their duration.", "To find the shortest assignment period, calculate the difference between date_assigned_to and date_assigned_from.", "Sort the results by the calculated duration in ascending order to get the shortest period first.", "Select the staff_id and staff_name from the sorted results.", "Limit the output to 1 to get only the staff with the shortest assignment period."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name\nFROM Staff_Department_Assignments\nORDER BY (date_assigned_to - date_assigned_from) ASC\nLIMIT 1;", "hint": "\n"}
