{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["Identify the tables involved: Students, Student_Course_Registrations, and Courses.", "Join the Students table with the Student_Course_Registrations table to link students to their course registrations.", "Join the result with the Courses table to retrieve the course names.", "Group the results by course ID to count the number of students registered for each course.", "Order the results in descending order based on the count of registered students.", "Limit the results to 1 to get the course with the most registered students."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT T3.course_name, COUNT(*) AS number_of_students \nFROM Students AS T1 \nJOIN Student_Course_Registrations AS T2 ON T1.student_id = T2.student_id \nJOIN Courses AS T3 ON T2.course_id = T3.course_id \nGROUP BY T2.course_id \nORDER BY number_of_students DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["We need to find the IDs of students who have attended courses.", "The relevant table for attendance is 'Student_Course_Attendance', which contains the 'student_id' of students who attended courses.", "To get unique student IDs, we will use the DISTINCT keyword to avoid duplicates in the results."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["We need to find the IDs of all students who have attended at least one course.", "The relevant table for attendance is 'Student_Course_Attendance', which contains the 'student_id' of students who attended courses.", "To get unique student IDs, we will use the DISTINCT keyword to avoid duplicates in our results."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["Identify the relevant tables: Candidates, Student_Course_Attendance, and Student_Course_Registrations.", "Join the Candidates table with Student_Course_Attendance on candidate_id and student_id to link candidates with their course attendance.", "Join the result with Student_Course_Registrations to ensure we are looking at the correct course registrations.", "Order the results by date_of_attendance in descending order to get the most recent attendance first.", "Limit the results to 1 to get only the most recent candidate who accessed a course."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT DISTINCT c.candidate_id\nFROM Candidates c\nJOIN Student_Course_Attendance sca ON c.candidate_id = sca.student_id\nJOIN Student_Course_Registrations scr ON sca.student_id = scr.student_id AND sca.course_id = scr.course_id\nORDER BY sca.date_of_attendance DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.77", "db_id": "student_assessment", "question": "What is detail of the student who registered the most number of courses?", "rationale": ["Identify the relevant tables: Students and Student_Course_Registrations.", "Join the Students table with the Student_Course_Registrations table to link students to their course registrations.", "Group the results by student_id to count the number of courses each student has registered for.", "Order the results in descending order based on the count of registered courses to find the student with the most registrations.", "Limit the results to 1 to get only the top student who registered for the most courses."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT S.student_id, S.student_details \nFROM Students AS S \nJOIN Student_Course_Registrations AS R ON S.student_id = R.student_id \nGROUP BY S.student_id \nORDER BY COUNT(R.course_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["Identify the tables involved: Students, Student_Course_Registrations, and Courses.", "Join the Students table with the Student_Course_Registrations table on student_id to link students to their course registrations.", "Join the result with the Courses table on course_id to retrieve course names.", "Use COUNT(*) to count the number of students registered for each course.", "Group the results by course_id to get the count for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT T3.course_name, COUNT(*) AS student_count \nFROM Students AS T1 \nJOIN Student_Course_Registrations AS T2 ON T1.student_id = T2.student_id \nJOIN Courses AS T3 ON T2.course_id = T3.course_id \nGROUP BY T2.course_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.90", "db_id": "student_assessment", "question": "What are the ids of the students who registered for course 301 most recently?", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Filter the records to only include those where the 'course_id' is '301'.", "Order the results by 'registration_date' in descending order to get the most recent registration first.", "Limit the results to 1 to get only the most recent student registration for course 301."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["We need to find distinct cities of addresses associated with students.", "To do this, we will need to join the Addresses table with the People_Addresses table to link addresses to people.", "Next, we will join the resulting table with the Students table to filter for only those people who are students.", "Finally, we will select the distinct cities from the Addresses table."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "pred_sql": "SELECT DISTINCT a.city\nFROM Addresses a\nJOIN People_Addresses pa ON a.address_id = pa.address_id\nJOIN Students s ON pa.person_id = s.student_id;", "hint": "\n"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["We need to find students who registered for courses but did not attend any.", "To do this, we will use a LEFT JOIN between the Students table and the Student_Course_Registrations table to get all students and their registrations.", "Next, we will perform another LEFT JOIN with the Student_Course_Attendance table to check if they attended any courses.", "In the WHERE clause, we will filter for students who have a registration (R.student_id IS NOT NULL) but do not have any attendance records (A.student_id IS NULL).", "Finally, we will select the required details from the Students table."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "pred_sql": "SELECT S.student_id, S.student_details \nFROM Students AS S \nLEFT JOIN Student_Course_Registrations AS R ON S.student_id = R.student_id \nLEFT JOIN Student_Course_Attendance AS A ON R.student_id = A.student_id AND R.course_id = A.course_id \nWHERE R.student_id IS NOT NULL AND A.student_id IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant tables: We need to look at the 'Students' and 'Student_Course_Registrations' tables to find students who registered for a specific course.", "Determine the course: The course we are interested in is 'Statistics'. We will need to find the course_id associated with this course from the 'Courses' table.", "Join the tables: We will join 'Student_Course_Registrations' with 'Students' to get the student_id for those who registered for the course.", "Filter by course: We will filter the registrations to only include those for the course_id that corresponds to 'Statistics'.", "Order by registration date: Finally, we will order the results by the registration_date to meet the requirement of the query."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant tables: We need to look at the 'Students' and 'Student_Course_Registrations' tables to find student IDs and their course registrations.", "Filter for the specific course: We need to filter the registrations to only include those for the course 'Statistics'.", "Order by registration date: The results should be ordered by the date of registration to meet the requirement of the query.", "Construct the SQL query: Combine the above steps into a single SQL query that selects student IDs from the 'Student_Course_Registrations' table where the course ID corresponds to 'Statistics', and order the results by registration date."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.123", "db_id": "bike_1", "question": "For each zip code, return the average mean temperature of August there.", "rationale": ["The task requires calculating the average mean temperature for each zip code specifically for the month of August.", "To achieve this, we will select the 'zip_code' and the average of 'mean_temperature_f' from the 'weather' table.", "We need to filter the records to include only those from August. In SQLite, we can extract the month from the 'date' column using the strftime function, checking if it equals '08'.", "Finally, we will group the results by 'zip_code' to get the average temperature for each zip code."], "gold_sql": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE '8/%' GROUP BY zip_code", "source_tables": ["weather"], "pred_sql": "SELECT zip_code, AVG(mean_temperature_f) AS average_mean_temperature\nFROM weather\nWHERE strftime('%m', date) = '08'\nGROUP BY zip_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.\",\n        \"virtual_table\": \"SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.135", "db_id": "bike_1", "question": "Which bike traveled the most often in zip code 94002?", "rationale": ["Identify the relevant table for trips, which is the 'trip' table.", "Filter the trips based on the specified zip code (94002).", "Group the results by 'bike_id' to count how many times each bike was used.", "Order the results in descending order based on the count of trips to find the most frequently used bike.", "Limit the results to 1 to get only the bike that traveled the most often."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id, COUNT(*) as trip_count \nFROM trip \nWHERE zip_code = '94002' \nGROUP BY bike_id \nORDER BY trip_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n        \"virtual_table\": \"SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] EXCEPT SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.136", "db_id": "bike_1", "question": "What is the id of the bike that traveled the most in 94002?", "rationale": ["Identify the relevant table for trips, which is the 'trip' table.", "Filter the trips based on the zip code '94002'.", "Order the results by the duration of the trips in descending order to find the longest trip.", "Limit the results to 1 to get the bike ID of the trip that traveled the most."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id FROM trip WHERE zip_code = '94002' ORDER BY duration DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n        \"virtual_table\": \"SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] EXCEPT SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.143", "db_id": "bike_1", "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?", "rationale": ["Identify the requirement to find station names and ids based on two conditions: average bikes available and installation date.", "Use the 'status' table to calculate the average number of bikes available per station by grouping on 'station_id'.", "Filter the results to include only those stations where the average number of bikes available is greater than 14.", "Use the 'station' table to check for stations installed in December by checking if 'installation_date' contains '-12-'.", "Combine both conditions using an OR clause to get the final list of station ids and names."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT id, name FROM station WHERE id IN (SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available) > 14) OR installation_date LIKE '%-12-%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n        \"virtual_table\": \"SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] EXCEPT SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique station IDs from the 'station' table located in a specific city. It intersects with the 'status' table to find stations that have an average number of available bikes greater than a specified threshold. The placeholders in the WHERE clause and HAVING clause represent the city name and the minimum average bikes available, respectively.\",\n        \"virtual_table\": \"SELECT id FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.144", "db_id": "bike_1", "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "rationale": ["Identify the requirement to find station names and ids based on two conditions: average bikes available and installation date.", "Use the 'status' table to calculate the average number of bikes available per station by grouping on 'station_id'.", "Filter the results to include only those stations where the average number of bikes available is greater than 14.", "Additionally, check the 'installation_date' in the 'station' table to see if it falls in December (using a LIKE clause to match the date format).", "Combine both conditions using an OR clause to get the final list of station ids and names."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT id, name FROM station WHERE id IN (SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available) > 14) OR installation_date LIKE '____-12-%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n        \"virtual_table\": \"SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] EXCEPT SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique station IDs from the 'station' table located in a specific city. It intersects with the 'status' table to find stations that have an average number of available bikes greater than a specified threshold. The placeholders in the WHERE clause and HAVING clause represent the city name and the minimum average bikes available, respectively.\",\n        \"virtual_table\": \"SELECT id FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.145", "db_id": "bike_1", "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?", "rationale": ["Identify the relevant table: The 'weather' table contains the cloud cover data.", "Filter by zip code: We need to focus on the region of zip code 94107.", "Group by cloud cover: To find the most common cloud cover rates, we group the results by the 'cloud_cover' column.", "Count occurrences: We order the grouped results by the count of occurrences in descending order to get the most common values.", "Limit the results: We limit the output to the top 3 most common cloud cover rates."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "pred_sql": "SELECT cloud_cover FROM weather WHERE zip_code = 94107 GROUP BY cloud_cover ORDER BY COUNT(*) DESC LIMIT 3", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.\",\n        \"virtual_table\": \"SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n        \"virtual_table\": \"SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.161", "db_id": "bike_1", "question": "For each trip, return its ending station's installation date.", "rationale": ["We need to return the installation date of each trip's ending station.", "To do this, we will join the 'trip' table with the 'station' table on the 'end_station_id' from the 'trip' table and the 'id' from the 'station' table.", "The relevant columns to select are 'end_station_id' from the 'trip' table and 'installation_date' from the 'station' table."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT end_station_id, installation_date FROM station JOIN trip ON station.id = trip.end_station_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.162", "db_id": "bike_1", "question": "What is the installation date for each ending station on all the trips?", "rationale": ["Identify the relevant tables: We need information from the 'trip' table for the ending stations and the 'station' table for the installation dates.", "Join the 'trip' table with the 'station' table on the station identifiers to get the installation dates for each ending station.", "Select the end station names and their corresponding installation dates.", "Group the results by end station name to ensure we get unique entries for each station."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT end_station_name, s.installation_date \nFROM trip t \nJOIN station s ON t.end_station_id = s.id \nGROUP BY end_station_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.163", "db_id": "bike_1", "question": "Which trip started from the station with the largest dock count? Give me the trip id.", "rationale": ["Identify the station with the largest dock count by ordering the 'station' table by 'dock_count' in descending order and limiting the result to 1.", "Use the 'id' of this station to filter the 'trip' table for trips that started from this station.", "Select the 'id' of the trip that matches the start station id found in the previous step."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "pred_sql": "SELECT id FROM trip WHERE start_station_id = (SELECT id FROM station ORDER BY dock_count DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.165", "db_id": "bike_1", "question": "Count the number of trips that did not end in San Francisco city.", "rationale": ["Identify the requirement to count trips that did not end in San Francisco.", "To achieve this, we need to filter the trips based on the end station name.", "We will use a subquery to get the names of stations located in San Francisco.", "The subquery will select names from the station table where the city is 'San Francisco'.", "The main query will count all trips where the end station name is not in the list returned by the subquery."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip WHERE end_station_name NOT IN (SELECT name FROM station WHERE city = 'San Francisco')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.166", "db_id": "bike_1", "question": "How many trips did not end in San Francisco?", "rationale": ["Identify the relevant table: The 'trip' table contains information about trips, including the end station name.", "Determine the condition: We need to count trips that did not end in San Francisco.", "Construct the SQL query: Use COUNT(*) to count the number of trips where the end_station_name is not 'San Francisco'."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != 'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip WHERE end_station_name != 'San Francisco';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.167", "db_id": "bike_1", "question": "In zip code 94107, on which day neither Fog nor Rain was not observed?", "rationale": ["Identify the relevant table: The 'weather' table contains the necessary information about weather events and zip codes.", "Filter by zip code: We need to focus on the zip code 94107, so we will include a WHERE clause for this zip code.", "Exclude specific weather events: We need to find days where neither Fog nor Rain was observed. This can be done by checking the 'events' column for the absence of these terms.", "Select distinct dates: We want to know the unique days that meet the criteria, so we will use SELECT DISTINCT to get unique dates from the filtered results."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT date FROM weather WHERE zip_code = 94107 AND events NOT LIKE '%Fog%' AND events NOT LIKE '%Rain%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n        \"virtual_table\": \"SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.\",\n        \"virtual_table\": \"SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.168", "db_id": "bike_1", "question": "On which day has it neither been foggy nor rained in the zip code of 94107?", "rationale": ["We need to find days with no fog and no rain in the specified zip code (94107).", "Fog is typically indicated by a high dew point, so we can assume that a maximum dew point below a certain threshold (e.g., 0) indicates no fog.", "Rain can be identified by checking if the total precipitation is zero.", "We will select distinct dates from the weather table where the zip code is 94107, the maximum dew point is below 0, and the precipitation is zero."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT date FROM weather WHERE zip_code = 94107 AND max_dew_point_f < 0 AND precipitation_inches = 0", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n        \"virtual_table\": \"SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.\",\n        \"virtual_table\": \"SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.183", "db_id": "bike_1", "question": "List all the cities in a decreasing order of each city's stations' highest latitude.", "rationale": ["Identify the relevant table: The 'station' table contains the necessary information about cities and their corresponding latitude coordinates.", "Select the city and the maximum latitude for each city: Use the MAX function to find the highest latitude for each city.", "Group the results by city: This is necessary to ensure that we get the maximum latitude for each unique city.", "Order the results in decreasing order of latitude: Use the ORDER BY clause to sort the results based on the highest latitude in descending order."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, MAX(lat) as highest_latitude FROM station GROUP BY city ORDER BY highest_latitude DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.184", "db_id": "bike_1", "question": "For each city, list their names in decreasing order by their highest station latitude.", "rationale": ["We need to list the names of bike stations for each city.", "To achieve this, we will select the 'city' and 'name' columns from the 'station' table.", "We want to order the results by the highest latitude of the stations, which is represented by the 'lat' column.", "The ordering should be in decreasing order, so we will use 'ORDER BY lat DESC'."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, name FROM station ORDER BY lat DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.189", "db_id": "bike_1", "question": "For each station, return its longitude and the average duration of trips that started from the station.", "rationale": ["Identify the required data: longitude of each station and the average duration of trips starting from each station.", "The 'station' table contains the longitude (long) and unique identifiers (id) for each station.", "The 'trip' table contains the duration of trips and the start station identifier (start_station_id).", "To get the average duration of trips for each station, we need to join the 'station' table with the 'trip' table on the station ID.", "Use the AVG() function to calculate the average duration of trips for each station.", "Group the results by the station ID to ensure we get one result per station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.long, AVG(t.duration) AS average_duration\nFROM station AS s\nJOIN trip AS t ON s.id = t.start_station_id\nGROUP BY s.id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n        \"virtual_table\": \"SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] EXCEPT SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.190", "db_id": "bike_1", "question": "For each start station id, what is its name, longitude and average duration of trips started there?", "rationale": ["Identify the relevant tables: We need data from the 'trip' table for trip durations and start station IDs, and from the 'station' table for station names and longitudes.", "Join the 'trip' table with the 'station' table on the station ID to get the necessary details about each start station.", "Select the start station ID, start station name, longitude from the 'station' table, and calculate the average duration of trips from the 'trip' table.", "Group the results by start station ID, start station name, and longitude to ensure we get one result per station with its average trip duration."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT start_station_id, start_station_name, station.long, AVG(duration) AS average_duration\nFROM trip\nJOIN station ON trip.start_station_id = station.id\nGROUP BY start_station_id, start_station_name, station.long;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.192", "db_id": "bike_1", "question": "For each end station id, what is its name, latitude, and minimum duration for trips ended there?", "rationale": ["Identify the relevant tables: We need data from the 'trip' table for trip durations and end station details, and from the 'station' table for station names and latitudes.", "Select the required columns: We need the end station id, end station name, latitude (lat), and the minimum duration of trips that ended at each station.", "Join the tables: We will join the 'trip' table with the 'station' table on the condition that the end station id in the trip matches the id in the station.", "Group by end station id and name: To get the minimum duration for each end station, we will group the results by end station id and name.", "Use aggregate function: We will use the MIN() function to find the minimum duration of trips for each group."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT end_station_id, end_station_name, lat, MIN(duration) AS min_duration \nFROM trip \nJOIN station ON trip.end_station_id = station.id \nGROUP BY end_station_id, end_station_name, lat;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.196", "db_id": "bike_1", "question": "What are all the different zip codes that have a maximum dew point that was always below 70?", "rationale": ["The question asks for unique zip codes with a maximum dew point always below 70.", "To find these zip codes, we can start by selecting all distinct zip codes from the weather table.", "Next, we need to exclude any zip codes that have a maximum dew point of 70 or above.", "This can be achieved using the EXCEPT clause, which will return the zip codes from the first selection that are not present in the second selection where the max_dew_point_f is 70 or more."], "gold_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f >= 70", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n        \"virtual_table\": \"SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.\",\n        \"virtual_table\": \"SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.205", "db_id": "bike_1", "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.", "rationale": ["We need to find zip codes where the average mean humidity is below 70 and at least 100 trips took place.", "To achieve this, we will group the weather data by zip code and calculate the average mean humidity for each zip code.", "We will also count the number of trips associated with each zip code by using a subquery that counts the trip IDs where the trip's zip code matches the weather's zip code.", "Finally, we will use the HAVING clause to filter the results to only include those zip codes where the average mean humidity is below 70 and the count of trips is at least 100."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity) < 70 AND COUNT((SELECT id FROM trip WHERE trip.zip_code = weather.zip_code)) >= 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n        \"virtual_table\": \"SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.206", "db_id": "bike_1", "question": "What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?", "rationale": ["We need to find zip codes with an average mean humidity below 70 and at least 100 trips.", "First, we will group the trips by zip code using GROUP BY zip_code.", "Next, we will count the number of trips for each zip code using COUNT(id) and filter those with at least 100 trips using HAVING COUNT(id) >= 100.", "Then, we will calculate the average mean humidity for each zip code by joining the trip table with the weather table on zip_code and using AVG(mean_humidity).", "Finally, we will filter the results to include only those zip codes where the average mean humidity is below 70 using HAVING AVG(mean_humidity) < 70."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code FROM trip GROUP BY zip_code HAVING COUNT(id) >= 100 AND AVG((SELECT mean_humidity FROM weather WHERE weather.zip_code = trip.zip_code)) < 70;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n        \"virtual_table\": \"SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.304", "db_id": "product_catalog", "question": "What are the attribute data types with more than 3 attribute definitions?", "rationale": ["Identify the table that contains the attribute definitions, which is 'Attribute_Definitions'.", "Determine the relevant column that contains the data types of the attributes, which is 'attribute_data_type'.", "To find data types with more than 3 definitions, we need to group the results by 'attribute_data_type'.", "Use the HAVING clause to filter groups that have a count of 'attribute_id' greater than 3."], "gold_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  3", "source_tables": ["attribute_definitions"], "pred_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING COUNT(attribute_id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.316", "db_id": "product_catalog", "question": "Find the entry names of the catalog with the attribute that have the most entries.", "rationale": ["Identify the tables involved: Catalog_Contents for entry names and Catalog_Contents_Additional_Attributes for attributes.", "Join the Catalog_Contents table with Catalog_Contents_Additional_Attributes on catalog_entry_id to link entries with their attributes.", "Use a subquery to find the attribute_value that has the most entries by grouping by attribute_value and ordering by count in descending order, limiting the result to 1 to get the most common attribute.", "Select the catalog_entry_name from the joined tables where the attribute_value matches the most common one found in the subquery."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id = t2.catalog_entry_id WHERE t2.attribute_value = (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table provides the latest revision dates of catalogs from the 'Catalogs' table, grouped by the revision date. The placeholder in the HAVING clause represents the minimum count of catalogs that must share the same revision date.\",\n        \"virtual_table\": \"SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.317", "db_id": "product_catalog", "question": "What is the entry name of the most expensive catalog (in USD)?", "rationale": ["Identify the relevant table: The question asks for the entry name of the most expensive catalog in USD, which relates to the 'Catalog_Contents' table where prices are stored.", "Determine the price column: The price in USD is stored in the 'price_in_dollars' column of the 'Catalog_Contents' table.", "Find the maximum price: To find the most expensive catalog, we need to select the maximum value from the 'price_in_dollars' column.", "Select the entry name: We need to select the 'catalog_entry_name' from the 'Catalog_Contents' table where the price matches the maximum price found in the previous step.", "Construct the SQL query: Combine these steps into a single SQL query that retrieves the catalog entry name corresponding to the highest price."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE price_in_dollars = (SELECT MAX(price_in_dollars) FROM Catalog_Contents)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.330", "db_id": "product_catalog", "question": "What are the names of catalog entries with level number 8?", "rationale": ["Identify the relevant table: The question asks for catalog entries, which are found in the 'Catalog_Contents' table.", "Determine the filtering criteria: The level number specified is '8', which corresponds to the 'catalog_level_number' column in the 'Catalog_Contents' table.", "Construct the SQL query: We need to select the 'catalog_entry_name' from 'Catalog_Contents' where 'catalog_level_number' equals '8'."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  '8'", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE catalog_level_number = '8'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.331", "db_id": "product_catalog", "question": "Find the names of the products with length smaller than 3 or height greater than 5.", "rationale": ["Identify the table that contains product information, which is the Catalog_Contents table.", "Determine the relevant columns needed for the query: catalog_entry_name for product names, length for the length condition, and height for the height condition.", "Construct the SQL SELECT statement to retrieve catalog_entry_name from Catalog_Contents.", "Add a WHERE clause to filter products based on the conditions: length smaller than 3 or height greater than 5."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name \nFROM Catalog_Contents \nWHERE length < 3 OR height > 5;", "hint": "\n"}
{"sample_id": "train.332", "db_id": "product_catalog", "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.", "rationale": ["Identify the relevant table: The question asks about catalog contents, which are stored in the 'Catalog_Contents' table.", "Determine the columns needed: We need the 'catalog_entry_name' and the 'length' of the catalog contents.", "Formulate the condition: The question specifies that we want entries with a length below 3 or above 5.", "Construct the SQL query: Using a SELECT statement to retrieve 'catalog_entry_name' from 'Catalog_Contents' where the length condition is met."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE length < 3 OR length > 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table provides the latest revision dates of catalogs from the 'Catalogs' table, grouped by the revision date. The placeholder in the HAVING clause represents the minimum count of catalogs that must share the same revision date.\",\n        \"virtual_table\": \"SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.338", "db_id": "product_catalog", "question": "On which days more than one revisions were made on catalogs.", "rationale": ["Identify the relevant table: The 'Catalogs' table contains the revision dates of catalogs.", "Group by the revision date: We need to group the results by 'date_of_latest_revision' to count how many catalogs share the same revision date.", "Count the number of catalogs: Use the COUNT function to count the number of catalogs for each revision date.", "Filter for more than one revision: Use the HAVING clause to filter the results where the count of catalogs is greater than 1."], "gold_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1", "source_tables": ["catalogs"], "pred_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*) > 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table provides the latest revision dates of catalogs from the 'Catalogs' table, grouped by the revision date. The placeholder in the HAVING clause represents the minimum count of catalogs that must share the same revision date.\",\n        \"virtual_table\": \"SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flight origins and destinations.", "Determine the required information: We need to find the origins of flights that are headed to Honolulu.", "Construct the SQL query: Use a SELECT statement to retrieve the 'origin' column from the 'flight' table where the 'destination' is 'Honolulu'."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight WHERE destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\",\n        \"virtual_table\": \"SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the required columns: We need the 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We want flights that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query: Using the SELECT statement to retrieve the specified columns from the 'flight' table with the appropriate WHERE clause."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\",\n        \"virtual_table\": \"SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the necessary information about flights, including their prices and origins.", "Determine the required calculation: We need to calculate the average price of flights, which can be done using the AVG() function in SQL.", "Specify the conditions: We need to filter the results to only include flights that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query: Using the identified table, calculation, and conditions, we can construct the SQL query to find the average price for flights from LA to Honolulu."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT avg(price) FROM flight WHERE origin = 'LA' AND destination = 'Honolulu'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\",\n        \"virtual_table\": \"SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["Identify the tables needed: We need data from the 'flight' table to count the number of flights and the 'aircraft' table to get the names of the aircraft.", "Join the 'flight' table with the 'aircraft' table on the aircraft ID (aid) to associate each flight with its corresponding aircraft name.", "Use COUNT() function to count the number of flights (flno) for each aircraft.", "Group the results by aircraft ID (aid) to get the count of flights for each aircraft.", "Select the aircraft name and the count of flights in the final output."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT T2.name, COUNT(T1.flno) AS number_of_flights \nFROM flight AS T1 \nJOIN aircraft AS T2 ON T1.aid = T2.aid \nGROUP BY T2.aid;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables needed: 'aircraft' for aircraft names and 'flight' for counting flights.", "Use a LEFT JOIN to include all aircraft, even those with no flights.", "Count the number of flights associated with each aircraft using COUNT(flight.flno).", "Group the results by aircraft ID to get the count for each aircraft.", "Select the aircraft name and the count of flights as the final output."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT aircraft.name, COUNT(flight.flno) AS flight_count FROM aircraft LEFT JOIN flight ON aircraft.aid = flight.aid GROUP BY aircraft.aid;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["Identify the main requirement: to find names of employees not certified to fly a specific aircraft model (Boeing 737-800).", "Use the EXCEPT clause to find employees who are not certified for the specified aircraft.", "The first part of the query selects all employee names from the employee table.", "The second part of the query selects names of employees who are certified to fly the Boeing 737-800 by joining the employee, certificate, and aircraft tables.", "In the second part, filter the results where the aircraft name is 'Boeing 737-800'.", "Combine both parts using EXCEPT to get the final result of employees not certified for that aircraft."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT name FROM employee EXCEPT SELECT T1.name FROM employee AS T1 JOIN certificate AS T2 ON T1.eid = T2.eid JOIN aircraft AS T3 ON T3.aid = T2.aid WHERE T3.name = 'Boeing 737-800'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\",\n        \"virtual_table\": \"SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["We need to find the aircraft with the fewest number of certifications.", "To do this, we will join the 'certificate' table with the 'aircraft' table on the aircraft ID (aid).", "We will group the results by the aircraft ID to count the number of certifications for each aircraft.", "Next, we will order the results by the count of certifications in ascending order to get the aircraft with the fewest certifications at the top.", "Finally, we will limit the results to just one entry to get the name of the aircraft with the fewest certifications."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT T2.name FROM certificate AS T1 JOIN aircraft AS T2 ON T2.aid = T1.aid GROUP BY T2.aid ORDER BY COUNT(T1.eid) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\",\n        \"virtual_table\": \"SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.432", "db_id": "flight_1", "question": "What are the names of the aircraft that the least people are certified to fly?", "rationale": ["Identify the tables involved: We need to find aircraft names and their certifications, so we will use the 'aircraft' and 'certificate' tables.", "Join the 'certificate' table with the 'aircraft' table on the aircraft ID (aid) to get the names of the aircraft that have certifications.", "Group the results by aircraft ID to count how many employees are certified for each aircraft.", "Order the results by the count of certifications in ascending order to find the aircraft with the least certifications.", "Limit the results to 1 to get only the aircraft with the least number of certified employees."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid = T1.aid GROUP BY T2.aid ORDER BY COUNT(T1.eid) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\",\n        \"virtual_table\": \"SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["Identify the employees who hold certificates for aircraft that can travel more than 5000 miles.", "Use the provided virtual table structure to create a subquery that counts the number of certificates each employee has for aircraft with a distance greater than 5000.", "Group the results by employee ID and order them by the count of certificates in descending order, limiting the results to the top employee.", "Join this result with the Employee table to get the names and salaries of the employees.", "Select the name and salary of the employee with the most certificates."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT T1.name, E.salary FROM (SELECT T1.eid, COUNT(*) as cert_count FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid = T1.aid WHERE T2.distance > 5000 GROUP BY T1.eid ORDER BY cert_count DESC LIMIT 1) AS C JOIN Employee AS E ON C.eid = E.eid;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The user wants to know all the different food allergies.", "To get the list of different allergies, we need to select the 'Allergy' column from the 'Allergy_Type' table.", "Using DISTINCT ensures that we only get unique allergy names, avoiding duplicates."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Allergy_Type", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.452", "db_id": "allergy_1", "question": "How many animal type allergies exist?", "rationale": ["Identify the relevant table: Allergy_Type contains the allergy names and their types.", "We need to count the distinct allergies that fall under the category of 'Animal'.", "Use the COUNT function to count distinct values in the Allergy column.", "Filter the results by specifying the condition that AllergyType must be 'Animal'."], "gold_sql": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  'animal'", "source_tables": ["allergy_type"], "pred_sql": "SELECT COUNT(DISTINCT Allergy) FROM Allergy_Type WHERE AllergyType = 'Animal';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["Identify the relevant tables: Allergy_Type and Has_Allergy are needed to find the allergy types and their counts.", "Join the Allergy_Type table with the Has_Allergy table on the Allergy column to associate allergies with their types.", "Group the results by AllergyType to count how many allergies belong to each type.", "Use COUNT(Allergy) to count the number of allergies for each type.", "Order the results in descending order based on the count of allergies to find the type with the most allergies.", "Limit the results to 1 to get only the allergy type with the highest count."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(Allergy) AS AllergyCount FROM Allergy_Type JOIN Has_Allergy ON Allergy_Type.Allergy = Has_Allergy.Allergy GROUP BY AllergyType ORDER BY AllergyCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["Identify the tables involved: We need to look at the 'Has_Allergy' table to see which allergies students have and the 'Allergy_Type' table to categorize these allergies.", "Join the two tables on the common column 'Allergy' to get the allergy types associated with each student.", "Group the results by 'AllergyType' to count how many students have each type of allergy.", "Use COUNT(*) to count the number of occurrences for each allergy type.", "Order the results in ascending order based on the count to find the least common allergy type.", "Limit the results to 1 to get only the least common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(*) AS AllergyCount FROM Has_Allergy AS HA JOIN Allergy_Type AS AT ON HA.Allergy = AT.Allergy GROUP BY AllergyType ORDER BY AllergyCount ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student names, which is the 'Student' table.", "To get the full names, we need to concatenate the 'Fname' and 'LName' columns.", "Use the SQL SELECT statement to retrieve the concatenated names from the 'Student' table."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName FROM Student;", "hint": "\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the table that contains student information, which is the 'Student' table.", "Determine the relevant column for filtering male students, which is the 'Sex' column.", "Construct a SQL SELECT statement to retrieve the 'StuID' of students where 'Sex' is equal to 'Male'."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male';", "hint": "\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the major information, which is the 'Student' table.", "To find the largest major, we need to count how many students are in each major.", "We will use the COUNT function to count the number of students for each major.", "We will group the results by the 'Major' column to get the count for each major.", "To find the largest major, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.502", "db_id": "allergy_1", "question": "Give the advisor with the most students.", "rationale": ["Identify the relevant table: The 'Student' table contains the 'Advisor' and 'StuID' columns.", "Count the number of students for each advisor: Use COUNT(StuID) to count the number of students associated with each advisor.", "Group the results by advisor: Use GROUP BY Advisor to aggregate the student counts for each advisor.", "Order the results to find the advisor with the most students: Use ORDER BY StudentCount DESC to sort the advisors by their student count in descending order.", "Limit the results to only one advisor: Use LIMIT 1 to get only the advisor with the highest count."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(StuID) AS StudentCount\nFROM Student\nGROUP BY Advisor\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["Identify the relevant table: We need to find students with cat allergies, so we will focus on the Has_Allergy table.", "Determine the condition: We are specifically looking for records where the Allergy column matches 'cat'.", "Count the number of records: We will use the COUNT function to count how many students have this allergy."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT count(*) FROM Has_Allergy WHERE Allergy = 'cat';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the main goal: Count the number of students affected by cat allergies.", "Determine the relevant tables: We need to use the 'Student' table to get student information and the 'Has_Allergy' table to find students with specific allergies.", "Join the 'Has_Allergy' table with the 'Allergy_Type' table to filter for cat allergies.", "Use a subquery to find all student IDs (StuID) that have a cat allergy.", "Count the number of unique student IDs from the 'Student' table that match the IDs from the subquery."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT count(*) FROM Student WHERE StuID IN ( SELECT StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the target group: female students.", "Count the number of female students who have specific allergies (milk or eggs).", "Use a subquery to find students with the specified allergies by joining the Has_Allergy and Allergy_Type tables.", "Filter the results based on the gender of the students in the main query."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT count(*) FROM Student WHERE Sex = 'Female' AND StuID IN (SELECT StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType IN ('Milk', 'Eggs'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.514", "db_id": "allergy_1", "question": "Which allergy is the most common?", "rationale": ["To find the most common allergy, we need to count the occurrences of each allergy in the Has_Allergy table.", "We will use the COUNT function to count how many times each allergy appears.", "We will group the results by the Allergy column to get the count for each unique allergy.", "To determine which allergy is the most common, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one entry to get the most common allergy."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT Allergy, COUNT(*) as AllergyCount FROM Has_Allergy GROUP BY Allergy ORDER BY AllergyCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["Identify the tables needed: We need to retrieve student information from the Student table and allergy information from the Has_Allergy and Allergy_Type tables.", "Determine the required fields: We need the last name (LName) and age of the student.", "Establish the relationship: We will use the StuID to link the Student table with the Has_Allergy table, which in turn links to the Allergy_Type table.", "Filter for students with specific allergies: We need to find students who have both 'milk' and 'cat' allergies. This can be done using an INTERSECT operation to find common StuIDs from two separate queries for each allergy.", "Construct the SQL query: The final query selects LName and Age from the Student table where the StuID is in the result of the INTERSECT query."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT LName, Age FROM Student WHERE StuID IN (SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'milk' INTERSECT SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the relevant tables: Student, Has_Allergy, and Allergy_Type.", "We need to find students who have specific allergies (milk and cat).", "Use the Has_Allergy table to find students with these allergies by their StuID.", "Join the Has_Allergy table with the Allergy_Type table to filter by allergy names (milk and cat).", "Use INTERSECT to ensure we get students who have both allergies.", "Select the last names and ages of these students from the Student table using their StuID."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT LName, Age FROM Student WHERE StuID IN (SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'milk' INTERSECT SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.523", "db_id": "allergy_1", "question": "Find the first name and gender of the student who has allergy to milk but not cat.", "rationale": ["Identify the relevant tables: We need to retrieve data from the Student table and filter based on allergies from the Has_Allergy table.", "We want to find students who have an allergy to milk. This requires a subquery that selects StuID from Has_Allergy where Allergy is 'milk'.", "We also want to exclude students who have an allergy to cat. This requires another subquery that selects StuID from Has_Allergy where Allergy is 'cat'.", "Combine these conditions using the IN and NOT IN clauses in the main query to filter the students accordingly.", "Finally, select the first name (Fname) and gender (Sex) of the students who meet these criteria."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'milk') AND StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.524", "db_id": "allergy_1", "question": "What are the first name and gender of the students who have allergy to milk but can put up with cats?", "rationale": ["Identify the required fields: first name (Fname) and gender (Sex) of students.", "Filter students who have an allergy to milk by checking the Has_Allergy table for 'milk'.", "Also, filter out students who have an allergy to cats by checking the Has_Allergy table for 'cats'.", "Combine these conditions using the IN and NOT IN clauses to get the desired results."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'milk') AND StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'cats')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being checked against the students' allergies.\",\n        \"virtual_table\": \"SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the goal: Calculate the average age of students with specific allergy types (food and animal).", "Use the Student table to access student ages.", "Join the Has_Allergy table with the Allergy_Type table to filter students based on their allergies.", "Use the INTERSECT operator to find students who have both food and animal allergies.", "Select the average age from the Student table where the student IDs match those found in the previous step."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT avg(Age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'food' INTERSECT SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'animal')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["Identify the requirement: We need the full names of students who are not allergic to any type of food.", "Understand the schema: We have three tables - Student, Has_Allergy, and Allergy_Type.", "We need to filter students based on their allergies, specifically those who do not have any food allergies.", "Using the provided hint, we can see that we can create a subquery that selects student IDs from Has_Allergy where the allergy type is 'Food'.", "The main query will select the first and last names from the Student table where the student ID is not in the list of IDs returned by the subquery.", "Construct the SQL query using the identified tables and conditions."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname, LName FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'Food')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being checked against the students' allergies.\",\n        \"virtual_table\": \"SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["Identify the relevant tables: Student, Has_Allergy, and Allergy_Type.", "We need to count the number of male students (sex = 'M').", "We need to check if these students have any type of food allergy.", "Join the Has_Allergy table with the Allergy_Type table to filter allergies by type.", "Use a subquery to find students with food allergies and count them in the main query."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT count(*) FROM Student WHERE sex = 'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.allergytype = 'Food')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables needed: We need data from the Student and Has_Allergy tables.", "We want to find students with specific allergies (milk or cat), so we will join the Has_Allergy table with the Student table on StuID.", "We need to select distinct first names and city codes of these students, so we will use SELECT DISTINCT to avoid duplicates.", "The WHERE clause will filter the allergies to only include 'milk' or 'cat'.", "Construct the SQL query using the identified tables, joins, and conditions."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code \nFROM Student AS S \nJOIN Has_Allergy AS HA ON S.StuID = HA.StuID \nWHERE HA.Allergy IN ('milk', 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being checked against the students' allergies.\",\n        \"virtual_table\": \"SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["Identify the tables needed: We need to get student information (first names and city codes) and their allergies, so we will use the Student and Has_Allergy tables.", "We need to join the Student table with the Has_Allergy table on the StuID to link students with their allergies.", "We want distinct first names and cities, so we will use SELECT DISTINCT to avoid duplicate entries.", "The WHERE clause will filter the results to include only those students who have allergies to either 'milk' or 'cat'.", "Finally, we will select the first names and city codes from the joined tables."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT T3.Fname, T3.city_code FROM Student AS T3 JOIN Has_Allergy AS T2 ON T3.StuID = T2.StuID WHERE T2.Allergy IN ('milk', 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being checked against the students' allergies.\",\n        \"virtual_table\": \"SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["We need to find the names of the countries and the average invoice size for each country.", "To do this, we will select the 'billing_country' from the 'invoices' table.", "We will calculate the average of the 'total' column, which represents the invoice size, using the AVG() function.", "We will group the results by 'billing_country' to get the average for each country.", "Finally, we will order the results by the average invoice size in descending order to get the top countries by size."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size\nFROM invoices\nGROUP BY billing_country\nORDER BY average_invoice_size DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["We need to count the number of invoices for each state.", "The relevant table for this information is the 'invoices' table, which contains the 'billing_state' and 'id' of each invoice.", "To get the count of invoices per state, we will use the COUNT() function and group the results by 'billing_state'.", "The final SQL query will select the 'billing_state' and the count of invoices, grouping by 'billing_state' to aggregate the counts."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count FROM invoices GROUP BY billing_state;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["Identify the relevant table: The 'invoices' table contains the billing information including states.", "Determine the required information: We need to count the number of invoices per state.", "Group the results: Use GROUP BY to aggregate the count of invoices for each state.", "Order the results: Use ORDER BY to sort the states by the count of invoices in descending order."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) FROM invoices GROUP BY billing_state ORDER BY COUNT(*) DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.568", "db_id": "store_1", "question": "What is the number of invoices and total money billed in them from CA?", "rationale": ["Identify the relevant table: The 'invoices' table contains the necessary information about invoices and their total amounts.", "Determine the required fields: We need to count the number of invoices and sum the total amount billed, which corresponds to COUNT(*) and SUM(total) respectively.", "Apply the filter: We need to filter the results to only include invoices from California (CA), which is done using the WHERE clause.", "Construct the SQL query: Combine the selected fields and the filter into a complete SQL query."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS number_of_invoices, SUM(total) AS total_billed FROM invoices WHERE billing_state = 'CA';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the relevant table: The 'employees' table contains the information needed (email and phone number).", "Determine the specific employee: The question specifies 'Astrid Gruber', so we need to filter the results based on the first name 'Astrid' and last name 'Gruber'.", "Construct the SQL query: Using the SELECT statement to retrieve the 'email' and 'phone' columns from the 'employees' table, and applying a WHERE clause to filter by the specified first and last names."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles, phone numbers, and hire dates of employees from the 'employees' table who have a specific first and last name. The placeholders in the WHERE clause represent the first and last names of the employee.\",\n        \"virtual_table\": \"SELECT title ,  phone ,  hire_date FROM employees WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["Identify the relevant table: The question asks about customers, so we will use the 'customers' table.", "Determine the condition: We need to count customers from California, which means we will filter by the 'state' column.", "Construct the SQL query: We will use the COUNT function to count the number of customers where the state is 'California'."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) FROM customers WHERE state = 'California';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: employees and customers.", "Join the employees table with the customers table on the support representative ID.", "Group the results by employee ID to count how many customers each employee supports.", "Order the results in descending order based on the count of customers supported.", "Limit the results to only the top employee who supports the most customers."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT T1.first_name, T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id = T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees who serve as support representatives for customers. The results are grouped by the employee's unique identifier and ordered by the number of customers they support in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of employees to return.\",\n        \"virtual_table\": \"SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of employees and their managers from the 'employees' table. It lists the first and last names of managers along with the count of employees reporting to each manager. The results are grouped by the manager's identifier and ordered by the number of reports in descending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.first_name , T2.last_name ,  count(T1.reports_to) FROM employees AS T1 JOIN employees AS T2 ON T1.reports_to = T2.id GROUP BY T1.reports_to ORDER BY count(T1.reports_to) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["Identify the customer by name: We need to find the customer ID for Luca Mancini.", "Use a subquery to get the customer ID: We will select the ID from the customers table where the first name is 'Luca' and the last name is 'Mancini'.", "Count the number of invoices: We will count the number of invoices associated with the customer ID obtained from the subquery."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "pred_sql": "SELECT COUNT(*) FROM invoices WHERE customer_id = (SELECT id FROM customers WHERE first_name = 'Luca' AND last_name = 'Mancini');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["Identify the tables involved: We need to find the album title for a specific track, so we will use the 'albums' and 'tracks' tables.", "Determine the relationship: The 'tracks' table has a foreign key 'album_id' that references the 'id' in the 'albums' table, allowing us to join these two tables.", "Formulate the SQL query: We will select the 'title' from the 'albums' table where the track name matches 'Balls to the Wall'.", "Use a JOIN clause to connect the 'albums' and 'tracks' tables based on the album ID."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT albums.title \nFROM albums \nJOIN tracks ON albums.id = tracks.album_id \nWHERE tracks.name = 'Balls to the Wall';", "hint": "\n"}
{"sample_id": "train.626", "db_id": "store_1", "question": "What is the name of all tracks in the album named Balls to the Wall?", "rationale": ["Identify the relevant tables: tracks and albums.", "We need to find tracks that belong to a specific album, so we will join the tracks table with the albums table using the album_id foreign key.", "The condition for the join will be that the album's title matches 'Balls to the Wall'.", "Select the name of the tracks from the resulting joined table."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN albums ON tracks.album_id = albums.id \nWHERE albums.title = 'Balls to the Wall';", "hint": "\n"}
{"sample_id": "train.630", "db_id": "store_1", "question": "What are the names of all Rock tracks that are stored on MPEG audio files?", "rationale": ["Identify the relevant tables: tracks, media_types, and genres.", "We need to find the names of tracks, so we will select the 'name' column from the tracks table.", "To filter by genre, we will join the genres table on the genre_id column of the tracks table.", "To filter by media type, we will join the media_types table on the media_type_id column of the tracks table.", "The WHERE clause will specify that we want tracks where the genre name is 'Rock' and the media type name is 'MPEG audio'."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN media_types ON tracks.media_type_id = media_types.id \nJOIN genres ON tracks.genre_id = genres.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG audio';", "hint": "\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the tables involved: tracks, genres, and media_types.", "We need to select the track names from the tracks table.", "To filter by genre, we will join the genres table on the genre_id column of the tracks table.", "To filter by media type, we will join the media_types table on the media_type_id column of the tracks table.", "The WHERE clause will specify that we want tracks where the genre name is 'Rock' and the media type name is 'MPEG'."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN genres ON tracks.genre_id = genres.id \nJOIN media_types ON tracks.media_type_id = media_types.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG';", "hint": "\n"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["Identify the relevant tables: We need to find tracks that a specific customer (Dean Peeters) bought, so we will use the 'tracks', 'invoice_lines', 'invoices', and 'customers' tables.", "Join the tables: We will join 'tracks' with 'invoice_lines' on the track ID, then join 'invoice_lines' with 'invoices' on the invoice ID, and finally join 'invoices' with 'customers' on the customer ID.", "Filter by customer name: We will filter the results to only include records where the customer's first name is 'Dean' and last name is 'Peeters'.", "Select the track names: Finally, we will select the names of the tracks that match these criteria."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN invoice_lines ON tracks.id = invoice_lines.track_id \nJOIN invoices ON invoice_lines.invoice_id = invoices.id \nJOIN customers ON invoices.customer_id = customers.id \nWHERE customers.first_name = 'Dean' AND customers.last_name = 'Peeters';", "hint": "\n"}
{"sample_id": "train.686", "db_id": "customers_card_transactions", "question": "What are the full names of customers who do not have any accounts?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to find customers who do not have any accounts, which means we need to exclude customer IDs that are present in the Accounts table.", "Use a subquery to select all customer_ids from the Accounts table.", "Use the NOT IN clause to filter out these customer_ids from the Customers table.", "Select the first and last names of the remaining customers."], "gold_sql": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name, customer_last_name FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.688", "db_id": "customers_card_transactions", "question": "What are the full names of customers who have accounts?", "rationale": ["Identify the tables involved: Accounts and Customers.", "Determine the relationship between the tables: Accounts has a foreign key customer_id that links to Customers.", "Select the required fields: customer_first_name and customer_last_name from the Customers table.", "Join the Accounts table with the Customers table on the customer_id field to get the full names of customers who have accounts."], "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT T2.customer_first_name, T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id = T2.customer_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have a certain number of cards associated with them. The placeholder in the HAVING clause represents the minimum count of cards a customer must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.704", "db_id": "customers_card_transactions", "question": "Return the full name and phone of the customer who has card number 4560596484842.", "rationale": ["Identify the tables needed: Customers and Customers_Cards.", "We need to retrieve the customer's first name, last name, and phone number.", "Join the Customers table with the Customers_Cards table on customer_id to link customers with their cards.", "Filter the results to only include the customer with the specified card number '4560596484842'.", "Select the required fields from the joined tables."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.card_number  =  '4560596484842'", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT C.customer_first_name, C.customer_last_name, C.customer_phone \nFROM Customers AS C \nJOIN Customers_Cards AS CC ON C.customer_id = CC.customer_id \nWHERE CC.card_number = '4560596484842';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have a certain number of cards associated with them. The placeholder in the HAVING clause represents the minimum count of cards a customer must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.717", "db_id": "customers_card_transactions", "question": "What is the customer id, first and last name with least number of accounts.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "Join the Accounts table with the Customers table on customer_id to get customer details associated with each account.", "Group the results by customer_id to count the number of accounts each customer has.", "Order the results by the count of accounts in ascending order to find the customer with the least number of accounts.", "Limit the results to 1 to get only the customer with the least number of accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT T2.customer_id, T2.customer_first_name, T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id = T2.customer_id GROUP BY T1.customer_id ORDER BY COUNT(*) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have a certain number of cards associated with them. The placeholder in the HAVING clause represents the minimum count of cards a customer must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.718", "db_id": "customers_card_transactions", "question": "Return the id and full name of the customer who has the fewest accounts.", "rationale": ["Identify the tables involved: Accounts and Customers.", "We need to join these tables on the customer_id to get customer details associated with their accounts.", "Group the results by customer_id to count the number of accounts each customer has.", "Order the results by the count of accounts in ascending order to find the customer with the fewest accounts.", "Limit the results to 1 to get only the customer with the fewest accounts.", "Select the customer_id and concatenate first and last names to get the full name of the customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT T2.customer_id, T2.customer_first_name || ' ' || T2.customer_last_name AS full_name \nFROM Accounts AS T1 \nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id \nGROUP BY T1.customer_id \nORDER BY COUNT(T1.account_id) ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have a certain number of cards associated with them. The placeholder in the HAVING clause represents the minimum count of cards a customer must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.721", "db_id": "customers_card_transactions", "question": "What is the card type code with most number of cards?", "rationale": ["We need to find the card type code with the most number of cards.", "To do this, we will count the number of cards for each card type code in the Customers_Cards table.", "We will use the COUNT function to count the card IDs grouped by card_type_code.", "Next, we will order the results in descending order based on the count of cards.", "Finally, we will limit the results to only one record to get the card type code with the highest count."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "pred_sql": "SELECT card_type_code, COUNT(card_id) AS card_count \nFROM Customers_Cards \nGROUP BY card_type_code \nORDER BY card_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have a certain number of cards associated with them. The placeholder in the HAVING clause represents the minimum count of cards a customer must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.735", "db_id": "customers_card_transactions", "question": "Show the number of transaction types.", "rationale": ["Identify the table that contains transaction types, which is the Financial_Transactions table.", "To count the number of each transaction type, we need to use the COUNT() function.", "We will select the transaction_type column and apply the COUNT() function to count occurrences of each type.", "To group the results by transaction type, we will use the GROUP BY clause on the transaction_type column."], "gold_sql": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, COUNT(*) AS transaction_count \nFROM Financial_Transactions \nGROUP BY transaction_type;", "hint": "\n"}
{"sample_id": "train.743", "db_id": "customers_card_transactions", "question": "What is the transaction type that has processed the greatest total amount in transactions?", "rationale": ["Identify the relevant table: Financial_Transactions contains the transaction details including type and amount.", "We need to group the transactions by their type to calculate the total amount for each type.", "Use the SUM function to calculate the total amount for each transaction type.", "Order the results in descending order to find the transaction type with the greatest total amount.", "Limit the results to 1 to get only the top transaction type."], "gold_sql": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, SUM(transaction_amount) AS total_amount\nFROM Financial_Transactions\nGROUP BY transaction_type\nORDER BY total_amount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.893", "db_id": "insurance_fnol", "question": "What are the customer phone numbers under the policy \"Life Insurance\"?", "rationale": ["Identify the relevant tables: Available_Policies, Customers_Policies, and Services.", "We need to find customer phone numbers, so we will select the 'Customer_Phone' column from the Available_Policies table.", "To link the policies to the customers, we will join the Available_Policies table with the Customers_Policies table on 'Policy_ID'.", "Next, we need to filter the policies to only include those with the name 'Life Insurance', so we will join the Services table to get the policy names.", "Finally, we will use a WHERE clause to filter for 'Life Insurance' and select distinct customer phone numbers."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nJOIN Services s ON ap.policy_type_code = s.Service_ID \nWHERE s.Service_name = 'Life Insurance';", "hint": "\n"}
{"sample_id": "train.895", "db_id": "insurance_fnol", "question": "Which policy type has the most records in the database?", "rationale": ["We need to find out which policy type has the most records in the database.", "To do this, we will query the 'Available_Policies' table.", "We will select the 'policy_type_code' and count the number of occurrences of each policy type using COUNT(*).", "We will group the results by 'policy_type_code' to aggregate the counts for each type.", "To find the type with the most records, we will order the results in descending order based on the count.", "Finally, we will limit the results to 1 to get only the top policy type."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "pred_sql": "SELECT policy_type_code, COUNT(*) as policy_count \nFROM Available_Policies \nGROUP BY policy_type_code \nORDER BY policy_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.897", "db_id": "insurance_fnol", "question": "What are all the customer phone numbers under the most popular policy type?", "rationale": ["Identify the most popular policy type by counting the number of policies issued for each type.", "Use a subquery to find the policy type with the maximum count.", "Join the Available_Policies table with Customers_Policies to link policies to customer phone numbers.", "Select distinct customer phone numbers associated with the most popular policy type."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nWHERE ap.policy_type_code = (\n    SELECT policy_type_code \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    HAVING COUNT(*) = (\n        SELECT MAX(policy_count) \n        FROM (\n            SELECT COUNT(*) AS policy_count \n            FROM Available_Policies \n            GROUP BY policy_type_code\n        )\n    )\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.898", "db_id": "insurance_fnol", "question": "Find the phone numbers of customers using the most common policy type among the available policies.", "rationale": ["Identify the relevant tables: Customers, Customers_Policies, and Available_Policies are needed to get customer phone numbers and their associated policies.", "Join the Customers table with Customers_Policies to link customers to their policies.", "Join the result with Available_Policies to access the policy types.", "To find the most common policy type, create a subquery that counts the occurrences of each policy type and selects the maximum count.", "Use this maximum count in another subquery to filter for the policy type(s) that match this count.", "Finally, select distinct customer phone numbers where the policy type matches the most common one."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT c.Customer_Phone \nFROM Customers c \nJOIN Customers_Policies cp ON c.Customer_ID = cp.Customer_ID \nJOIN Available_Policies ap ON cp.Policy_ID = ap.Policy_ID \nWHERE ap.policy_type_code = (\n    SELECT policy_type_code \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    HAVING COUNT(*) = (\n        SELECT MAX(policy_count) \n        FROM (\n            SELECT COUNT(*) AS policy_count \n            FROM Available_Policies \n            GROUP BY policy_type_code\n        )\n    )\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1060", "db_id": "match_season", "question": "Show the players from college UCLA.", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players and their colleges.", "Determine the condition: We need to filter players based on the college they attended, specifically 'UCLA'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Player' column from the 'match_season' table where the 'College' column matches 'UCLA'."], "gold_sql": "SELECT Player FROM match_season WHERE College  =  'UCLA'", "source_tables": ["match_season"], "pred_sql": "SELECT Player FROM match_season WHERE College = 'UCLA'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\",\n        \"virtual_table\": \"SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1082", "db_id": "match_season", "question": "Show the season, the player, and the name of the team that players belong to.", "rationale": ["Identify the columns needed: Season, Player, and Team Name.", "The Season and Player are from the match_season table.", "The Team Name is from the team table.", "To get the Team Name, we need to join the match_season table with the team table on the Team ID.", "Construct the SQL query using SELECT to retrieve the required columns and JOIN to combine the tables."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "pred_sql": "SELECT match_season.Season, match_season.Player, team.Name \nFROM match_season \nJOIN team ON match_season.Team = team.Team_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides information about the draft pick number and draft class of players from the 'match_season' table who play in a specific position. The placeholder in the WHERE clause represents the position of the player.\",\n        \"virtual_table\": \"SELECT Draft_Pick_Number ,  Draft_Class FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1092", "db_id": "match_season", "question": "Show the country names and the corresponding number of players.", "rationale": ["The task is to show the country names and the corresponding number of players.", "To achieve this, we need to count the number of players associated with each country.", "We will join the 'country' table with the 'match_season' table on the country identifier.", "Using COUNT(*) will allow us to count the number of entries (players) for each country.", "Finally, we will group the results by country name to get the count for each individual country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "pred_sql": "SELECT Country_name, COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id = T2.Country GROUP BY T1.Country_name", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of countries represented by players who occupy a specific position in matches. It uses an intersection to find countries where players in that position are participating in matches, ensuring that only countries with players in that position are returned. The placeholders in the query represent the position of the players being filtered.\",\n        \"virtual_table\": \"SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of matches played by players from each country, by joining the 'country' table with the 'match_season' table. The placeholder in the SELECT clause represents the country names, and the COUNT function aggregates the number of matches for each country.\",\n        \"virtual_table\": \"SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name\"\n    }\n}\n"}
{"sample_id": "train.1098", "db_id": "match_season", "question": "Show the top 3 most common colleges of players in match seasons.", "rationale": ["The task is to find the top 3 most common colleges of players in match seasons.", "To achieve this, we need to count the occurrences of each college in the match_season table.", "We will use the COUNT function to count how many players attended each college.", "We will group the results by the College column to aggregate the counts for each college.", "To get the most common colleges, we will order the results in descending order based on the count of players from each college.", "Finally, we will limit the results to the top 3 colleges."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as College_Count \nFROM match_season \nGROUP BY College \nORDER BY College_Count DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\",\n        \"virtual_table\": \"SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1099", "db_id": "match_season", "question": "What are the three colleges from which the most players are from?", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players and their colleges.", "We need to count the number of players from each college, so we will use the COUNT() function.", "Group the results by 'College' to aggregate the player counts for each college.", "Order the results in descending order based on the player count to get the colleges with the most players at the top.", "Limit the results to the top three colleges using LIMIT 3."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as Player_Count \nFROM match_season \nGROUP BY College \nORDER BY Player_Count DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\",\n        \"virtual_table\": \"SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1107", "db_id": "match_season", "question": "Return the names of countries that have players that play the Forward position, as well as players who play the Defender position.", "rationale": ["Identify the requirement to find countries with players in specific positions (Forward and Defender).", "Use the provided virtual table structure to create a query that selects country names based on player positions.", "Join the 'country' table with the 'match_season' table on the country ID.", "Filter the results for players in the Forward position in the first part of the INTERSECT query.", "Filter the results for players in the Defender position in the second part of the INTERSECT query."], "gold_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "pred_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id = T2.Country WHERE T2.Position = 'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id = T2.Country WHERE T2.Position = 'Defender'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of countries represented by players who occupy a specific position in matches. It uses an intersection to find countries where players in that position are participating in matches, ensuring that only countries with players in that position are returned. The placeholders in the query represent the position of the players being filtered.\",\n        \"virtual_table\": \"SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\",\n        \"virtual_table\": \"SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
