{"sample_id": "train.3672", "db_id": "baseball_1", "question": "For each year, return the year and the number of times the team Boston Red Stockings won in the postseasons.", "rationale": ["Identify the relevant table for postseason results, which is the 'postseason' table.", "Determine the condition for winning, which is when 'team_id_winner' matches the team ID for 'Boston Red Stockings'.", "Use a subquery to find the 'team_id' for 'Boston Red Stockings' from the 'team' table.", "Group the results by 'year' to count the number of wins for each year.", "Count the number of times the team won in each year using COUNT(*) and alias it as 'wins'."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "pred_sql": "SELECT year, COUNT(*) AS wins\nFROM postseason\nWHERE team_id_winner = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')\nGROUP BY year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3677", "db_id": "baseball_1", "question": "What is the total salary paid by team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant tables: We need to calculate the total salary, so we will use the 'salary' table and join it with the 'team' table to filter by team name.", "Determine the filtering criteria: We need to filter for the team 'Boston Red Stockings' and the year 2010.", "Construct the SQL query: We will use the SUM function to calculate the total salary for the specified team and year, joining the 'salary' table with the 'team' table on 'team_id'."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT SUM(salary.salary) \nFROM salary \nJOIN team ON salary.team_id = team.team_id \nWHERE team.name = 'Boston Red Stockings' AND salary.year = 2010;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\",\n        \"virtual_table\": \"SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant table: The 'salary' table contains the salary information for players.", "Filter by year: We need to focus on the year 2001, so we will add a WHERE clause to filter the records for that year.", "Select the necessary columns: We want to retrieve the 'player_id' and 'salary' columns from the 'salary' table.", "Order the results: To find the highest salaries, we will order the results in descending order based on the 'salary' column.", "Limit the results: Since we only want the top 3 salaries, we will use the LIMIT clause to restrict the output to 3 records."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3682", "db_id": "baseball_1", "question": "How much salary did the top 3 well-paid players get in 2001?", "rationale": ["Identify the relevant table: The 'salary' table contains the salary information for players.", "Filter by year: We need to focus on the year 2001, so we will add a WHERE clause to filter the records for that year.", "Sort the results: To find the top 3 well-paid players, we will order the results by the 'salary' column in descending order.", "Limit the results: We will use LIMIT 3 to get only the top 3 salaries."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3683", "db_id": "baseball_1", "question": "What were all the salary values of players in 2010 and 2001?", "rationale": ["Identify the relevant table for salary information, which is the 'salary' table.", "Determine the years of interest, which are 2010 and 2001.", "Construct a SQL query to select the 'salary' column from the 'salary' table where the 'year' is either 2010 or 2001 using the IN clause."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT salary FROM salary WHERE year IN (2010, 2001);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["To find the year with the least number of players inducted into the Hall of Fame, we need to count the number of inductees for each year.", "We can use the `hall_of_fame` table, which contains the `yearid` for each induction.", "We will group the results by `yearid` and use the `COUNT(*)` function to count the number of inductees for each year.", "To find the year with the least inductees, we will order the results in ascending order based on the count and limit the results to 1 to get the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY COUNT(*) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["To find the year with the least number of players inducted into the Hall of Fame, we need to count the number of inductees for each year.", "We can use the COUNT function to aggregate the total number of inductees per year from the hall_of_fame table.", "We will group the results by the year of induction (yearid) to get the count for each year.", "To find the year with the least inductees, we will order the results in ascending order based on the count of inductees.", "Finally, we will limit the results to just one entry to get the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY COUNT(*) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: home_game and park.", "We need to find the total number of games played in a specific park (Columbia Park) in a specific year (1907).", "Join the home_game table with the park table on the park_id to access park names.", "Filter the results to only include games played in 'Columbia Park' and in the year 1907.", "Use the SUM function to calculate the total number of games played."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(T1.games) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id = T2.park_id WHERE T2.park_name = 'Columbia Park' AND T1.year = 1907;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: home_game and park.", "We need to count the number of games played in a specific park (Columbia Park) in a specific year (1907).", "Join the home_game table with the park table on the park_id to access park names.", "Filter the results for the year 1907 and the park name 'Columbia Park'.", "Use the SUM function to count the total number of games played in that park for that year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(T1.games) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id = T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant tables: home_game and team.", "We need to find the total number of games played in Atlanta in the year 2000.", "The home_game table contains the number of games played, while the team table contains the city information.", "Join the home_game table with the team table on the team_id to access both games and city information.", "Filter the results to only include games played in Atlanta for the year 2000.", "Use the SUM function to calculate the total number of games played."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.city = 'Atlanta' AND T1.year = 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: home_game and team.", "We need to find the total number of games played in Atlanta in the year 2000.", "Join the home_game table with the team table on team_id to access team information.", "Filter the results for the city 'Atlanta' and the year 2000.", "Use the SUM function to calculate the total number of games played."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.city = 'Atlanta' AND T1.year = 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3693", "db_id": "baseball_1", "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?", "rationale": ["Identify the relevant tables: home_game and team.", "We need to calculate the total attendance for home games played by the Boston Red Stockings.", "Join the home_game table with the team table on team_id to filter by team name.", "Use the SUM function to aggregate the attendance over the specified years (2000 to 2010).", "Construct the SQL query using the identified elements."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\",\n        \"virtual_table\": \"SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3698", "db_id": "baseball_1", "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?", "rationale": ["Identify the relevant tables: We need the 'player' table for player names and the 'salary' table for salary records.", "Join the 'player' table with the 'salary' table to get the players who have salary records.", "We need to filter for players who were paid by the Washington Nationals in both 2005 and 2007.", "To do this, we can join the 'salary' table twice: once for 2005 and once for 2007, ensuring both records belong to the same player.", "Use subqueries to get the team_id for the Washington Nationals from the 'team' table.", "Select the first and last names of the players who meet these criteria."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT p.name_first, p.name_last \nFROM player p \nJOIN salary s1 ON p.player_id = s1.player_id \nJOIN salary s2 ON p.player_id = s2.player_id \nWHERE s1.team_id = (SELECT team_id FROM team WHERE name = 'Washington Nationals') AND s1.year = '2005' \nAND s2.team_id = (SELECT team_id FROM team WHERE name = 'Washington Nationals') AND s2.year = '2007';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a specified year of death. The placeholder in the WHERE clause represents the year of death.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant tables: 'home_game' for home games and 'team' for team names.", "Join the 'home_game' table with the 'team' table on 'team_id' to get team names associated with home games.", "Filter the results for the year 1980 to focus on that specific season.", "Group the results by team to aggregate the number of home games played by each team.", "Order the results by the total number of home games in ascending order to find the team with the least number of home games.", "Limit the results to 1 to get only the team with the least number of home games."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id WHERE T1.year = 1980 GROUP BY T2.team_id ORDER BY SUM(T1.games) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3709", "db_id": "baseball_1", "question": "Which park had most attendances in 2008?", "rationale": ["Identify the relevant tables: home_game for attendance data and park for park names.", "Join the home_game table with the park table on park_id to get park names along with attendance data.", "Filter the results to only include records from the year 2008.", "Order the results by attendance in descending order to find the park with the highest attendance.", "Limit the results to 1 to get only the park with the most attendance."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id = T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\",\n        \"virtual_table\": \"SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3857", "db_id": "insurance_policies", "question": "Find the settlement amount of the claim with the largest claim amount. Show both the settlement amount and claim amount.", "rationale": ["Identify the table needed: The 'Claims' table contains the relevant information about claim amounts and settled amounts.", "Determine the requirement: We need to find the settlement amount of the claim with the largest claim amount.", "Use the hint provided: The hint suggests using a virtual table that orders claims by the claimed amount in descending order.", "Construct the SQL query: Select 'Amount_Settled' and 'Amount_Claimed' from 'Claims', order by 'Amount_Claimed' in descending order, and limit the results to 1 to get the largest claim."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"], "pred_sql": "SELECT Amount_Settled, Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the amounts claimed and settled for insurance claims from the 'Claims' table. The results are ordered by the claimed amount in descending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3862", "db_id": "insurance_policies", "question": "Among all the claims, which settlements have a claimed amount that is no more than the average? List the claim start date.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find settlements where the claimed amount is no more than the average claimed amount.", "To do this, we will join the Claims table with the Settlements table on Claim_ID.", "We will filter the results using a WHERE clause that compares the Amount_Claimed in Settlements to the average Amount_Claimed from the Claims table.", "Finally, we will select the Start_Date from the Claims table for the filtered results."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT c.Start_Date\nFROM Claims AS cl\nJOIN Settlements AS s ON cl.Claim_ID = s.Claim_ID\nWHERE s.Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Claims)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the amounts claimed and settled for insurance claims from the 'Claims' table. The results are ordered by the claimed amount in descending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3863", "db_id": "insurance_policies", "question": "Return the claim start date for the claims whose claimed amount is no more than the average", "rationale": ["Identify the relevant table: The 'Claims' table contains the information about claims, including the claimed amounts and the claim dates.", "Determine the condition: We need to find claims where the claimed amount is no more than the average claimed amount. This requires calculating the average of 'Amount_Claimed' from the 'Claims' table.", "Construct the subquery: The subquery will calculate the average claimed amount using 'SELECT AVG(Amount_Claimed) FROM Claims'.", "Combine the main query and subquery: The main query will select 'Date_Claim_Made' from 'Claims' where 'Amount_Claimed' is less than or equal to the result of the subquery.", "Final SQL query: The complete SQL statement combines these elements to retrieve the desired claim start dates."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Claims)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the amounts claimed and settled for insurance claims from the 'Claims' table. The results are ordered by the claimed amount in descending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3868", "db_id": "insurance_policies", "question": "How many settlements were made on the claim with the most recent claim settlement date? List the number and the claim id.", "rationale": ["Identify the most recent claim settlement date from the Settlements table using a subquery.", "Join the Claims table with the Settlements table on Claim_ID to link claims with their settlements.", "Filter the results to only include settlements that match the most recent claim settlement date.", "Count the number of settlements for each claim that meets the criteria and select the Claim_ID along with the count."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT COUNT(*) AS Settlement_Count, T1.Claim_ID \nFROM Claims AS T1 \nJOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID \nWHERE T2.Date_Claim_Settled = (SELECT MAX(Date_Claim_Settled) FROM Settlements) \nGROUP BY T1.Claim_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of settlements associated with each insurance claim from the 'Claims' table. The placeholder in the SELECT statement represents the unique identifier for each claim, while the count reflects the number of settlements linked to that claim.\",\n        \"virtual_table\": \"SELECT T1.Claim_id ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3869", "db_id": "insurance_policies", "question": "Find the claim id and the number of settlements made for the claim with the most recent settlement date.", "rationale": ["We need to find the claim ID and the number of settlements for the claim with the most recent settlement date.", "To achieve this, we will first create a virtual table that counts the number of settlements for each claim by joining the Claims and Settlements tables.", "The join condition is based on the Claim_ID, which is common in both tables.", "Next, we need to filter the results to only include the claim(s) with the most recent settlement date. This can be done using a subquery that selects the maximum Date_Claim_Settled from the Settlements table.", "Finally, we group the results by Claim_ID to get the count of settlements for each claim."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT T1.Claim_ID, COUNT(*) AS Number_of_Settlements \nFROM Claims AS T1 \nJOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID \nWHERE T2.Date_Claim_Settled = (SELECT MAX(Date_Claim_Settled) FROM Settlements) \nGROUP BY T1.Claim_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of settlements associated with each insurance claim from the 'Claims' table. The placeholder in the SELECT statement represents the unique identifier for each claim, while the count reflects the number of settlements linked to that claim.\",\n        \"virtual_table\": \"SELECT T1.Claim_id ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3878", "db_id": "insurance_policies", "question": "What is the most popular payment method?", "rationale": ["Identify the table relevant to payment methods, which is the 'Payments' table.", "To find the most popular payment method, we need to group the records by 'Payment_Method_Code'.", "We will count the occurrences of each payment method using the COUNT function.", "To determine popularity, we will order the results in descending order based on the count of each payment method.", "Finally, we will limit the results to 1 to get only the most popular payment method."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.\",\n        \"virtual_table\": \"SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3879", "db_id": "insurance_policies", "question": "Which payment method is used the most often?", "rationale": ["Identify the table relevant to payment methods, which is the 'Payments' table.", "To find the most frequently used payment method, we need to group the records by 'Payment_Method_Code'.", "We will count the occurrences of each payment method using the COUNT function.", "To get the most often used payment method, we will order the results in descending order based on the count.", "Finally, we will limit the results to 1 to get only the top payment method."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.\",\n        \"virtual_table\": \"SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3880", "db_id": "insurance_policies", "question": "With which kind of payment method were the least number of payments processed?", "rationale": ["Identify the relevant table: The Payments table contains information about payment transactions, including the payment method used.", "Group by payment method: To find out how many payments were processed for each payment method, we need to group the results by the Payment_Method_Code.", "Count the number of payments: We will use the count function to count the number of payments for each payment method.", "Order by frequency: To find the least used payment method, we will order the results in ascending order based on the count of payments.", "Limit the results: Since we only want the payment method with the least number of payments, we will limit the results to 1."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.\",\n        \"virtual_table\": \"SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3886", "db_id": "insurance_policies", "question": "Which kind of policy type was chosen by the most customers?", "rationale": ["Identify the relevant table: The question pertains to the types of insurance policies, which are stored in the 'Customer_Policies' table.", "Group by policy type: To find out which policy type was chosen by the most customers, we need to group the records in 'Customer_Policies' by 'Policy_Type_Code'.", "Count the occurrences: We will count the number of occurrences of each policy type using the COUNT function.", "Order by frequency: To determine which policy type was chosen the most, we will order the results in descending order based on the count of each policy type.", "Limit the results: Since we only want the most chosen policy type, we will limit the results to 1."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "pred_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies from the 'Customer_Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.\",\n        \"virtual_table\": \"SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3893", "db_id": "insurance_policies", "question": "Which customers do not have any policies? Find the details of these customers.", "rationale": ["Identify the Customers table which contains customer details.", "Identify the Customer_Policies table which contains policies linked to customers.", "To find customers without any policies, we need to select customers whose IDs are not present in the Customer_Policies table.", "Use a subquery to select all Customer_IDs from the Customer_Policies table and use the NOT IN clause to filter out those customers from the Customers table."], "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"], "pred_sql": "SELECT * FROM Customers WHERE Customer_ID NOT IN (SELECT Customer_ID FROM Customer_Policies);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies from the 'Customer_Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.\",\n        \"virtual_table\": \"SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3895", "db_id": "insurance_policies", "question": "Which claims had exactly one settlement? For each, tell me the the date the claim was made, the date it was settled and the amount settled.", "rationale": ["Identify the relevant tables: Claims and Settlements are needed to get the claim details and settlement amounts.", "We need to find claims that have exactly one settlement. This can be done by counting the number of settlements for each claim using a subquery.", "The subquery selects Claim_IDs from the Claims table, joining with the Settlements table, grouping by Claim_ID, and filtering with HAVING COUNT(*) = 1 to ensure only claims with one settlement are selected.", "The main query selects the Date_Claim_Made, Date_Claim_Settled from the Claims table and Amount_Settled from the Settlements table, joining them on Claim_ID.", "Finally, we filter the main query using the results of the subquery to only include claims that have exactly one settlement."], "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT C.Date_Claim_Made, C.Date_Claim_Settled, S.Amount_Settled \nFROM Claims AS C \nJOIN Settlements AS S ON C.Claim_ID = S.Claim_ID \nWHERE C.Claim_ID IN (\n    SELECT T1.Claim_ID \n    FROM Claims AS T1 \n    JOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID \n    GROUP BY T1.Claim_ID \n    HAVING COUNT(*) = 1\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of settlements associated with each insurance claim from the 'Claims' table. The placeholder in the SELECT statement represents the unique identifier for each claim, while the count reflects the number of settlements linked to that claim.\",\n        \"virtual_table\": \"SELECT T1.Claim_id ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to count the number of employees (physicians) in each department.", "Join the Department table with the Physician table on the Head of the department.", "Group the results by department to get the count of physicians in each department.", "Order the results by the count of physicians in descending order to find the department with the most employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT d.Name, COUNT(p.EmployeeID) AS EmployeeCount\nFROM Department d\nLEFT JOIN Physician p ON d.Head = p.EmployeeID\nGROUP BY d.DepartmentID\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["Identify the relevant tables: Department and Affiliated_With.", "Join the Department table with the Affiliated_With table on the DepartmentID to get the count of physicians in each department.", "Group the results by DepartmentID to aggregate the count of physicians per department.", "Order the results by the count of physicians in descending order to find the department with the most employees.", "Limit the results to 1 to get only the top department."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT d.Name, COUNT(a.Physician) AS EmployeeCount\nFROM Department d\nJOIN Affiliated_With a ON d.DepartmentID = a.Department\nGROUP BY d.DepartmentID\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3901", "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["Identify the department with the least number of employees by counting the number of physicians affiliated with each department.", "Use the 'Affiliated_With' table to count the number of physicians for each department.", "Order the results by the count of physicians in ascending order to find the department with the least employees.", "Limit the results to 1 to get only the department with the least employees.", "Once we have the DepartmentID of the department with the least employees, we can find the head of that department from the 'Department' table."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Head FROM Department WHERE DepartmentID = (SELECT DepartmentID FROM Affiliated_With GROUP BY DepartmentID ORDER BY COUNT(Physician) ASC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["Identify the head of each department by joining the 'Department' table with the 'Physician' table on the 'Head' column.", "To find the department with the least number of employees, use the 'Affiliated_With' table to count the number of physicians affiliated with each department.", "Group the results by 'DepartmentID' and order them by the count of physicians in ascending order to get the department with the least number of employees.", "Use a subquery to get the 'DepartmentID' of the department with the least number of employees.", "Finally, select the name and position of the physician who is the head of that department."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Department \nJOIN Physician ON Department.Head = Physician.EmployeeID \nWHERE Department.DepartmentID = \n  (SELECT DepartmentID \n   FROM Affiliated_With \n   GROUP BY DepartmentID \n   ORDER BY COUNT(Physician) \n   LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3903", "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["Identify the department with the least employees by counting the number of physicians affiliated with each department.", "Use a subquery to find the DepartmentID that has the minimum count of physicians.", "Join the Department table with the Physician table to get the names and positions of the heads of departments.", "Select the Name and Position of the physician who is the head of the department identified in the previous step."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Department \nJOIN Physician ON Department.Head = Physician.EmployeeID \nWHERE Department.DepartmentID = (SELECT DepartmentID \n                                   FROM Affiliated_With \n                                   GROUP BY DepartmentID \n                                   ORDER BY COUNT(Physician) \n                                   LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["Identify the relevant tables: Appointment and Patient.", "We need to retrieve the names of patients who have made appointments, which means we will join the Appointment table with the Patient table.", "The join condition will be based on the Patient's SSN in the Patient table matching the Patient identifier in the Appointment table.", "We will select the distinct names of patients to avoid duplicates, as a patient may have multiple appointments."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT Patient.Name \nFROM Appointment \nJOIN Patient ON Appointment.Patient = Patient.SSN;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of nurses who are on call, filtered by specific block floor and block code statuses. The placeholders in the WHERE clause represent the identifiers for the blocked floor and blocked code statuses.\",\n        \"virtual_table\": \"SELECT nurse FROM on_call WHERE blockfloor  =  [PLACEHOLDER-TYPE:NUMBER] AND blockcode  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["We need to find the names of all physicians and their primary affiliated departments' names.", "The relevant tables are 'Physician', 'Department', and 'Affiliated_With'.", "We will join 'Affiliated_With' with 'Physician' to get the physician names and with 'Department' to get the department names.", "We need to filter the results to only include primary affiliations, which is indicated by the 'PrimaryAffiliation' column in the 'Affiliated_With' table.", "The final SQL query selects the physician names and their corresponding department names where the affiliation is primary."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name, Department.Name \nFROM Affiliated_With \nJOIN Physician ON Affiliated_With.Physician = Physician.EmployeeID \nJOIN Department ON Affiliated_With.Department = Department.DepartmentID \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3928", "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["Identify the tables needed: Physician and Patient.", "We need to count the number of patients each physician takes care of, which is indicated by the Patient's PCP (Primary Care Physician) being linked to the Physician's EmployeeID.", "Use a LEFT JOIN to connect the Physician table with the Patient table on the condition that Patient.PCP = Physician.EmployeeID.", "Count the number of patients for each physician using COUNT(Patient.SSN).", "Group the results by Physician.Name to get the count for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name, COUNT(Patient.SSN) AS NumberOfPatients\nFROM Physician\nLEFT JOIN Patient ON Physician.EmployeeID = Patient.PCP\nGROUP BY Physician.Name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["Identify the relevant tables: Physician and Patient.", "Determine the relationship: A physician can be a primary care physician (PCP) for multiple patients.", "Join the Physician table with the Patient table on the PCP field.", "Group the results by physician to count the number of patients each physician is responsible for.", "Use HAVING clause to filter those physicians who are in charge of more than one patient."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT p.Name\nFROM Physician p\nJOIN Patient pt ON p.EmployeeID = pt.PCP\nGROUP BY p.EmployeeID\nHAVING COUNT(pt.SSN) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3940", "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["Identify the relevant tables: 'Physician', 'Prescribes', and 'Medication'.", "We need to find the names of physicians who have prescribed a specific medication, 'Thesisin'.", "Join the 'Prescribes' table with the 'Physician' table on the physician's identifier (EmployeeID).", "Join the 'Prescribes' table with the 'Medication' table on the medication code.", "Filter the results where the medication name is 'Thesisin'.", "Select distinct physician names to avoid duplicates."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT DISTINCT Physician.Name \nFROM Prescribes \nJOIN Physician ON Prescribes.Physician = Physician.EmployeeID \nJOIN Medication ON Prescribes.Medication = Medication.Code \nWHERE Medication.Name = 'Thesisin';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3941", "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication.", "We need to find the names of physicians who prescribe a specific medication, which is 'Thesisin'.", "Join the Physician table with the Prescribes table on the EmployeeID and Physician columns respectively.", "Join the Prescribes table with the Medication table on the Medication code.", "Filter the results where the medication name is 'Thesisin'.", "Select the Name column from the Physician table to get the names of the physicians."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT Physician.Name \nFROM Physician \nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician \nJOIN Medication ON Prescribes.Medication = Medication.Code \nWHERE Medication.Name = 'Thesisin';", "hint": "\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["Identify the relevant tables: Medication and Prescribes.", "We need to count the number of medications prescribed for each brand, so we will join the Medication table with the Prescribes table on the medication code.", "Select the brand from the Medication table and count the number of prescriptions from the Prescribes table.", "Group the results by the brand to get the count for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT m.Brand, COUNT(p.Medication) AS NumberOfMedications\nFROM Medication m\nJOIN Prescribes p ON m.Code = p.Medication\nGROUP BY m.Brand;", "hint": "\n"}
{"sample_id": "train.3948", "db_id": "hospital_1", "question": "Find the patient who has the most recent undergoing treatment?", "rationale": ["Identify the relevant table: The 'Undergoes' table contains information about patients undergoing procedures, including the date of the procedures.", "Select the patient identifier from the 'Undergoes' table: We need to retrieve the 'Patient' column.", "Order the results by the date of the procedures: We will sort the results by 'DateUndergoes' in descending order to get the most recent treatment first.", "Limit the results to one: To find only the patient with the most recent undergoing treatment, we will limit the results to 1."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT u.Patient\nFROM Undergoes u\nORDER BY u.DateUndergoes DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3949", "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["Identify the relevant tables: Patient and Undergoes are the main tables needed to find patients undergoing treatments.", "Join the Patient table with the Undergoes table on the patient identifier (SSN) to link patients with their treatments.", "Order the results by the DateUndergoes in descending order to get the most recent treatment first.", "Limit the results to 1 to get only the most recent patient undergoing treatment."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT Patient.Name\nFROM Patient\nJOIN Undergoes ON Patient.SSN = Undergoes.Patient\nORDER BY Undergoes.DateUndergoes DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: 'Prescribes' for prescriptions and 'Physician' for physician details.", "We need to find the physician who prescribed the highest dose, so we will use the 'Dose' column from the 'Prescribes' table.", "To get the physician's name, we will join the 'Prescribes' table with the 'Physician' table on the physician identifier (EmployeeID).", "We will use a subquery to find the maximum dose prescribed by any physician.", "The final query will select the name of the physician whose dose matches the maximum dose found in the subquery."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT Physician.Name\nFROM Prescribes\nJOIN Physician ON Prescribes.Physician = Physician.EmployeeID\nWHERE Prescribes.Dose = (SELECT MAX(Dose) FROM Prescribes);", "hint": "\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["Identify the tables needed: Physician and Affiliated_With.", "We need to select the EmployeeID from the Physician table and the Department from the Affiliated_With table.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns respectively.", "Filter the results to include only those records where the PrimaryAffiliation is 'Yes' to get primary affiliations."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department FROM Physician JOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician WHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["Identify the table that contains procedure information, which is the Procedures table.", "Determine the relevant columns needed for the query: Name and Cost of the procedures.", "To find the most costly procedures, sort the results by the Cost column in descending order.", "Limit the results to the top three entries to get the three most costly procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "\n"}
{"sample_id": "train.3972", "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find physicians who are trained in specific procedures, so we will join the Physician table with the Trained_In table on the EmployeeID and Physician columns.", "Next, we will join the Procedures table to get the cost of each procedure, linking it through the Treatment column in Trained_In and the Code column in Procedures.", "We need to filter the results to only include procedures that cost more than 5000, so we will add a WHERE clause for Procedures.Cost > 5000.", "Finally, we select the distinct names of the physicians who meet this criterion."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT DISTINCT Physician.Name\nFROM Physician\nJOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician\nJOIN Procedures ON Trained_In.Treatment = Procedures.Code\nWHERE Procedures.Cost > 5000;", "hint": "\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find the physician associated with the most expensive procedure.", "Join the Physician table with the Trained_In table on the EmployeeID and Physician columns.", "Then join the result with the Procedures table on the Treatment and Code columns.", "To find the most expensive procedure, we can use a subquery to get the maximum cost from the Procedures table.", "Finally, select the name of the physician whose trained procedure matches the maximum cost."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT p.Name\nFROM Physician p\nJOIN Trained_In t ON p.EmployeeID = t.Physician\nJOIN Procedures pr ON t.Treatment = pr.Code\nWHERE pr.Cost = (SELECT MAX(Cost) FROM Procedures)", "hint": "\n"}
{"sample_id": "train.3980", "db_id": "hospital_1", "question": "Find all procedures which cost more than 1000 or which physician John Wen was trained in.", "rationale": ["Identify the relevant tables: Procedures and Trained_In, as well as Physician for the physician's name.", "We need to select the procedure names from the Procedures table.", "We will join the Procedures table with the Trained_In table on the procedure code to find out which physicians are trained in which procedures.", "We will also join the Trained_In table with the Physician table to filter by the physician's name, 'John Wen'.", "The WHERE clause will include two conditions: one for procedures costing more than 1000 and another for those associated with 'John Wen'.", "Use DISTINCT to ensure that we do not get duplicate procedure names in the result."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT DISTINCT Procedures.Name \nFROM Procedures \nLEFT JOIN Trained_In ON Procedures.Code = Trained_In.Treatment \nLEFT JOIN Physician ON Trained_In.Physician = Physician.EmployeeID \nWHERE Procedures.Cost > 1000 OR Physician.Name = 'John Wen';", "hint": "\n"}
{"sample_id": "train.3993", "db_id": "hospital_1", "question": "How many patients are not using Procrastin-X as medication?", "rationale": ["Identify the main goal: Count the number of patients not using 'Procrastin-X' as medication.", "To find patients not using a specific medication, we need to check the 'Prescribes' table where medications are linked to patients.", "First, we need to find the code for 'Procrastin-X' from the 'Medication' table.", "Next, we will create a subquery that selects all patients who have been prescribed 'Procrastin-X'.", "Finally, we will count all patients from the 'Patient' table whose SSN is not in the list of patients prescribed 'Procrastin-X'."], "gold_sql": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )", "source_tables": ["patient", "prescribes", "medication"], "pred_sql": "SELECT COUNT(*) AS PatientCount \nFROM Patient \nWHERE SSN NOT IN (\n    SELECT Patient \n    FROM Prescribes \n    WHERE Medication = (SELECT Code FROM Medication WHERE Name = 'Procrastin-X')\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4256", "db_id": "club_1", "question": "What are the first names of all the students?", "rationale": ["The question asks for the first names of all students, which corresponds to the 'Fname' column in the 'Student' table.", "To retrieve the first names, we need to select the 'Fname' column from the 'Student' table without any conditions or filters, as we want all students.", "The SQL query will be a simple SELECT statement that specifies the column to retrieve from the specified table."], "gold_sql": "SELECT DISTINCT fname FROM student", "source_tables": ["student"], "pred_sql": "SELECT Fname FROM Student;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  [PLACEHOLDER-TYPE:STRING] AND t3.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4271", "db_id": "club_1", "question": "Give me the first name and last name for all the female members of the club \"Bootup Baltimore\".", "rationale": ["Identify the tables needed: We need data from the Student, Member_of_club, and Club tables.", "Determine the columns to select: We need the first name (Fname) and last name (LName) of female members.", "Establish the relationships: We will join the Student table with Member_of_club on StuID, and then join Member_of_club with Club on ClubID.", "Filter for female students: We will add a condition to filter where Sex is 'Female'.", "Filter for the specific club: We will add a condition to filter where ClubName is 'Bootup Baltimore'.", "Construct the SQL query using the selected columns and the established joins and filters."], "gold_sql": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  'Bootup Baltimore' AND t3.sex  =  'F'", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Fname, LName FROM Student AS s JOIN Member_of_club AS m ON s.StuID = m.StuID JOIN Club AS c ON m.ClubID = c.ClubID WHERE s.Sex = 'Female' AND c.ClubName = 'Bootup Baltimore';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  [PLACEHOLDER-TYPE:STRING] AND t3.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4277", "db_id": "club_1", "question": "Find the club which has the largest number of members majoring in \"600\".", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "We need to count the number of members in each club who are majoring in '600'.", "Join the Club table with the Member_of_club table on ClubID to link clubs with their members.", "Join the resulting table with the Student table on StuID to access student details, specifically their Major.", "Filter the results to include only those students whose Major is '600'.", "Group the results by Club name to aggregate the member counts for each club.", "Order the results by the count of members in descending order to find the club with the most members majoring in '600'.", "Limit the results to 1 to get only the club with the largest number of members."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  '600' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Club.ClubName, COUNT(Member_of_club.StuID) AS MemberCount\nFROM Club\nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID\nJOIN Student ON Member_of_club.StuID = Student.StuID\nWHERE Student.Major = '600'\nGROUP BY Club.ClubName\nORDER BY MemberCount DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  [PLACEHOLDER-TYPE:STRING] AND t3.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4278", "db_id": "club_1", "question": "Find the name of the club that has the most female students.", "rationale": ["Identify the tables involved: We need to get club names and count female students, so we will use the Student, Club, and Member_of_club tables.", "Join the tables: We need to join the Club table with the Member_of_club table on ClubID, and then join the Member_of_club table with the Student table on StuID to access student details.", "Filter for female students: We will add a WHERE clause to filter students by sex, specifically looking for 'Female'.", "Group by club name: To count the number of female students in each club, we will group the results by ClubName.", "Count female students: We will use COUNT(s.StuID) to count the number of female students in each club.", "Order by count: We will order the results in descending order based on the count of female students to find the club with the most female members.", "Limit the results: Finally, we will limit the results to 1 to get only the club with the most female students."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT c.ClubName\nFROM Club c\nJOIN Member_of_club m ON c.ClubID = m.ClubID\nJOIN Student s ON m.StuID = s.StuID\nWHERE s.Sex = 'Female'\nGROUP BY c.ClubName\nORDER BY COUNT(s.StuID) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  [PLACEHOLDER-TYPE:STRING] AND t3.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4312", "db_id": "club_1", "question": "List the clubs that have at least a member with advisor \"1121\".", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "We need to find clubs that have members with a specific advisor, which means we will join the Club table with the Member_of_club table and then with the Student table.", "The join condition will be based on the ClubID in the Club and Member_of_club tables, and the StuID in the Member_of_club and Student tables.", "We need to filter the results where the Advisor column in the Student table matches '1121'.", "Finally, we select distinct club names to avoid duplicates in the result."], "gold_sql": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  1121", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT DISTINCT c.ClubName \nFROM Club AS c \nJOIN Member_of_club AS m ON c.ClubID = m.ClubID \nJOIN Student AS s ON m.StuID = s.StuID \nWHERE s.Advisor = '1121';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  [PLACEHOLDER-TYPE:STRING] AND t3.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: Grants and Organisations are needed to get the total grant amount and filter by organisation type.", "Join the Grants table with the Organisations table on the organisation_id to access the organisation type for each grant.", "Filter the results to include only those organisations that are described as 'research'. This requires a subquery to find the organisation_type associated with 'research' from the Organisation_Types table.", "Use the SUM function to calculate the total grant amount for the filtered organisations."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT SUM(grant_amount) AS total_grant_amount \nFROM Grants \nJOIN Organisations ON Grants.organisation_id = Organisations.organisation_id \nWHERE Organisations.organisation_type = (SELECT organisation_type FROM Organisation_Types WHERE organisation_type_description = 'research')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the role code for the leader role from the Staff_Roles table.", "Count the number of staff members associated with each project that has at least one leader role.", "Select the project with the maximum number of staff members by grouping by project_id and ordering by the count of staff members in descending order.", "Join this result with the Project_Staff table to get the start and end dates of staff members working on that project."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT ps.date_from, ps.date_to \nFROM Project_Staff ps \nJOIN ( \n    SELECT project_id \n    FROM Project_Staff \n    WHERE role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Leader') \n    GROUP BY project_id \n    ORDER BY COUNT(staff_id) DESC \n    LIMIT 1 \n) AS most_staff_project ON ps.project_id = most_staff_project.project_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4328", "db_id": "tracking_grants_for_research", "question": "Find the organisation ids and details of the organisations which are involved in", "rationale": ["The user wants to find the organisation ids and details of the organisations involved.", "We need to select the 'organisation_id' and 'organisation_details' from the 'Organisations' table.", "There are no specific filters or conditions mentioned in the user's query, so we will retrieve all records from the 'Organisations' table."], "gold_sql": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  6000", "source_tables": ["grants", "organisations"], "pred_sql": "SELECT organisation_id, organisation_details FROM Organisations", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of organisations from the 'Organisations' table that are associated with a specific type of organisation. It joins the 'Organisations' table with the 'Organisation_Types' table to filter organisations based on their type description. The placeholder in the WHERE clause represents the description of the organisation type, and the results are ordered by the organisation details.\",\n        \"virtual_table\": \"SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING] ORDER BY organisation_details\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields to associate research staff with their respective organisations.", "Group the results by organisation_id and organisation_type to count the number of research staff per organisation type.", "Order the results in descending order based on the count of research staff to find the organisation type with the most research staff.", "Limit the results to 1 to get only the top organisation type with the most research staff."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT T1.organisation_type, T1.organisation_id \nFROM Organisations AS T1 \nJOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id \nGROUP BY T1.organisation_id, T1.organisation_type \nORDER BY count(T2.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4331", "db_id": "tracking_grants_for_research", "question": "What is the type and id of the organization that has the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff are needed to find the organization type and ID associated with research staff.", "Join the Organisations table with the Research_Staff table on the organisation_id to link organizations with their respective research staff.", "Group the results by organisation_id and organisation_type to aggregate the count of research staff for each organization.", "Order the results by the count of research staff in descending order to find the organization with the most research staff.", "Limit the results to 1 to get only the top organization with the most research staff."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT T1.organisation_type, T1.organisation_id \nFROM Organisations AS T1 \nJOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id \nGROUP BY T1.organisation_id, T1.organisation_type \nORDER BY count(T2.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4333", "db_id": "tracking_grants_for_research", "question": "What is the type of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff are needed to find the organization type associated with research staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id to link organizations with their research staff.", "Group the results by organisation type to count the number of research staff in each type.", "Order the results in descending order based on the count of research staff to find the type with the most staff.", "Limit the results to 1 to get only the top organization type."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the relevant tables: Documents, Grants, and Organisations.", "We need to retrieve the 'sent_date' from the Documents table.", "Join the Documents table with the Grants table on 'grant_id' to access grant amounts.", "Join the Grants table with the Organisations table to filter by organisation type if needed.", "Apply a condition to filter grants with an amount greater than 5000."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT T1.sent_date FROM Documents AS T1 JOIN Grants AS T2 ON T1.grant_id = T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id = T3.organisation_id WHERE T2.grant_amount > 5000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.4335", "db_id": "tracking_grants_for_research", "question": "What are the send dates for all documents that have a grant amount of more than 5000 and are involved in research?", "rationale": ["Identify the relevant tables: Documents and Grants.", "We need to retrieve the 'sent_date' from the Documents table.", "We need to filter documents based on the grant amount, which is in the Grants table.", "Join the Documents table with the Grants table on 'grant_id'.", "Apply the condition to filter grants with an amount greater than 5000."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT T1.sent_date FROM Documents AS T1 JOIN Grants AS T2 ON T1.grant_id = T2.grant_id WHERE T2.grant_amount > 5000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4343", "db_id": "tracking_grants_for_research", "question": "When did researchers start and stop working?", "rationale": ["Identify the relevant table: Project_Staff contains the start and end dates of staff members' involvement in projects.", "Determine the necessary columns: We need the 'date_from' and 'date_to' columns to know when researchers started and stopped working.", "Filter by role: We need to filter the results to only include researchers, which can be done by joining with the Staff_Roles table to find the appropriate role code for researchers.", "Construct the SQL query: Combine the information to create a SQL query that selects the start and end dates for researchers."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to FROM Project_Staff WHERE role_code = (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%researcher%')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4349", "db_id": "tracking_grants_for_research", "question": "What are the details for the project whose research has been published?", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes are needed to find project details related to published research.", "Join the Projects table with Project_Outcomes to link projects with their outcomes.", "Join the resulting table with Research_Outcomes to filter for those outcomes that indicate research has been published.", "Use a WHERE clause to specify that we are looking for outcomes that have 'published' in their description.", "Select the project_id and project_details from the final joined result."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE '%Published%'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT P.project_id, P.project_details FROM Projects AS P JOIN Project_Outcomes AS PO ON P.project_id = PO.project_id JOIN Research_Outcomes AS RO ON PO.outcome_code = RO.outcome_code WHERE RO.outcome_description LIKE '%published%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of tasks associated with each project along with the project details from the 'Projects' table. The count is grouped by the unique project identifier, allowing users to see how many tasks are linked to each project.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the tables involved: Projects and Project_Outcomes.", "We need to join these tables on the project_id to relate projects to their outcomes.", "We will select the project details and project ID from the Projects table.", "To find the project with the most outcomes, we will group the results by project_id and count the outcomes for each project.", "We will order the results in descending order based on the count of outcomes.", "Finally, we will limit the results to only one project, which will be the one with the most outcomes."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT T1.project_details, T1.project_id FROM Projects AS T1 JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated outcomes in the 'Project_Outcomes' table. The placeholder in the WHERE clause indicates that we are filtering projects based on their unique identifiers, ensuring we only retrieve those without outcomes.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )\"\n    }\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id respectively to link organisations with their research staff.", "Group the results by organisation_id, organisation_type, and organisation_details to aggregate the count of research staff for each organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT O.organisation_id, O.organisation_type, O.organisation_details \nFROM Organisations AS O \nJOIN Research_Staff AS R ON O.organisation_id = R.employer_organisation_id \nGROUP BY O.organisation_id, O.organisation_type, O.organisation_details \nORDER BY COUNT(R.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4361", "db_id": "tracking_grants_for_research", "question": "What are the ids, types, and details of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff are needed to get the organization details and the count of research staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields to link organizations with their respective research staff.", "Group the results by organisation_id, organisation_type, and organisation_details to aggregate the count of research staff for each organization.", "Order the results by the count of research staff in descending order to get the organization with the most research staff at the top.", "Limit the results to 1 to get only the organization with the highest count of research staff."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT O.organisation_id, O.organisation_type, O.organisation_details \nFROM Organisations AS O \nJOIN Research_Staff AS R ON O.organisation_id = R.employer_organisation_id \nGROUP BY O.organisation_id, O.organisation_type, O.organisation_details \nORDER BY COUNT(R.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff for staff involvement in projects and Staff_Roles for role descriptions.", "Join the Project_Staff table with the Staff_Roles table on the role_code to get the role descriptions.", "Group the results by role_code to count how many projects each role is involved in.", "Order the results by the count of projects in descending order to find the role involved in the most projects.", "Limit the results to 1 to get only the top role with the most projects."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT ps.staff_id, sr.role_description\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nGROUP BY ps.role_code\nORDER BY COUNT(ps.project_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4367", "db_id": "tracking_grants_for_research", "question": "For grants that have descriptions of Regular and Initial Applications, what are their start dates?", "rationale": ["Identify the relevant tables: Grants, Documents, and Document_Types.", "We need to retrieve the start dates of grants, so we will select 'grant_start_date' from the Grants table.", "To filter the grants based on document descriptions, we will join the Documents table with the Grants table using 'grant_id'.", "Next, we will join the Document_Types table with the Documents table using 'document_type_code' to access the document descriptions.", "We will filter the results where the document descriptions are either 'Regular Applications' or 'Initial Applications' using a WHERE clause with an IN condition."], "gold_sql": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Regular' INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Initial Application'", "source_tables": ["grants", "document_types", "documents"], "pred_sql": "SELECT G.grant_start_date FROM Grants AS G JOIN Documents AS D ON G.grant_id = D.grant_id JOIN Document_Types AS DT ON D.document_type_code = DT.document_type_code WHERE DT.document_description IN ('Regular Applications', 'Initial Applications')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["Identify the tables involved: We need to count documents per grant, so we will use the 'Documents' and 'Grants' tables.", "Join the 'Documents' table with the 'Grants' table on 'grant_id' to associate each document with its corresponding grant.", "Group the results by 'grant_id' to count the number of documents for each grant.", "Use COUNT() to get the number of documents for each grant and alias it as 'document_count'.", "To find which grant has the most documents, we can use a subquery that counts documents grouped by 'grant_id' and finds the maximum count.", "The final query will select the grant id, the count of documents, and the document id for the grant with the maximum document count."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT D.grant_id, COUNT(D.document_id) AS document_count, D.document_id \nFROM Documents AS D \nJOIN Grants AS G ON D.grant_id = G.grant_id \nGROUP BY D.grant_id \nHAVING COUNT(D.document_id) = (SELECT MAX(doc_count) \n                               FROM (SELECT COUNT(document_id) AS doc_count \n                                     FROM Documents \n                                     GROUP BY grant_id))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4372", "db_id": "tracking_grants_for_research", "question": "What are all the details of the organisations described as 'Sponsor'? Sort the result in an ascending order.", "rationale": ["Identify the relevant tables: Organisations and Organisation_Types.", "Determine the relationship between the tables: Organisations has a foreign key to Organisation_Types via organisation_type.", "Filter the organisations based on the description 'Sponsor' from Organisation_Types.", "Select all relevant details from the Organisations table.", "Sort the results in ascending order based on organisation_details."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "pred_sql": "SELECT organisation_id, organisation_type, organisation_details FROM Organisations AS T1 JOIN Organisation_Types AS T2 ON T1.organisation_type = T2.organisation_type WHERE T2.organisation_type_description = 'Sponsor' ORDER BY organisation_details ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the details of organisations from the 'Organisations' table that are associated with a specific type of organisation. It joins the 'Organisations' table with the 'Organisation_Types' table to filter organisations based on their type description. The placeholder in the WHERE clause represents the description of the organisation type, and the results are ordered by the organisation details.\",\n        \"virtual_table\": \"SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING] ORDER BY organisation_details\"\n    }\n}\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant table: The question asks for project details, which are found in the 'Projects' table.", "Determine the condition: We need to filter the projects based on the project detail being 'sint'.", "Construct the SQL query: Use a SELECT statement to retrieve 'project_details' from the 'Projects' table where 'project_details' matches 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT project_details FROM Projects WHERE project_details = 'sint'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of tasks associated with each project along with the project details from the 'Projects' table. The count is grouped by the unique project identifier, allowing users to see how many tasks are linked to each project.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant project by filtering the Projects table for the project detail 'sint'.", "Retrieve the organisation_id associated with the identified project.", "Use the organisation_id to find the corresponding grant_id from the Grants table.", "With the grant_id, find the document_type_code from the Documents table.", "Finally, use the document_type_code to get the document_description from the Document_Types table."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT document_description FROM Document_Types WHERE document_type_code IN (SELECT document_type_code FROM Documents WHERE grant_id IN (SELECT grant_id FROM Grants WHERE organisation_id IN (SELECT organisation_id FROM Projects WHERE project_details = 'sint')));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of tasks associated with each project along with the project details from the 'Projects' table. The count is grouped by the unique project identifier, allowing users to see how many tasks are linked to each project.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id\"\n    }\n}\n"}
{"sample_id": "train.4383", "db_id": "tracking_grants_for_research", "question": "What is the id of the organization with the maximum number of outcomes and how many outcomes are there?", "rationale": ["Identify the tables involved: Organisations, Projects, and Project_Outcomes.", "Join the Organisations table with the Projects table on organisation_id to link organisations to their projects.", "Join the resulting table with the Project_Outcomes table on project_id to link projects to their outcomes.", "Group the results by organisation_id to count the number of outcomes for each organisation.", "Order the results by the count of outcomes in descending order to find the organisation with the maximum outcomes.", "Limit the results to 1 to get only the organisation with the maximum number of outcomes."], "gold_sql": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT organisation_id, COUNT(outcome_code) AS outcome_count \nFROM Organisations \nJOIN Projects ON Organisations.organisation_id = Projects.organisation_id \nJOIN Project_Outcomes ON Projects.project_id = Project_Outcomes.project_id \nGROUP BY Organisations.organisation_id \nORDER BY outcome_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.4384", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects launched by the organisation", "rationale": ["The user wants to list project details of projects launched by an organisation.", "To achieve this, we need to select the 'project_details' from the 'Projects' table.", "We need to filter the projects based on the organisation that launched them.", "To find the organisations with projects, we can use a subquery that groups the projects by 'organisation_id' and orders them by the count of projects in descending order.", "Since the user did not specify a limit on the number of organisations, we will not include a LIMIT clause in our final query."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC )", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of tasks associated with each project along with the project details from the 'Projects' table. The count is grouped by the unique project identifier, allowing users to see how many tasks are linked to each project.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["The user wants to know the staff roles of the staff members associated with projects.", "To find the staff roles, we need to select the 'role_code' from the 'Project_Staff' table.", "The hint provides a virtual table that describes how to filter staff members based on their involvement dates, but it does not specify any dates in the user query.", "Since no specific date range is provided in the user query, we will retrieve all role codes from the 'Project_Staff' table without filtering by date."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code FROM Project_Staff", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4394", "db_id": "tracking_grants_for_research", "question": "What are the descriptions of all the project outcomes?", "rationale": ["The user wants to retrieve descriptions of all project outcomes.", "The relevant table for project outcomes is 'Project_Outcomes', which contains the columns 'outcome_code' and 'outcome_details'.", "To get the descriptions, we need to select 'outcome_code' and 'outcome_details' from the 'Project_Outcomes' table.", "The SQL query will be a simple SELECT statement that retrieves these two columns from the 'Project_Outcomes' table."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code", "source_tables": ["project_outcomes", "research_outcomes"], "pred_sql": "SELECT outcome_code, outcome_details FROM Project_Outcomes", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated outcomes in the 'Project_Outcomes' table. The placeholder in the WHERE clause indicates that we are filtering projects based on their unique identifiers, ensuring we only retrieve those without outcomes.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["To find the most common role for the staff, we need to count the occurrences of each role code in the Project_Staff table.", "We will use the COUNT function to count how many times each role_code appears.", "We will group the results by role_code to get the count for each role.", "To determine which role is the most common, we will order the results in descending order based on the count.", "Finally, we will limit the results to 1 to get only the most common role."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count \nFROM Project_Staff \nGROUP BY role_code \nORDER BY role_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of staff members associated with projects, filtered by a specific role code or by their involvement start date. The placeholders in the WHERE clause represent the role code and the date from which the staff member's involvement is considered.\",\n        \"virtual_table\": \"SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4410", "db_id": "network_2", "question": "Who is the oldest person whose job is student?", "rationale": ["Identify the target job title, which is 'student'.", "Use a subquery to find the maximum age of individuals with the job title 'student'.", "Construct the main query to select the name of the person whose job is 'student' and whose age matches the maximum age found in the subquery."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "pred_sql": "SELECT name FROM Person WHERE job = 'student' AND age = (SELECT max(age) FROM Person WHERE job = 'student')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE age  =  (SELECT max(age) FROM person)\"\n    }\n}\n"}
{"sample_id": "train.4439", "db_id": "network_2", "question": "What is the name and age of every male? Order the results by age.", "rationale": ["Identify the relevant table: The 'Person' table contains the necessary information about individuals, including their name, age, and gender.", "Filter by gender: We need to select only those individuals who are male, which requires a WHERE clause to filter the results based on the 'gender' column.", "Select the required columns: We need to retrieve both the 'name' and 'age' of the individuals, so we specify these columns in the SELECT statement.", "Order the results: The results should be ordered by age, which is done using the ORDER BY clause."], "gold_sql": "SELECT name FROM Person WHERE gender  =  'male' ORDER BY age", "source_tables": ["person"], "pred_sql": "SELECT name, age FROM Person WHERE gender = 'male' ORDER BY age", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE age  =  (SELECT max(age) FROM person)\"\n    }\n}\n"}
{"sample_id": "train.4441", "db_id": "network_2", "question": "What are the names and ages of every person who is a friend of both Dan and Alice?", "rationale": ["Identify the tables involved: We need data from the Person table for names and ages, and the PersonFriend table to find friends of Dan and Alice.", "We need to find friends of both Dan and Alice. This requires joining the PersonFriend table twice: once for Dan and once for Alice.", "Use INNER JOIN to connect the Person table with the PersonFriend table based on the friend's name.", "Filter the results to include only those friends who are listed as friends of both Dan and Alice.", "Select the name and age of these friends from the Person table."], "gold_sql": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, P.age FROM Person P JOIN PersonFriend PF1 ON P.name = PF1.friend JOIN PersonFriend PF2 ON P.name = PF2.friend WHERE PF1.name = 'Dan' AND PF2.name = 'Alice';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4444", "db_id": "network_2", "question": "Find the name of the person who has friends with age above 40 and under age 30?", "rationale": ["Identify the tables involved: We need to use both the 'Person' and 'PersonFriend' tables to find the names of individuals who have friends with specific age criteria.", "Determine the relationship: The 'PersonFriend' table links a person to their friends, so we will join 'Person' and 'PersonFriend' on the name of the friend.", "Set the conditions for age: We need to filter for friends who are either above 40 or under 30 years old. This means we will apply a WHERE clause to check the age of friends in the 'Person' table.", "Select distinct names: Since we are interested in the names of people who have friends meeting the age criteria, we will select distinct names from the result set to avoid duplicates."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT p.name \nFROM Person p \nJOIN PersonFriend pf ON p.name = pf.friend \nWHERE p.age > 40 OR p.age < 30;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE age  =  (SELECT max(age) FROM person)\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4445", "db_id": "network_2", "question": "What are the names of every person who has a friend over 40 and under 30?", "rationale": ["Identify the main table to query from, which is the 'Person' table for the names of individuals.", "We need to find friends of these individuals, so we will join the 'PersonFriend' table on the person's name.", "Next, we need to join again with the 'Person' table to access the age of the friends.", "The condition requires us to filter friends who are either over 40 or under 30 years old.", "We use DISTINCT to ensure that we only get unique names of individuals who meet the criteria."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT p1.name \nFROM Person p1 \nJOIN PersonFriend pf1 ON p1.name = pf1.name \nJOIN Person p2 ON pf1.friend = p2.name \nWHERE (p2.age > 40 OR p2.age < 30);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4449", "db_id": "network_2", "question": "What are the names of the people who have no friends who are students?", "rationale": ["Identify the main requirement: We need the names of people who have no friends that are students.", "To find friends who are students, we need to look at the 'Person' table and filter by job = 'student'.", "We will create a subquery to select names of friends who are students.", "Next, we need to find names of people in the 'Person' table who are not in the list of friends who are students.", "This can be achieved using a NOT IN clause with the subquery that selects names of friends who are students."], "gold_sql": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  'student'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT name FROM Person WHERE name NOT IN (SELECT name FROM PersonFriend WHERE friend IN (SELECT name FROM Person WHERE job = 'student'));", "hint": "\n"}
{"sample_id": "train.4454", "db_id": "network_2", "question": "Find the name of persons who are friends with Bob.", "rationale": ["Identify the table that contains friendship information, which is the 'PersonFriend' table.", "We need to find friends of a specific person, in this case, 'Bob'.", "The query should select the 'friend' column from the 'PersonFriend' table where the 'name' is 'Bob'.", "Additionally, we want to filter the results to only include the most recent friendship established by using a subquery that selects the maximum 'year' for Bob from the same table.", "Combine these elements into a single SQL query."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Bob' AND year = (SELECT max(year) FROM PersonFriend WHERE name = 'Bob')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    }\n}\n"}
{"sample_id": "train.4455", "db_id": "network_2", "question": "What are the names of all of Bob's friends?", "rationale": ["Identify the table that contains the friends of a person, which is the PersonFriend table.", "We need to filter the friends specifically for Bob, so we will use a WHERE clause to specify that the name is 'Bob'.", "The hint suggests using a virtual table that lists friends filtered by the most recent year of friendship established, but since we only need the names of all of Bob's friends, we can simplify the query to just select the friends without filtering by year."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Bob'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4456", "db_id": "network_2", "question": "Find the names of females who are friends with Zach", "rationale": ["Identify the gender of the individuals we are interested in, which is 'female'.", "We need to find the names of females, so we will use the 'Person' table to filter by gender.", "Next, we need to find the friends of Zach. We will use the 'PersonFriend' table to get the list of friends for Zach.", "We will use a subquery to select friends from the 'PersonFriend' table where the name is 'Zach'.", "Finally, we will combine these two queries to get the names of females who are also friends with Zach."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Zach' AND T1.gender  =  'female'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT name FROM Person WHERE gender = 'female' AND name IN (SELECT friend FROM PersonFriend WHERE name = 'Zach')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4465", "db_id": "network_2", "question": "What are the different names of friends who are younger than the average age for a friend?", "rationale": ["Identify the requirement to find friends who are younger than the average age.", "Calculate the average age of all individuals in the Person table using AVG(age).", "Filter the friends from the PersonFriend table based on the condition that their age is less than the calculated average age.", "Use a subquery to select friends from the Person table where their age is less than the average age.", "Ensure to select distinct names to avoid duplicates in the final result."], "gold_sql": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT friend FROM PersonFriend WHERE friend IN (SELECT name FROM Person WHERE age < (SELECT AVG(age) FROM Person))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4466", "db_id": "network_2", "question": "Who has friends that are older than the average age? Print their friends and their ages as well", "rationale": ["First, we need to find the average age of all individuals in the Person table. This can be done using the AVG() function.", "Next, we need to identify friends of individuals from the PersonFriend table. We will join the PersonFriend table with the Person table to get the ages of these friends.", "We will filter the results to include only those friends whose age is greater than the average age calculated in the first step.", "Finally, we will select the friend's name and their age to display the required information."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT pf.friend, p.age \nFROM PersonFriend pf \nJOIN Person p ON pf.friend = p.name \nWHERE p.age > (SELECT AVG(age) FROM Person)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4467", "db_id": "network_2", "question": "Whare the names, friends, and ages of all people who are older than the average age of a person?", "rationale": ["Identify the required fields: names, friends, and ages of people.", "To get the names and ages, we need to select from the 'Person' table.", "To get the friends, we need to join the 'PersonFriend' table on the name.", "We need to filter the results to include only those people whose age is greater than the average age of all persons.", "The average age can be calculated using a subquery: (SELECT AVG(age) FROM Person).", "Combine all these elements into a single SQL query."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name, pf.friend, p.age \nFROM Person p \nJOIN PersonFriend pf ON p.name = pf.name \nWHERE p.age > (SELECT AVG(age) FROM Person)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE age  =  (SELECT max(age) FROM person)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4473", "db_id": "network_2", "question": "What are the names of all people who are friends with Alice for the shortest amount of time?", "rationale": ["Identify the person of interest, which is 'Alice'.", "We need to find the friends of Alice, so we will query the PersonFriend table where the name is 'Alice'.", "To find the friends with whom Alice has been friends for the shortest amount of time, we need to find the minimum year of friendship established.", "We will use a subquery to get the minimum year from the PersonFriend table for Alice.", "Finally, we will select the friends from the PersonFriend table where the year matches the minimum year found in the subquery."], "gold_sql": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Alice' AND year = (SELECT MIN(year) FROM PersonFriend WHERE name = 'Alice')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    }\n}\n"}
{"sample_id": "train.4475", "db_id": "network_2", "question": "What are the names, ages, and jobs of all people who are friends with Alice for the longest amount of time?", "rationale": ["Identify the relevant tables: We need to gather information from the 'Person' table for names, ages, and jobs, and from the 'PersonFriend' table to find friends of Alice.", "We need to join the 'Person' table with the 'PersonFriend' table on the condition that the name in 'Person' matches the friend in 'PersonFriend'.", "We filter the results to only include friends of Alice by using a WHERE clause on the 'name' column of the 'PersonFriend' table.", "To find the friends who have been friends with Alice for the longest time, we can order the results by the 'year' column in ascending order.", "Finally, we select the name, age, and job of the friend who has been friends with Alice for the longest time by limiting the results to 1."], "gold_sql": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, P.age, P.job \nFROM Person P \nJOIN PersonFriend PF ON P.name = PF.friend \nWHERE PF.name = 'Alice' \nORDER BY PF.year ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    }\n}\n"}
{"sample_id": "train.4478", "db_id": "network_2", "question": "Which person whose friends have the oldest average age?", "rationale": ["To find the person whose friends have the oldest average age, we need to calculate the average age of friends for each person.", "We will join the 'PersonFriend' table with the 'Person' table to get the ages of friends.", "We will group the results by the person's name to calculate the average age of their friends using AVG function.", "Next, we will order the results by the average age in descending order to find the oldest average age.", "Finally, we will limit the results to 1 to get the person with the oldest average age of friends."], "gold_sql": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT 1", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name FROM Person p JOIN (SELECT pf.name, AVG(CAST(p.age AS INTEGER)) AS avg_age FROM PersonFriend pf JOIN Person p ON pf.friend = p.name GROUP BY pf.name) AS avg_ages ON p.name = avg_ages.name ORDER BY avg_age DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE age  =  (SELECT max(age) FROM person)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4480", "db_id": "network_2", "question": "What is the total number of people who has no friend living in the city of Austin.", "rationale": ["We need to count the total number of people who have no friends living in Austin.", "First, we filter the 'Person' table to only include those who live in Austin.", "Next, we need to check if these people have friends. We can do this by using a subquery that selects friends from the 'PersonFriend' table where the person's name matches.", "The subquery will return a list of friends for each person, and we want to exclude those names from our count.", "Finally, we use the COUNT function to get the total number of people who meet these criteria."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT COUNT(*) FROM Person WHERE city = 'Austin' AND name NOT IN (SELECT friend FROM PersonFriend WHERE name = Person.name)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4503", "db_id": "document_management", "question": "Find the types of documents with more than 4 documents.", "rationale": ["We need to find the types of documents that have more than 4 documents associated with them.", "To achieve this, we will join the 'Documents' table with the 'Document_Structures' table using the 'document_structure_code'.", "We will group the results by 'document_structure_code' to count the number of documents for each structure.", "Using the HAVING clause, we can filter the groups to only include those with a count greater than 4.", "Finally, we will select the 'document_structure_description' from the 'Document_Structures' table to get the desired output."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code = t2.document_structure_code GROUP BY t1.document_structure_code HAVING COUNT(t1.document_code) > 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average access count of documents grouped by their document structure code. The placeholder in the LIMIT clause allows the user to specify the maximum number of groups to return, based on the ascending order of their count.\",\n        \"virtual_table\": \"SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of document structure descriptions from the 'Document_Structures' table, which are associated with documents in the 'Documents' table. The results are grouped by the document structure code and ordered by the number of documents associated with each structure, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code  =  t2.document_structure_code GROUP BY t1.document_structure_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4504", "db_id": "document_management", "question": "What are the codes of types of documents of which there are for or more?", "rationale": ["Identify the table that contains the document types, which is the 'Documents' table.", "We need to group the results by 'document_type_code' to count how many documents exist for each type.", "Use the HAVING clause to filter the groups to only include those with a count of 4 or more."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code FROM Documents GROUP BY document_type_code HAVING COUNT(*) >= 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of document structure descriptions from the 'Document_Structures' table, which are associated with documents in the 'Documents' table. The results are grouped by the document structure code and ordered by the number of documents associated with each structure, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code  =  t2.document_structure_code GROUP BY t1.document_structure_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4505", "db_id": "document_management", "question": "Find the total access count of all documents in the most popular document type.", "rationale": ["Identify the requirement to find the total access count of all documents in the most popular document type.", "To determine the most popular document type, we need to group the documents by their document type code and sum their access counts.", "We will order these groups by the total access count in descending order to find the most popular one.", "Using a subquery, we can select the document type code that has the highest total access count.", "Finally, we will sum the access counts of all documents that match this most popular document type code."], "gold_sql": "SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT SUM(access_count) FROM documents WHERE document_type_code = (SELECT document_type_code FROM documents GROUP BY document_type_code ORDER BY SUM(access_count) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average access count of documents grouped by their document structure code. The placeholder in the LIMIT clause allows the user to specify the maximum number of groups to return, based on the ascending order of their count.\",\n        \"virtual_table\": \"SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4525", "db_id": "document_management", "question": "Find names of the document without any images.", "rationale": ["Identify the main table to query: The 'Documents' table contains the names of the documents.", "Determine the condition for documents without images: We need to find documents that do not have any associated images, which can be checked using the 'Document_Sections_Images' table.", "Use a subquery to find documents with images: The subquery will select all document codes from the 'Document_Sections_Images' table, which indicates that those documents have images.", "Use the NOT IN clause: The main query will select document names from the 'Documents' table where the document code is not in the list of document codes returned by the subquery."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "pred_sql": "SELECT document_name FROM Documents WHERE document_code NOT IN (SELECT DISTINCT document_code FROM Document_Sections_Images)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of document structure descriptions from the 'Document_Structures' table, which are associated with documents in the 'Documents' table. The results are grouped by the document structure code and ordered by the number of documents associated with each structure, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code  =  t2.document_structure_code GROUP BY t1.document_structure_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4532", "db_id": "document_management", "question": "Count the number of users that are logged in.", "rationale": ["Identify the table that contains user information, which is the 'Users' table.", "To count the number of users, we will use the COUNT() function.", "Since the question asks for the number of users that are logged in, we assume all users in the 'Users' table are considered logged in unless specified otherwise.", "Construct the SQL query to select the count of all users from the 'Users' table."], "gold_sql": "SELECT count(*) FROM users WHERE user_login  =  1", "source_tables": ["users"], "pred_sql": "SELECT COUNT(*) AS logged_in_users FROM Users;", "hint": "\n"}
{"sample_id": "train.4733", "db_id": "department_store", "question": "Return the distinct name of customers whose order status is Pending, in the order of customer id.", "rationale": ["Identify the relevant tables: Customers and Customer_Orders.", "We need to find customers with a specific order status, which is 'Pending'.", "Use a subquery to get distinct customer_ids from Customer_Orders where order_status_code is 'Pending'.", "Join this result with the Customers table to get the customer names.", "Select distinct customer names to avoid duplicates.", "Order the results by customer_id as specified."], "gold_sql": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending' ORDER BY T2.customer_id", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT customer_name FROM Customers WHERE customer_id IN (SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_status_code = 'Pending') ORDER BY customer_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The date is determined by finding the earliest order date associated with a particular order status, represented by a placeholder.\",\n        \"virtual_table\": \"SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4736", "db_id": "department_store", "question": "What are the names and addressed of customers who have both New and Pending orders?", "rationale": ["Identify the relevant tables: Customers, Customer_Orders, and Customer_Addresses.", "We need to select customer names and their addresses, so we will join Customers with Customer_Orders and Customer_Addresses.", "The condition requires customers to have both 'New' and 'Pending' orders, which means we need to filter the orders based on their status codes.", "Using a GROUP BY clause on customer_id allows us to aggregate the results for each customer.", "The HAVING clause checks that the count of distinct order statuses for each customer is 2, ensuring they have both statuses."], "gold_sql": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'New' INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending'", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT c.customer_name, ca.address_id \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nWHERE co.order_status_code IN ('New', 'Pending') \nGROUP BY c.customer_id \nHAVING COUNT(DISTINCT co.order_status_code) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The date is determined by finding the earliest order date associated with a particular order status, represented by a placeholder.\",\n        \"virtual_table\": \"SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4749", "db_id": "department_store", "question": "Find the id and name of the staff who has been assigned for the shortest period.", "rationale": ["Identify the relevant tables: We need to look at the Staff and Staff_Department_Assignments tables to find the staff members and their assignment periods.", "Determine the assignment period: The assignment period can be calculated by subtracting the date_assigned_from from date_assigned_to.", "Find the shortest assignment period: We can order the results by the calculated assignment period and limit the results to get the staff member with the shortest period.", "Select the required fields: We need to select the staff_id and staff_name from the Staff table for the staff member with the shortest assignment period."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Staff_Department_Assignments ORDER BY date_assigned_to - date_assigned_from LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\",\n        \"virtual_table\": \"SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
