{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["To find out which course has the most registered students, we need to count the number of students registered for each course.", "We will use the 'Student_Course_Registrations' table, which contains the 'student_id' and 'course_id'.", "We will group the results by 'course_id' to get the count of students for each course.", "We will order the results in descending order based on the count of students to get the course with the highest number of registrations at the top.", "Finally, we will limit the results to 1 to get only the course with the most registered students."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT course_id, COUNT(student_id) AS number_of_students \nFROM Student_Course_Registrations \nGROUP BY course_id \nORDER BY number_of_students DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["The question asks for the IDs of students who attended some courses.", "To find this information, we need to look at the 'Student_Course_Attendance' table, which records attendance of students for various courses.", "We will select the 'student_id' from this table.", "Using DISTINCT ensures that we only get unique student IDs, as a student may have attended multiple courses."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["We need to find the IDs of all students who have attended at least one course.", "The relevant table for this information is 'Student_Course_Attendance', which records attendance of students for courses.", "To get unique student IDs, we will use the DISTINCT keyword to avoid duplicates in our results.", "The final SQL query will select the distinct student_id from the Student_Course_Attendance table."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["We need to find the candidate who most recently accessed a course, which implies we need to look at the attendance records.", "The relevant table for attendance is 'Student_Course_Attendance', which contains the 'student_id' and 'date_of_attendance'.", "Candidates are linked to people through the 'candidate_id', which corresponds to 'student_id' in the attendance table.", "To get the most recent attendance, we will order the results by 'date_of_attendance' in descending order.", "Finally, we limit the results to 1 to get only the most recent record."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT c.candidate_id \nFROM Candidates c \nJOIN Student_Course_Attendance a ON c.candidate_id = a.student_id \nORDER BY a.date_of_attendance DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.77", "db_id": "student_assessment", "question": "What is detail of the student who registered the most number of courses?", "rationale": ["Identify the relevant tables: Students and Student_Course_Registrations are needed to get student details and their course registrations.", "Join the Students table with the Student_Course_Registrations table on the student_id to link students with their registered courses.", "Group the results by student_id to aggregate the number of courses each student has registered for.", "Order the results in descending order based on the count of course registrations to find the student with the most registrations.", "Limit the results to 1 to get only the top student who registered for the most courses."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT S.student_details \nFROM Students AS S \nJOIN Student_Course_Registrations AS R ON S.student_id = R.student_id \nGROUP BY S.student_id \nORDER BY COUNT(R.course_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["Identify the tables involved: We need to get course names and the count of registered students, which involves the 'Courses' and 'Student_Course_Registrations' tables.", "Join the tables: We will join 'Student_Course_Registrations' with 'Courses' on the course_id to get the course names along with the registrations.", "Group by course_id and course_name: To count the number of students registered for each course, we will group the results by course_id and course_name.", "Count the number of students: Use COUNT() function to count the number of student registrations for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT SC.course_id, C.course_name, COUNT(SCR.student_id) AS student_count \nFROM Student_Course_Registrations AS SCR \nJOIN Courses AS C ON SCR.course_id = C.course_id \nGROUP BY SC.course_id, C.course_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.90", "db_id": "student_assessment", "question": "What are the ids of the students who registered for course 301 most recently?", "rationale": ["Identify the relevant table: The 'Student_Course_Registrations' table contains information about student registrations for courses.", "Filter by course_id: We need to focus on registrations for course 301, so we will add a WHERE clause to filter by course_id.", "Order by registration date: To find the most recent registration, we will order the results by the 'registration_date' in descending order.", "Limit the results: Since we only want the most recent registration, we will limit the results to 1."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["We need to find distinct cities of addresses associated with students.", "To do this, we will need to join the Addresses table with the People_Addresses table to link addresses to people.", "Next, we will join the resulting table with the Students table to filter for only those people who are students.", "Finally, we will select the distinct cities from the Addresses table."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "pred_sql": "SELECT DISTINCT a.city\nFROM Addresses a\nJOIN People_Addresses pa ON a.address_id = pa.address_id\nJOIN Students s ON pa.person_id = s.student_id;", "hint": "\n"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["We need to find details of students who registered for courses but did not attend any.", "To achieve this, we will use a LEFT JOIN between the Students table and the Student_Course_Registrations table.", "The LEFT JOIN will allow us to include all students from the Students table and match them with their registrations in the Student_Course_Registrations table.", "We will filter the results using a WHERE clause to check for students who have no corresponding entries in the Student_Course_Registrations table (i.e., R.student_id IS NULL).", "Finally, we will select the student_id and student_details from the Students table."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "pred_sql": "SELECT S.student_id, S.student_details \nFROM Students AS S \nLEFT JOIN Student_Course_Registrations AS R ON S.student_id = R.student_id \nWHERE R.student_id IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Determine the specific course of interest, which is 'Statistics'.", "Filter the registrations to only include those for the 'Statistics' course.", "Order the results by the 'registration_date' to get the order of registration."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Determine the specific course of interest, which is 'Statistics'.", "Use a subquery to find the course_id associated with the course name 'Statistics'.", "Select the student_id from 'Student_Course_Registrations' where the course_id matches the one found in the subquery.", "Order the results by the registration_date to get the ids of students in the order they registered."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.123", "db_id": "bike_1", "question": "For each zip code, return the average mean temperature of August there.", "rationale": ["We need to calculate the average mean temperature for each zip code in August.", "To filter the records for August, we can use the strftime function to extract the month from the date column in the weather table.", "We will select the zip_code and the average of mean_temperature_f from the weather table.", "We will group the results by zip_code to get the average temperature for each zip code."], "gold_sql": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE '8/%' GROUP BY zip_code", "source_tables": ["weather"], "pred_sql": "SELECT zip_code, AVG(mean_temperature_f) AS average_mean_temperature\nFROM weather\nWHERE strftime('%m', date) = '08'\nGROUP BY zip_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.135", "db_id": "bike_1", "question": "Which bike traveled the most often in zip code 94002?", "rationale": ["Identify the relevant table for trips, which is the 'trip' table.", "Filter the trips based on the specified zip code (94002).", "Group the results by 'bike_id' to count how many times each bike was used.", "Order the results in descending order based on the count of trips to find the most frequently used bike.", "Limit the results to 1 to get only the bike that traveled the most often."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id, COUNT(*) as trip_count \nFROM trip \nWHERE zip_code = '94002' \nGROUP BY bike_id \nORDER BY trip_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.136", "db_id": "bike_1", "question": "What is the id of the bike that traveled the most in 94002?", "rationale": ["Identify the relevant table for trips, which is the 'trip' table.", "Filter the trips based on the zip code '94002'.", "Order the results by the duration of the trips in descending order to find the longest trip.", "Limit the results to 1 to get only the bike that traveled the most."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id FROM trip WHERE zip_code = '94002' ORDER BY duration DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.143", "db_id": "bike_1", "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?", "rationale": ["We need to find the names and ids of stations that had more than 14 bikes available on average or were installed in December.", "To find the average number of bikes available, we can use the 'status' table and group by 'station_id', calculating the average of 'bikes_available'.", "We will filter these results to only include those stations where the average is greater than 14.", "Next, we also need to check the installation date from the 'station' table to see if it falls in December. We can use the strftime function to extract the month from 'installation_date'.", "Finally, we combine both conditions using an OR clause to get the desired results."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT id, name FROM station WHERE id IN (SELECT station_id FROM status GROUP BY station_id HAVING AVG(bikes_available) > 14) OR strftime('%m', installation_date) = '12';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.144", "db_id": "bike_1", "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "rationale": ["We need to find the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December.", "To achieve this, we will join the 'station' table with the 'status' table on the station id.", "We will use the GROUP BY clause to group the results by station id and name, allowing us to calculate the average number of bikes available for each station.", "The HAVING clause will be used to filter the results based on two conditions: the average number of bikes available must be greater than 14, or the installation date must indicate that the station was installed in December.", "The installation date can be checked using a LIKE clause to match any date that contains '-12-' (indicating December).", "Finally, we will select the distinct ids and names of the stations that meet either of these conditions."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT DISTINCT T1.id, T1.name \nFROM station AS T1 \nJOIN status AS T2 ON T1.id = T2.station_id \nGROUP BY T1.id, T1.name \nHAVING AVG(T2.bikes_available) > 14 \nOR T1.installation_date LIKE '%-12-%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.145", "db_id": "bike_1", "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?", "rationale": ["Identify the relevant table: The 'weather' table contains the cloud cover data and zip codes.", "Filter the data: We need to filter the records for the specific zip code 94107.", "Group the results: We will group the results by cloud cover to count occurrences of each cloud cover rate.", "Order the results: We will order the results by the count of cloud cover rates in descending order to find the most common rates.", "Limit the results: We will limit the output to the top 3 most common cloud cover rates."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "pred_sql": "SELECT cloud_cover, COUNT(cloud_cover) as cover_count \nFROM weather \nWHERE zip_code = 94107 \nGROUP BY cloud_cover \nORDER BY cover_count DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.161", "db_id": "bike_1", "question": "For each trip, return its ending station's installation date.", "rationale": ["Identify the relevant tables: We need data from the 'trip' table for the ending station and the 'station' table for the installation date.", "Join the 'trip' table with the 'station' table on the end station ID to get the installation date of each ending station.", "Select the end station ID and its corresponding installation date from the joined tables."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T3.end_station_id, T1.installation_date FROM trip AS T3 JOIN station AS T1 ON T3.end_station_id = T1.id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.162", "db_id": "bike_1", "question": "What is the installation date for each ending station on all the trips?", "rationale": ["Identify the relevant tables: 'station' for installation dates and 'trip' for ending stations.", "We need to join the 'station' table with the 'trip' table on the condition that the station ID in the 'station' table matches the end station ID in the 'trip' table.", "Select the station name and installation date from the 'station' table.", "Group the results by the end station ID to ensure we get unique entries for each ending station."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T1.name, T1.installation_date FROM station AS T1 JOIN trip AS T2 ON T1.id = T2.end_station_id GROUP BY T2.end_station_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.163", "db_id": "bike_1", "question": "Which trip started from the station with the largest dock count? Give me the trip id.", "rationale": ["Identify the station with the largest dock count by ordering the 'station' table by 'dock_count' in descending order and limiting the result to 1.", "Use the 'id' of this station to filter the 'trip' table for trips that started from this station.", "Select the 'id' of the trip that meets this condition."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "pred_sql": "SELECT id FROM trip WHERE start_station_id = (SELECT id FROM station ORDER BY dock_count DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.165", "db_id": "bike_1", "question": "Count the number of trips that did not end in San Francisco city.", "rationale": ["Identify the requirement to count trips that did not end in San Francisco.", "To achieve this, we need to filter trips based on their end station's city.", "We can use a subquery to find all station IDs located in San Francisco.", "The subquery will select the IDs from the 'station' table where the city is 'San Francisco'.", "The main query will count all trips where the end station ID is not in the list of IDs returned by the subquery."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip WHERE end_station_id NOT IN (SELECT id FROM station WHERE city = 'San Francisco')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.166", "db_id": "bike_1", "question": "How many trips did not end in San Francisco?", "rationale": ["Identify the relevant table: The 'trip' table contains information about trips, including the end station name.", "Determine the condition: We need to count trips that did not end in San Francisco, which means we will filter out trips where the 'end_station_name' is 'San Francisco'.", "Construct the SQL query: We will use the COUNT function to count the number of trips that meet the condition specified."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != 'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip WHERE end_station_name != 'San Francisco';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.167", "db_id": "bike_1", "question": "In zip code 94107, on which day neither Fog nor Rain was not observed?", "rationale": ["Identify the relevant table: The question pertains to weather observations, so we will use the 'weather' table.", "Filter by zip code: We need to focus on records where the zip code is 94107.", "Exclude specific weather events: We want to find days where neither Fog nor Rain was observed, which means we need to filter out any records that contain these events in the 'events' column.", "Construct the SQL query: Combine the filters into a SELECT statement that retrieves the date from the 'weather' table based on the specified conditions."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT date FROM weather WHERE zip_code = 94107 AND events NOT LIKE '%Fog%' AND events NOT LIKE '%Rain%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.168", "db_id": "bike_1", "question": "On which day has it neither been foggy nor rained in the zip code of 94107?", "rationale": ["Identify the relevant table: The 'weather' table contains the necessary information about weather conditions.", "Determine the conditions for the query: We need to find days with no rain (precipitation_inches = 0) and no fog (events = 0).", "Specify the zip code: We are interested in the weather reports for the zip code 94107.", "Construct the SQL query: Select the date from the weather table where the zip code is 94107 and both conditions (no rain and no fog) are met."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT date FROM weather WHERE zip_code = 94107 AND precipitation_inches = 0 AND events = 0", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.183", "db_id": "bike_1", "question": "List all the cities in a decreasing order of each city's stations' highest latitude.", "rationale": ["We need to list all the cities from the 'station' table.", "To find the highest latitude for each city, we will use the MAX function on the 'lat' column.", "We will group the results by 'city' to ensure we get the highest latitude for each city.", "Finally, we will order the results in decreasing order of the highest latitude using ORDER BY clause."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, MAX(lat) AS highest_latitude FROM station GROUP BY city ORDER BY highest_latitude DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.184", "db_id": "bike_1", "question": "For each city, list their names in decreasing order by their highest station latitude.", "rationale": ["We need to list the names of bike stations for each city, ordered by their highest latitude.", "To achieve this, we can use a subquery to find the maximum latitude for each city from the 'station' table.", "We will select the city and name from the 'station' table where the latitude matches the maximum latitude found in the subquery.", "Finally, we will order the results by latitude in descending order to meet the requirement."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, name FROM station WHERE lat = (SELECT MAX(lat) FROM station GROUP BY city) ORDER BY lat DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.189", "db_id": "bike_1", "question": "For each station, return its longitude and the average duration of trips that started from the station.", "rationale": ["We need to select the longitude of each station and the average duration of trips that started from that station.", "The 'station' table contains the longitude information, while the 'trip' table contains the duration of trips and the starting station ID.", "To get the average duration of trips for each station, we will join the 'station' table with the 'trip' table on the condition that the station ID in the 'station' table matches the start station ID in the 'trip' table.", "We will use the AVG() function to calculate the average duration of trips for each station.", "Finally, we will group the results by the station ID to ensure we get one result per station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT S.long, AVG(T.duration) AS average_duration\nFROM station AS S\nJOIN trip AS T ON S.id = T.start_station_id\nGROUP BY S.id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.190", "db_id": "bike_1", "question": "For each start station id, what is its name, longitude and average duration of trips started there?", "rationale": ["Identify the relevant tables: 'station' for station details and 'trip' for trip durations.", "We need to select the station's id, name, longitude, and the average duration of trips that started at each station.", "Join the 'station' table (aliased as T1) with the 'trip' table (aliased as T2) on the condition that the station id in 'station' matches the start station id in 'trip'.", "Use the AVG() function to calculate the average duration of trips for each station.", "Group the results by station id, name, and longitude to ensure we get one result per station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T1.id, T1.name, T1.long, AVG(T2.duration) AS average_duration\nFROM station AS T1\nJOIN trip AS T2 ON T1.id = T2.start_station_id\nGROUP BY T1.id, T1.name, T1.long;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.192", "db_id": "bike_1", "question": "For each end station id, what is its name, latitude, and minimum duration for trips ended there?", "rationale": ["Identify the required columns: end station name, latitude, and minimum trip duration.", "The 'station' table contains the station names and latitude, while the 'trip' table contains the trip durations and end station IDs.", "Join the 'station' table (aliased as T1) with the 'trip' table (aliased as T2) on the condition that the station ID in the trip table matches the end station ID in the station table.", "Use the MIN() function to calculate the minimum duration of trips for each end station.", "Group the results by end station ID to ensure that we get one result per end station."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T1.name, T1.lat, MIN(T2.duration) \nFROM station AS T1 \nJOIN trip AS T2 ON T1.id = T2.end_station_id \nGROUP BY T2.end_station_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.196", "db_id": "bike_1", "question": "What are all the different zip codes that have a maximum dew point that was always below 70?", "rationale": ["We need to find all unique zip codes where the maximum dew point is always below 70.", "To achieve this, we will select distinct zip codes from the weather table.", "We will apply a condition to filter the records where the max_dew_point_f is less than 70."], "gold_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f < 70", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.205", "db_id": "bike_1", "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.", "rationale": ["We need to find zip codes where the average mean humidity is below 70.", "We can use the 'weather' table to filter for mean humidity less than 70.", "We also need to ensure that at least 100 trips took place for those zip codes.", "To do this, we can use the 'trip' table and group by zip code, counting the number of trips for each zip code.", "We will use a subquery to get the zip codes from the 'trip' table that have at least 100 trips.", "Finally, we will combine these two conditions using an IN clause to filter the zip codes accordingly."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code FROM weather WHERE mean_humidity < 70 AND zip_code IN (SELECT zip_code FROM trip GROUP BY zip_code HAVING COUNT(*) >= 100)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.206", "db_id": "bike_1", "question": "What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?", "rationale": ["We need to find zip codes with an average mean humidity below 70 and at least 100 trips.", "First, we will group the trips by zip code and count the number of trips for each zip code using COUNT(id).", "Next, we will filter these groups using HAVING to ensure that only those with at least 100 trips are included.", "To check the average mean humidity for each zip code, we will use a subquery that calculates the average mean humidity from the weather table for each zip code.", "Finally, we will ensure that this average mean humidity is less than 70 in the HAVING clause."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code \nFROM trip \nWHERE zip_code IS NOT NULL \nGROUP BY zip_code \nHAVING COUNT(id) >= 100 AND \n       (SELECT AVG(mean_humidity) \n        FROM weather \n        WHERE zip_code = trip.zip_code) < 70;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique trip identifiers from the 'trip' table where the duration of the trip is greater than or equal to the average duration of trips associated with a specific zip code. The placeholder in the subquery represents the user's zip code.\",\n        \"virtual_table\": \"SELECT id FROM trip WHERE duration  >=  (SELECT avg(duration) FROM trip WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of weather reports from the 'weather' table where the mean humidity exceeds a specified threshold and the mean visibility in miles also exceeds another specified threshold. The placeholders in the WHERE clause represent the numeric values for mean humidity and mean visibility that the user can define.\",\n        \"virtual_table\": \"SELECT COUNT(*) FROM weather WHERE mean_humidity  >  [PLACEHOLDER-TYPE:NUMBER] AND mean_visibility_miles  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.304", "db_id": "product_catalog", "question": "What are the attribute data types with more than 3 attribute definitions?", "rationale": ["Identify the table that contains the attribute definitions, which is 'Attribute_Definitions'.", "Determine the relevant column that contains the data types of the attributes, which is 'attribute_data_type'.", "To find data types with more than 3 definitions, we need to group the results by 'attribute_data_type'.", "Use the COUNT function to count the number of attribute definitions for each data type.", "Apply the HAVING clause to filter groups where the count is greater than 3."], "gold_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  3", "source_tables": ["attribute_definitions"], "pred_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING COUNT(attribute_id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.316", "db_id": "product_catalog", "question": "Find the entry names of the catalog with the attribute that have the most entries.", "rationale": ["Identify the relevant tables: Catalog_Contents for entry names and Catalog_Contents_Additional_Attributes for attributes.", "Join Catalog_Contents with Catalog_Contents_Additional_Attributes on catalog_entry_id to link entries with their attributes.", "Group the results by catalog_entry_name to count how many attributes each entry has.", "Order the results by the count of attributes in descending order to find the entry with the most attributes.", "Limit the results to 1 to get only the entry name with the most attributes."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT cc.catalog_entry_name \nFROM Catalog_Contents AS cc \nJOIN Catalog_Contents_Additional_Attributes AS cca ON cc.catalog_entry_id = cca.catalog_entry_id \nGROUP BY cc.catalog_entry_name \nORDER BY COUNT(cca.catalog_entry_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.317", "db_id": "product_catalog", "question": "What is the entry name of the most expensive catalog (in USD)?", "rationale": ["Identify the relevant tables: Catalog_Contents for catalog entries and Catalogs for catalog information.", "Join Catalog_Contents with Catalogs to access the catalog details associated with each entry.", "Order the results by price in dollars in descending order to find the most expensive entry.", "Limit the results to 1 to get only the most expensive catalog entry name."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1", "source_tables": ["catalog_contents"], "pred_sql": "SELECT cc.catalog_entry_name FROM Catalog_Contents AS cc JOIN Catalogs AS c ON cc.catalog_level_number = c.catalog_id ORDER BY CAST(cc.price_in_dollars AS REAL) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.330", "db_id": "product_catalog", "question": "What are the names of catalog entries with level number 8?", "rationale": ["Identify the relevant tables: Catalog_Contents for catalog entries and Catalog_Contents_Additional_Attributes for additional attributes including level numbers.", "Join the Catalog_Contents table with the Catalog_Contents_Additional_Attributes table on the catalog_entry_id to link entries with their attributes.", "Filter the results to only include entries where the catalog_level_number is '8'.", "Select the catalog_entry_name from the resulting joined table."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  '8'", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id = t2.catalog_entry_id WHERE t2.catalog_level_number = '8'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.331", "db_id": "product_catalog", "question": "Find the names of the products with length smaller than 3 or height greater than 5.", "rationale": ["Identify the table that contains product information, which is the Catalog_Contents table.", "Determine the relevant columns needed for the query: catalog_entry_name for product names, length for the length condition, and height for the height condition.", "Construct the SELECT statement to retrieve the catalog_entry_name from the Catalog_Contents table.", "Add a WHERE clause to filter products based on the conditions: length smaller than 3 or height greater than 5."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name \nFROM Catalog_Contents \nWHERE length < 3 OR height > 5;", "hint": "\n"}
{"sample_id": "train.332", "db_id": "product_catalog", "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.", "rationale": ["Identify the relevant table: The question asks about catalog contents, which are stored in the 'Catalog_Contents' table.", "Determine the columns needed: We need the 'catalog_entry_name' and the 'length' of the catalog contents.", "Apply the filtering criteria: The question specifies that we want entries with a length below 3 or above 5, so we will use a WHERE clause to filter these results.", "Construct the SQL query: Combine the SELECT statement with the FROM clause and the WHERE clause to form a complete SQL query."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE length < 3 OR length > 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.338", "db_id": "product_catalog", "question": "On which days more than one revisions were made on catalogs.", "rationale": ["Identify the relevant table: The question pertains to revisions made on catalogs, which relates to the 'Catalogs' table.", "Focus on the 'date_of_latest_revision' column: This column indicates when the last revision was made for each catalog.", "Group by the 'date_of_latest_revision': To find out how many revisions were made on each day, we need to group the results by this date.", "Count the number of revisions: Use COUNT(*) to count how many catalogs were revised on each date.", "Filter for days with more than one revision: Use HAVING COUNT(*) > 1 to filter the results to only include days where more than one revision occurred."], "gold_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1", "source_tables": ["catalogs"], "pred_sql": "SELECT date_of_latest_revision, COUNT(*) as revision_count \nFROM Catalogs \nGROUP BY date_of_latest_revision \nHAVING COUNT(*) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of catalog publishers from the 'Catalogs' table, grouped by publisher name. The results are ordered by the number of catalogs each publisher has, in descending order, and limited to a specified number of publishers. The placeholder in the LIMIT clause represents the maximum number of publishers to return.\",\n        \"virtual_table\": \"SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their origins and destinations.", "Determine the required columns: We need the 'origin' column for flights headed to Honolulu.", "Specify the condition: We need to filter the results where the 'destination' is 'Honolulu'.", "Construct the SQL query: Combine the selected columns and conditions into a valid SQL statement."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight WHERE destination = 'Honolulu'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the required columns: We need the 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We want flights that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query: Using SELECT to get the required columns from the flight table with the specified conditions."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their prices, origins, and destinations.", "Determine the columns needed: We need the 'price' column to calculate the average price of flights.", "Filter the results: We want to find flights specifically from 'LA' to 'Honolulu', so we will add a WHERE clause to filter by 'origin' and 'destination'.", "Use the AVG() function: To calculate the average price, we will use the AVG() function on the 'price' column.", "Construct the SQL query: Combine all these elements into a single SQL query."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT AVG(price) AS average_price FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["Identify the tables needed: We need data from the 'aircraft' table for aircraft names and from the 'flight' table to count the number of flights.", "Determine the relationship: The 'flight' table has a foreign key 'aid' that relates to the 'aircraft' table's primary key 'aid'.", "Use a LEFT JOIN to include all aircraft even if they have no flights, ensuring we count flights correctly.", "Select the aircraft name and count the number of flights, using COUNT(f.flno) to get the number of flights per aircraft.", "Group the results by aircraft ID and name to aggregate the flight counts correctly."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT a.name, COUNT(f.flno) AS number_of_flights\nFROM aircraft a\nLEFT JOIN flight f ON a.aid = f.aid\nGROUP BY a.aid, a.name;", "hint": "\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables needed: We need data from the 'aircraft' table for aircraft names and from the 'flight' table to count the number of flights.", "We will use a LEFT JOIN to connect the 'aircraft' table with the 'flight' table on the aircraft ID (aid) since we want to include all aircraft even if they have no flights.", "We will use COUNT(f.flno) to count the number of flights for each aircraft. If an aircraft has no flights, it will still be included in the results with a count of 0.", "Finally, we will group the results by the aircraft ID (a.aid) to ensure we get a count for each individual aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT a.name, COUNT(f.flno) AS flight_count\nFROM aircraft a\nLEFT JOIN flight f ON a.aid = f.aid\nGROUP BY a.aid;", "hint": "\n"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["Identify the main table to query: employee.", "We need to find employees who are not certified to fly a specific aircraft (Boeing 737-800).", "To do this, we will use a subquery to find all employee IDs (eid) that are certified to fly the Boeing 737-800.", "The subquery will join the certificate table with the aircraft table to filter by the aircraft name 'Boeing 737-800'.", "The main query will select the names of employees whose IDs are not in the list returned by the subquery."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.name \nFROM employee e \nWHERE e.eid NOT IN (\n    SELECT c.eid \n    FROM certificate c \n    JOIN aircraft a ON c.aid = a.aid \n    WHERE a.name = 'Boeing 737-800'\n);", "hint": "\n"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["We need to find the name of the aircraft with the fewest number of certificates held by employees.", "To do this, we will join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid).", "We will group the results by the aircraft ID to count how many certificates each aircraft has.", "Next, we will order the results by the count of certificates in ascending order to get the aircraft with the fewest certificates at the top.", "Finally, we will limit the results to just one record to get the aircraft with the fewest certificates."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nORDER BY COUNT(c.eid) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.432", "db_id": "flight_1", "question": "What are the names of the aircraft that the least people are certified to fly?", "rationale": ["We need to find the names of aircraft with the least number of certified pilots.", "To do this, we will join the 'aircraft' table with the 'certificate' table on the aircraft ID ('aid').", "We will group the results by the aircraft ID to count how many employees are certified for each aircraft.", "We will use the HAVING clause to filter for those aircraft that have the minimum count of certified employees.", "To find the minimum count, we will use a subquery that counts the number of certifications for each aircraft and selects the minimum count from those counts."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nHAVING COUNT(c.eid) = (\n    SELECT MIN(cert_count)\n    FROM (\n        SELECT COUNT(eid) AS cert_count\n        FROM certificate\n        GROUP BY aid\n    ) AS counts\n);", "hint": "\n"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["Identify the relevant tables: employee, certificate, and aircraft.", "We need to find employees who have certificates to fly aircraft with a distance greater than 5000.", "Join the employee table with the certificate table on employee ID (eid) and then join with the aircraft table on aircraft ID (aid).", "Filter the results to include only those aircraft where the distance is greater than 5000.", "Group the results by employee ID to count the number of certificates each employee has.", "Order the results by the count of certificates in descending order to find the employee with the most certificates.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.salary, e.name \nFROM employee e \nJOIN certificate c ON e.eid = c.eid \nJOIN aircraft a ON c.aid = a.aid \nWHERE a.distance > 5000 \nGROUP BY e.eid \nORDER BY COUNT(c.aid) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The user is asking for all the different food allergies, which implies we need to retrieve unique allergy names.", "We will use the 'Has_Allergy' table since it contains the allergies associated with students.", "To get distinct allergy names, we will use the SELECT DISTINCT statement on the 'Allergy' column from the 'Has_Allergy' table."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Has_Allergy", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.452", "db_id": "allergy_1", "question": "How many animal type allergies exist?", "rationale": ["The question asks for the count of animal type allergies.", "To find this, we need to join the 'Has_Allergy' table with the 'Allergy_Type' table to access the allergy types.", "We will filter the results to only include those allergies that are categorized as 'Animal'.", "Finally, we will use COUNT(DISTINCT ...) to count the unique animal type allergies."], "gold_sql": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  'animal'", "source_tables": ["allergy_type"], "pred_sql": "SELECT COUNT(DISTINCT T2.allergytype) FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.allergy = T2.allergy WHERE T2.allergytype = 'Animal';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["Identify the tables involved: 'Has_Allergy' for student allergies and 'Allergy_Type' for allergy types.", "Join the 'Has_Allergy' table with the 'Allergy_Type' table on the Allergy column to associate students with their allergy types.", "Group the results by AllergyType to count how many allergies fall under each type.", "Use COUNT(*) to get the number of allergies for each type.", "Order the results in descending order based on the count of allergies to find the most common allergy type.", "Limit the results to 1 to get only the allergy type with the highest count."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT T2.AllergyType, COUNT(*) as AllergyCount \nFROM Has_Allergy AS T1 \nJOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \nGROUP BY T2.AllergyType \nORDER BY AllergyCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["The question asks for the least common allergy type, which implies we need to count the occurrences of each allergy type.", "To achieve this, we will join the 'Has_Allergy' table with the 'Allergy_Type' table on the Allergy column.", "We will group the results by the allergy type to get the count of students for each type.", "Next, we will order the results in ascending order based on the count to find the least common allergy type.", "Finally, we will limit the results to 1 to get only the least common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT T2.allergytype, COUNT(*) as allergy_count \nFROM Has_Allergy AS T1 \nJOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \nGROUP BY T2.allergytype \nORDER BY allergy_count ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student names, which is the 'Student' table.", "To get the full names, we need to concatenate the 'Fname' and 'LName' columns.", "Use the SQL SELECT statement to retrieve the concatenated names as 'FullName'."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName FROM Student;", "hint": "\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the table that contains student information, which is the 'Student' table.", "Determine the relevant column for filtering by gender, which is 'Sex'.", "Specify the condition to filter for male students, which is 'Sex = 'Male''.", "Select the 'StuID' column to retrieve the unique identifiers for the male students."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the majors, which is the 'Student' table.", "We need to group the results by the 'Major' column to count how many students are in each major.", "Order the results in descending order based on the count of students in each major to find the largest major.", "Limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major and ordered by the number of students in each major in descending order. The placeholder in the LIMIT clause represents the maximum number of majors to return.\",\n        \"virtual_table\": \"SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.502", "db_id": "allergy_1", "question": "Give the advisor with the most students.", "rationale": ["Identify the relevant table: The 'Student' table contains information about students and their advisors.", "Determine the required information: We need to find the advisor with the most students, which involves counting the number of students for each advisor.", "Use the COUNT function: This function will help us count the number of students associated with each advisor.", "Group the results: We will group the results by the advisor's name to aggregate the student counts correctly.", "Order the results: We will order the results in descending order based on the student count to get the advisor with the most students at the top.", "Limit the results: Since we only want the advisor with the most students, we will limit our results to 1."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(*) as StudentCount FROM Student GROUP BY Advisor ORDER BY StudentCount DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of academic advisors from the 'Student' table, grouped by the advisor's name. The results are ordered by the number of students assigned to each advisor in descending order, with a limit on the number of advisors returned, specified by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["Identify the relevant table: The 'Has_Allergy' table contains information about which students have which allergies.", "Determine the specific allergy of interest: The question asks about students with cat allergies.", "Construct the SQL query: Use the COUNT function to count the number of entries in the 'Has_Allergy' table where the Allergy column matches 'cat'."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(*) FROM Has_Allergy WHERE Allergy = 'cat';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the relevant tables: Has_Allergy and Student.", "We need to count the number of students affected by cat allergies, so we will use COUNT(*) to get the total number.", "Join the Has_Allergy table with the Student table on StuID to link students with their allergies.", "Filter the results where the Allergy is 'cat allergies'.", "Construct the SQL query using the above logic."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT COUNT(*) FROM Has_Allergy AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.Allergy = 'cat allergies'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the tables needed: Has_Allergy for allergies and Student for student details.", "We need to count the number of students, so we will use the COUNT function.", "Join the Has_Allergy table with the Student table on StuID to link students with their allergies.", "Filter the results to include only female students by adding a condition in the WHERE clause: T2.Sex = 'Female'.", "Add another condition to check if the allergy is either 'Milk' or 'Eggs' using the OR operator.", "Combine these conditions in the WHERE clause to filter the results accordingly."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T2.Sex = 'Female' AND (T1.Allergy = 'Milk' OR T1.Allergy = 'Eggs')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.514", "db_id": "allergy_1", "question": "Which allergy is the most common?", "rationale": ["The question asks for the most common allergy, which implies we need to count occurrences of allergies.", "We will join the 'Has_Allergy' table with the 'Allergy_Type' table to get the allergy types associated with each student.", "Using COUNT(*) will allow us to count how many students have each type of allergy.", "We will group the results by the allergy type to aggregate the counts for each type.", "To find the most common allergy, we will order the results in descending order based on the count of students for each allergy type.", "Finally, we will limit the results to 1 to get only the most common allergy."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT T2.allergytype, count(*) as allergy_count FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy GROUP BY T2.allergytype ORDER BY allergy_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["Identify the tables needed: We need to retrieve student information (last name and age) and their allergies, so we will use the Student and Has_Allergy tables.", "Determine the relationships: The Has_Allergy table links students to their allergies via StuID. We will need to join the Has_Allergy table twice to check for both allergies (milk and cat).", "Select the required columns: We need to select the last name (LName) and age (Age) of the student from the Student table.", "Construct the SQL query: We will join the Student table with the Has_Allergy table twice, once for each allergy, and filter the results to include only those students who have both allergies."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.LName, S.Age \nFROM Student AS S \nJOIN Has_Allergy AS H1 ON S.StuID = H1.StuID \nJOIN Has_Allergy AS H2 ON S.StuID = H2.StuID \nWHERE H1.Allergy = 'milk' AND H2.Allergy = 'cat';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the tables needed: We need to retrieve student information (last names and ages) and their allergies, so we will use the 'Student' and 'Has_Allergy' tables.", "Determine the columns to select: We need the last names (LName) and ages (Age) of the students.", "Establish the relationship between tables: The 'Has_Allergy' table links students to their allergies through the StuID column, which is common in both tables.", "Filter the results: We want to find students who are allergic to 'milk' or 'cat', so we will use a WHERE clause with an IN condition to filter allergies.", "Construct the SQL query: Combine all the elements into a complete SQL query that selects the required columns from the joined tables with the specified conditions."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.LName, S.Age FROM Student AS S JOIN Has_Allergy AS H ON S.StuID = H.StuID WHERE H.Allergy IN ('milk', 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.523", "db_id": "allergy_1", "question": "Find the first name and gender of the student who has allergy to milk but not cat.", "rationale": ["Identify the tables needed: We need data from the Student and Has_Allergy tables.", "We want to select the first name (Fname) and gender (Sex) of students.", "We need to filter students who have an allergy to 'milk'.", "Additionally, we need to ensure that these students do not have an allergy to 'cat'.", "To achieve this, we can use a subquery to find all students with a 'cat' allergy and exclude them from our main query.", "Join the Student table with the Has_Allergy table on StuID to get the relevant information about students and their allergies."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex FROM Student AS S JOIN Has_Allergy AS H ON S.StuID = H.StuID WHERE H.Allergy = 'milk' AND S.StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.524", "db_id": "allergy_1", "question": "What are the first name and gender of the students who have allergy to milk but can put up with cats?", "rationale": ["Identify the relevant tables: We need to retrieve student information from the 'Student' table and allergy information from the 'Has_Allergy' table.", "Determine the required fields: We need the first name (Fname) and gender (Sex) of the students.", "Set the conditions for the query: We want students who have an allergy to milk. This means we will filter the 'Has_Allergy' table for records where Allergy = 'milk'.", "Additionally, we want to exclude students who have an allergy to cats. This can be done using a subquery that selects StuID from 'Has_Allergy' where Allergy = 'cats'.", "Join the 'Student' and 'Has_Allergy' tables on StuID to combine student data with their allergy information.", "Construct the SQL query using the identified fields and conditions."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex FROM Student AS S JOIN Has_Allergy AS H ON S.StuID = H.StuID WHERE H.Allergy = 'milk' AND S.StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'cats')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the tables needed: We need to get student ages from the Student table and filter allergies from the Has_Allergy and Allergy_Type tables.", "Join the tables: We will join the Student table with the Has_Allergy table on StuID, and then join with the Allergy_Type table on Allergy.", "Filter by allergy types: We need to filter the results to include only those allergies that are categorized as 'food' or 'animal'.", "Calculate the average age: We will use the AVG function to calculate the average age of the filtered students."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT AVG(CAST(Age AS INTEGER)) FROM Student AS S JOIN Has_Allergy AS HA ON S.StuID = HA.StuID JOIN Allergy_Type AS AT ON HA.Allergy = AT.Allergy WHERE AT.AllergyType IN ('food', 'animal')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["Identify the tables involved: We need to retrieve student names from the 'Student' table and check for allergies in the 'Has_Allergy' table.", "We want to find students who are not allergic to any type of food, which means we need to exclude those who have entries in the 'Has_Allergy' table.", "To achieve this, we can use a subquery that selects all 'StuID's from the 'Has_Allergy' table.", "The main query will select the first name (Fname) and last name (LName) of students whose 'StuID' is not in the list returned by the subquery."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname, LName FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Allergy)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["Identify the relevant tables: Has_Allergy, Student, and Allergy_Type.", "We need to count the number of male students (Sex = 'M') who have allergies related to food.", "Join the Has_Allergy table with the Student table on StuID to filter by gender.", "Join the Allergy_Type table to filter allergies specifically related to food.", "Use a WHERE clause to specify the conditions for male students and food allergies.", "Use the COUNT function to get the total number of male students with food allergies."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID JOIN Allergy_Type AS T3 ON T1.Allergy = T3.Allergy WHERE T2.Sex = 'M' AND T3.AllergyType = 'Food'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables needed: We need data from the Student and Has_Allergy tables.", "We want to find students with specific allergies (milk or cat), so we will join the Has_Allergy table with the Student table on StuID.", "We need to select distinct first names and city codes of students, so we will use SELECT DISTINCT to avoid duplicates.", "The WHERE clause will filter the results to include only those students who have allergies to either milk or cat using the IN operator."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code \nFROM Student AS S \nJOIN Has_Allergy AS HA ON S.StuID = HA.StuID \nWHERE HA.Allergy IN ('milk', 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["Identify the tables needed: We need data from the Student and Has_Allergy tables.", "We want distinct first names and cities, so we will select S.Fname and S.city_code.", "We need to join the Student table with the Has_Allergy table on StuID to link students with their allergies.", "We filter the results to include only those students who have allergies to either 'milk' or 'cat'.", "Use the IN clause to specify the allergies we are interested in: 'milk' and 'cat'.", "Finally, we use DISTINCT to ensure that we only get unique combinations of first names and city codes."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code \nFROM Student AS S \nJOIN Has_Allergy AS H ON S.StuID = H.StuID \nWHERE H.Allergy IN ('milk', 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.\",\n        \"virtual_table\": \"SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.\",\n        \"virtual_table\": \"SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["The query needs to find the names of countries and the average invoice size for each country.", "We will select the 'billing_country' from the 'invoices' table.", "To calculate the average invoice size, we will use the AVG() function on the 'total' column from the 'invoices' table.", "We need to group the results by 'billing_country' to get the average for each country.", "Finally, we will order the results by the average invoice size in descending order to get the top countries by size."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size \nFROM invoices \nGROUP BY billing_country \nORDER BY AVG(total) DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["We need to count the number of invoices for each state.", "The relevant table for invoices is the 'invoices' table, which contains a 'billing_state' column.", "To get the count of invoices per state, we can use the COUNT() function.", "We will group the results by 'billing_state' to get the count for each state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count FROM invoices GROUP BY billing_state;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["We need to find the states with the most invoices, which means we need to count the number of invoices per state.", "The relevant table for this information is the 'invoices' table, which contains a 'billing_state' column.", "We will use the COUNT() function to count the number of invoices for each state.", "To group the results by state, we will use the GROUP BY clause on the 'billing_state' column.", "Finally, we will order the results in descending order based on the count of invoices to get the states with the most invoices at the top."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count \nFROM invoices \nGROUP BY billing_state \nORDER BY invoice_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.568", "db_id": "store_1", "question": "What is the number of invoices and total money billed in them from CA?", "rationale": ["Identify the relevant table: invoices, which contains billing information.", "Determine the required fields: count of invoices and total amount billed.", "Use COUNT(*) to get the number of invoices and SUM(total) to calculate the total amount billed.", "Filter the results by the state 'CA' using a WHERE clause."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS number_of_invoices, SUM(total) AS total_billed FROM invoices WHERE billing_state = 'CA';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the table that contains the required information: The 'employees' table has the email and phone number of employees.", "Determine the specific employee: The question asks for Astrid Gruber, so we need to filter by first name 'Astrid' and last name 'Gruber'.", "Construct the SQL query to select the email and phone columns from the employees table where the first and last names match."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the street address of employees from the 'employees' table based on their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the employee being queried.\",\n        \"virtual_table\": \"SELECT address FROM employees WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["Identify the relevant table: The question asks about customers, so we will use the 'customers' table.", "Determine the condition: We need to count customers from California, which is specified in the 'state' column.", "Construct the SQL query: We will use the COUNT function to count the number of customers where the state is 'California'."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) FROM customers WHERE state = 'California';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: We need to find employees and their associated customers, so we will use the 'employees' and 'customers' tables.", "Join the tables: We will join the 'employees' table with the 'customers' table on the condition that the employee's ID matches the support representative ID in the customers table.", "Group by employee: To count how many customers each employee supports, we will group the results by employee ID.", "Count customers: We will use COUNT(c.id) to count the number of customers for each employee.", "Order by count: We will order the results in descending order based on the count of customers supported by each employee.", "Limit to one: Since we only want the employee who supports the most customers, we will limit the results to 1."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees who report to a specific manager from the 'employees' table. The placeholders in the WHERE clause represent the first and last names of the manager.\",\n        \"virtual_table\": \"SELECT T2.first_name , T2.last_name FROM employees AS T1 JOIN employees AS T2 ON T1.id = T2.reports_to WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["Identify the customer by name: 'Luca Mancini'.", "Use the customers table to find the id of Luca Mancini.", "Count the number of invoices associated with that customer id in the invoices table."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "pred_sql": "SELECT COUNT(*) FROM invoices WHERE customer_id IN (SELECT id FROM customers WHERE first_name = 'Luca' AND last_name = 'Mancini');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["Identify the track 'Balls to the Wall' in the tracks table.", "Join the tracks table with the albums table using the album_id foreign key.", "Select the title of the album that corresponds to the identified track."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT albums.title \nFROM albums \nJOIN tracks ON albums.id = tracks.album_id \nWHERE tracks.name = 'Balls to the Wall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\",\n        \"virtual_table\": \"SELECT title FROM albums WHERE title LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY title;\"\n    }\n}\n"}
{"sample_id": "train.626", "db_id": "store_1", "question": "What is the name of all tracks in the album named Balls to the Wall?", "rationale": ["Identify the relevant tables: We need to retrieve track names, which are stored in the 'tracks' table, and we need to filter these tracks based on the album title, which is stored in the 'albums' table.", "Establish the relationship: The 'tracks' table has a foreign key 'album_id' that references the 'id' in the 'albums' table. This means we can join these two tables on this key to get the necessary information.", "Formulate the SQL query: We will select the track names from the 'tracks' table and join it with the 'albums' table to filter by the album title 'Balls to the Wall'.", "Use the WHERE clause to specify that we only want tracks from the album with the title 'Balls to the Wall'."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN albums ON tracks.album_id = albums.id \nWHERE albums.title = 'Balls to the Wall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\",\n        \"virtual_table\": \"SELECT title FROM albums WHERE title LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY title;\"\n    }\n}\n"}
{"sample_id": "train.630", "db_id": "store_1", "question": "What are the names of all Rock tracks that are stored on MPEG audio files?", "rationale": ["Identify the relevant tables: tracks, media_types, and genres.", "We need to find the names of tracks, so we will select the 'name' column from the tracks table.", "To filter by genre, we will join the genres table on the genre_id column of the tracks table.", "To filter by media type, we will join the media_types table on the media_type_id column of the tracks table.", "The WHERE clause will specify that we want tracks where the genre name is 'Rock' and the media type name is 'MPEG audio'."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN media_types ON tracks.media_type_id = media_types.id \nJOIN genres ON tracks.genre_id = genres.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG audio';", "hint": "\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the tables involved: tracks, genres, and media_types.", "We need to select the track names from the tracks table.", "To filter tracks by genre, we join the genres table on the genre_id column of the tracks table.", "To filter tracks by media type, we join the media_types table on the media_type_id column of the tracks table.", "We apply a WHERE clause to filter for tracks that belong to the 'Rock' genre and have a media type of 'MPEG'."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN genres ON tracks.genre_id = genres.id \nJOIN media_types ON tracks.media_type_id = media_types.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG';", "hint": "\n"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["Identify the relevant tables: We need to find tracks that a specific customer (Dean Peeters) bought, so we will use the 'tracks', 'invoice_lines', 'invoices', and 'customers' tables.", "Join the tables: We will join 'tracks' with 'invoice_lines' on the track ID, then join 'invoice_lines' with 'invoices' on the invoice ID, and finally join 'invoices' with 'customers' on the customer ID. This will allow us to link tracks to the specific customer.", "Filter by customer name: We will add a WHERE clause to filter the results to only include purchases made by Dean Peeters, using both first and last name."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN invoice_lines ON tracks.id = invoice_lines.track_id \nJOIN invoices ON invoice_lines.invoice_id = invoices.id \nJOIN customers ON invoices.customer_id = customers.id \nWHERE customers.first_name = 'Dean' AND customers.last_name = 'Peeters';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\",\n        \"virtual_table\": \"SELECT title FROM albums WHERE title LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY title;\"\n    }\n}\n"}
{"sample_id": "train.686", "db_id": "customers_card_transactions", "question": "What are the full names of customers who do not have any accounts?", "rationale": ["We need to find customers who do not have any accounts.", "To do this, we can use a LEFT JOIN between the Customers table and a virtual table that counts the number of accounts per customer from the Accounts table.", "The virtual table will select customer_id and count the number of accounts grouped by customer_id.", "The LEFT JOIN will allow us to include all customers, even those without accounts, and we can filter for those with a NULL account count.", "Finally, we select the first and last names of these customers."], "gold_sql": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_first_name, c.customer_last_name \nFROM Customers c \nLEFT JOIN (SELECT customer_id, COUNT(*) as account_count FROM Accounts GROUP BY customer_id) a \nON c.customer_id = a.customer_id \nWHERE a.account_count IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\",\n        \"virtual_table\": \"SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers\"\n    }\n}\n"}
{"sample_id": "train.688", "db_id": "customers_card_transactions", "question": "What are the full names of customers who have accounts?", "rationale": ["We need to find the full names of customers who have accounts, which means we need to join the Customers table with the Accounts table.", "The first step is to create a virtual table that counts the number of accounts for each customer. This is done using the SQL query: 'SELECT customer_id, count(*) FROM Accounts GROUP BY customer_id'.", "Next, we need to select the first name and last name of customers from the Customers table. This can be done with the query: 'SELECT customer_id, customer_first_name, customer_last_name FROM Customers'.", "To get the full names of customers who have accounts, we will join the results of the first virtual table (account counts) with the Customers table on the customer_id field.", "The final SQL query will select the first and last names from the Customers table where there is a matching customer_id in the virtual table that counts accounts."], "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_first_name, c.customer_last_name \nFROM Customers c \nJOIN (SELECT customer_id, count(*) \n      FROM Accounts \n      GROUP BY customer_id) a \nON c.customer_id = a.customer_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\",\n        \"virtual_table\": \"SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers\"\n    }\n}\n"}
{"sample_id": "train.704", "db_id": "customers_card_transactions", "question": "Return the full name and phone of the customer who has card number 4560596484842.", "rationale": ["Identify the required information: full name and phone number of the customer.", "The full name can be constructed by concatenating the first name and last name from the Customers table.", "To find the customer associated with a specific card number, we need to join the Customers table with the Customers_Cards table using the customer_id.", "The inner query selects the customer_id from the Customers_Cards table where the card_number matches '4560596484842'.", "The outer query selects the full name and phone number from the Customers table where the customer_id is in the result of the inner query."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.card_number  =  '4560596484842'", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name, customer_phone FROM Customers WHERE customer_id IN (SELECT customer_id FROM Customers_Cards WHERE card_number = '4560596484842')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers\"\n    }\n}\n"}
{"sample_id": "train.717", "db_id": "customers_card_transactions", "question": "What is the customer id, first and last name with least number of accounts.", "rationale": ["We need to find the customer with the least number of accounts.", "First, we can summarize the number of accounts associated with each customer using a subquery that counts the accounts grouped by customer_id.", "Next, we will join this subquery with the Customers table to get the customer details (customer_id, first name, last name).", "Finally, we will order the results by the account count in ascending order and limit the result to 1 to get the customer with the least number of accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name \nFROM Customers c \nJOIN (SELECT customer_id, COUNT(*) as account_count \n      FROM Accounts \n      GROUP BY customer_id) a \nON c.customer_id = a.customer_id \nORDER BY a.account_count ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\",\n        \"virtual_table\": \"SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id\"\n    }\n}\n"}
{"sample_id": "train.718", "db_id": "customers_card_transactions", "question": "Return the id and full name of the customer who has the fewest accounts.", "rationale": ["We need to find the customer with the fewest accounts.", "The hint provides a virtual table that summarizes the number of accounts per customer using a GROUP BY clause on the Accounts table.", "We will use this virtual table to join with the Customers table to get the customer's details.", "We select the customer_id and concatenate the first and last name to get the full name.", "To find the customer with the fewest accounts, we will order the results by account count in ascending order and limit the result to 1."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name \nFROM Customers c \nJOIN (SELECT customer_id, COUNT(*) AS account_count \n      FROM Accounts \n      GROUP BY customer_id) AS account_summary \nON c.customer_id = account_summary.customer_id \nORDER BY account_count ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\",\n        \"virtual_table\": \"SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id\"\n    }\n}\n"}
{"sample_id": "train.721", "db_id": "customers_card_transactions", "question": "What is the card type code with most number of cards?", "rationale": ["Identify the relevant table: Customers_Cards contains the card type codes.", "We need to count the number of cards for each card type code.", "Use GROUP BY to group the results by card_type_code.", "Use COUNT(*) to count the number of cards for each type.", "Order the results in descending order based on the count to get the most frequent card type code at the top.", "Limit the results to 1 to get only the card type code with the most number of cards."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "pred_sql": "SELECT card_type_code FROM Customers_Cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table summarizes the different types of cards issued to customers, displaying the card type codes from the 'Customers_Cards' table. The results are grouped by card type code and ordered by the frequency of each type, allowing the user to specify a limit on the number of types returned.\",\n        \"virtual_table\": \"SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.735", "db_id": "customers_card_transactions", "question": "Show the number of transaction types.", "rationale": ["The user wants to show the number of transaction types.", "To achieve this, we need to count the occurrences of each transaction type in the 'Financial_Transactions' table.", "We will use the COUNT function to aggregate the total number of transactions for each type.", "The SQL query will select the 'transaction_type' and the count of transactions, grouping the results by 'transaction_type' to get the desired summary."], "gold_sql": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, COUNT(*) as transaction_count FROM Financial_Transactions GROUP BY transaction_type", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions associated with each account from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account identifier, while the count function aggregates the total number of transactions for each account.\",\n        \"virtual_table\": \"SELECT account_id ,  count(*) FROM Financial_transactions GROUP BY account_id\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table summarizes the different types of cards issued to customers, displaying the card type codes from the 'Customers_Cards' table. The results are grouped by card type code and ordered by the frequency of each type, allowing the user to specify a limit on the number of types returned.\",\n        \"virtual_table\": \"SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.743", "db_id": "customers_card_transactions", "question": "What is the transaction type that has processed the greatest total amount in transactions?", "rationale": ["We need to find the transaction type with the greatest total amount in transactions.", "To do this, we will select the 'transaction_type' and the sum of 'transaction_amount' from the 'Financial_Transactions' table.", "We will group the results by 'transaction_type' to aggregate the amounts for each type.", "Next, we will order the results in descending order based on the total amount to get the highest one at the top.", "Finally, we will limit the results to just one record to get the transaction type with the greatest total amount."], "gold_sql": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, SUM(transaction_amount) AS total_amount \nFROM Financial_Transactions \nGROUP BY transaction_type \nORDER BY total_amount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions associated with each account from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account identifier, while the count function aggregates the total number of transactions for each account.\",\n        \"virtual_table\": \"SELECT account_id ,  count(*) FROM Financial_transactions GROUP BY account_id\"\n    }\n}\n"}
{"sample_id": "train.893", "db_id": "insurance_fnol", "question": "What are the customer phone numbers under the policy \"Life Insurance\"?", "rationale": ["Identify the relevant tables: Available_Policies, Customers_Policies, and Customers.", "We need to retrieve customer phone numbers, which are in the Available_Policies table.", "Join the Available_Policies table with the Customers_Policies table on Policy_ID to link policies to customers.", "Join the Customers_Policies table with the Customers table on Customer_ID to access customer details.", "Filter the results to only include policies of type 'Life Insurance' using a WHERE clause."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "pred_sql": "SELECT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nJOIN Customers c ON cp.Customer_ID = c.Customer_ID \nWHERE ap.policy_type_code = 'Life Insurance';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.895", "db_id": "insurance_fnol", "question": "Which policy type has the most records in the database?", "rationale": ["Identify the table that contains policy types, which is 'Available_Policies'.", "We need to group the records by 'policy_type_code' to count how many records exist for each type.", "Use the COUNT function to count the occurrences of each policy type.", "Order the results in descending order to get the most common policy type at the top.", "Limit the results to 1 to get only the policy type with the most records."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "pred_sql": "SELECT policy_type_code FROM Available_Policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.897", "db_id": "insurance_fnol", "question": "What are all the customer phone numbers under the most popular policy type?", "rationale": ["Identify the most popular policy type by counting occurrences in the Available_Policies table.", "Use a subquery to select the policy_type_code that has the highest count, limiting the result to 1.", "Join the Available_Policies table with the Customers_Policies table to link policies to customers.", "Select distinct customer phone numbers from the Available_Policies table where the policy type matches the most popular policy type."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nJOIN (\n    SELECT policy_type_code \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    ORDER BY count(*) DESC \n    LIMIT 1\n) AS most_popular_policy ON ap.policy_type_code = most_popular_policy.policy_type_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.898", "db_id": "insurance_fnol", "question": "Find the phone numbers of customers using the most common policy type among the available policies.", "rationale": ["Identify the goal: We need to find the phone numbers of customers who are using the most common policy type.", "Understand the schema: We have tables for Customers, Policies, and a table that links customers to their policies.", "Use the hint provided: The hint gives a virtual table that summarizes policy types and identifies the most common one.", "Construct a subquery to find the most common policy type using the provided virtual table structure.", "Join the Customers table with Customers_Policies to link customers to their policies.", "Join the Available_Policies table to filter by the most common policy type found in the subquery.", "Select the Customer_Phone from the resulting joined tables."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT c.Customer_Phone \nFROM Customers c \nJOIN Customers_Policies cp ON c.Customer_ID = cp.Customer_ID \nJOIN Available_Policies ap ON cp.Policy_ID = ap.Policy_ID \nWHERE ap.policy_type_code = (\n    SELECT policy_type_code \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    ORDER BY count(*) DESC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1060", "db_id": "match_season", "question": "Show the players from college UCLA.", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their college.", "Determine the condition: We need to filter players based on their college, specifically those who attended UCLA.", "Use a subquery: Since the 'player' table does not directly contain college information, we will use a subquery to find the teams associated with UCLA from the 'match_season' table.", "Construct the subquery: The subquery will select 'Team_id' from 'match_season' where 'College' is 'UCLA'.", "Combine the main query and subquery: The main query will select 'Player' from the 'player' table where the 'Team' is in the result of the subquery."], "gold_sql": "SELECT Player FROM match_season WHERE College  =  'UCLA'", "source_tables": ["match_season"], "pred_sql": "SELECT Player FROM player WHERE Team IN (SELECT Team_id FROM match_season WHERE College = 'UCLA');", "hint": "\n"}
{"sample_id": "train.1082", "db_id": "match_season", "question": "Show the season, the player, and the name of the team that players belong to.", "rationale": ["The user wants to retrieve the season, player, and team name.", "We need to access the 'match_season' table to get the season and player information.", "To get the team name associated with each player, we will join the 'match_season' table with the 'team' table using the 'Team' identifier.", "The SQL query will select the 'Season' and 'Player' from 'match_season' and the 'Name' from 'team'."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "pred_sql": "SELECT T1.Season, T1.Player, T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team = T2.Team_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of match seasons, including the season name, player name, and the corresponding team name. The data is retrieved from the 'match_season' table, which is joined with the 'team' table to associate each player with their respective team using the team identifier.\",\n        \"virtual_table\": \"SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\",\n        \"virtual_table\": \"SELECT T2.Season ,  T2.Player ,  T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country\"\n    }\n}\n"}
{"sample_id": "train.1092", "db_id": "match_season", "question": "Show the country names and the corresponding number of players.", "rationale": ["We need to show the country names and the corresponding number of players.", "To achieve this, we will join the 'country' table with the 'match_season' table using the country identifier.", "The 'country' table contains the country names, and the 'match_season' table contains the players associated with those countries.", "We will use a COUNT function to count the number of players for each country.", "Finally, we will group the results by country name to get the count for each individual country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "pred_sql": "SELECT T1.Country_name, COUNT(T2.Player) AS Number_of_Players \nFROM country AS T1 \nJOIN match_season AS T2 ON T1.Country_id = T2.Country \nGROUP BY T1.Country_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct official native languages of countries represented by players in a specific position during matches. The placeholder in the WHERE clause represents the player's position.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T1.Official_native_language) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\",\n        \"virtual_table\": \"SELECT T2.Season ,  T2.Player ,  T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country\"\n    }\n}\n"}
{"sample_id": "train.1098", "db_id": "match_season", "question": "Show the top 3 most common colleges of players in match seasons.", "rationale": ["We need to find the top 3 most common colleges of players in match seasons.", "To do this, we will query the 'match_season' table, which contains a column for 'College'.", "We will use the COUNT function to count how many players are associated with each college.", "We will group the results by 'College' to aggregate the counts for each college.", "To get the most common colleges, we will order the results in descending order based on the count of players.", "Finally, we will limit the results to the top 3 colleges."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as College_Count FROM match_season GROUP BY College ORDER BY College_Count DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\",\n        \"virtual_table\": \"SELECT T2.Season ,  T2.Player ,  T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of match seasons, including the season name, player name, and the corresponding team name. The data is retrieved from the 'match_season' table, which is joined with the 'team' table to associate each player with their respective team using the team identifier.\",\n        \"virtual_table\": \"SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id\"\n    }\n}\n"}
{"sample_id": "train.1099", "db_id": "match_season", "question": "What are the three colleges from which the most players are from?", "rationale": ["Identify the relevant table: The 'match_season' table contains the 'College' column and player information.", "We need to count the number of players from each college, so we will use the COUNT() function.", "Group the results by 'College' to aggregate the player counts for each college.", "Order the results in descending order based on the player count to get the colleges with the most players at the top.", "Limit the results to the top three colleges using LIMIT 3."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as Player_Count \nFROM match_season \nGROUP BY College \nORDER BY Player_Count DESC \nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.1107", "db_id": "match_season", "question": "Return the names of countries that have players that play the Forward position, as well as players who play the Defender position.", "rationale": ["We need to find the names of countries that have players in specific positions (Forward and Defender).", "To do this, we will join the 'country' table with the 'match_season' table on the country identifier (Country_id).", "We will filter the results based on the player's position using a WHERE clause that checks if the position is either 'Forward' or 'Defender'.", "Finally, we will select distinct country names to avoid duplicates in the results."], "gold_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "pred_sql": "SELECT DISTINCT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id = T2.Country WHERE T2.Position IN ('Forward', 'Defender')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct official native languages of countries represented by players in a specific position during matches. The placeholder in the WHERE clause represents the player's position.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T1.Official_native_language) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\",\n        \"virtual_table\": \"SELECT T2.Season ,  T2.Player ,  T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country\"\n    }\n}\n"}
