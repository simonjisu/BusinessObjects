{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["Identify the relevant tables: We need to retrieve staff information, which is in the 'Staff' table, and their assignment details from the 'Staff_Department_Assignments' table.", "Determine the criteria: We want to find the staff member who has been assigned for the least amount of time. This can be determined by looking at the 'date_assigned_from' column in the 'Staff_Department_Assignments' table.", "Use a subquery to find the staff ID with the earliest 'date_assigned_from': We can order the assignments by 'date_assigned_from' in ascending order and limit the result to 1 to get the earliest assignment.", "Join the results with the 'Staff' table: We need to retrieve the staff name along with the staff ID, so we will join the 'Staff' table with the result of our subquery using the staff ID."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Staff_Department_Assignments ORDER BY date_assigned_from ASC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\",\n        \"virtual_table\": \"SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4753", "db_id": "department_store", "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.", "rationale": ["Identify the requirement to find distinct customer IDs who made orders after cancelled orders.", "Use a subquery to find the minimum order date for orders that have a status of 'Cancelled'.", "The main query selects distinct customer IDs from the 'Customer_Orders' table where the order date is greater than the date obtained from the subquery."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "pred_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date > (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code = 'Cancelled')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The date is determined by finding the earliest order date associated with a particular order status, represented by a placeholder.\",\n        \"virtual_table\": \"SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4755", "db_id": "department_store", "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?", "rationale": ["Identify the requirement to find staff IDs who had assignments earlier than any Clerical Staff.", "Use the provided virtual table structure to create a subquery that finds the maximum end date of assignments for Clerical staff.", "The subquery will be: (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical').", "The main query will select staff_id from Staff_Department_Assignments where the date_assigned_to is less than the result of the subquery."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "pred_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to < (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\",\n        \"virtual_table\": \"SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to join these tables to access customer names and their addresses.", "The Customers table contains customer names and IDs, while the Addresses table contains address details.", "The Customer_Addresses table serves as a bridge between Customers and Addresses, linking customer IDs to address IDs.", "Use a JOIN operation to combine these tables based on their relationships: Customers to Customer_Addresses on customer_id, and Customer_Addresses to Addresses on address_id.", "Filter the results to include only those addresses that contain 'TN' in their address details using the LIKE operator."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "pred_sql": "SELECT c.customer_name, c.customer_id \nFROM Customers c \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nJOIN Addresses a ON ca.address_id = a.address_id \nWHERE a.address_details LIKE '%TN%';", "hint": "\n"}
{"sample_id": "train.4760", "db_id": "department_store", "question": "What are the names and genders of staff who were assigned in 2016?", "rationale": ["Identify the relevant tables: 'Staff' for staff details and 'Staff_Department_Assignments' for assignment dates.", "We need to select the staff names and genders, which are in the 'Staff' table.", "Join the 'Staff' table with the 'Staff_Department_Assignments' table on 'staff_id' to link staff members with their assignments.", "Filter the results to include only those assignments that started in 2016 by using a WHERE clause with a date condition that checks if 'date_assigned_from' starts with '2016'."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT T1.staff_name, T1.staff_gender FROM Staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id = T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\",\n        \"virtual_table\": \"SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["Identify the staff members who have been assigned to multiple jobs.", "To do this, we can use the Staff_Department_Assignments table to group by staff_id and count the distinct job_title_code for each staff member.", "We will filter those groups to only include staff members with a count greater than 1, indicating multiple job assignments.", "Finally, we will join this result with the Staff table to get the names of those staff members."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Staff_Department_Assignments GROUP BY staff_id HAVING COUNT(DISTINCT job_title_code) > 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the staff members' IDs and genders from the 'Staff' table who are assigned to a specific job title. The placeholder in the WHERE clause represents the job title code.\",\n        \"virtual_table\": \"SELECT T1.staff_id ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.job_title_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["Identify the relevant table: Customers, which contains customer_id, customer_name, customer_address, and payment_method_code.", "Filter customers based on their address containing 'WY'. This can be done using the LIKE operator with a wildcard: '%WY%'.", "Exclude customers who use a credit card for payment by checking that payment_method_code is not equal to 'CREDIT_CARD'.", "Combine these conditions in the WHERE clause of the SQL query to retrieve the desired customer ids and names."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name \nFROM Customers \nWHERE customer_address LIKE '%WY%' \nAND payment_method_code != 'CREDIT_CARD';", "hint": "\n"}
{"sample_id": "train.4793", "db_id": "department_store", "question": "Find the average price of all product clothes.", "rationale": ["Identify the table that contains product information, which is the 'Products' table.", "Determine the relevant column for price, which is 'product_price'.", "To find the average price, use the AVG() function.", "Filter the products to only include those that are classified as clothes by using a WHERE clause on 'product_type_code'.", "Construct the SQL query to select the average price from the Products table where the product type is clothes."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "pred_sql": "SELECT AVG(product_price) AS average_price\nFROM Products\nWHERE product_type_code = 'clothes';", "hint": "\n"}
{"sample_id": "train.4795", "db_id": "department_store", "question": "Find the name of the most expensive hardware product.", "rationale": ["Identify the relevant table: Products.", "Determine the criteria for 'hardware' products, which is indicated by the product_type_code.", "Select the product_name from the Products table.", "Order the results by product_price in descending order to get the most expensive product at the top.", "Limit the results to 1 to get only the most expensive hardware product."], "gold_sql": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1", "source_tables": ["products"], "pred_sql": "SELECT product_name FROM Products WHERE product_type_code = 'hardware' ORDER BY product_price DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["Identify the relevant table: The 'product' table contains the 'max_page_size' and 'product_id' columns.", "Group the results by 'max_page_size' to aggregate products with the same page size.", "Use the HAVING clause to filter groups where the count of 'product_id' is greater than 3, indicating more than 3 products listed for that page size."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING COUNT(product_id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4903", "db_id": "store_product", "question": "What is the maximum page size for everything that has more than 3 products listed?", "rationale": ["Identify the requirement: We need to find the maximum page size for products that have more than 3 stores listing them.", "To achieve this, we will use a subquery to first find all products that are listed in more than 3 stores.", "The subquery will group the 'store_product' table by 'Product_ID' and count the number of 'Store_ID' entries for each product.", "We will use the HAVING clause to filter these groups to only include those with a count greater than 3.", "Next, we will use this subquery in the main query to select the 'max_page_size' from the 'product' table for those products that meet the criteria."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size FROM product WHERE product_id IN (SELECT Product_ID FROM store_product GROUP BY Product_ID HAVING COUNT(Store_ID) > 3);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4913", "db_id": "store_product", "question": "What is the total number of residents for the districts with the 3 largest areas?", "rationale": ["Identify the requirement to find the total number of residents in districts with the largest areas.", "Determine that we need to sum the population of districts, which is stored in the 'City_Population' column of the 'district' table.", "To find the districts with the largest areas, we will order the districts by 'City_Area' in descending order and limit the results to the top 3.", "Use a subquery to select the 'District_ID' of these top 3 districts based on area.", "Finally, sum the 'City_Population' for these selected districts to get the total number of residents."], "gold_sql": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3", "source_tables": ["district"], "pred_sql": "SELECT SUM(City_Population) AS Total_Residents \nFROM district \nWHERE District_ID IN (\n    SELECT District_ID \n    FROM district \n    ORDER BY City_Area DESC \n    LIMIT 3\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of stores grouped by the city where their respective districts are headquartered. The placeholders in the query represent the relationships between stores and districts, allowing for aggregation of store counts based on the city names.\",\n        \"virtual_table\": \"SELECT t3.headquartered_city ,  count(*) FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in each city, with a limit on the number of cities returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["Identify the relevant tables: store, store_district, and district are needed to find stores in a specific district.", "Join the store table with the store_district table on Store_ID to link stores to their respective districts.", "Join the resulting table with the district table on District_ID to access district names.", "Filter the results where the District_name is 'Khanewal' to get only those stores located in Khanewal District.", "Select the Store_Name from the filtered results to get the names of the stores."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT s.Store_Name FROM store AS s JOIN store_district AS sd ON s.Store_ID = sd.Store_ID JOIN district AS d ON sd.District_ID = d.District_ID WHERE d.District_name = 'Khanewal'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in each city, with a limit on the number of cities returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of stores grouped by the city where their respective districts are headquartered. The placeholders in the query represent the relationships between stores and districts, allowing for aggregation of store counts based on the city names.\",\n        \"virtual_table\": \"SELECT t3.headquartered_city ,  count(*) FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city\"\n    }\n}\n"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["Identify the tables involved: store, store_district, and district.", "Join the store table with store_district on Store_ID to link stores to their respective districts.", "Join the resulting table with the district table on District_ID to access the city information.", "Group the results by the Headquartered_City to count the number of stores in each city.", "Order the results by the count of stores in descending order to find the city with the most stores.", "Limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT t3.Headquartered_City FROM store AS t1 JOIN store_district AS t2 ON t1.Store_ID = t2.Store_ID JOIN district AS t3 ON t2.District_ID = t3.District_ID GROUP BY t3.Headquartered_City ORDER BY COUNT(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in each city, with a limit on the number of cities returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of stores grouped by the city where their respective districts are headquartered. The placeholders in the query represent the relationships between stores and districts, allowing for aggregation of store counts based on the city names.\",\n        \"virtual_table\": \"SELECT t3.headquartered_city ,  count(*) FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city\"\n    }\n}\n"}
{"sample_id": "train.4930", "db_id": "store_product", "question": "Find products with max page size as \"A4\" and pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to filter products based on 'max_page_size' being 'A4' and 'pages_per_minute_color' being less than 5.", "Construct the SQL query: Use the SELECT statement to retrieve the 'product' column from the 'product' table, applying the specified conditions in the WHERE clause."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE max_page_size = 'A4' AND pages_per_minute_color < 5", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4932", "db_id": "store_product", "question": "Find products with max page size as \"A4\" or pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to find products with a maximum page size of 'A4' or a pages per minute color speed less than 5.", "Use the OR operator: Since we are looking for products that meet either of the two conditions, we will use the OR operator in the WHERE clause.", "Construct the SQL query: Based on the conditions and the structure of the 'product' table, we can construct the SQL query."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < 5", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4935", "db_id": "store_product", "question": "What are all of the products whose name includes the substring \"Scanner\"?", "rationale": ["Identify the relevant table: The 'product' table contains the information about products.", "Determine the required condition: We need to find products whose name includes the substring 'Scanner'.", "Use the SQL LIKE operator: The LIKE operator allows us to search for a specified pattern in a column.", "Construct the SQL query: We will select the 'product' column from the 'product' table where the 'product' name matches the pattern '%Scanner%'."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4937", "db_id": "store_product", "question": "What is the most common maximum page size?", "rationale": ["Identify the relevant table: The 'product' table contains the 'max_page_size' column which is needed to answer the question.", "Determine the goal: We need to find the most common maximum page size, which implies counting occurrences of each maximum page size.", "Use GROUP BY: To count how many times each maximum page size appears, we will group the results by 'max_page_size'.", "Count occurrences: Use COUNT(*) to count the number of products for each maximum page size.", "Order results: To find the most common maximum page size, we will order the results in descending order based on the count.", "Limit results: Since we only want the most common maximum page size, we will limit the results to 1."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1", "source_tables": ["product"], "pred_sql": "SELECT max_page_size, COUNT(*) as count FROM product GROUP BY max_page_size ORDER BY count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4938", "db_id": "store_product", "question": "Find the name of the products that are not using the most frequently-used max page size.", "rationale": ["Identify the requirement to find products that do not use the most frequently-used max page size.", "To achieve this, we need to first determine what the most frequently-used max page size is.", "We can do this by using a subquery that selects the maximum value of max_page_size from the product table.", "Then, we can select products from the product table where the max_page_size is not equal to this maximum value."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE max_page_size != (SELECT max(max_page_size) FROM product)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["Identify the table that contains the enrollment information, which is the 'College' table.", "To find the average number of students enrolled in each college, we need to use the AVG() function on the 'enr' column.", "The query should select the average enrollment from the 'College' table without any additional filtering, as we want the overall average for all colleges."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "pred_sql": "SELECT AVG(enr) AS average_enrollment FROM College;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\",\n        \"virtual_table\": \"SELECT cName FROM college WHERE enr  >  (SELECT max(enr) FROM college WHERE state  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["The question asks for the average training hours of players.", "Since the schema does not explicitly mention training hours, we will assume that the 'HS' column in the Player table represents some form of training hours or is a proxy for it.", "We need to join the Player table with the Tryout table to ensure we are only considering players who participated in tryouts.", "The average can be calculated using the AVG() function in SQL.", "The final SQL query will select the average of the 'HS' column from the Player table after performing the necessary join."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT avg(T1.HS) FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4956", "db_id": "soccer_2", "question": "Find the name and training hours of players whose hours are below 1500.", "rationale": ["The query needs to find players whose training hours are below 1500.", "Since the training hours are not directly available in the provided schema, we need to infer that the decision in the Tryout table might indicate whether a player's hours are below a certain threshold.", "We will select player names from the Player table where their IDs match those in the Tryout table with a decision indicating they are below 1500.", "The final SQL query will use a subquery to filter players based on their IDs from the Tryout table."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE decision = 'below 1500')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\",\n        \"virtual_table\": \"SELECT pName FROM Player WHERE yCard  =  [PLACEHOLDER-TYPE:STRING] ORDER BY HS DESC\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who attended high schools with an enrollment number less than a specified value. The placeholder in the WHERE clause represents the enrollment number of students.\",\n        \"virtual_table\": \"SELECT pName ,  HS FROM Player WHERE HS  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4961", "db_id": "soccer_2", "question": "What are the different types of player positions?", "rationale": ["The question asks for the different types of player positions.", "To find the different types of player positions, we need to select the 'pPos' column from the 'Tryout' table.", "Using 'DISTINCT' will ensure that we only get unique player positions without duplicates."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT pPos FROM Tryout;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\",\n        \"virtual_table\": \"SELECT pName FROM Player WHERE yCard  =  [PLACEHOLDER-TYPE:STRING] ORDER BY HS DESC\"\n    }\n}\n"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["The question asks for the number of students accepted after the tryout.", "To find this, we need to count the entries in the 'Tryout' table where the decision is 'accepted'.", "The SQL query will use the COUNT() function to count these entries.", "The final SQL query will be: SELECT COUNT(*) FROM tryout WHERE decision = 'accepted';"], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) FROM tryout WHERE decision = 'accepted';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["Identify the need to calculate maximum, average, and minimum training hours of players.", "Understand that training hours can be derived from the number of tryouts each player has participated in.", "Create a subquery to count the number of tryouts for each player, which will represent their training hours.", "Use the outer query to calculate the max, avg, and min of these training hours from the subquery."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT max(training_hours), avg(training_hours), min(training_hours) FROM (SELECT pID, COUNT(*) AS training_hours FROM Tryout GROUP BY pID) AS training_data;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4967", "db_id": "soccer_2", "question": "What is the average, maximum, and minimum for the number of hours spent training?", "rationale": ["The question asks for the average, maximum, and minimum hours spent training, which implies we need to calculate these statistics from a relevant column.", "The hint provided mentions a virtual table that calculates average and maximum values from the 'Player' table based on a decision from the 'Tryout' table.", "To get the minimum value as well, we need to include the min() function in our SQL query.", "We will join the 'Player' table with the 'Tryout' table on the player ID (pID) to filter players based on their tryout decisions.", "The WHERE clause will specify a decision, which is currently a placeholder in the hint. We will replace it with a specific decision for our query."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT avg(T1.HS) AS average_hours, max(T1.HS) AS max_hours, min(T1.HS) AS min_hours FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'specific_decision'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4970", "db_id": "soccer_2", "question": "What are the names of players whose training hours is between 500 and 1500?", "rationale": ["The question asks for the names of players whose training hours are between 500 and 1500.", "We need to select the player names from the Player table.", "We will join the Player table with the Tryout table on the player ID (pID) to filter based on tryout decisions.", "The decision regarding the player's tryout is assumed to be 'accepted' for this query, as it is a common decision type.", "We will apply a condition to filter players based on their training hours being between 500 and 1500."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT T1.pName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'accepted' AND T1.training_hours BETWEEN 500 AND 1500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\",\n        \"virtual_table\": \"SELECT pName FROM Player WHERE yCard  =  [PLACEHOLDER-TYPE:STRING] ORDER BY HS DESC\"\n    }\n}\n"}
{"sample_id": "train.4971", "db_id": "soccer_2", "question": "What are the names of players who train between 500 and 1500 hours?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find player names, so we will select 'pName' from the Player table.", "We need to join the Player table with the Tryout table on 'pID' to link players with their tryout decisions.", "The question specifies a range of training hours (500 to 1500), so we will filter the results based on this condition.", "Assuming that the decision made regarding the player's tryout is 'accepted', we will include this condition in the WHERE clause."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT T1.pName FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'accepted' AND T2.hours BETWEEN 500 AND 1500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4975", "db_id": "soccer_2", "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?", "rationale": ["Identify the relevant table: The question pertains to colleges, so we will use the 'College' table.", "Determine the columns needed: We need the names of the colleges (cName) and their enrollment numbers (enr).", "Set the conditions: We need colleges with an enrollment number greater than 10000 and located in Louisiana.", "Construct the SQL query: Using the SELECT statement to retrieve cName and enr from the College table with the specified conditions."], "gold_sql": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = 'LA'", "source_tables": ["college"], "pred_sql": "SELECT cName, enr FROM College WHERE enr > 10000 AND state = 'Louisiana'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\",\n        \"virtual_table\": \"SELECT cName FROM college WHERE enr  >  (SELECT max(enr) FROM college WHERE state  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who attended high schools with an enrollment number less than a specified value. The placeholder in the WHERE clause represents the enrollment number of students.\",\n        \"virtual_table\": \"SELECT pName ,  HS FROM Player WHERE HS  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4981", "db_id": "soccer_2", "question": "What are the name of the players who received a card in descending order of the hours of training?", "rationale": ["The question asks for the names of players who received a card, which implies we need to select from the 'Player' table.", "The hint suggests that we can use a virtual table that selects player names and orders them by high school attended.", "Since the question specifies ordering in descending order, we will use 'ORDER BY HS DESC'.", "We do not have a specific year of eligibility or decision mentioned in the question, so we will select all players without filtering by 'yCard' or 'decision'."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player ORDER BY HS DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\",\n        \"virtual_table\": \"SELECT pName FROM Player WHERE yCard  =  [PLACEHOLDER-TYPE:STRING] ORDER BY HS DESC\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["Identify the relevant table: The 'Tryout' table contains the positions players are trying out for.", "Count the occurrences of each position: Use COUNT(*) to count how many players are trying out for each position.", "Group the results by position: Use GROUP BY pPos to aggregate the counts for each position.", "Order the results: Use ORDER BY position_count DESC to sort the positions by their popularity in descending order.", "Limit the results to the most popular position: Use LIMIT 1 to get only the top result."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["To find the most popular position at tryouts, we need to count how many players tried out for each position.", "We can achieve this by selecting the position (pPos) from the Tryout table and counting the occurrences of each position.", "We will group the results by the position to get the count for each one.", "To determine which position is the most popular, we will order the results by the count in descending order.", "Finally, we will limit the results to just one entry to get the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count FROM Tryout GROUP BY pPos ORDER BY position_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["Identify the relevant tables: We need to look at the 'Tryout' table since it contains information about players and their positions.", "Determine the required information: We need to find the minimum hours played by students in different positions.", "Assume there is a column for hours played in the Tryout table (not explicitly mentioned in the schema), we will group by position and use the MIN function to find the minimum hours for each position.", "Construct the SQL query using GROUP BY to aggregate results by position and select the minimum hours."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(hours) AS min_hours\nFROM Tryout\nGROUP BY pPos;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["Identify the required information: We need to find the minimum time students spent practicing for each position.", "Determine the relevant tables: The 'Practice' table is assumed to contain the practice times associated with each player's position.", "Use aggregation: We will use the MIN function to find the minimum practice time for each position.", "Group the results: We will group the results by position (pPos) to get the minimum time for each one."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(practice_time) AS min_practice_time\nFROM Practice\nGROUP BY pPos;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["Identify the tables involved: Player and Tryout.", "We need the names of players, which are in the Player table (column pName).", "We also need the hours spent practicing, which is not directly mentioned in the schema but can be assumed to be part of the Tryout table based on the context of the question.", "Join the Player table with the Tryout table on the pID column to link players with their tryout decisions.", "Filter the results to include only those players who received a 'yes' decision in their tryouts."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT T1.pName, T2.hours_spent_practicing FROM player AS T1 JOIN tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["Identify the relevant tables: We need to retrieve player names based on their tryout decisions and positions, so we will use the 'Player' and 'Tryout' tables.", "Determine the join condition: The 'Player' table can be joined with the 'Tryout' table using the 'pID' column, which is common to both tables.", "Specify the selection criteria: We are interested in players who had a successful tryout for the position of striker. This means we need to filter the results where 'decision' is 'successful' and 'pPos' is 'striker'.", "Construct the SQL query: Using the identified tables, join condition, and selection criteria, we can construct the SQL query to retrieve the names of the players."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'successful' AND T2.pPos = 'striker'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["The question asks for the average number of hours spent practicing for students who got rejected.", "We need to find players who participated in tryouts and received a 'rejected' decision.", "To do this, we will join the Player table with the Tryout table on the player ID (pID).", "We will then filter the results to only include those where the decision is 'rejected'.", "Finally, we will calculate the average of the hours spent practicing, which is represented by the HS column in the Player table."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT avg(T1.HS) FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'rejected'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5018", "db_id": "soccer_2", "question": "Which college has any student who is a goalie and succeeded in the tryout.", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find colleges that have students who are goalies and succeeded in their tryouts.", "Join the College table with the Tryout table on the college name (cName).", "Filter the results where the decision is 'succeeded' and the position (pPos) is 'goalie'.", "Select distinct college names to avoid duplicates."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT T1.cName \nFROM College AS T1 \nJOIN Tryout AS T2 ON T1.cName = T2.cName \nWHERE T2.decision = 'succeeded' AND T2.pPos = 'goalie';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find the state and enrollment of colleges where students got accepted in the tryout decision.", "The Tryout table contains the decision made regarding players' tryouts, so we will filter this table for the decision 'accepted'.", "We will join the College table with the Tryout table on the college name (cName) to get the relevant information from both tables.", "Select the state and enrollment number (enr) from the College table where the decision in the Tryout table is 'accepted'."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT C.state, C.enr FROM College AS C JOIN Tryout AS T ON C.cName = T.cName WHERE T.decision = 'accepted';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["Identify the colleges that have accepted students during tryouts by using the Tryout table to filter for decisions that indicate acceptance.", "Join the College table with the Tryout table on the college name to get the relevant colleges.", "Use a subquery to select distinct college names from the Tryout table where the decision is 'accepted'.", "In the main query, sum the enrollment numbers of these colleges, ensuring to convert the enrollment number from text to integer for accurate summation.", "Group the results by state to get the total enrollment per state for colleges that accepted students."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT SUM(CAST(enr AS INTEGER)) AS total_enrollment, state FROM College WHERE cName IN (SELECT DISTINCT T1.cName FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName WHERE T2.decision = 'accepted') GROUP BY state;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5026", "db_id": "soccer_2", "question": "Find the names of schools that have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant table: The 'Tryout' table contains information about players and their positions.", "Determine the required columns: We need the 'cName' column to find the names of schools.", "Filter the results: We want to find schools where players are trying out for either 'goalie' or 'mid' positions.", "Use the DISTINCT keyword: To ensure that we only get unique college names, we will use DISTINCT in our query."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT cName FROM Tryout WHERE pPos IN ('goalie', 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5028", "db_id": "soccer_2", "question": "Find the names of states that have some college students playing in goalie and mid positions.", "rationale": ["We need to find distinct states where colleges have students playing in specific positions (goalie and mid).", "To achieve this, we will join the College table with the Tryout table on the college name (cName).", "We will filter the results based on the positions specified (goalie and mid) using the IN clause in the WHERE statement.", "Finally, we will select distinct states from the resulting joined table to avoid duplicates."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT T1.state \nFROM College AS T1 \nJOIN Tryout AS T2 ON T1.cName = T2.cName \nWHERE T2.pPos IN ('goalie', 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5029", "db_id": "soccer_2", "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find distinct states from the College table where players are trying out for specific positions.", "Join the College table with the Tryout table on the college name (cName).", "Filter the results based on the positions of 'goalie' and 'mid-field' using the IN clause.", "Select distinct states from the filtered results."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT T1.state \nFROM College AS T1 \nJOIN Tryout AS T2 ON T1.cName = T2.cName \nWHERE T2.pPos IN ('goalie', 'mid-field')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["Identify the positions of interest: goalie and mid.", "Use the Tryout table to filter for players trying out for these positions.", "Count the distinct colleges (cName) from the filtered results to avoid duplicates."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(DISTINCT cName) FROM Tryout WHERE pPos IN ('goalie', 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who have a specific decision regarding their tryout. The placeholder in the WHERE clause represents the decision made about the player's tryout.\",\n        \"virtual_table\": \"SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5037", "db_id": "soccer_2", "question": "What is the count of states with college students playing in the mid position but not as goalies?", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to count distinct states, so we will use COUNT(DISTINCT state).", "Join the College table with the Tryout table on the college name (cName).", "Filter the results to include only players who are playing in the 'mid' position and not as goalies.", "Assume that 'accepted' is the decision indicating participation in the tryout for the mid position.", "Construct the SQL query using the identified conditions."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')", "source_tables": ["tryout", "college"], "pred_sql": "SELECT COUNT(DISTINCT T1.state) FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName WHERE T2.decision = 'accepted' AND T2.pPos = 'mid'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["Identify the requirement to find states with colleges that have enrollments less than some other college.", "To achieve this, we need to compare the enrollment numbers of colleges.", "We can use a subquery to find the maximum enrollment number from the College table.", "The outer query will select distinct states from the College table where the enrollment is less than the maximum enrollment found in the subquery."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE enr < (SELECT MAX(enr) FROM College)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\",\n        \"virtual_table\": \"SELECT cName FROM college WHERE enr  >  (SELECT max(enr) FROM college WHERE state  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and high schools of players from the 'Player' table who attended high schools with an enrollment number less than a specified value. The placeholder in the WHERE clause represents the enrollment number of students.\",\n        \"virtual_table\": \"SELECT pName ,  HS FROM Player WHERE HS  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5102", "db_id": "cre_Drama_Workshop_Groups", "question": "Show the minimum, average, maximum order quantity of all invoices.", "rationale": ["Identify the relevant table: Invoices contains the order quantities we need to analyze.", "Use aggregate functions to calculate minimum, average, and maximum order quantities: MIN(), AVG(), and MAX() respectively.", "Select the Order_Quantity column from the Invoices table and apply the aggregate functions to it.", "Construct the SQL query to retrieve the minimum, average, and maximum order quantities from the Invoices table."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "pred_sql": "SELECT MIN(Order_Quantity) AS Min_Quantity, AVG(Order_Quantity) AS Avg_Quantity, MAX(Order_Quantity) AS Max_Quantity \nFROM Invoices;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n        \"virtual_table\": \"SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n        \"virtual_table\": \"SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5118", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the payment method code used by the most orders?", "rationale": ["Identify the relevant table: Invoices contains the payment_method_code and Order_ID.", "Group the results by payment_method_code to count how many orders are associated with each payment method.", "Use COUNT(Order_ID) to count the number of orders for each payment method.", "Order the results in descending order to get the payment method with the most orders at the top.", "Limit the results to 1 to get only the top payment method code."], "gold_sql": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices"], "pred_sql": "SELECT payment_method_code\nFROM Invoices\nGROUP BY payment_method_code\nORDER BY COUNT(Order_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5127", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the descriptions of the service types that cost more than 100.", "rationale": ["Identify the relevant table: The question asks for service types, which are found in the Services table.", "Determine the required columns: We need the descriptions of the service types, so we will select the 'Service_Type_Description' column.", "Filter the results: The question specifies that we only want service types that cost more than 100, so we will add a WHERE clause to filter based on 'Product_Price'.", "Construct the SQL query: Combine the selected columns, table, and filter condition into a complete SQL query."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT Service_Type_Description \nFROM Services \nWHERE Product_Price > 100;", "hint": "\n"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["Identify the relevant tables: We need to find workshop groups and services, so we will use the 'Drama_Workshop_Groups' and 'Services' tables.", "Determine the relationship: The 'Services' table has a foreign key 'Workshop_Group_ID' that links to 'Drama_Workshop_Groups'.", "Filter the services: We need to filter the services to only those with the product name 'film'.", "Select the distinct workshop group names: We want the names of the workshop groups, so we will select 'Store_Name' from 'Drama_Workshop_Groups' and ensure we get distinct values."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "pred_sql": "SELECT DISTINCT dg.Store_Name\nFROM Drama_Workshop_Groups dg\nJOIN Services s ON dg.Workshop_Group_ID = s.Workshop_Group_ID\nWHERE s.Product_Name = 'film';", "hint": "\n"}
{"sample_id": "train.5142", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the order details of the products with price higher than 2000?", "rationale": ["Identify the relevant tables: Customer_Orders, Order_Items, and Products are needed to get order details and product information.", "Select the necessary columns: We need order details (Order_ID, Order_Date, Planned_Delivery_Date, Actual_Delivery_Date) from Customer_Orders and product details (Product_Name, Product_Price) from Products.", "Join the tables: Use JOIN to connect Customer_Orders with Order_Items on Order_ID and Order_Items with Products on Product_ID.", "Apply the filter: Use a WHERE clause to filter products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT o.Order_ID, o.Order_Date, o.Planned_Delivery_Date, o.Actual_Delivery_Date, oi.Order_Quantity, p.Product_Name, p.Product_Price \nFROM Customer_Orders o \nJOIN Order_Items oi ON o.Order_ID = oi.Order_ID \nJOIN Products p ON oi.Product_ID = p.Product_ID \nWHERE p.Product_Price > 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n        \"virtual_table\": \"SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n        \"virtual_table\": \"SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["Identify the relevant tables: We need to look at the 'Invoice_Items' table for order details and the 'Products' table for product prices.", "Filter products based on price: We will filter products with a price greater than 2000 from the 'Products' table.", "Join the results: We will use a subquery to get the Product_IDs of products with a price above 2000 and use that in the main query to get the corresponding order details from 'Invoice_Items'.", "Select the required columns: We need to select Order_ID, Product_ID, and Order_Quantity from the 'Invoice_Items' table."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_ID, Product_ID, Order_Quantity FROM Invoice_Items WHERE Product_ID IN (SELECT Product_ID FROM Products WHERE Product_Price > 2000)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n        \"virtual_table\": \"SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n        \"virtual_table\": \"SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5160", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the most frequent status of bookings?", "rationale": ["Identify the relevant table: The question pertains to the 'Bookings' table, which contains the 'Status_Code' column that indicates the status of each booking.", "Count the frequency of each status: Use the COUNT() function to count how many times each 'Status_Code' appears in the 'Bookings' table.", "Group the results: Use GROUP BY to group the results by 'Status_Code' so that we can count occurrences for each unique status.", "Order the results: Use ORDER BY to sort the results by frequency in descending order, so the most frequent status appears first.", "Limit the results: Use LIMIT 1 to return only the most frequent status."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Frequency\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most common status code, which implies counting occurrences of each status code.", "Use the COUNT function: We will count how many times each status code appears in the 'Bookings' table.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each unique status code.", "Order the results: To find the most common status code, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most common status code, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Count\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["Identify the relevant tables: We need to find workshop groups and their bookings, so we will use the Drama_Workshop_Groups and Bookings tables.", "Determine the relationship: The Drama_Workshop_Groups table has a Workshop_Group_ID that links to the Bookings table's Workshop_Group_ID.", "Filter the bookings: We need to filter the bookings to only those with a status code of 'stop'.", "Select the required information: We want the names of the workshop groups, which are found in the Store_Name column of the Drama_Workshop_Groups table.", "Use DISTINCT to avoid duplicate names in the result."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "pred_sql": "SELECT DISTINCT dg.Store_Name\nFROM Drama_Workshop_Groups dg\nJOIN Bookings b ON dg.Workshop_Group_ID = b.Workshop_Group_ID\nWHERE b.Status_Code = 'stop';", "hint": "\n"}
{"sample_id": "train.5171", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the description of the service type that offers not only the photo product but also the film product.", "rationale": ["Identify the relevant tables: Ref_Service_Types for service descriptions, Services for linking services to products, and Order_Items for product details.", "Join Ref_Service_Types with Services on Service_Type_Code to get the service descriptions associated with each service.", "Join Services with Order_Items to link services to the products they offer.", "Filter the products to include only those that are 'photo' and 'film'.", "Use a subquery to find Product_IDs for 'photo' and 'film'.", "Group the results by Service_Type_Description to aggregate services that offer both products.", "Use HAVING clause to ensure that only service types offering both products are included, which means counting distinct Product_IDs should equal 2."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT DISTINCT rst.Service_Type_Description\nFROM Ref_Service_Types rst\nJOIN Services s ON rst.Service_Type_Code = s.Service_Type_Code\nJOIN Order_Items oi ON s.Product_ID = oi.Product_ID\nWHERE oi.Product_ID IN (\n    SELECT Product_ID\n    FROM Products\n    WHERE Product_Name IN ('photo', 'film')\n)\nGROUP BY rst.Service_Type_Description\nHAVING COUNT(DISTINCT oi.Product_ID) = 2;", "hint": "\n"}
{"sample_id": "train.5459", "db_id": "voter_2", "question": "Find the average age of female students.", "rationale": ["Identify the table needed: The 'Student' table contains the age and gender information.", "Determine the condition: We need to filter for female students, which is done using the 'Sex' column.", "Calculate the average: Use the AVG() function to calculate the average age of the filtered results."], "gold_sql": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  'F'", "source_tables": ["student"], "pred_sql": "SELECT avg(Age) FROM Student WHERE Sex = 'Female'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5466", "db_id": "voter_2", "question": "What are the distinct president votes on 08/30/2015?", "rationale": ["Identify the relevant table for the query, which is 'Voting_record' for the president votes.", "We need to select distinct president votes, so we will use SELECT DISTINCT President_Vote.", "The condition specifies a date, which corresponds to the 'Registration_Date' column in the Voting_record table.", "We will filter the results to only include records where the Registration_Date is '2015-08-30'."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote FROM Voting_record WHERE Registration_Date = '2015-08-30'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["The query needs to show all distinct president votes made on a specific date, which is 08/30/2015.", "To achieve this, we will select distinct values from the 'President_Vote' column in the 'Voting_record' table.", "We will filter the results based on the 'Registration_Date' column to match the specified date.", "The final SQL query will be constructed accordingly."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT President_Vote FROM Voting_record WHERE Registration_Date = '08/30/2015'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5476", "db_id": "voter_2", "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.", "rationale": ["Identify the tables involved: Student and Voting_record.", "We need to find distinct ages of students, so we will select the Age column from the Student table.", "We need to join the Student table with the Voting_record table on the condition that the StuID in Student matches the Secretary_Vote in Voting_record.", "We need to filter the results based on the Election_Cycle, which is specified as 'fall'.", "Construct the SQL query using SELECT DISTINCT to get unique ages of students who voted for the secretary candidate in the fall election cycle."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT T1.Age FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Secretary_Vote WHERE T2.Election_Cycle = 'fall'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of votes cast for the secretary position from the 'Voting_record' table during a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT Secretary_Vote FROM VOTING_RECORD WHERE ELECTION_CYCLE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["Identify the relevant tables: Student and Voting_record.", "Determine the relationship between the tables: Student's StuID is linked to Voting_record's Treasurer_Vote.", "We need to find advisors for students who voted for a treasurer in a specific election cycle, which is 'spring'.", "Use SELECT DISTINCT to get unique advisors from the Student table based on the voting records in the Voting_record table.", "Construct the SQL query using JOIN to combine the two tables on the StuID and Treasurer_Vote, and filter by the Election_Cycle."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT T1.Advisor FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Treasurer_Vote WHERE T2.Election_Cycle = 'spring'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5486", "db_id": "voter_2", "question": "How many male (sex is M) students have class senator votes in the fall election cycle?", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "Determine the condition for counting students: they must be male (Sex = 'M').", "Identify the voting record condition: they must have voted in the fall election cycle.", "Join the two tables on the student ID (StuID) and the class senator vote.", "Count the number of records that meet these conditions."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT count(*) FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Class_Senator_Vote WHERE T1.Sex = 'M' AND T2.Election_Cycle = 'fall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are registered to vote in a specific election cycle and belong to a particular gender. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "Determine the columns needed: average age from 'Student' and filtering based on city code and voting record for secretary.", "Use a JOIN to connect 'Student' and 'Voting_record' on the StuID and Secretary_Vote columns.", "Apply the WHERE clause to filter students by city code 'NYC' and the specific election cycle 'spring'.", "Construct the SQL query to calculate the average age of the filtered students."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT avg(T1.Age) FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Secretary_Vote WHERE T1.city_code = 'NYC' AND T2.Election_Cycle = 'spring'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5492", "db_id": "voter_2", "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "We need to find the average age of female students, so we will filter by 'Sex' = 'F'.", "We are interested in students who have voted for the secretary candidate, which means we will join the 'Student' table with the 'Voting_record' table on the condition that 'StuID' from 'Student' matches 'Secretary_Vote' from 'Voting_record'.", "The election cycle specified is 'spring', so we will add a condition to filter by 'Election_Cycle' = 'spring'.", "Using the average function, we can calculate the average age of the filtered results."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT avg(T1.Age) FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Secretary_Vote WHERE T1.Sex = 'F' AND T2.Election_Cycle = 'spring'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["Identify the columns needed: We need distinct first names of students, so we will select 'Fname' from the 'Student' table.", "Join the 'Student' table with the 'Voting_record' table on the condition that 'StuID' in 'Student' matches 'Vice_President_Vote' in 'Voting_record'. This will allow us to filter students based on their voting records.", "Add a WHERE clause to filter out students whose city code is 'PIT'. We want those whose city code is not 'PIT'.", "Use DISTINCT to ensure that we only get unique first names in the result."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Fname FROM Student JOIN Voting_record ON Student.StuID = Voting_record.Vice_President_Vote WHERE Student.city_code != 'PIT';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5495", "db_id": "voter_2", "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?", "rationale": ["Identify the requirement to find distinct first names of students.", "The relevant table for student information is the 'Student' table, which contains the 'Fname' column.", "The 'Voting_record' table is needed to check for vice president votes, specifically the 'Vice_President_Vote' column.", "We need to filter students who have voted for the vice president, which means we will check for non-null values in the 'Vice_President_Vote' column.", "Additionally, we need to ensure that the city code of the students is not 'PIT'.", "To achieve this, we will use a subquery to get the StuIDs of students who voted for the vice president and then filter the main query based on this condition and the city code condition."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Fname FROM Student WHERE StuID IN (SELECT StuID FROM Voting_record WHERE Vice_President_Vote IS NOT NULL) AND city_code != 'PIT';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5496", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is not 2192.", "rationale": ["Identify the requirement to find distinct last names of students who voted for president.", "The relevant table for student information is 'Student' and for voting records is 'Voting_record'.", "We need to filter students based on their votes for president, which corresponds to the 'President_Vote' column in the 'Voting_record' table.", "We also need to ensure that the advisor of these students is not '2192'.", "To achieve this, we will use a subquery to select all 'StuID's from 'Voting_record' where they voted for president.", "Finally, we will select distinct last names from the 'Student' table where the 'StuID' is in the result of the subquery and the advisor is not '2192'."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student WHERE StuID IN (SELECT President_Vote FROM Voting_record) AND Advisor != '2192';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5499", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes and have 8741 as the advisor?", "rationale": ["Identify the requirement to find distinct last names of students who voted for president.", "The relevant table for student information is 'Student' and for voting records is 'Voting_record'.", "We need to filter students based on their votes for president, which corresponds to the 'President_Vote' column in the 'Voting_record' table.", "We also need to filter students whose advisor is '8741'.", "To achieve this, we can use a subquery to select the 'President_Vote' from 'Voting_record' and then filter the 'Student' table based on this subquery and the advisor condition."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student WHERE StuID IN (SELECT President_Vote FROM Voting_record) AND Advisor = '8741';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and sex.", "Filter the records: We need to focus on female students, so we will add a WHERE clause to filter by Sex = 'F'.", "Group the results: To find the most common major, we will group the results by the Major column.", "Count occurrences: We will order the grouped results by the count of students in each major in descending order to find the most common one.", "Limit the results: Since we only want the most common major, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student WHERE Sex = 'F' GROUP BY Major ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major field of study. The results are ordered by the number of students in each major in descending order, with a limit on the number of majors returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are registered to vote in a specific election cycle and belong to a particular gender. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and gender.", "Filter for female students: We need to focus on female students, so we will add a WHERE clause to filter by Sex = 'Female'.", "Group by major: To find out how many female students are in each major, we will group the results by the Major column.", "Count the number of female students in each major: We will use COUNT(*) to count the number of students in each major after filtering and grouping.", "Order the results: We want to order the results in descending order based on the count of female students, so we will use ORDER BY COUNT(*) DESC.", "Limit the results: Since we only want the major with the most female students, we will limit the results to 1 using LIMIT 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student WHERE Sex = 'Female' GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major field of study. The results are ordered by the number of students in each major in descending order, with a limit on the number of majors returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are registered to vote in a specific election cycle and belong to a particular gender. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to count the number of products, so we will use the COUNT function.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to filter by category.", "Add a WHERE clause to filter for products in the 'Spices' category and with a typical selling price greater than 1000."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT count(*) FROM Products AS p JOIN Ref_Product_Categories AS pc ON p.product_category_code = pc.product_category_code WHERE pc.product_category_description = 'Spices' AND p.typical_selling_price > 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the tables needed: Products and Ref_Product_Categories.", "We need to retrieve the product category descriptions, so we will select 'product_category_description' from Ref_Product_Categories.", "Join the Products table with Ref_Product_Categories on 'product_category_code' to link products to their categories.", "Filter the products based on their descriptions containing the letter 't' using the LIKE operator with a wildcard.", "Use DISTINCT to ensure that we only get unique category descriptions."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description FROM Products AS p JOIN Ref_Product_Categories AS rpc ON p.product_category_code = rpc.product_category_code WHERE p.product_description LIKE '%t%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\",\n        \"virtual_table\": \"SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["Identify the tables involved: Products, Product_Characteristics, and Characteristics.", "Determine the relationship between these tables using their foreign keys.", "We need to count distinct characteristic names associated with the product 'cumin'.", "Use a JOIN to connect Products to Product_Characteristics and then to Characteristics.", "Filter the results where the product name is 'cumin'.", "Use the COUNT function with DISTINCT to get the number of unique characteristic names."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM Products AS t1 JOIN Product_Characteristics AS t2 ON t1.product_id = t2.product_id JOIN Characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id WHERE t1.product_name = 'cumin'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\",\n        \"virtual_table\": \"SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["Identify the tables involved: Products, Product_Characteristics, Characteristics, and Ref_Colors.", "Determine the relationships between these tables using foreign keys: Products to Product_Characteristics, Product_Characteristics to Characteristics, and Products to Ref_Colors.", "Use a JOIN operation to combine these tables based on their relationships.", "Filter the results using a WHERE clause to check for products with color description 'white' or characteristic name 'hot'.", "Count the total number of products that meet either of these conditions using COUNT(*) function."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT count(*) FROM Products AS t1 JOIN Product_Characteristics AS t2 ON t1.product_id = t2.product_id JOIN Characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id JOIN Ref_Colors AS t4 ON t1.color_code = t4.color_code WHERE t4.color_description = 'white' OR t3.characteristic_name = 'hot'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant product category for 'Herb' products.", "Join the Products table with Product_Characteristics to find product IDs associated with the 'Herb' characteristic.", "Use the characteristic name 'Herb' to filter the Characteristics table and get the corresponding characteristic IDs.", "Select the product category codes from the Products table that match the product IDs found in the previous step.", "Finally, retrieve the unit of measure from the Ref_Product_Categories table using the product category codes obtained."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT unit_of_measure FROM Ref_Product_Categories WHERE product_category_code IN (SELECT product_category_code FROM Products WHERE product_id IN (SELECT product_id FROM Product_Characteristics WHERE characteristic_id IN (SELECT characteristic_id FROM Characteristics WHERE characteristic_name = 'Herb')));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the tables needed: We need to get the product category code and unit of measure for a specific product named 'chervil'.", "The relevant tables are 'Products' for product details and 'Ref_Product_Categories' for category details.", "Join the 'Products' table with the 'Ref_Product_Categories' table on the product_category_code to access both product and category information.", "Filter the results by the product name 'chervil' to get the specific product's details."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT product_category_code, unit_of_measure FROM Ref_Product_Categories AS rpc JOIN Products AS p ON rpc.product_category_code = p.product_category_code WHERE p.product_name = 'chervil'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\",\n        \"virtual_table\": \"SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["Identify the tables involved: Products and Ref_Colors.", "Join the Products table with the Ref_Colors table on the color_code column to get color descriptions for each product.", "Group the results by color_description to aggregate the products by their colors.", "Order the results by the count of products in descending order to find the most common color description.", "Limit the results to 1 to get only the top color description."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT t2.color_description FROM Products AS t1 JOIN Ref_Colors AS t2 ON t1.color_code = t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["Identify the tables involved: Products and Ref_Colors.", "Join the Products table with the Ref_Colors table on the color_code to get color descriptions for each product.", "Group the results by color description to count how many products are associated with each color.", "Order the results by the count of products in ascending order to find the color used by the least products.", "Limit the results to 1 to get only the description of the color used by the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT t2.color_description FROM Products AS t1 JOIN Ref_Colors AS t2 ON t1.color_code = t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To achieve this, we will join the 'Product_Characteristics' table with the 'Characteristics' table to get the characteristic names.", "Next, we will join the 'Products' table to link each characteristic to its respective products.", "We will group the results by the characteristic name to count how many distinct products each characteristic is associated with.", "Finally, we will use the HAVING clause to filter the results to only include characteristics that are linked to two or more products."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT t3.characteristic_name\nFROM product_characteristics AS t2\nJOIN characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id\nJOIN products AS t1 ON t2.product_id = t1.product_id\nGROUP BY t3.characteristic_name\nHAVING COUNT(DISTINCT t1.product_id) >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\",\n        \"virtual_table\": \"SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to query.", "Select the 'Builder' column: We want to list the builders, so we will select this column.", "Use DISTINCT to avoid duplicate entries: Since multiple railways can have the same builder, we will use DISTINCT to ensure each builder is listed only once.", "Order the results: We need the results in ascending alphabetical order, so we will use ORDER BY Builder ASC.", "Construct the SQL query: Combine all these elements into a complete SQL query."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "pred_sql": "SELECT DISTINCT Builder FROM railway ORDER BY Builder ASC;", "hint": "\n"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["Identify the relevant tables: 'railway' and 'train'.", "We need to find the railway associated with the most trains, so we will join the 'railway' table with the 'train' table on 'Railway_ID'.", "We will group the results by 'Railway_ID' and 'Builder' to count the number of trains associated with each railway.", "Use COUNT(train.Train_ID) to count the number of trains for each railway.", "Order the results in descending order based on the count of trains to get the railway with the most trains at the top.", "Limit the results to 1 to get only the railway associated with the most trains."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "pred_sql": "SELECT railway.Railway_ID, railway.Builder \nFROM railway \nJOIN train ON railway.Railway_ID = train.Railway_ID \nGROUP BY railway.Railway_ID, railway.Builder \nORDER BY COUNT(train.Train_ID) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["We need to find the most common builder of railways, which means we will be counting how many railways each builder has constructed.", "To do this, we will select the 'Builder' column from the 'railway' table and count the occurrences of each builder using COUNT(*).", "We will group the results by 'Builder' to aggregate the counts for each builder.", "Next, we will order the results in descending order based on the count of railways built (BuilderCount).", "Finally, we will limit the results to just one entry to get the most common builder."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "pred_sql": "SELECT Builder, COUNT(*) as BuilderCount \nFROM railway \nGROUP BY Builder \nORDER BY BuilderCount DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["Identify the table to query: The relevant table is 'Student' since we need student information.", "Determine the columns needed: We need the 'LName' column for the last names of students.", "Define the conditions for selection: We need students who are either female, live in a city with code 'BAL', or are male and under 20 years old.", "Construct the SQL query using the SELECT statement to retrieve 'LName' from 'Student' where the defined conditions are met."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "pred_sql": "SELECT LName FROM Student WHERE (Sex = 'Female') OR (city_code = 'BAL') OR (Sex = 'Male' AND Age < '20');", "hint": "\n"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["Identify the relevant tables: Dorm and Has_amenity are needed to get dormitory information and their amenities.", "We need to count the number of amenities for each dormitory, so we will use COUNT() function on the amenity identifier from Has_amenity.", "We need to filter dormitories that can accommodate more than 100 students, which is done using a WHERE clause on the student_capacity column in the Dorm table.", "We will group the results by dormid and dorm_name to get the count of amenities for each dormitory.", "Finally, we will select the dormid, dorm_name, and the count of amenities in the final output."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "pred_sql": "SELECT D.dormid, D.dorm_name, COUNT(HA.amenid) AS amenity_count \nFROM Dorm AS D \nJOIN Has_amenity AS HA ON D.dormid = HA.dormid \nWHERE D.student_capacity > 100 \nGROUP BY D.dormid, D.dorm_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\",\n        \"virtual_table\": \"SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables needed: We need to count students, so we will use the 'Student' table and the 'Lives_in' table to find out where students live.", "Join the 'Student' table with the 'Lives_in' table on the student ID to link students with their dorms.", "Next, we need to filter the dorms based on gender. We will join the 'Dorm' table to access the gender information of each dorm.", "We will apply a WHERE clause to filter for dorms that are designated for males (D.gender = 'male').", "Finally, we will use COUNT(*) to get the total number of students living in male dorms."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(*) FROM Student AS S JOIN Lives_in AS L ON S.StuID = L.stuid JOIN Dorm AS D ON L.dormid = D.dormid WHERE D.gender = 'male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\",\n        \"virtual_table\": \"SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["Identify the main goal: Find the first names of students living in the dorm with the most amenities.", "Join the 'Student' table with the 'Lives_in' table to link students to their respective dorms.", "Use a subquery to find the dormitory IDs that have the most amenities.", "Join the 'Dorm' table with the 'Has_amenity' table to count the number of amenities for each dorm.", "Group the results by dormitory ID and order them by the count of amenities in descending order.", "Limit the results of the subquery to 1 to get the dorm with the most amenities.", "Use the result of the subquery in the main query to filter students living in that dorm."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT T1.Fname FROM Student AS T1 JOIN Lives_in AS T2 ON T1.StuID = T2.stuid WHERE T2.dormid IN (SELECT T3.dormid FROM Dorm AS T3 JOIN Has_amenity AS T4 ON T3.dormid = T4.dormid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\",\n        \"virtual_table\": \"SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["Identify the information needed: first name and age of students living in dorms with a specific amenity (TV Lounge).", "Start with the Student table to get the first name and age.", "Use the Lives_in table to find which students live in which dorms.", "Filter the dorms based on the amenities they have by joining the Has_amenity and Dorm_amenity tables.", "Specifically, look for dorms that have the amenity 'TV Lounge'.", "Construct a subquery to find dorm IDs that have the 'TV Lounge' amenity.", "Use this subquery to filter the Lives_in table to get student IDs of those who live in those dorms.", "Finally, use these student IDs to filter the Student table to get the desired first names and ages."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "pred_sql": "SELECT Fname, Age FROM Student WHERE StuID IN (SELECT stuid FROM Lives_in WHERE dormid IN (SELECT dormid FROM Has_amenity WHERE amenid IN (SELECT amenid FROM Dorm_amenity WHERE amenity_name = 'TV Lounge')));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\",\n        \"virtual_table\": \"SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the main goal: Retrieve the email addresses of customers who have filed complaints about the product with the greatest number of complaints.", "To find the product with the greatest number of complaints, a subquery is needed that counts complaints grouped by product_id and orders them in descending order, limiting the result to the top one.", "Join the Customers table with the Complaints table on customer_id to get the email addresses of customers who have made complaints.", "Use the result of the subquery to filter the complaints to only those related to the product with the highest complaint count."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT t1.email_address FROM Customers AS t1 JOIN Complaints AS t2 ON t1.customer_id = t2.customer_id WHERE t2.product_id = (SELECT product_id FROM Complaints GROUP BY product_id ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["Identify the customer who has filed the least amount of complaints by using a subquery that counts complaints grouped by customer ID and orders them in ascending order, limiting the result to 1.", "Join the Complaints table with the Products table to find the products associated with the complaints made by that customer.", "Select the product names from the Products table where the product ID matches the complaints made by the identified customer."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT p.product_name FROM Products p JOIN Complaints c ON p.product_id = c.product_id WHERE c.customer_id = (SELECT customer_id FROM Customers c1 JOIN Complaints c2 ON c1.customer_id = c2.customer_id GROUP BY c1.customer_id ORDER BY COUNT(*) ASC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the relevant tables: Staff, Complaints, and Products.", "We need to find the last name of the staff member handling a complaint related to the product with the lowest price.", "Join the Staff table with the Complaints table on staff_id to link staff members to complaints.", "Join the Complaints table with the Products table on product_id to link complaints to products.", "Use a subquery to find the minimum product price from the Products table.", "Filter the results to only include complaints related to the product with the lowest price and select the last name of the staff member."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT s.last_name \nFROM Staff s \nJOIN Complaints c ON s.staff_id = c.staff_id \nJOIN Products p ON c.product_id = p.product_id \nWHERE p.product_price = (SELECT MIN(product_price) FROM Products)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["Identify the relevant table: The Complaints table contains the complaint status information.", "Determine the required fields: We need the complaint status code and the count of records for each status.", "Group the results: Use GROUP BY to aggregate the results by complaint status code.", "Filter the results: Use HAVING to filter out any complaint statuses that have 3 or fewer records."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "pred_sql": "SELECT complaint_status_code, COUNT(*) as record_count \nFROM Complaints \nGROUP BY complaint_status_code \nHAVING COUNT(*) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["Identify the need to count customers based on their type.", "Use the Customers table to access customer data.", "Group the results by customer_type_code to count how many customers belong to each type.", "Order the results in descending order based on the count to find the most common customer type.", "Limit the results to 1 to get only the most common customer type."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT count(*) FROM Customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the states where customers reside, grouping the results by state and ordering them by the number of customers in each state. The placeholder in the LIMIT clause allows for specifying the maximum number of states to return.\",\n        \"virtual_table\": \"SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the states where customers reside, grouping the results by state and ordering them by the number of customers in each state. The placeholder in the LIMIT clause allows for specifying the maximum number of states to return.\",\n        \"virtual_table\": \"SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to find the first names of staff members, so we will select 'first_name' from the Staff table.", "To determine how many complaints each staff member has handled, we will join the Staff table with the Complaints table on 'staff_id'.", "We will group the results by 'staff_id' to aggregate the number of complaints handled by each staff member.", "We will order the results in descending order based on the count of complaints to get the top staff members who handled the most complaints.", "Finally, we will limit the results to the top 5 staff members."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT s.first_name FROM Staff s JOIN Complaints c ON s.staff_id = c.staff_id GROUP BY s.staff_id ORDER BY COUNT(c.complaint_id) DESC LIMIT 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["We need to return the first names of staff members who have handled complaints.", "To find out which staff members have handled complaints, we will join the Staff table with the Complaints table on the staff_id column.", "We will group the results by staff_id to aggregate the number of complaints each staff member has handled.", "Next, we will order the results in descending order based on the count of complaints handled by each staff member.", "Finally, we will limit the results to the top 5 staff members who have handled the most complaints."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT s.first_name FROM Staff s JOIN Complaints c ON s.staff_id = c.staff_id GROUP BY s.staff_id ORDER BY COUNT(c.complaint_id) DESC LIMIT 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The user wants to see all investor details, which means we need to select all columns from the Investors table.", "The SQL query to retrieve all columns from a table is done using 'SELECT *'.", "We specify the table name 'Investors' to get the data from that specific table."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "pred_sql": "SELECT * FROM Investors;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["Identify the main goal: to show details of all investors who have made transactions with a share count greater than 100.", "Determine the necessary tables: Investors and Transactions are required to get investor details and their transaction information.", "Establish the relationship between the tables: Investors are linked to Transactions through the investor_id.", "Construct the SQL query: Select investor_id and Investor_details from Investors, joining with Transactions on investor_id, and filter for share_count greater than 100."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "pred_sql": "SELECT I.investor_id, I.Investor_details \nFROM Investors AS I \nJOIN Transactions AS T ON I.investor_id = T.investor_id \nWHERE T.share_count > 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["Identify the tables involved: Lots, Transactions, and Transactions_Lots.", "Determine the relationship between these tables: Lots are linked to Transactions through Transactions_Lots.", "Select the lot details from the Lots table.", "Filter the results based on the share count from the Transactions table, specifically looking for transactions with a share count smaller than 50."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT L.lot_details \nFROM Lots AS L \nJOIN Transactions_Lots AS TL ON L.lot_id = TL.lot_id \nJOIN Transactions AS T ON TL.transaction_id = T.transaction_id \nWHERE T.share_count < 50;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\",\n        \"virtual_table\": \"SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["Identify the tables involved: We need to get transaction amounts and their types, so we will use the Transactions and Ref_Transaction_Types tables.", "Determine the necessary columns: We need the transaction type description from Ref_Transaction_Types and the amount of transaction from Transactions.", "Join the tables: We will join Transactions with Ref_Transaction_Types on the transaction_type_code to link transaction amounts with their respective types.", "Calculate the average: We will use the AVG() function to calculate the average transaction amount for each transaction type.", "Group the results: We will group the results by transaction type description to get the average for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\",\n        \"virtual_table\": \"SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["Identify the relevant table: The Transactions table contains the share count and transaction type code.", "Determine the required aggregation: We need to find the maximum and minimum share counts for each transaction type.", "Use the GROUP BY clause to group results by transaction_type_code, allowing us to calculate the max and min share counts for each type.", "Select the transaction_type_code along with the aggregated max and min share counts in the final output."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT transaction_type_code, MAX(share_count) AS max_share_count, MIN(share_count) AS min_share_count \nFROM Transactions \nGROUP BY transaction_type_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\",\n        \"virtual_table\": \"SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["The question asks for details of all sales and purchases, which means we need to retrieve data from both the Sales and Purchases tables.", "To get the details from both tables, we will use a LEFT JOIN to combine the Sales table with the Purchases table based on their transaction IDs.", "We select the relevant columns from both tables: sales_transaction_id and sales_details from the Sales table, and purchase_transaction_id and purchase_details from the Purchases table."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "pred_sql": "SELECT S.sales_transaction_id, S.sales_details, P.purchase_transaction_id, P.purchase_details \nFROM Sales AS S \nLEFT JOIN Purchases AS P ON S.sales_transaction_id = P.purchase_transaction_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\",\n        \"virtual_table\": \"SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
